var dq = Object.defineProperty;
var hq = (e, t, r) => t in e ? dq(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var O_ = (e, t, r) => hq(e, typeof t != "symbol" ? t + "" : t, r);
var ft = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function og(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function Di(e) {
  if (e.__esModule) return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach(function(n) {
    var i = Object.getOwnPropertyDescriptor(e, n);
    Object.defineProperty(r, n, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[n];
      }
    });
  }), r;
}
var i$ = { exports: {} }, sg = {}, o$ = { exports: {} }, lt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var bp = Symbol.for("react.element"), mq = Symbol.for("react.portal"), gq = Symbol.for("react.fragment"), yq = Symbol.for("react.strict_mode"), vq = Symbol.for("react.profiler"), bq = Symbol.for("react.provider"), wq = Symbol.for("react.context"), Sq = Symbol.for("react.forward_ref"), xq = Symbol.for("react.suspense"), Eq = Symbol.for("react.memo"), _q = Symbol.for("react.lazy"), k_ = Symbol.iterator;
function Oq(e) {
  return e === null || typeof e != "object" ? null : (e = k_ && e[k_] || e["@@iterator"], typeof e == "function" ? e : null);
}
var s$ = { isMounted: function() {
  return !1;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, a$ = Object.assign, l$ = {};
function Jl(e, t, r) {
  this.props = e, this.context = t, this.refs = l$, this.updater = r || s$;
}
Jl.prototype.isReactComponent = {};
Jl.prototype.setState = function(e, t) {
  if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, e, t, "setState");
};
Jl.prototype.forceUpdate = function(e) {
  this.updater.enqueueForceUpdate(this, e, "forceUpdate");
};
function u$() {
}
u$.prototype = Jl.prototype;
function Mw(e, t, r) {
  this.props = e, this.context = t, this.refs = l$, this.updater = r || s$;
}
var Dw = Mw.prototype = new u$();
Dw.constructor = Mw;
a$(Dw, Jl.prototype);
Dw.isPureReactComponent = !0;
var A_ = Array.isArray, c$ = Object.prototype.hasOwnProperty, Fw = { current: null }, p$ = { key: !0, ref: !0, __self: !0, __source: !0 };
function f$(e, t, r) {
  var n, i = {}, s = null, o = null;
  if (t != null) for (n in t.ref !== void 0 && (o = t.ref), t.key !== void 0 && (s = "" + t.key), t) c$.call(t, n) && !p$.hasOwnProperty(n) && (i[n] = t[n]);
  var a = arguments.length - 2;
  if (a === 1) i.children = r;
  else if (1 < a) {
    for (var l = Array(a), u = 0; u < a; u++) l[u] = arguments[u + 2];
    i.children = l;
  }
  if (e && e.defaultProps) for (n in a = e.defaultProps, a) i[n] === void 0 && (i[n] = a[n]);
  return { $$typeof: bp, type: e, key: s, ref: o, props: i, _owner: Fw.current };
}
function kq(e, t) {
  return { $$typeof: bp, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner };
}
function zw(e) {
  return typeof e == "object" && e !== null && e.$$typeof === bp;
}
function Aq(e) {
  var t = { "=": "=0", ":": "=2" };
  return "$" + e.replace(/[=:]/g, function(r) {
    return t[r];
  });
}
var P_ = /\/+/g;
function Xy(e, t) {
  return typeof e == "object" && e !== null && e.key != null ? Aq("" + e.key) : t.toString(36);
}
function Th(e, t, r, n, i) {
  var s = typeof e;
  (s === "undefined" || s === "boolean") && (e = null);
  var o = !1;
  if (e === null) o = !0;
  else switch (s) {
    case "string":
    case "number":
      o = !0;
      break;
    case "object":
      switch (e.$$typeof) {
        case bp:
        case mq:
          o = !0;
      }
  }
  if (o) return o = e, i = i(o), e = n === "" ? "." + Xy(o, 0) : n, A_(i) ? (r = "", e != null && (r = e.replace(P_, "$&/") + "/"), Th(i, t, r, "", function(u) {
    return u;
  })) : i != null && (zw(i) && (i = kq(i, r + (!i.key || o && o.key === i.key ? "" : ("" + i.key).replace(P_, "$&/") + "/") + e)), t.push(i)), 1;
  if (o = 0, n = n === "" ? "." : n + ":", A_(e)) for (var a = 0; a < e.length; a++) {
    s = e[a];
    var l = n + Xy(s, a);
    o += Th(s, t, r, l, i);
  }
  else if (l = Oq(e), typeof l == "function") for (e = l.call(e), a = 0; !(s = e.next()).done; ) s = s.value, l = n + Xy(s, a++), o += Th(s, t, r, l, i);
  else if (s === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
  return o;
}
function Qf(e, t, r) {
  if (e == null) return e;
  var n = [], i = 0;
  return Th(e, n, "", "", function(s) {
    return t.call(r, s, i++);
  }), n;
}
function Pq(e) {
  if (e._status === -1) {
    var t = e._result;
    t = t(), t.then(function(r) {
      (e._status === 0 || e._status === -1) && (e._status = 1, e._result = r);
    }, function(r) {
      (e._status === 0 || e._status === -1) && (e._status = 2, e._result = r);
    }), e._status === -1 && (e._status = 0, e._result = t);
  }
  if (e._status === 1) return e._result.default;
  throw e._result;
}
var Ur = { current: null }, Ch = { transition: null }, Tq = { ReactCurrentDispatcher: Ur, ReactCurrentBatchConfig: Ch, ReactCurrentOwner: Fw };
function d$() {
  throw Error("act(...) is not supported in production builds of React.");
}
lt.Children = { map: Qf, forEach: function(e, t, r) {
  Qf(e, function() {
    t.apply(this, arguments);
  }, r);
}, count: function(e) {
  var t = 0;
  return Qf(e, function() {
    t++;
  }), t;
}, toArray: function(e) {
  return Qf(e, function(t) {
    return t;
  }) || [];
}, only: function(e) {
  if (!zw(e)) throw Error("React.Children.only expected to receive a single React element child.");
  return e;
} };
lt.Component = Jl;
lt.Fragment = gq;
lt.Profiler = vq;
lt.PureComponent = Mw;
lt.StrictMode = yq;
lt.Suspense = xq;
lt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Tq;
lt.act = d$;
lt.cloneElement = function(e, t, r) {
  if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + ".");
  var n = a$({}, e.props), i = e.key, s = e.ref, o = e._owner;
  if (t != null) {
    if (t.ref !== void 0 && (s = t.ref, o = Fw.current), t.key !== void 0 && (i = "" + t.key), e.type && e.type.defaultProps) var a = e.type.defaultProps;
    for (l in t) c$.call(t, l) && !p$.hasOwnProperty(l) && (n[l] = t[l] === void 0 && a !== void 0 ? a[l] : t[l]);
  }
  var l = arguments.length - 2;
  if (l === 1) n.children = r;
  else if (1 < l) {
    a = Array(l);
    for (var u = 0; u < l; u++) a[u] = arguments[u + 2];
    n.children = a;
  }
  return { $$typeof: bp, type: e.type, key: i, ref: s, props: n, _owner: o };
};
lt.createContext = function(e) {
  return e = { $$typeof: wq, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, e.Provider = { $$typeof: bq, _context: e }, e.Consumer = e;
};
lt.createElement = f$;
lt.createFactory = function(e) {
  var t = f$.bind(null, e);
  return t.type = e, t;
};
lt.createRef = function() {
  return { current: null };
};
lt.forwardRef = function(e) {
  return { $$typeof: Sq, render: e };
};
lt.isValidElement = zw;
lt.lazy = function(e) {
  return { $$typeof: _q, _payload: { _status: -1, _result: e }, _init: Pq };
};
lt.memo = function(e, t) {
  return { $$typeof: Eq, type: e, compare: t === void 0 ? null : t };
};
lt.startTransition = function(e) {
  var t = Ch.transition;
  Ch.transition = {};
  try {
    e();
  } finally {
    Ch.transition = t;
  }
};
lt.unstable_act = d$;
lt.useCallback = function(e, t) {
  return Ur.current.useCallback(e, t);
};
lt.useContext = function(e) {
  return Ur.current.useContext(e);
};
lt.useDebugValue = function() {
};
lt.useDeferredValue = function(e) {
  return Ur.current.useDeferredValue(e);
};
lt.useEffect = function(e, t) {
  return Ur.current.useEffect(e, t);
};
lt.useId = function() {
  return Ur.current.useId();
};
lt.useImperativeHandle = function(e, t, r) {
  return Ur.current.useImperativeHandle(e, t, r);
};
lt.useInsertionEffect = function(e, t) {
  return Ur.current.useInsertionEffect(e, t);
};
lt.useLayoutEffect = function(e, t) {
  return Ur.current.useLayoutEffect(e, t);
};
lt.useMemo = function(e, t) {
  return Ur.current.useMemo(e, t);
};
lt.useReducer = function(e, t, r) {
  return Ur.current.useReducer(e, t, r);
};
lt.useRef = function(e) {
  return Ur.current.useRef(e);
};
lt.useState = function(e) {
  return Ur.current.useState(e);
};
lt.useSyncExternalStore = function(e, t, r) {
  return Ur.current.useSyncExternalStore(e, t, r);
};
lt.useTransition = function() {
  return Ur.current.useTransition();
};
lt.version = "18.3.1";
o$.exports = lt;
var et = o$.exports;
const at = /* @__PURE__ */ og(et);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Cq = et, $q = Symbol.for("react.element"), Rq = Symbol.for("react.fragment"), Iq = Object.prototype.hasOwnProperty, Nq = Cq.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, jq = { key: !0, ref: !0, __self: !0, __source: !0 };
function h$(e, t, r) {
  var n, i = {}, s = null, o = null;
  r !== void 0 && (s = "" + r), t.key !== void 0 && (s = "" + t.key), t.ref !== void 0 && (o = t.ref);
  for (n in t) Iq.call(t, n) && !jq.hasOwnProperty(n) && (i[n] = t[n]);
  if (e && e.defaultProps) for (n in t = e.defaultProps, t) i[n] === void 0 && (i[n] = t[n]);
  return { $$typeof: $q, type: e, key: s, ref: o, props: i, _owner: Nq.current };
}
sg.Fragment = Rq;
sg.jsx = h$;
sg.jsxs = h$;
i$.exports = sg;
var Zb = i$.exports, m$ = { exports: {} }, vn = {}, g$ = { exports: {} }, y$ = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(e) {
  function t(G, ee) {
    var K = G.length;
    G.push(ee);
    e: for (; 0 < K; ) {
      var z = K - 1 >>> 1, te = G[z];
      if (0 < i(te, ee)) G[z] = ee, G[K] = te, K = z;
      else break e;
    }
  }
  function r(G) {
    return G.length === 0 ? null : G[0];
  }
  function n(G) {
    if (G.length === 0) return null;
    var ee = G[0], K = G.pop();
    if (K !== ee) {
      G[0] = K;
      e: for (var z = 0, te = G.length, q = te >>> 1; z < q; ) {
        var j = 2 * (z + 1) - 1, H = G[j], B = j + 1, pe = G[B];
        if (0 > i(H, K)) B < te && 0 > i(pe, H) ? (G[z] = pe, G[B] = K, z = B) : (G[z] = H, G[j] = K, z = j);
        else if (B < te && 0 > i(pe, K)) G[z] = pe, G[B] = K, z = B;
        else break e;
      }
    }
    return ee;
  }
  function i(G, ee) {
    var K = G.sortIndex - ee.sortIndex;
    return K !== 0 ? K : G.id - ee.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    e.unstable_now = function() {
      return s.now();
    };
  } else {
    var o = Date, a = o.now();
    e.unstable_now = function() {
      return o.now() - a;
    };
  }
  var l = [], u = [], f = 1, d = null, m = 3, v = !1, S = !1, y = !1, E = typeof setTimeout == "function" ? setTimeout : null, x = typeof clearTimeout == "function" ? clearTimeout : null, g = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function b(G) {
    for (var ee = r(u); ee !== null; ) {
      if (ee.callback === null) n(u);
      else if (ee.startTime <= G) n(u), ee.sortIndex = ee.expirationTime, t(l, ee);
      else break;
      ee = r(u);
    }
  }
  function A(G) {
    if (y = !1, b(G), !S) if (r(l) !== null) S = !0, ce(P);
    else {
      var ee = r(u);
      ee !== null && be(A, ee.startTime - G);
    }
  }
  function P(G, ee) {
    S = !1, y && (y = !1, x(I), I = -1), v = !0;
    var K = m;
    try {
      for (b(ee), d = r(l); d !== null && (!(d.expirationTime > ee) || G && !Q()); ) {
        var z = d.callback;
        if (typeof z == "function") {
          d.callback = null, m = d.priorityLevel;
          var te = z(d.expirationTime <= ee);
          ee = e.unstable_now(), typeof te == "function" ? d.callback = te : d === r(l) && n(l), b(ee);
        } else n(l);
        d = r(l);
      }
      if (d !== null) var q = !0;
      else {
        var j = r(u);
        j !== null && be(A, j.startTime - ee), q = !1;
      }
      return q;
    } finally {
      d = null, m = K, v = !1;
    }
  }
  var k = !1, $ = null, I = -1, F = 5, L = -1;
  function Q() {
    return !(e.unstable_now() - L < F);
  }
  function Y() {
    if ($ !== null) {
      var G = e.unstable_now();
      L = G;
      var ee = !0;
      try {
        ee = $(!0, G);
      } finally {
        ee ? ae() : (k = !1, $ = null);
      }
    } else k = !1;
  }
  var ae;
  if (typeof g == "function") ae = function() {
    g(Y);
  };
  else if (typeof MessageChannel < "u") {
    var le = new MessageChannel(), ue = le.port2;
    le.port1.onmessage = Y, ae = function() {
      ue.postMessage(null);
    };
  } else ae = function() {
    E(Y, 0);
  };
  function ce(G) {
    $ = G, k || (k = !0, ae());
  }
  function be(G, ee) {
    I = E(function() {
      G(e.unstable_now());
    }, ee);
  }
  e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(G) {
    G.callback = null;
  }, e.unstable_continueExecution = function() {
    S || v || (S = !0, ce(P));
  }, e.unstable_forceFrameRate = function(G) {
    0 > G || 125 < G ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : F = 0 < G ? Math.floor(1e3 / G) : 5;
  }, e.unstable_getCurrentPriorityLevel = function() {
    return m;
  }, e.unstable_getFirstCallbackNode = function() {
    return r(l);
  }, e.unstable_next = function(G) {
    switch (m) {
      case 1:
      case 2:
      case 3:
        var ee = 3;
        break;
      default:
        ee = m;
    }
    var K = m;
    m = ee;
    try {
      return G();
    } finally {
      m = K;
    }
  }, e.unstable_pauseExecution = function() {
  }, e.unstable_requestPaint = function() {
  }, e.unstable_runWithPriority = function(G, ee) {
    switch (G) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        G = 3;
    }
    var K = m;
    m = G;
    try {
      return ee();
    } finally {
      m = K;
    }
  }, e.unstable_scheduleCallback = function(G, ee, K) {
    var z = e.unstable_now();
    switch (typeof K == "object" && K !== null ? (K = K.delay, K = typeof K == "number" && 0 < K ? z + K : z) : K = z, G) {
      case 1:
        var te = -1;
        break;
      case 2:
        te = 250;
        break;
      case 5:
        te = 1073741823;
        break;
      case 4:
        te = 1e4;
        break;
      default:
        te = 5e3;
    }
    return te = K + te, G = { id: f++, callback: ee, priorityLevel: G, startTime: K, expirationTime: te, sortIndex: -1 }, K > z ? (G.sortIndex = K, t(u, G), r(l) === null && G === r(u) && (y ? (x(I), I = -1) : y = !0, be(A, K - z))) : (G.sortIndex = te, t(l, G), S || v || (S = !0, ce(P))), G;
  }, e.unstable_shouldYield = Q, e.unstable_wrapCallback = function(G) {
    var ee = m;
    return function() {
      var K = m;
      m = ee;
      try {
        return G.apply(this, arguments);
      } finally {
        m = K;
      }
    };
  };
})(y$);
g$.exports = y$;
var Lq = g$.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Mq = et, gn = Lq;
function Ne(e) {
  for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, r = 1; r < arguments.length; r++) t += "&args[]=" + encodeURIComponent(arguments[r]);
  return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var v$ = /* @__PURE__ */ new Set(), zc = {};
function wa(e, t) {
  Rl(e, t), Rl(e + "Capture", t);
}
function Rl(e, t) {
  for (zc[e] = t, e = 0; e < t.length; e++) v$.add(t[e]);
}
var ho = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), e0 = Object.prototype.hasOwnProperty, Dq = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, T_ = {}, C_ = {};
function Fq(e) {
  return e0.call(C_, e) ? !0 : e0.call(T_, e) ? !1 : Dq.test(e) ? C_[e] = !0 : (T_[e] = !0, !1);
}
function zq(e, t, r, n) {
  if (r !== null && r.type === 0) return !1;
  switch (typeof t) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return n ? !1 : r !== null ? !r.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-");
    default:
      return !1;
  }
}
function qq(e, t, r, n) {
  if (t === null || typeof t > "u" || zq(e, t, r, n)) return !0;
  if (n) return !1;
  if (r !== null) switch (r.type) {
    case 3:
      return !t;
    case 4:
      return t === !1;
    case 5:
      return isNaN(t);
    case 6:
      return isNaN(t) || 1 > t;
  }
  return !1;
}
function Vr(e, t, r, n, i, s, o) {
  this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = n, this.attributeNamespace = i, this.mustUseProperty = r, this.propertyName = e, this.type = t, this.sanitizeURL = s, this.removeEmptyString = o;
}
var kr = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e) {
  kr[e] = new Vr(e, 0, !1, e, null, !1, !1);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(e) {
  var t = e[0];
  kr[t] = new Vr(t, 1, !1, e[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e) {
  kr[e] = new Vr(e, 2, !1, e.toLowerCase(), null, !1, !1);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e) {
  kr[e] = new Vr(e, 2, !1, e, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e) {
  kr[e] = new Vr(e, 3, !1, e.toLowerCase(), null, !1, !1);
});
["checked", "multiple", "muted", "selected"].forEach(function(e) {
  kr[e] = new Vr(e, 3, !0, e, null, !1, !1);
});
["capture", "download"].forEach(function(e) {
  kr[e] = new Vr(e, 4, !1, e, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function(e) {
  kr[e] = new Vr(e, 6, !1, e, null, !1, !1);
});
["rowSpan", "start"].forEach(function(e) {
  kr[e] = new Vr(e, 5, !1, e.toLowerCase(), null, !1, !1);
});
var qw = /[\-:]([a-z])/g;
function Bw(e) {
  return e[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e) {
  var t = e.replace(
    qw,
    Bw
  );
  kr[t] = new Vr(t, 1, !1, e, null, !1, !1);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e) {
  var t = e.replace(qw, Bw);
  kr[t] = new Vr(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(e) {
  var t = e.replace(qw, Bw);
  kr[t] = new Vr(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function(e) {
  kr[e] = new Vr(e, 1, !1, e.toLowerCase(), null, !1, !1);
});
kr.xlinkHref = new Vr("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function(e) {
  kr[e] = new Vr(e, 1, !1, e.toLowerCase(), null, !0, !0);
});
function Uw(e, t, r, n) {
  var i = kr.hasOwnProperty(t) ? kr[t] : null;
  (i !== null ? i.type !== 0 : n || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (qq(t, r, i, n) && (r = null), n || i === null ? Fq(t) && (r === null ? e.removeAttribute(t) : e.setAttribute(t, "" + r)) : i.mustUseProperty ? e[i.propertyName] = r === null ? i.type === 3 ? !1 : "" : r : (t = i.attributeName, n = i.attributeNamespace, r === null ? e.removeAttribute(t) : (i = i.type, r = i === 3 || i === 4 && r === !0 ? "" : "" + r, n ? e.setAttributeNS(n, t, r) : e.setAttribute(t, r))));
}
var Oo = Mq.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Yf = Symbol.for("react.element"), al = Symbol.for("react.portal"), ll = Symbol.for("react.fragment"), Vw = Symbol.for("react.strict_mode"), t0 = Symbol.for("react.profiler"), b$ = Symbol.for("react.provider"), w$ = Symbol.for("react.context"), Ww = Symbol.for("react.forward_ref"), r0 = Symbol.for("react.suspense"), n0 = Symbol.for("react.suspense_list"), Hw = Symbol.for("react.memo"), zo = Symbol.for("react.lazy"), S$ = Symbol.for("react.offscreen"), $_ = Symbol.iterator;
function qu(e) {
  return e === null || typeof e != "object" ? null : (e = $_ && e[$_] || e["@@iterator"], typeof e == "function" ? e : null);
}
var Ht = Object.assign, Jy;
function mc(e) {
  if (Jy === void 0) try {
    throw Error();
  } catch (r) {
    var t = r.stack.trim().match(/\n( *(at )?)/);
    Jy = t && t[1] || "";
  }
  return `
` + Jy + e;
}
var Zy = !1;
function ev(e, t) {
  if (!e || Zy) return "";
  Zy = !0;
  var r = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (t) if (t = function() {
      throw Error();
    }, Object.defineProperty(t.prototype, "props", { set: function() {
      throw Error();
    } }), typeof Reflect == "object" && Reflect.construct) {
      try {
        Reflect.construct(t, []);
      } catch (u) {
        var n = u;
      }
      Reflect.construct(e, [], t);
    } else {
      try {
        t.call();
      } catch (u) {
        n = u;
      }
      e.call(t.prototype);
    }
    else {
      try {
        throw Error();
      } catch (u) {
        n = u;
      }
      e();
    }
  } catch (u) {
    if (u && n && typeof u.stack == "string") {
      for (var i = u.stack.split(`
`), s = n.stack.split(`
`), o = i.length - 1, a = s.length - 1; 1 <= o && 0 <= a && i[o] !== s[a]; ) a--;
      for (; 1 <= o && 0 <= a; o--, a--) if (i[o] !== s[a]) {
        if (o !== 1 || a !== 1)
          do
            if (o--, a--, 0 > a || i[o] !== s[a]) {
              var l = `
` + i[o].replace(" at new ", " at ");
              return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l;
            }
          while (1 <= o && 0 <= a);
        break;
      }
    }
  } finally {
    Zy = !1, Error.prepareStackTrace = r;
  }
  return (e = e ? e.displayName || e.name : "") ? mc(e) : "";
}
function Bq(e) {
  switch (e.tag) {
    case 5:
      return mc(e.type);
    case 16:
      return mc("Lazy");
    case 13:
      return mc("Suspense");
    case 19:
      return mc("SuspenseList");
    case 0:
    case 2:
    case 15:
      return e = ev(e.type, !1), e;
    case 11:
      return e = ev(e.type.render, !1), e;
    case 1:
      return e = ev(e.type, !0), e;
    default:
      return "";
  }
}
function i0(e) {
  if (e == null) return null;
  if (typeof e == "function") return e.displayName || e.name || null;
  if (typeof e == "string") return e;
  switch (e) {
    case ll:
      return "Fragment";
    case al:
      return "Portal";
    case t0:
      return "Profiler";
    case Vw:
      return "StrictMode";
    case r0:
      return "Suspense";
    case n0:
      return "SuspenseList";
  }
  if (typeof e == "object") switch (e.$$typeof) {
    case w$:
      return (e.displayName || "Context") + ".Consumer";
    case b$:
      return (e._context.displayName || "Context") + ".Provider";
    case Ww:
      var t = e.render;
      return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e;
    case Hw:
      return t = e.displayName || null, t !== null ? t : i0(e.type) || "Memo";
    case zo:
      t = e._payload, e = e._init;
      try {
        return i0(e(t));
      } catch {
      }
  }
  return null;
}
function Uq(e) {
  var t = e.type;
  switch (e.tag) {
    case 24:
      return "Cache";
    case 9:
      return (t.displayName || "Context") + ".Consumer";
    case 10:
      return (t._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return t;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return i0(t);
    case 8:
      return t === Vw ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof t == "function") return t.displayName || t.name || null;
      if (typeof t == "string") return t;
  }
  return null;
}
function ls(e) {
  switch (typeof e) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return e;
    case "object":
      return e;
    default:
      return "";
  }
}
function x$(e) {
  var t = e.type;
  return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio");
}
function Vq(e) {
  var t = x$(e) ? "checked" : "value", r = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), n = "" + e[t];
  if (!e.hasOwnProperty(t) && typeof r < "u" && typeof r.get == "function" && typeof r.set == "function") {
    var i = r.get, s = r.set;
    return Object.defineProperty(e, t, { configurable: !0, get: function() {
      return i.call(this);
    }, set: function(o) {
      n = "" + o, s.call(this, o);
    } }), Object.defineProperty(e, t, { enumerable: r.enumerable }), { getValue: function() {
      return n;
    }, setValue: function(o) {
      n = "" + o;
    }, stopTracking: function() {
      e._valueTracker = null, delete e[t];
    } };
  }
}
function Gf(e) {
  e._valueTracker || (e._valueTracker = Vq(e));
}
function E$(e) {
  if (!e) return !1;
  var t = e._valueTracker;
  if (!t) return !0;
  var r = t.getValue(), n = "";
  return e && (n = x$(e) ? e.checked ? "true" : "false" : e.value), e = n, e !== r ? (t.setValue(e), !0) : !1;
}
function rm(e) {
  if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null;
  try {
    return e.activeElement || e.body;
  } catch {
    return e.body;
  }
}
function o0(e, t) {
  var r = t.checked;
  return Ht({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: r ?? e._wrapperState.initialChecked });
}
function R_(e, t) {
  var r = t.defaultValue == null ? "" : t.defaultValue, n = t.checked != null ? t.checked : t.defaultChecked;
  r = ls(t.value != null ? t.value : r), e._wrapperState = { initialChecked: n, initialValue: r, controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null };
}
function _$(e, t) {
  t = t.checked, t != null && Uw(e, "checked", t, !1);
}
function s0(e, t) {
  _$(e, t);
  var r = ls(t.value), n = t.type;
  if (r != null) n === "number" ? (r === 0 && e.value === "" || e.value != r) && (e.value = "" + r) : e.value !== "" + r && (e.value = "" + r);
  else if (n === "submit" || n === "reset") {
    e.removeAttribute("value");
    return;
  }
  t.hasOwnProperty("value") ? a0(e, t.type, r) : t.hasOwnProperty("defaultValue") && a0(e, t.type, ls(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked);
}
function I_(e, t, r) {
  if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
    var n = t.type;
    if (!(n !== "submit" && n !== "reset" || t.value !== void 0 && t.value !== null)) return;
    t = "" + e._wrapperState.initialValue, r || t === e.value || (e.value = t), e.defaultValue = t;
  }
  r = e.name, r !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, r !== "" && (e.name = r);
}
function a0(e, t, r) {
  (t !== "number" || rm(e.ownerDocument) !== e) && (r == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + r && (e.defaultValue = "" + r));
}
var gc = Array.isArray;
function Ol(e, t, r, n) {
  if (e = e.options, t) {
    t = {};
    for (var i = 0; i < r.length; i++) t["$" + r[i]] = !0;
    for (r = 0; r < e.length; r++) i = t.hasOwnProperty("$" + e[r].value), e[r].selected !== i && (e[r].selected = i), i && n && (e[r].defaultSelected = !0);
  } else {
    for (r = "" + ls(r), t = null, i = 0; i < e.length; i++) {
      if (e[i].value === r) {
        e[i].selected = !0, n && (e[i].defaultSelected = !0);
        return;
      }
      t !== null || e[i].disabled || (t = e[i]);
    }
    t !== null && (t.selected = !0);
  }
}
function l0(e, t) {
  if (t.dangerouslySetInnerHTML != null) throw Error(Ne(91));
  return Ht({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue });
}
function N_(e, t) {
  var r = t.value;
  if (r == null) {
    if (r = t.children, t = t.defaultValue, r != null) {
      if (t != null) throw Error(Ne(92));
      if (gc(r)) {
        if (1 < r.length) throw Error(Ne(93));
        r = r[0];
      }
      t = r;
    }
    t == null && (t = ""), r = t;
  }
  e._wrapperState = { initialValue: ls(r) };
}
function O$(e, t) {
  var r = ls(t.value), n = ls(t.defaultValue);
  r != null && (r = "" + r, r !== e.value && (e.value = r), t.defaultValue == null && e.defaultValue !== r && (e.defaultValue = r)), n != null && (e.defaultValue = "" + n);
}
function j_(e) {
  var t = e.textContent;
  t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t);
}
function k$(e) {
  switch (e) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function u0(e, t) {
  return e == null || e === "http://www.w3.org/1999/xhtml" ? k$(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e;
}
var Kf, A$ = function(e) {
  return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(t, r, n, i) {
    MSApp.execUnsafeLocalFunction(function() {
      return e(t, r, n, i);
    });
  } : e;
}(function(e, t) {
  if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t;
  else {
    for (Kf = Kf || document.createElement("div"), Kf.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = Kf.firstChild; e.firstChild; ) e.removeChild(e.firstChild);
    for (; t.firstChild; ) e.appendChild(t.firstChild);
  }
});
function qc(e, t) {
  if (t) {
    var r = e.firstChild;
    if (r && r === e.lastChild && r.nodeType === 3) {
      r.nodeValue = t;
      return;
    }
  }
  e.textContent = t;
}
var _c = {
  animationIterationCount: !0,
  aspectRatio: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridArea: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
}, Wq = ["Webkit", "ms", "Moz", "O"];
Object.keys(_c).forEach(function(e) {
  Wq.forEach(function(t) {
    t = t + e.charAt(0).toUpperCase() + e.substring(1), _c[t] = _c[e];
  });
});
function P$(e, t, r) {
  return t == null || typeof t == "boolean" || t === "" ? "" : r || typeof t != "number" || t === 0 || _c.hasOwnProperty(e) && _c[e] ? ("" + t).trim() : t + "px";
}
function T$(e, t) {
  e = e.style;
  for (var r in t) if (t.hasOwnProperty(r)) {
    var n = r.indexOf("--") === 0, i = P$(r, t[r], n);
    r === "float" && (r = "cssFloat"), n ? e.setProperty(r, i) : e[r] = i;
  }
}
var Hq = Ht({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
function c0(e, t) {
  if (t) {
    if (Hq[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(Ne(137, e));
    if (t.dangerouslySetInnerHTML != null) {
      if (t.children != null) throw Error(Ne(60));
      if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(Ne(61));
    }
    if (t.style != null && typeof t.style != "object") throw Error(Ne(62));
  }
}
function p0(e, t) {
  if (e.indexOf("-") === -1) return typeof t.is == "string";
  switch (e) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var f0 = null;
function Qw(e) {
  return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e;
}
var d0 = null, kl = null, Al = null;
function L_(e) {
  if (e = xp(e)) {
    if (typeof d0 != "function") throw Error(Ne(280));
    var t = e.stateNode;
    t && (t = pg(t), d0(e.stateNode, e.type, t));
  }
}
function C$(e) {
  kl ? Al ? Al.push(e) : Al = [e] : kl = e;
}
function $$() {
  if (kl) {
    var e = kl, t = Al;
    if (Al = kl = null, L_(e), t) for (e = 0; e < t.length; e++) L_(t[e]);
  }
}
function R$(e, t) {
  return e(t);
}
function I$() {
}
var tv = !1;
function N$(e, t, r) {
  if (tv) return e(t, r);
  tv = !0;
  try {
    return R$(e, t, r);
  } finally {
    tv = !1, (kl !== null || Al !== null) && (I$(), $$());
  }
}
function Bc(e, t) {
  var r = e.stateNode;
  if (r === null) return null;
  var n = pg(r);
  if (n === null) return null;
  r = n[t];
  e: switch (t) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (n = !n.disabled) || (e = e.type, n = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !n;
      break e;
    default:
      e = !1;
  }
  if (e) return null;
  if (r && typeof r != "function") throw Error(Ne(231, t, typeof r));
  return r;
}
var h0 = !1;
if (ho) try {
  var Bu = {};
  Object.defineProperty(Bu, "passive", { get: function() {
    h0 = !0;
  } }), window.addEventListener("test", Bu, Bu), window.removeEventListener("test", Bu, Bu);
} catch {
  h0 = !1;
}
function Qq(e, t, r, n, i, s, o, a, l) {
  var u = Array.prototype.slice.call(arguments, 3);
  try {
    t.apply(r, u);
  } catch (f) {
    this.onError(f);
  }
}
var Oc = !1, nm = null, im = !1, m0 = null, Yq = { onError: function(e) {
  Oc = !0, nm = e;
} };
function Gq(e, t, r, n, i, s, o, a, l) {
  Oc = !1, nm = null, Qq.apply(Yq, arguments);
}
function Kq(e, t, r, n, i, s, o, a, l) {
  if (Gq.apply(this, arguments), Oc) {
    if (Oc) {
      var u = nm;
      Oc = !1, nm = null;
    } else throw Error(Ne(198));
    im || (im = !0, m0 = u);
  }
}
function Sa(e) {
  var t = e, r = e;
  if (e.alternate) for (; t.return; ) t = t.return;
  else {
    e = t;
    do
      t = e, t.flags & 4098 && (r = t.return), e = t.return;
    while (e);
  }
  return t.tag === 3 ? r : null;
}
function j$(e) {
  if (e.tag === 13) {
    var t = e.memoizedState;
    if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated;
  }
  return null;
}
function M_(e) {
  if (Sa(e) !== e) throw Error(Ne(188));
}
function Xq(e) {
  var t = e.alternate;
  if (!t) {
    if (t = Sa(e), t === null) throw Error(Ne(188));
    return t !== e ? null : e;
  }
  for (var r = e, n = t; ; ) {
    var i = r.return;
    if (i === null) break;
    var s = i.alternate;
    if (s === null) {
      if (n = i.return, n !== null) {
        r = n;
        continue;
      }
      break;
    }
    if (i.child === s.child) {
      for (s = i.child; s; ) {
        if (s === r) return M_(i), e;
        if (s === n) return M_(i), t;
        s = s.sibling;
      }
      throw Error(Ne(188));
    }
    if (r.return !== n.return) r = i, n = s;
    else {
      for (var o = !1, a = i.child; a; ) {
        if (a === r) {
          o = !0, r = i, n = s;
          break;
        }
        if (a === n) {
          o = !0, n = i, r = s;
          break;
        }
        a = a.sibling;
      }
      if (!o) {
        for (a = s.child; a; ) {
          if (a === r) {
            o = !0, r = s, n = i;
            break;
          }
          if (a === n) {
            o = !0, n = s, r = i;
            break;
          }
          a = a.sibling;
        }
        if (!o) throw Error(Ne(189));
      }
    }
    if (r.alternate !== n) throw Error(Ne(190));
  }
  if (r.tag !== 3) throw Error(Ne(188));
  return r.stateNode.current === r ? e : t;
}
function L$(e) {
  return e = Xq(e), e !== null ? M$(e) : null;
}
function M$(e) {
  if (e.tag === 5 || e.tag === 6) return e;
  for (e = e.child; e !== null; ) {
    var t = M$(e);
    if (t !== null) return t;
    e = e.sibling;
  }
  return null;
}
var D$ = gn.unstable_scheduleCallback, D_ = gn.unstable_cancelCallback, Jq = gn.unstable_shouldYield, Zq = gn.unstable_requestPaint, er = gn.unstable_now, eB = gn.unstable_getCurrentPriorityLevel, Yw = gn.unstable_ImmediatePriority, F$ = gn.unstable_UserBlockingPriority, om = gn.unstable_NormalPriority, tB = gn.unstable_LowPriority, z$ = gn.unstable_IdlePriority, ag = null, $i = null;
function rB(e) {
  if ($i && typeof $i.onCommitFiberRoot == "function") try {
    $i.onCommitFiberRoot(ag, e, void 0, (e.current.flags & 128) === 128);
  } catch {
  }
}
var ei = Math.clz32 ? Math.clz32 : oB, nB = Math.log, iB = Math.LN2;
function oB(e) {
  return e >>>= 0, e === 0 ? 32 : 31 - (nB(e) / iB | 0) | 0;
}
var Xf = 64, Jf = 4194304;
function yc(e) {
  switch (e & -e) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return e & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return e;
  }
}
function sm(e, t) {
  var r = e.pendingLanes;
  if (r === 0) return 0;
  var n = 0, i = e.suspendedLanes, s = e.pingedLanes, o = r & 268435455;
  if (o !== 0) {
    var a = o & ~i;
    a !== 0 ? n = yc(a) : (s &= o, s !== 0 && (n = yc(s)));
  } else o = r & ~i, o !== 0 ? n = yc(o) : s !== 0 && (n = yc(s));
  if (n === 0) return 0;
  if (t !== 0 && t !== n && !(t & i) && (i = n & -n, s = t & -t, i >= s || i === 16 && (s & 4194240) !== 0)) return t;
  if (n & 4 && (n |= r & 16), t = e.entangledLanes, t !== 0) for (e = e.entanglements, t &= n; 0 < t; ) r = 31 - ei(t), i = 1 << r, n |= e[r], t &= ~i;
  return n;
}
function sB(e, t) {
  switch (e) {
    case 1:
    case 2:
    case 4:
      return t + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return t + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function aB(e, t) {
  for (var r = e.suspendedLanes, n = e.pingedLanes, i = e.expirationTimes, s = e.pendingLanes; 0 < s; ) {
    var o = 31 - ei(s), a = 1 << o, l = i[o];
    l === -1 ? (!(a & r) || a & n) && (i[o] = sB(a, t)) : l <= t && (e.expiredLanes |= a), s &= ~a;
  }
}
function g0(e) {
  return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0;
}
function q$() {
  var e = Xf;
  return Xf <<= 1, !(Xf & 4194240) && (Xf = 64), e;
}
function rv(e) {
  for (var t = [], r = 0; 31 > r; r++) t.push(e);
  return t;
}
function wp(e, t, r) {
  e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - ei(t), e[t] = r;
}
function lB(e, t) {
  var r = e.pendingLanes & ~t;
  e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements;
  var n = e.eventTimes;
  for (e = e.expirationTimes; 0 < r; ) {
    var i = 31 - ei(r), s = 1 << i;
    t[i] = 0, n[i] = -1, e[i] = -1, r &= ~s;
  }
}
function Gw(e, t) {
  var r = e.entangledLanes |= t;
  for (e = e.entanglements; r; ) {
    var n = 31 - ei(r), i = 1 << n;
    i & t | e[n] & t && (e[n] |= t), r &= ~i;
  }
}
var xt = 0;
function B$(e) {
  return e &= -e, 1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1;
}
var U$, Kw, V$, W$, H$, y0 = !1, Zf = [], Xo = null, Jo = null, Zo = null, Uc = /* @__PURE__ */ new Map(), Vc = /* @__PURE__ */ new Map(), Uo = [], uB = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function F_(e, t) {
  switch (e) {
    case "focusin":
    case "focusout":
      Xo = null;
      break;
    case "dragenter":
    case "dragleave":
      Jo = null;
      break;
    case "mouseover":
    case "mouseout":
      Zo = null;
      break;
    case "pointerover":
    case "pointerout":
      Uc.delete(t.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Vc.delete(t.pointerId);
  }
}
function Uu(e, t, r, n, i, s) {
  return e === null || e.nativeEvent !== s ? (e = { blockedOn: t, domEventName: r, eventSystemFlags: n, nativeEvent: s, targetContainers: [i] }, t !== null && (t = xp(t), t !== null && Kw(t)), e) : (e.eventSystemFlags |= n, t = e.targetContainers, i !== null && t.indexOf(i) === -1 && t.push(i), e);
}
function cB(e, t, r, n, i) {
  switch (t) {
    case "focusin":
      return Xo = Uu(Xo, e, t, r, n, i), !0;
    case "dragenter":
      return Jo = Uu(Jo, e, t, r, n, i), !0;
    case "mouseover":
      return Zo = Uu(Zo, e, t, r, n, i), !0;
    case "pointerover":
      var s = i.pointerId;
      return Uc.set(s, Uu(Uc.get(s) || null, e, t, r, n, i)), !0;
    case "gotpointercapture":
      return s = i.pointerId, Vc.set(s, Uu(Vc.get(s) || null, e, t, r, n, i)), !0;
  }
  return !1;
}
function Q$(e) {
  var t = Xs(e.target);
  if (t !== null) {
    var r = Sa(t);
    if (r !== null) {
      if (t = r.tag, t === 13) {
        if (t = j$(r), t !== null) {
          e.blockedOn = t, H$(e.priority, function() {
            V$(r);
          });
          return;
        }
      } else if (t === 3 && r.stateNode.current.memoizedState.isDehydrated) {
        e.blockedOn = r.tag === 3 ? r.stateNode.containerInfo : null;
        return;
      }
    }
  }
  e.blockedOn = null;
}
function $h(e) {
  if (e.blockedOn !== null) return !1;
  for (var t = e.targetContainers; 0 < t.length; ) {
    var r = v0(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
    if (r === null) {
      r = e.nativeEvent;
      var n = new r.constructor(r.type, r);
      f0 = n, r.target.dispatchEvent(n), f0 = null;
    } else return t = xp(r), t !== null && Kw(t), e.blockedOn = r, !1;
    t.shift();
  }
  return !0;
}
function z_(e, t, r) {
  $h(e) && r.delete(t);
}
function pB() {
  y0 = !1, Xo !== null && $h(Xo) && (Xo = null), Jo !== null && $h(Jo) && (Jo = null), Zo !== null && $h(Zo) && (Zo = null), Uc.forEach(z_), Vc.forEach(z_);
}
function Vu(e, t) {
  e.blockedOn === t && (e.blockedOn = null, y0 || (y0 = !0, gn.unstable_scheduleCallback(gn.unstable_NormalPriority, pB)));
}
function Wc(e) {
  function t(i) {
    return Vu(i, e);
  }
  if (0 < Zf.length) {
    Vu(Zf[0], e);
    for (var r = 1; r < Zf.length; r++) {
      var n = Zf[r];
      n.blockedOn === e && (n.blockedOn = null);
    }
  }
  for (Xo !== null && Vu(Xo, e), Jo !== null && Vu(Jo, e), Zo !== null && Vu(Zo, e), Uc.forEach(t), Vc.forEach(t), r = 0; r < Uo.length; r++) n = Uo[r], n.blockedOn === e && (n.blockedOn = null);
  for (; 0 < Uo.length && (r = Uo[0], r.blockedOn === null); ) Q$(r), r.blockedOn === null && Uo.shift();
}
var Pl = Oo.ReactCurrentBatchConfig, am = !0;
function fB(e, t, r, n) {
  var i = xt, s = Pl.transition;
  Pl.transition = null;
  try {
    xt = 1, Xw(e, t, r, n);
  } finally {
    xt = i, Pl.transition = s;
  }
}
function dB(e, t, r, n) {
  var i = xt, s = Pl.transition;
  Pl.transition = null;
  try {
    xt = 4, Xw(e, t, r, n);
  } finally {
    xt = i, Pl.transition = s;
  }
}
function Xw(e, t, r, n) {
  if (am) {
    var i = v0(e, t, r, n);
    if (i === null) fv(e, t, n, lm, r), F_(e, n);
    else if (cB(i, e, t, r, n)) n.stopPropagation();
    else if (F_(e, n), t & 4 && -1 < uB.indexOf(e)) {
      for (; i !== null; ) {
        var s = xp(i);
        if (s !== null && U$(s), s = v0(e, t, r, n), s === null && fv(e, t, n, lm, r), s === i) break;
        i = s;
      }
      i !== null && n.stopPropagation();
    } else fv(e, t, n, null, r);
  }
}
var lm = null;
function v0(e, t, r, n) {
  if (lm = null, e = Qw(n), e = Xs(e), e !== null) if (t = Sa(e), t === null) e = null;
  else if (r = t.tag, r === 13) {
    if (e = j$(t), e !== null) return e;
    e = null;
  } else if (r === 3) {
    if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null;
    e = null;
  } else t !== e && (e = null);
  return lm = e, null;
}
function Y$(e) {
  switch (e) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (eB()) {
        case Yw:
          return 1;
        case F$:
          return 4;
        case om:
        case tB:
          return 16;
        case z$:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var Wo = null, Jw = null, Rh = null;
function G$() {
  if (Rh) return Rh;
  var e, t = Jw, r = t.length, n, i = "value" in Wo ? Wo.value : Wo.textContent, s = i.length;
  for (e = 0; e < r && t[e] === i[e]; e++) ;
  var o = r - e;
  for (n = 1; n <= o && t[r - n] === i[s - n]; n++) ;
  return Rh = i.slice(e, 1 < n ? 1 - n : void 0);
}
function Ih(e) {
  var t = e.keyCode;
  return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0;
}
function ed() {
  return !0;
}
function q_() {
  return !1;
}
function bn(e) {
  function t(r, n, i, s, o) {
    this._reactName = r, this._targetInst = i, this.type = n, this.nativeEvent = s, this.target = o, this.currentTarget = null;
    for (var a in e) e.hasOwnProperty(a) && (r = e[a], this[a] = r ? r(s) : s[a]);
    return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? ed : q_, this.isPropagationStopped = q_, this;
  }
  return Ht(t.prototype, { preventDefault: function() {
    this.defaultPrevented = !0;
    var r = this.nativeEvent;
    r && (r.preventDefault ? r.preventDefault() : typeof r.returnValue != "unknown" && (r.returnValue = !1), this.isDefaultPrevented = ed);
  }, stopPropagation: function() {
    var r = this.nativeEvent;
    r && (r.stopPropagation ? r.stopPropagation() : typeof r.cancelBubble != "unknown" && (r.cancelBubble = !0), this.isPropagationStopped = ed);
  }, persist: function() {
  }, isPersistent: ed }), t;
}
var Zl = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(e) {
  return e.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, Zw = bn(Zl), Sp = Ht({}, Zl, { view: 0, detail: 0 }), hB = bn(Sp), nv, iv, Wu, lg = Ht({}, Sp, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: eS, button: 0, buttons: 0, relatedTarget: function(e) {
  return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget;
}, movementX: function(e) {
  return "movementX" in e ? e.movementX : (e !== Wu && (Wu && e.type === "mousemove" ? (nv = e.screenX - Wu.screenX, iv = e.screenY - Wu.screenY) : iv = nv = 0, Wu = e), nv);
}, movementY: function(e) {
  return "movementY" in e ? e.movementY : iv;
} }), B_ = bn(lg), mB = Ht({}, lg, { dataTransfer: 0 }), gB = bn(mB), yB = Ht({}, Sp, { relatedTarget: 0 }), ov = bn(yB), vB = Ht({}, Zl, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), bB = bn(vB), wB = Ht({}, Zl, { clipboardData: function(e) {
  return "clipboardData" in e ? e.clipboardData : window.clipboardData;
} }), SB = bn(wB), xB = Ht({}, Zl, { data: 0 }), U_ = bn(xB), EB = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, _B = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, OB = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function kB(e) {
  var t = this.nativeEvent;
  return t.getModifierState ? t.getModifierState(e) : (e = OB[e]) ? !!t[e] : !1;
}
function eS() {
  return kB;
}
var AB = Ht({}, Sp, { key: function(e) {
  if (e.key) {
    var t = EB[e.key] || e.key;
    if (t !== "Unidentified") return t;
  }
  return e.type === "keypress" ? (e = Ih(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? _B[e.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: eS, charCode: function(e) {
  return e.type === "keypress" ? Ih(e) : 0;
}, keyCode: function(e) {
  return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
}, which: function(e) {
  return e.type === "keypress" ? Ih(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
} }), PB = bn(AB), TB = Ht({}, lg, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), V_ = bn(TB), CB = Ht({}, Sp, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: eS }), $B = bn(CB), RB = Ht({}, Zl, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), IB = bn(RB), NB = Ht({}, lg, {
  deltaX: function(e) {
    return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0;
  },
  deltaY: function(e) {
    return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), jB = bn(NB), LB = [9, 13, 27, 32], tS = ho && "CompositionEvent" in window, kc = null;
ho && "documentMode" in document && (kc = document.documentMode);
var MB = ho && "TextEvent" in window && !kc, K$ = ho && (!tS || kc && 8 < kc && 11 >= kc), W_ = " ", H_ = !1;
function X$(e, t) {
  switch (e) {
    case "keyup":
      return LB.indexOf(t.keyCode) !== -1;
    case "keydown":
      return t.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function J$(e) {
  return e = e.detail, typeof e == "object" && "data" in e ? e.data : null;
}
var ul = !1;
function DB(e, t) {
  switch (e) {
    case "compositionend":
      return J$(t);
    case "keypress":
      return t.which !== 32 ? null : (H_ = !0, W_);
    case "textInput":
      return e = t.data, e === W_ && H_ ? null : e;
    default:
      return null;
  }
}
function FB(e, t) {
  if (ul) return e === "compositionend" || !tS && X$(e, t) ? (e = G$(), Rh = Jw = Wo = null, ul = !1, e) : null;
  switch (e) {
    case "paste":
      return null;
    case "keypress":
      if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
        if (t.char && 1 < t.char.length) return t.char;
        if (t.which) return String.fromCharCode(t.which);
      }
      return null;
    case "compositionend":
      return K$ && t.locale !== "ko" ? null : t.data;
    default:
      return null;
  }
}
var zB = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
function Q_(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase();
  return t === "input" ? !!zB[e.type] : t === "textarea";
}
function Z$(e, t, r, n) {
  C$(n), t = um(t, "onChange"), 0 < t.length && (r = new Zw("onChange", "change", null, r, n), e.push({ event: r, listeners: t }));
}
var Ac = null, Hc = null;
function qB(e) {
  cR(e, 0);
}
function ug(e) {
  var t = fl(e);
  if (E$(t)) return e;
}
function BB(e, t) {
  if (e === "change") return t;
}
var eR = !1;
if (ho) {
  var sv;
  if (ho) {
    var av = "oninput" in document;
    if (!av) {
      var Y_ = document.createElement("div");
      Y_.setAttribute("oninput", "return;"), av = typeof Y_.oninput == "function";
    }
    sv = av;
  } else sv = !1;
  eR = sv && (!document.documentMode || 9 < document.documentMode);
}
function G_() {
  Ac && (Ac.detachEvent("onpropertychange", tR), Hc = Ac = null);
}
function tR(e) {
  if (e.propertyName === "value" && ug(Hc)) {
    var t = [];
    Z$(t, Hc, e, Qw(e)), N$(qB, t);
  }
}
function UB(e, t, r) {
  e === "focusin" ? (G_(), Ac = t, Hc = r, Ac.attachEvent("onpropertychange", tR)) : e === "focusout" && G_();
}
function VB(e) {
  if (e === "selectionchange" || e === "keyup" || e === "keydown") return ug(Hc);
}
function WB(e, t) {
  if (e === "click") return ug(t);
}
function HB(e, t) {
  if (e === "input" || e === "change") return ug(t);
}
function QB(e, t) {
  return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t;
}
var ai = typeof Object.is == "function" ? Object.is : QB;
function Qc(e, t) {
  if (ai(e, t)) return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1;
  var r = Object.keys(e), n = Object.keys(t);
  if (r.length !== n.length) return !1;
  for (n = 0; n < r.length; n++) {
    var i = r[n];
    if (!e0.call(t, i) || !ai(e[i], t[i])) return !1;
  }
  return !0;
}
function K_(e) {
  for (; e && e.firstChild; ) e = e.firstChild;
  return e;
}
function X_(e, t) {
  var r = K_(e);
  e = 0;
  for (var n; r; ) {
    if (r.nodeType === 3) {
      if (n = e + r.textContent.length, e <= t && n >= t) return { node: r, offset: t - e };
      e = n;
    }
    e: {
      for (; r; ) {
        if (r.nextSibling) {
          r = r.nextSibling;
          break e;
        }
        r = r.parentNode;
      }
      r = void 0;
    }
    r = K_(r);
  }
}
function rR(e, t) {
  return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? rR(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1;
}
function nR() {
  for (var e = window, t = rm(); t instanceof e.HTMLIFrameElement; ) {
    try {
      var r = typeof t.contentWindow.location.href == "string";
    } catch {
      r = !1;
    }
    if (r) e = t.contentWindow;
    else break;
    t = rm(e.document);
  }
  return t;
}
function rS(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase();
  return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true");
}
function YB(e) {
  var t = nR(), r = e.focusedElem, n = e.selectionRange;
  if (t !== r && r && r.ownerDocument && rR(r.ownerDocument.documentElement, r)) {
    if (n !== null && rS(r)) {
      if (t = n.start, e = n.end, e === void 0 && (e = t), "selectionStart" in r) r.selectionStart = t, r.selectionEnd = Math.min(e, r.value.length);
      else if (e = (t = r.ownerDocument || document) && t.defaultView || window, e.getSelection) {
        e = e.getSelection();
        var i = r.textContent.length, s = Math.min(n.start, i);
        n = n.end === void 0 ? s : Math.min(n.end, i), !e.extend && s > n && (i = n, n = s, s = i), i = X_(r, s);
        var o = X_(
          r,
          n
        );
        i && o && (e.rangeCount !== 1 || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== o.node || e.focusOffset !== o.offset) && (t = t.createRange(), t.setStart(i.node, i.offset), e.removeAllRanges(), s > n ? (e.addRange(t), e.extend(o.node, o.offset)) : (t.setEnd(o.node, o.offset), e.addRange(t)));
      }
    }
    for (t = [], e = r; e = e.parentNode; ) e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop });
    for (typeof r.focus == "function" && r.focus(), r = 0; r < t.length; r++) e = t[r], e.element.scrollLeft = e.left, e.element.scrollTop = e.top;
  }
}
var GB = ho && "documentMode" in document && 11 >= document.documentMode, cl = null, b0 = null, Pc = null, w0 = !1;
function J_(e, t, r) {
  var n = r.window === r ? r.document : r.nodeType === 9 ? r : r.ownerDocument;
  w0 || cl == null || cl !== rm(n) || (n = cl, "selectionStart" in n && rS(n) ? n = { start: n.selectionStart, end: n.selectionEnd } : (n = (n.ownerDocument && n.ownerDocument.defaultView || window).getSelection(), n = { anchorNode: n.anchorNode, anchorOffset: n.anchorOffset, focusNode: n.focusNode, focusOffset: n.focusOffset }), Pc && Qc(Pc, n) || (Pc = n, n = um(b0, "onSelect"), 0 < n.length && (t = new Zw("onSelect", "select", null, t, r), e.push({ event: t, listeners: n }), t.target = cl)));
}
function td(e, t) {
  var r = {};
  return r[e.toLowerCase()] = t.toLowerCase(), r["Webkit" + e] = "webkit" + t, r["Moz" + e] = "moz" + t, r;
}
var pl = { animationend: td("Animation", "AnimationEnd"), animationiteration: td("Animation", "AnimationIteration"), animationstart: td("Animation", "AnimationStart"), transitionend: td("Transition", "TransitionEnd") }, lv = {}, iR = {};
ho && (iR = document.createElement("div").style, "AnimationEvent" in window || (delete pl.animationend.animation, delete pl.animationiteration.animation, delete pl.animationstart.animation), "TransitionEvent" in window || delete pl.transitionend.transition);
function cg(e) {
  if (lv[e]) return lv[e];
  if (!pl[e]) return e;
  var t = pl[e], r;
  for (r in t) if (t.hasOwnProperty(r) && r in iR) return lv[e] = t[r];
  return e;
}
var oR = cg("animationend"), sR = cg("animationiteration"), aR = cg("animationstart"), lR = cg("transitionend"), uR = /* @__PURE__ */ new Map(), Z_ = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ys(e, t) {
  uR.set(e, t), wa(t, [e]);
}
for (var uv = 0; uv < Z_.length; uv++) {
  var cv = Z_[uv], KB = cv.toLowerCase(), XB = cv[0].toUpperCase() + cv.slice(1);
  ys(KB, "on" + XB);
}
ys(oR, "onAnimationEnd");
ys(sR, "onAnimationIteration");
ys(aR, "onAnimationStart");
ys("dblclick", "onDoubleClick");
ys("focusin", "onFocus");
ys("focusout", "onBlur");
ys(lR, "onTransitionEnd");
Rl("onMouseEnter", ["mouseout", "mouseover"]);
Rl("onMouseLeave", ["mouseout", "mouseover"]);
Rl("onPointerEnter", ["pointerout", "pointerover"]);
Rl("onPointerLeave", ["pointerout", "pointerover"]);
wa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
wa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
wa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
wa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
wa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
wa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var vc = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), JB = new Set("cancel close invalid load scroll toggle".split(" ").concat(vc));
function eO(e, t, r) {
  var n = e.type || "unknown-event";
  e.currentTarget = r, Kq(n, t, void 0, e), e.currentTarget = null;
}
function cR(e, t) {
  t = (t & 4) !== 0;
  for (var r = 0; r < e.length; r++) {
    var n = e[r], i = n.event;
    n = n.listeners;
    e: {
      var s = void 0;
      if (t) for (var o = n.length - 1; 0 <= o; o--) {
        var a = n[o], l = a.instance, u = a.currentTarget;
        if (a = a.listener, l !== s && i.isPropagationStopped()) break e;
        eO(i, a, u), s = l;
      }
      else for (o = 0; o < n.length; o++) {
        if (a = n[o], l = a.instance, u = a.currentTarget, a = a.listener, l !== s && i.isPropagationStopped()) break e;
        eO(i, a, u), s = l;
      }
    }
  }
  if (im) throw e = m0, im = !1, m0 = null, e;
}
function jt(e, t) {
  var r = t[O0];
  r === void 0 && (r = t[O0] = /* @__PURE__ */ new Set());
  var n = e + "__bubble";
  r.has(n) || (pR(t, e, 2, !1), r.add(n));
}
function pv(e, t, r) {
  var n = 0;
  t && (n |= 4), pR(r, e, n, t);
}
var rd = "_reactListening" + Math.random().toString(36).slice(2);
function Yc(e) {
  if (!e[rd]) {
    e[rd] = !0, v$.forEach(function(r) {
      r !== "selectionchange" && (JB.has(r) || pv(r, !1, e), pv(r, !0, e));
    });
    var t = e.nodeType === 9 ? e : e.ownerDocument;
    t === null || t[rd] || (t[rd] = !0, pv("selectionchange", !1, t));
  }
}
function pR(e, t, r, n) {
  switch (Y$(t)) {
    case 1:
      var i = fB;
      break;
    case 4:
      i = dB;
      break;
    default:
      i = Xw;
  }
  r = i.bind(null, t, r, e), i = void 0, !h0 || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (i = !0), n ? i !== void 0 ? e.addEventListener(t, r, { capture: !0, passive: i }) : e.addEventListener(t, r, !0) : i !== void 0 ? e.addEventListener(t, r, { passive: i }) : e.addEventListener(t, r, !1);
}
function fv(e, t, r, n, i) {
  var s = n;
  if (!(t & 1) && !(t & 2) && n !== null) e: for (; ; ) {
    if (n === null) return;
    var o = n.tag;
    if (o === 3 || o === 4) {
      var a = n.stateNode.containerInfo;
      if (a === i || a.nodeType === 8 && a.parentNode === i) break;
      if (o === 4) for (o = n.return; o !== null; ) {
        var l = o.tag;
        if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo, l === i || l.nodeType === 8 && l.parentNode === i)) return;
        o = o.return;
      }
      for (; a !== null; ) {
        if (o = Xs(a), o === null) return;
        if (l = o.tag, l === 5 || l === 6) {
          n = s = o;
          continue e;
        }
        a = a.parentNode;
      }
    }
    n = n.return;
  }
  N$(function() {
    var u = s, f = Qw(r), d = [];
    e: {
      var m = uR.get(e);
      if (m !== void 0) {
        var v = Zw, S = e;
        switch (e) {
          case "keypress":
            if (Ih(r) === 0) break e;
          case "keydown":
          case "keyup":
            v = PB;
            break;
          case "focusin":
            S = "focus", v = ov;
            break;
          case "focusout":
            S = "blur", v = ov;
            break;
          case "beforeblur":
          case "afterblur":
            v = ov;
            break;
          case "click":
            if (r.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            v = B_;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            v = gB;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            v = $B;
            break;
          case oR:
          case sR:
          case aR:
            v = bB;
            break;
          case lR:
            v = IB;
            break;
          case "scroll":
            v = hB;
            break;
          case "wheel":
            v = jB;
            break;
          case "copy":
          case "cut":
          case "paste":
            v = SB;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            v = V_;
        }
        var y = (t & 4) !== 0, E = !y && e === "scroll", x = y ? m !== null ? m + "Capture" : null : m;
        y = [];
        for (var g = u, b; g !== null; ) {
          b = g;
          var A = b.stateNode;
          if (b.tag === 5 && A !== null && (b = A, x !== null && (A = Bc(g, x), A != null && y.push(Gc(g, A, b)))), E) break;
          g = g.return;
        }
        0 < y.length && (m = new v(m, S, null, r, f), d.push({ event: m, listeners: y }));
      }
    }
    if (!(t & 7)) {
      e: {
        if (m = e === "mouseover" || e === "pointerover", v = e === "mouseout" || e === "pointerout", m && r !== f0 && (S = r.relatedTarget || r.fromElement) && (Xs(S) || S[mo])) break e;
        if ((v || m) && (m = f.window === f ? f : (m = f.ownerDocument) ? m.defaultView || m.parentWindow : window, v ? (S = r.relatedTarget || r.toElement, v = u, S = S ? Xs(S) : null, S !== null && (E = Sa(S), S !== E || S.tag !== 5 && S.tag !== 6) && (S = null)) : (v = null, S = u), v !== S)) {
          if (y = B_, A = "onMouseLeave", x = "onMouseEnter", g = "mouse", (e === "pointerout" || e === "pointerover") && (y = V_, A = "onPointerLeave", x = "onPointerEnter", g = "pointer"), E = v == null ? m : fl(v), b = S == null ? m : fl(S), m = new y(A, g + "leave", v, r, f), m.target = E, m.relatedTarget = b, A = null, Xs(f) === u && (y = new y(x, g + "enter", S, r, f), y.target = b, y.relatedTarget = E, A = y), E = A, v && S) t: {
            for (y = v, x = S, g = 0, b = y; b; b = Ga(b)) g++;
            for (b = 0, A = x; A; A = Ga(A)) b++;
            for (; 0 < g - b; ) y = Ga(y), g--;
            for (; 0 < b - g; ) x = Ga(x), b--;
            for (; g--; ) {
              if (y === x || x !== null && y === x.alternate) break t;
              y = Ga(y), x = Ga(x);
            }
            y = null;
          }
          else y = null;
          v !== null && tO(d, m, v, y, !1), S !== null && E !== null && tO(d, E, S, y, !0);
        }
      }
      e: {
        if (m = u ? fl(u) : window, v = m.nodeName && m.nodeName.toLowerCase(), v === "select" || v === "input" && m.type === "file") var P = BB;
        else if (Q_(m)) if (eR) P = HB;
        else {
          P = VB;
          var k = UB;
        }
        else (v = m.nodeName) && v.toLowerCase() === "input" && (m.type === "checkbox" || m.type === "radio") && (P = WB);
        if (P && (P = P(e, u))) {
          Z$(d, P, r, f);
          break e;
        }
        k && k(e, m, u), e === "focusout" && (k = m._wrapperState) && k.controlled && m.type === "number" && a0(m, "number", m.value);
      }
      switch (k = u ? fl(u) : window, e) {
        case "focusin":
          (Q_(k) || k.contentEditable === "true") && (cl = k, b0 = u, Pc = null);
          break;
        case "focusout":
          Pc = b0 = cl = null;
          break;
        case "mousedown":
          w0 = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          w0 = !1, J_(d, r, f);
          break;
        case "selectionchange":
          if (GB) break;
        case "keydown":
        case "keyup":
          J_(d, r, f);
      }
      var $;
      if (tS) e: {
        switch (e) {
          case "compositionstart":
            var I = "onCompositionStart";
            break e;
          case "compositionend":
            I = "onCompositionEnd";
            break e;
          case "compositionupdate":
            I = "onCompositionUpdate";
            break e;
        }
        I = void 0;
      }
      else ul ? X$(e, r) && (I = "onCompositionEnd") : e === "keydown" && r.keyCode === 229 && (I = "onCompositionStart");
      I && (K$ && r.locale !== "ko" && (ul || I !== "onCompositionStart" ? I === "onCompositionEnd" && ul && ($ = G$()) : (Wo = f, Jw = "value" in Wo ? Wo.value : Wo.textContent, ul = !0)), k = um(u, I), 0 < k.length && (I = new U_(I, e, null, r, f), d.push({ event: I, listeners: k }), $ ? I.data = $ : ($ = J$(r), $ !== null && (I.data = $)))), ($ = MB ? DB(e, r) : FB(e, r)) && (u = um(u, "onBeforeInput"), 0 < u.length && (f = new U_("onBeforeInput", "beforeinput", null, r, f), d.push({ event: f, listeners: u }), f.data = $));
    }
    cR(d, t);
  });
}
function Gc(e, t, r) {
  return { instance: e, listener: t, currentTarget: r };
}
function um(e, t) {
  for (var r = t + "Capture", n = []; e !== null; ) {
    var i = e, s = i.stateNode;
    i.tag === 5 && s !== null && (i = s, s = Bc(e, r), s != null && n.unshift(Gc(e, s, i)), s = Bc(e, t), s != null && n.push(Gc(e, s, i))), e = e.return;
  }
  return n;
}
function Ga(e) {
  if (e === null) return null;
  do
    e = e.return;
  while (e && e.tag !== 5);
  return e || null;
}
function tO(e, t, r, n, i) {
  for (var s = t._reactName, o = []; r !== null && r !== n; ) {
    var a = r, l = a.alternate, u = a.stateNode;
    if (l !== null && l === n) break;
    a.tag === 5 && u !== null && (a = u, i ? (l = Bc(r, s), l != null && o.unshift(Gc(r, l, a))) : i || (l = Bc(r, s), l != null && o.push(Gc(r, l, a)))), r = r.return;
  }
  o.length !== 0 && e.push({ event: t, listeners: o });
}
var ZB = /\r\n?/g, e3 = /\u0000|\uFFFD/g;
function rO(e) {
  return (typeof e == "string" ? e : "" + e).replace(ZB, `
`).replace(e3, "");
}
function nd(e, t, r) {
  if (t = rO(t), rO(e) !== t && r) throw Error(Ne(425));
}
function cm() {
}
var S0 = null, x0 = null;
function E0(e, t) {
  return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null;
}
var _0 = typeof setTimeout == "function" ? setTimeout : void 0, t3 = typeof clearTimeout == "function" ? clearTimeout : void 0, nO = typeof Promise == "function" ? Promise : void 0, r3 = typeof queueMicrotask == "function" ? queueMicrotask : typeof nO < "u" ? function(e) {
  return nO.resolve(null).then(e).catch(n3);
} : _0;
function n3(e) {
  setTimeout(function() {
    throw e;
  });
}
function dv(e, t) {
  var r = t, n = 0;
  do {
    var i = r.nextSibling;
    if (e.removeChild(r), i && i.nodeType === 8) if (r = i.data, r === "/$") {
      if (n === 0) {
        e.removeChild(i), Wc(t);
        return;
      }
      n--;
    } else r !== "$" && r !== "$?" && r !== "$!" || n++;
    r = i;
  } while (r);
  Wc(t);
}
function es(e) {
  for (; e != null; e = e.nextSibling) {
    var t = e.nodeType;
    if (t === 1 || t === 3) break;
    if (t === 8) {
      if (t = e.data, t === "$" || t === "$!" || t === "$?") break;
      if (t === "/$") return null;
    }
  }
  return e;
}
function iO(e) {
  e = e.previousSibling;
  for (var t = 0; e; ) {
    if (e.nodeType === 8) {
      var r = e.data;
      if (r === "$" || r === "$!" || r === "$?") {
        if (t === 0) return e;
        t--;
      } else r === "/$" && t++;
    }
    e = e.previousSibling;
  }
  return null;
}
var eu = Math.random().toString(36).slice(2), Oi = "__reactFiber$" + eu, Kc = "__reactProps$" + eu, mo = "__reactContainer$" + eu, O0 = "__reactEvents$" + eu, i3 = "__reactListeners$" + eu, o3 = "__reactHandles$" + eu;
function Xs(e) {
  var t = e[Oi];
  if (t) return t;
  for (var r = e.parentNode; r; ) {
    if (t = r[mo] || r[Oi]) {
      if (r = t.alternate, t.child !== null || r !== null && r.child !== null) for (e = iO(e); e !== null; ) {
        if (r = e[Oi]) return r;
        e = iO(e);
      }
      return t;
    }
    e = r, r = e.parentNode;
  }
  return null;
}
function xp(e) {
  return e = e[Oi] || e[mo], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e;
}
function fl(e) {
  if (e.tag === 5 || e.tag === 6) return e.stateNode;
  throw Error(Ne(33));
}
function pg(e) {
  return e[Kc] || null;
}
var k0 = [], dl = -1;
function vs(e) {
  return { current: e };
}
function Mt(e) {
  0 > dl || (e.current = k0[dl], k0[dl] = null, dl--);
}
function Rt(e, t) {
  dl++, k0[dl] = e.current, e.current = t;
}
var us = {}, Lr = vs(us), rn = vs(!1), la = us;
function Il(e, t) {
  var r = e.type.contextTypes;
  if (!r) return us;
  var n = e.stateNode;
  if (n && n.__reactInternalMemoizedUnmaskedChildContext === t) return n.__reactInternalMemoizedMaskedChildContext;
  var i = {}, s;
  for (s in r) i[s] = t[s];
  return n && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = i), i;
}
function nn(e) {
  return e = e.childContextTypes, e != null;
}
function pm() {
  Mt(rn), Mt(Lr);
}
function oO(e, t, r) {
  if (Lr.current !== us) throw Error(Ne(168));
  Rt(Lr, t), Rt(rn, r);
}
function fR(e, t, r) {
  var n = e.stateNode;
  if (t = t.childContextTypes, typeof n.getChildContext != "function") return r;
  n = n.getChildContext();
  for (var i in n) if (!(i in t)) throw Error(Ne(108, Uq(e) || "Unknown", i));
  return Ht({}, r, n);
}
function fm(e) {
  return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || us, la = Lr.current, Rt(Lr, e), Rt(rn, rn.current), !0;
}
function sO(e, t, r) {
  var n = e.stateNode;
  if (!n) throw Error(Ne(169));
  r ? (e = fR(e, t, la), n.__reactInternalMemoizedMergedChildContext = e, Mt(rn), Mt(Lr), Rt(Lr, e)) : Mt(rn), Rt(rn, r);
}
var io = null, fg = !1, hv = !1;
function dR(e) {
  io === null ? io = [e] : io.push(e);
}
function s3(e) {
  fg = !0, dR(e);
}
function bs() {
  if (!hv && io !== null) {
    hv = !0;
    var e = 0, t = xt;
    try {
      var r = io;
      for (xt = 1; e < r.length; e++) {
        var n = r[e];
        do
          n = n(!0);
        while (n !== null);
      }
      io = null, fg = !1;
    } catch (i) {
      throw io !== null && (io = io.slice(e + 1)), D$(Yw, bs), i;
    } finally {
      xt = t, hv = !1;
    }
  }
  return null;
}
var hl = [], ml = 0, dm = null, hm = 0, An = [], Pn = 0, ua = null, so = 1, ao = "";
function Qs(e, t) {
  hl[ml++] = hm, hl[ml++] = dm, dm = e, hm = t;
}
function hR(e, t, r) {
  An[Pn++] = so, An[Pn++] = ao, An[Pn++] = ua, ua = e;
  var n = so;
  e = ao;
  var i = 32 - ei(n) - 1;
  n &= ~(1 << i), r += 1;
  var s = 32 - ei(t) + i;
  if (30 < s) {
    var o = i - i % 5;
    s = (n & (1 << o) - 1).toString(32), n >>= o, i -= o, so = 1 << 32 - ei(t) + i | r << i | n, ao = s + e;
  } else so = 1 << s | r << i | n, ao = e;
}
function nS(e) {
  e.return !== null && (Qs(e, 1), hR(e, 1, 0));
}
function iS(e) {
  for (; e === dm; ) dm = hl[--ml], hl[ml] = null, hm = hl[--ml], hl[ml] = null;
  for (; e === ua; ) ua = An[--Pn], An[Pn] = null, ao = An[--Pn], An[Pn] = null, so = An[--Pn], An[Pn] = null;
}
var hn = null, dn = null, Ft = !1, Jn = null;
function mR(e, t) {
  var r = $n(5, null, null, 0);
  r.elementType = "DELETED", r.stateNode = t, r.return = e, t = e.deletions, t === null ? (e.deletions = [r], e.flags |= 16) : t.push(r);
}
function aO(e, t) {
  switch (e.tag) {
    case 5:
      var r = e.type;
      return t = t.nodeType !== 1 || r.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null ? (e.stateNode = t, hn = e, dn = es(t.firstChild), !0) : !1;
    case 6:
      return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null ? (e.stateNode = t, hn = e, dn = null, !0) : !1;
    case 13:
      return t = t.nodeType !== 8 ? null : t, t !== null ? (r = ua !== null ? { id: so, overflow: ao } : null, e.memoizedState = { dehydrated: t, treeContext: r, retryLane: 1073741824 }, r = $n(18, null, null, 0), r.stateNode = t, r.return = e, e.child = r, hn = e, dn = null, !0) : !1;
    default:
      return !1;
  }
}
function A0(e) {
  return (e.mode & 1) !== 0 && (e.flags & 128) === 0;
}
function P0(e) {
  if (Ft) {
    var t = dn;
    if (t) {
      var r = t;
      if (!aO(e, t)) {
        if (A0(e)) throw Error(Ne(418));
        t = es(r.nextSibling);
        var n = hn;
        t && aO(e, t) ? mR(n, r) : (e.flags = e.flags & -4097 | 2, Ft = !1, hn = e);
      }
    } else {
      if (A0(e)) throw Error(Ne(418));
      e.flags = e.flags & -4097 | 2, Ft = !1, hn = e;
    }
  }
}
function lO(e) {
  for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13; ) e = e.return;
  hn = e;
}
function id(e) {
  if (e !== hn) return !1;
  if (!Ft) return lO(e), Ft = !0, !1;
  var t;
  if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !E0(e.type, e.memoizedProps)), t && (t = dn)) {
    if (A0(e)) throw gR(), Error(Ne(418));
    for (; t; ) mR(e, t), t = es(t.nextSibling);
  }
  if (lO(e), e.tag === 13) {
    if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(Ne(317));
    e: {
      for (e = e.nextSibling, t = 0; e; ) {
        if (e.nodeType === 8) {
          var r = e.data;
          if (r === "/$") {
            if (t === 0) {
              dn = es(e.nextSibling);
              break e;
            }
            t--;
          } else r !== "$" && r !== "$!" && r !== "$?" || t++;
        }
        e = e.nextSibling;
      }
      dn = null;
    }
  } else dn = hn ? es(e.stateNode.nextSibling) : null;
  return !0;
}
function gR() {
  for (var e = dn; e; ) e = es(e.nextSibling);
}
function Nl() {
  dn = hn = null, Ft = !1;
}
function oS(e) {
  Jn === null ? Jn = [e] : Jn.push(e);
}
var a3 = Oo.ReactCurrentBatchConfig;
function Hu(e, t, r) {
  if (e = r.ref, e !== null && typeof e != "function" && typeof e != "object") {
    if (r._owner) {
      if (r = r._owner, r) {
        if (r.tag !== 1) throw Error(Ne(309));
        var n = r.stateNode;
      }
      if (!n) throw Error(Ne(147, e));
      var i = n, s = "" + e;
      return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === s ? t.ref : (t = function(o) {
        var a = i.refs;
        o === null ? delete a[s] : a[s] = o;
      }, t._stringRef = s, t);
    }
    if (typeof e != "string") throw Error(Ne(284));
    if (!r._owner) throw Error(Ne(290, e));
  }
  return e;
}
function od(e, t) {
  throw e = Object.prototype.toString.call(t), Error(Ne(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e));
}
function uO(e) {
  var t = e._init;
  return t(e._payload);
}
function yR(e) {
  function t(x, g) {
    if (e) {
      var b = x.deletions;
      b === null ? (x.deletions = [g], x.flags |= 16) : b.push(g);
    }
  }
  function r(x, g) {
    if (!e) return null;
    for (; g !== null; ) t(x, g), g = g.sibling;
    return null;
  }
  function n(x, g) {
    for (x = /* @__PURE__ */ new Map(); g !== null; ) g.key !== null ? x.set(g.key, g) : x.set(g.index, g), g = g.sibling;
    return x;
  }
  function i(x, g) {
    return x = is(x, g), x.index = 0, x.sibling = null, x;
  }
  function s(x, g, b) {
    return x.index = b, e ? (b = x.alternate, b !== null ? (b = b.index, b < g ? (x.flags |= 2, g) : b) : (x.flags |= 2, g)) : (x.flags |= 1048576, g);
  }
  function o(x) {
    return e && x.alternate === null && (x.flags |= 2), x;
  }
  function a(x, g, b, A) {
    return g === null || g.tag !== 6 ? (g = Sv(b, x.mode, A), g.return = x, g) : (g = i(g, b), g.return = x, g);
  }
  function l(x, g, b, A) {
    var P = b.type;
    return P === ll ? f(x, g, b.props.children, A, b.key) : g !== null && (g.elementType === P || typeof P == "object" && P !== null && P.$$typeof === zo && uO(P) === g.type) ? (A = i(g, b.props), A.ref = Hu(x, g, b), A.return = x, A) : (A = zh(b.type, b.key, b.props, null, x.mode, A), A.ref = Hu(x, g, b), A.return = x, A);
  }
  function u(x, g, b, A) {
    return g === null || g.tag !== 4 || g.stateNode.containerInfo !== b.containerInfo || g.stateNode.implementation !== b.implementation ? (g = xv(b, x.mode, A), g.return = x, g) : (g = i(g, b.children || []), g.return = x, g);
  }
  function f(x, g, b, A, P) {
    return g === null || g.tag !== 7 ? (g = ia(b, x.mode, A, P), g.return = x, g) : (g = i(g, b), g.return = x, g);
  }
  function d(x, g, b) {
    if (typeof g == "string" && g !== "" || typeof g == "number") return g = Sv("" + g, x.mode, b), g.return = x, g;
    if (typeof g == "object" && g !== null) {
      switch (g.$$typeof) {
        case Yf:
          return b = zh(g.type, g.key, g.props, null, x.mode, b), b.ref = Hu(x, null, g), b.return = x, b;
        case al:
          return g = xv(g, x.mode, b), g.return = x, g;
        case zo:
          var A = g._init;
          return d(x, A(g._payload), b);
      }
      if (gc(g) || qu(g)) return g = ia(g, x.mode, b, null), g.return = x, g;
      od(x, g);
    }
    return null;
  }
  function m(x, g, b, A) {
    var P = g !== null ? g.key : null;
    if (typeof b == "string" && b !== "" || typeof b == "number") return P !== null ? null : a(x, g, "" + b, A);
    if (typeof b == "object" && b !== null) {
      switch (b.$$typeof) {
        case Yf:
          return b.key === P ? l(x, g, b, A) : null;
        case al:
          return b.key === P ? u(x, g, b, A) : null;
        case zo:
          return P = b._init, m(
            x,
            g,
            P(b._payload),
            A
          );
      }
      if (gc(b) || qu(b)) return P !== null ? null : f(x, g, b, A, null);
      od(x, b);
    }
    return null;
  }
  function v(x, g, b, A, P) {
    if (typeof A == "string" && A !== "" || typeof A == "number") return x = x.get(b) || null, a(g, x, "" + A, P);
    if (typeof A == "object" && A !== null) {
      switch (A.$$typeof) {
        case Yf:
          return x = x.get(A.key === null ? b : A.key) || null, l(g, x, A, P);
        case al:
          return x = x.get(A.key === null ? b : A.key) || null, u(g, x, A, P);
        case zo:
          var k = A._init;
          return v(x, g, b, k(A._payload), P);
      }
      if (gc(A) || qu(A)) return x = x.get(b) || null, f(g, x, A, P, null);
      od(g, A);
    }
    return null;
  }
  function S(x, g, b, A) {
    for (var P = null, k = null, $ = g, I = g = 0, F = null; $ !== null && I < b.length; I++) {
      $.index > I ? (F = $, $ = null) : F = $.sibling;
      var L = m(x, $, b[I], A);
      if (L === null) {
        $ === null && ($ = F);
        break;
      }
      e && $ && L.alternate === null && t(x, $), g = s(L, g, I), k === null ? P = L : k.sibling = L, k = L, $ = F;
    }
    if (I === b.length) return r(x, $), Ft && Qs(x, I), P;
    if ($ === null) {
      for (; I < b.length; I++) $ = d(x, b[I], A), $ !== null && (g = s($, g, I), k === null ? P = $ : k.sibling = $, k = $);
      return Ft && Qs(x, I), P;
    }
    for ($ = n(x, $); I < b.length; I++) F = v($, x, I, b[I], A), F !== null && (e && F.alternate !== null && $.delete(F.key === null ? I : F.key), g = s(F, g, I), k === null ? P = F : k.sibling = F, k = F);
    return e && $.forEach(function(Q) {
      return t(x, Q);
    }), Ft && Qs(x, I), P;
  }
  function y(x, g, b, A) {
    var P = qu(b);
    if (typeof P != "function") throw Error(Ne(150));
    if (b = P.call(b), b == null) throw Error(Ne(151));
    for (var k = P = null, $ = g, I = g = 0, F = null, L = b.next(); $ !== null && !L.done; I++, L = b.next()) {
      $.index > I ? (F = $, $ = null) : F = $.sibling;
      var Q = m(x, $, L.value, A);
      if (Q === null) {
        $ === null && ($ = F);
        break;
      }
      e && $ && Q.alternate === null && t(x, $), g = s(Q, g, I), k === null ? P = Q : k.sibling = Q, k = Q, $ = F;
    }
    if (L.done) return r(
      x,
      $
    ), Ft && Qs(x, I), P;
    if ($ === null) {
      for (; !L.done; I++, L = b.next()) L = d(x, L.value, A), L !== null && (g = s(L, g, I), k === null ? P = L : k.sibling = L, k = L);
      return Ft && Qs(x, I), P;
    }
    for ($ = n(x, $); !L.done; I++, L = b.next()) L = v($, x, I, L.value, A), L !== null && (e && L.alternate !== null && $.delete(L.key === null ? I : L.key), g = s(L, g, I), k === null ? P = L : k.sibling = L, k = L);
    return e && $.forEach(function(Y) {
      return t(x, Y);
    }), Ft && Qs(x, I), P;
  }
  function E(x, g, b, A) {
    if (typeof b == "object" && b !== null && b.type === ll && b.key === null && (b = b.props.children), typeof b == "object" && b !== null) {
      switch (b.$$typeof) {
        case Yf:
          e: {
            for (var P = b.key, k = g; k !== null; ) {
              if (k.key === P) {
                if (P = b.type, P === ll) {
                  if (k.tag === 7) {
                    r(x, k.sibling), g = i(k, b.props.children), g.return = x, x = g;
                    break e;
                  }
                } else if (k.elementType === P || typeof P == "object" && P !== null && P.$$typeof === zo && uO(P) === k.type) {
                  r(x, k.sibling), g = i(k, b.props), g.ref = Hu(x, k, b), g.return = x, x = g;
                  break e;
                }
                r(x, k);
                break;
              } else t(x, k);
              k = k.sibling;
            }
            b.type === ll ? (g = ia(b.props.children, x.mode, A, b.key), g.return = x, x = g) : (A = zh(b.type, b.key, b.props, null, x.mode, A), A.ref = Hu(x, g, b), A.return = x, x = A);
          }
          return o(x);
        case al:
          e: {
            for (k = b.key; g !== null; ) {
              if (g.key === k) if (g.tag === 4 && g.stateNode.containerInfo === b.containerInfo && g.stateNode.implementation === b.implementation) {
                r(x, g.sibling), g = i(g, b.children || []), g.return = x, x = g;
                break e;
              } else {
                r(x, g);
                break;
              }
              else t(x, g);
              g = g.sibling;
            }
            g = xv(b, x.mode, A), g.return = x, x = g;
          }
          return o(x);
        case zo:
          return k = b._init, E(x, g, k(b._payload), A);
      }
      if (gc(b)) return S(x, g, b, A);
      if (qu(b)) return y(x, g, b, A);
      od(x, b);
    }
    return typeof b == "string" && b !== "" || typeof b == "number" ? (b = "" + b, g !== null && g.tag === 6 ? (r(x, g.sibling), g = i(g, b), g.return = x, x = g) : (r(x, g), g = Sv(b, x.mode, A), g.return = x, x = g), o(x)) : r(x, g);
  }
  return E;
}
var jl = yR(!0), vR = yR(!1), mm = vs(null), gm = null, gl = null, sS = null;
function aS() {
  sS = gl = gm = null;
}
function lS(e) {
  var t = mm.current;
  Mt(mm), e._currentValue = t;
}
function T0(e, t, r) {
  for (; e !== null; ) {
    var n = e.alternate;
    if ((e.childLanes & t) !== t ? (e.childLanes |= t, n !== null && (n.childLanes |= t)) : n !== null && (n.childLanes & t) !== t && (n.childLanes |= t), e === r) break;
    e = e.return;
  }
}
function Tl(e, t) {
  gm = e, sS = gl = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & t && (Zr = !0), e.firstContext = null);
}
function Nn(e) {
  var t = e._currentValue;
  if (sS !== e) if (e = { context: e, memoizedValue: t, next: null }, gl === null) {
    if (gm === null) throw Error(Ne(308));
    gl = e, gm.dependencies = { lanes: 0, firstContext: e };
  } else gl = gl.next = e;
  return t;
}
var Js = null;
function uS(e) {
  Js === null ? Js = [e] : Js.push(e);
}
function bR(e, t, r, n) {
  var i = t.interleaved;
  return i === null ? (r.next = r, uS(t)) : (r.next = i.next, i.next = r), t.interleaved = r, go(e, n);
}
function go(e, t) {
  e.lanes |= t;
  var r = e.alternate;
  for (r !== null && (r.lanes |= t), r = e, e = e.return; e !== null; ) e.childLanes |= t, r = e.alternate, r !== null && (r.childLanes |= t), r = e, e = e.return;
  return r.tag === 3 ? r.stateNode : null;
}
var qo = !1;
function cS(e) {
  e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function wR(e, t) {
  e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects });
}
function lo(e, t) {
  return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null };
}
function ts(e, t, r) {
  var n = e.updateQueue;
  if (n === null) return null;
  if (n = n.shared, mt & 2) {
    var i = n.pending;
    return i === null ? t.next = t : (t.next = i.next, i.next = t), n.pending = t, go(e, r);
  }
  return i = n.interleaved, i === null ? (t.next = t, uS(n)) : (t.next = i.next, i.next = t), n.interleaved = t, go(e, r);
}
function Nh(e, t, r) {
  if (t = t.updateQueue, t !== null && (t = t.shared, (r & 4194240) !== 0)) {
    var n = t.lanes;
    n &= e.pendingLanes, r |= n, t.lanes = r, Gw(e, r);
  }
}
function cO(e, t) {
  var r = e.updateQueue, n = e.alternate;
  if (n !== null && (n = n.updateQueue, r === n)) {
    var i = null, s = null;
    if (r = r.firstBaseUpdate, r !== null) {
      do {
        var o = { eventTime: r.eventTime, lane: r.lane, tag: r.tag, payload: r.payload, callback: r.callback, next: null };
        s === null ? i = s = o : s = s.next = o, r = r.next;
      } while (r !== null);
      s === null ? i = s = t : s = s.next = t;
    } else i = s = t;
    r = { baseState: n.baseState, firstBaseUpdate: i, lastBaseUpdate: s, shared: n.shared, effects: n.effects }, e.updateQueue = r;
    return;
  }
  e = r.lastBaseUpdate, e === null ? r.firstBaseUpdate = t : e.next = t, r.lastBaseUpdate = t;
}
function ym(e, t, r, n) {
  var i = e.updateQueue;
  qo = !1;
  var s = i.firstBaseUpdate, o = i.lastBaseUpdate, a = i.shared.pending;
  if (a !== null) {
    i.shared.pending = null;
    var l = a, u = l.next;
    l.next = null, o === null ? s = u : o.next = u, o = l;
    var f = e.alternate;
    f !== null && (f = f.updateQueue, a = f.lastBaseUpdate, a !== o && (a === null ? f.firstBaseUpdate = u : a.next = u, f.lastBaseUpdate = l));
  }
  if (s !== null) {
    var d = i.baseState;
    o = 0, f = u = l = null, a = s;
    do {
      var m = a.lane, v = a.eventTime;
      if ((n & m) === m) {
        f !== null && (f = f.next = {
          eventTime: v,
          lane: 0,
          tag: a.tag,
          payload: a.payload,
          callback: a.callback,
          next: null
        });
        e: {
          var S = e, y = a;
          switch (m = t, v = r, y.tag) {
            case 1:
              if (S = y.payload, typeof S == "function") {
                d = S.call(v, d, m);
                break e;
              }
              d = S;
              break e;
            case 3:
              S.flags = S.flags & -65537 | 128;
            case 0:
              if (S = y.payload, m = typeof S == "function" ? S.call(v, d, m) : S, m == null) break e;
              d = Ht({}, d, m);
              break e;
            case 2:
              qo = !0;
          }
        }
        a.callback !== null && a.lane !== 0 && (e.flags |= 64, m = i.effects, m === null ? i.effects = [a] : m.push(a));
      } else v = { eventTime: v, lane: m, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, f === null ? (u = f = v, l = d) : f = f.next = v, o |= m;
      if (a = a.next, a === null) {
        if (a = i.shared.pending, a === null) break;
        m = a, a = m.next, m.next = null, i.lastBaseUpdate = m, i.shared.pending = null;
      }
    } while (!0);
    if (f === null && (l = d), i.baseState = l, i.firstBaseUpdate = u, i.lastBaseUpdate = f, t = i.shared.interleaved, t !== null) {
      i = t;
      do
        o |= i.lane, i = i.next;
      while (i !== t);
    } else s === null && (i.shared.lanes = 0);
    pa |= o, e.lanes = o, e.memoizedState = d;
  }
}
function pO(e, t, r) {
  if (e = t.effects, t.effects = null, e !== null) for (t = 0; t < e.length; t++) {
    var n = e[t], i = n.callback;
    if (i !== null) {
      if (n.callback = null, n = r, typeof i != "function") throw Error(Ne(191, i));
      i.call(n);
    }
  }
}
var Ep = {}, Ri = vs(Ep), Xc = vs(Ep), Jc = vs(Ep);
function Zs(e) {
  if (e === Ep) throw Error(Ne(174));
  return e;
}
function pS(e, t) {
  switch (Rt(Jc, t), Rt(Xc, e), Rt(Ri, Ep), e = t.nodeType, e) {
    case 9:
    case 11:
      t = (t = t.documentElement) ? t.namespaceURI : u0(null, "");
      break;
    default:
      e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = u0(t, e);
  }
  Mt(Ri), Rt(Ri, t);
}
function Ll() {
  Mt(Ri), Mt(Xc), Mt(Jc);
}
function SR(e) {
  Zs(Jc.current);
  var t = Zs(Ri.current), r = u0(t, e.type);
  t !== r && (Rt(Xc, e), Rt(Ri, r));
}
function fS(e) {
  Xc.current === e && (Mt(Ri), Mt(Xc));
}
var Vt = vs(0);
function vm(e) {
  for (var t = e; t !== null; ) {
    if (t.tag === 13) {
      var r = t.memoizedState;
      if (r !== null && (r = r.dehydrated, r === null || r.data === "$?" || r.data === "$!")) return t;
    } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) {
      if (t.flags & 128) return t;
    } else if (t.child !== null) {
      t.child.return = t, t = t.child;
      continue;
    }
    if (t === e) break;
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e) return null;
      t = t.return;
    }
    t.sibling.return = t.return, t = t.sibling;
  }
  return null;
}
var mv = [];
function dS() {
  for (var e = 0; e < mv.length; e++) mv[e]._workInProgressVersionPrimary = null;
  mv.length = 0;
}
var jh = Oo.ReactCurrentDispatcher, gv = Oo.ReactCurrentBatchConfig, ca = 0, Wt = null, ur = null, hr = null, bm = !1, Tc = !1, Zc = 0, l3 = 0;
function Tr() {
  throw Error(Ne(321));
}
function hS(e, t) {
  if (t === null) return !1;
  for (var r = 0; r < t.length && r < e.length; r++) if (!ai(e[r], t[r])) return !1;
  return !0;
}
function mS(e, t, r, n, i, s) {
  if (ca = s, Wt = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, jh.current = e === null || e.memoizedState === null ? f3 : d3, e = r(n, i), Tc) {
    s = 0;
    do {
      if (Tc = !1, Zc = 0, 25 <= s) throw Error(Ne(301));
      s += 1, hr = ur = null, t.updateQueue = null, jh.current = h3, e = r(n, i);
    } while (Tc);
  }
  if (jh.current = wm, t = ur !== null && ur.next !== null, ca = 0, hr = ur = Wt = null, bm = !1, t) throw Error(Ne(300));
  return e;
}
function gS() {
  var e = Zc !== 0;
  return Zc = 0, e;
}
function Ei() {
  var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  return hr === null ? Wt.memoizedState = hr = e : hr = hr.next = e, hr;
}
function jn() {
  if (ur === null) {
    var e = Wt.alternate;
    e = e !== null ? e.memoizedState : null;
  } else e = ur.next;
  var t = hr === null ? Wt.memoizedState : hr.next;
  if (t !== null) hr = t, ur = e;
  else {
    if (e === null) throw Error(Ne(310));
    ur = e, e = { memoizedState: ur.memoizedState, baseState: ur.baseState, baseQueue: ur.baseQueue, queue: ur.queue, next: null }, hr === null ? Wt.memoizedState = hr = e : hr = hr.next = e;
  }
  return hr;
}
function ep(e, t) {
  return typeof t == "function" ? t(e) : t;
}
function yv(e) {
  var t = jn(), r = t.queue;
  if (r === null) throw Error(Ne(311));
  r.lastRenderedReducer = e;
  var n = ur, i = n.baseQueue, s = r.pending;
  if (s !== null) {
    if (i !== null) {
      var o = i.next;
      i.next = s.next, s.next = o;
    }
    n.baseQueue = i = s, r.pending = null;
  }
  if (i !== null) {
    s = i.next, n = n.baseState;
    var a = o = null, l = null, u = s;
    do {
      var f = u.lane;
      if ((ca & f) === f) l !== null && (l = l.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), n = u.hasEagerState ? u.eagerState : e(n, u.action);
      else {
        var d = {
          lane: f,
          action: u.action,
          hasEagerState: u.hasEagerState,
          eagerState: u.eagerState,
          next: null
        };
        l === null ? (a = l = d, o = n) : l = l.next = d, Wt.lanes |= f, pa |= f;
      }
      u = u.next;
    } while (u !== null && u !== s);
    l === null ? o = n : l.next = a, ai(n, t.memoizedState) || (Zr = !0), t.memoizedState = n, t.baseState = o, t.baseQueue = l, r.lastRenderedState = n;
  }
  if (e = r.interleaved, e !== null) {
    i = e;
    do
      s = i.lane, Wt.lanes |= s, pa |= s, i = i.next;
    while (i !== e);
  } else i === null && (r.lanes = 0);
  return [t.memoizedState, r.dispatch];
}
function vv(e) {
  var t = jn(), r = t.queue;
  if (r === null) throw Error(Ne(311));
  r.lastRenderedReducer = e;
  var n = r.dispatch, i = r.pending, s = t.memoizedState;
  if (i !== null) {
    r.pending = null;
    var o = i = i.next;
    do
      s = e(s, o.action), o = o.next;
    while (o !== i);
    ai(s, t.memoizedState) || (Zr = !0), t.memoizedState = s, t.baseQueue === null && (t.baseState = s), r.lastRenderedState = s;
  }
  return [s, n];
}
function xR() {
}
function ER(e, t) {
  var r = Wt, n = jn(), i = t(), s = !ai(n.memoizedState, i);
  if (s && (n.memoizedState = i, Zr = !0), n = n.queue, yS(kR.bind(null, r, n, e), [e]), n.getSnapshot !== t || s || hr !== null && hr.memoizedState.tag & 1) {
    if (r.flags |= 2048, tp(9, OR.bind(null, r, n, i, t), void 0, null), gr === null) throw Error(Ne(349));
    ca & 30 || _R(r, t, i);
  }
  return i;
}
function _R(e, t, r) {
  e.flags |= 16384, e = { getSnapshot: t, value: r }, t = Wt.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, Wt.updateQueue = t, t.stores = [e]) : (r = t.stores, r === null ? t.stores = [e] : r.push(e));
}
function OR(e, t, r, n) {
  t.value = r, t.getSnapshot = n, AR(t) && PR(e);
}
function kR(e, t, r) {
  return r(function() {
    AR(t) && PR(e);
  });
}
function AR(e) {
  var t = e.getSnapshot;
  e = e.value;
  try {
    var r = t();
    return !ai(e, r);
  } catch {
    return !0;
  }
}
function PR(e) {
  var t = go(e, 1);
  t !== null && ti(t, e, 1, -1);
}
function fO(e) {
  var t = Ei();
  return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ep, lastRenderedState: e }, t.queue = e, e = e.dispatch = p3.bind(null, Wt, e), [t.memoizedState, e];
}
function tp(e, t, r, n) {
  return e = { tag: e, create: t, destroy: r, deps: n, next: null }, t = Wt.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, Wt.updateQueue = t, t.lastEffect = e.next = e) : (r = t.lastEffect, r === null ? t.lastEffect = e.next = e : (n = r.next, r.next = e, e.next = n, t.lastEffect = e)), e;
}
function TR() {
  return jn().memoizedState;
}
function Lh(e, t, r, n) {
  var i = Ei();
  Wt.flags |= e, i.memoizedState = tp(1 | t, r, void 0, n === void 0 ? null : n);
}
function dg(e, t, r, n) {
  var i = jn();
  n = n === void 0 ? null : n;
  var s = void 0;
  if (ur !== null) {
    var o = ur.memoizedState;
    if (s = o.destroy, n !== null && hS(n, o.deps)) {
      i.memoizedState = tp(t, r, s, n);
      return;
    }
  }
  Wt.flags |= e, i.memoizedState = tp(1 | t, r, s, n);
}
function dO(e, t) {
  return Lh(8390656, 8, e, t);
}
function yS(e, t) {
  return dg(2048, 8, e, t);
}
function CR(e, t) {
  return dg(4, 2, e, t);
}
function $R(e, t) {
  return dg(4, 4, e, t);
}
function RR(e, t) {
  if (typeof t == "function") return e = e(), t(e), function() {
    t(null);
  };
  if (t != null) return e = e(), t.current = e, function() {
    t.current = null;
  };
}
function IR(e, t, r) {
  return r = r != null ? r.concat([e]) : null, dg(4, 4, RR.bind(null, t, e), r);
}
function vS() {
}
function NR(e, t) {
  var r = jn();
  t = t === void 0 ? null : t;
  var n = r.memoizedState;
  return n !== null && t !== null && hS(t, n[1]) ? n[0] : (r.memoizedState = [e, t], e);
}
function jR(e, t) {
  var r = jn();
  t = t === void 0 ? null : t;
  var n = r.memoizedState;
  return n !== null && t !== null && hS(t, n[1]) ? n[0] : (e = e(), r.memoizedState = [e, t], e);
}
function LR(e, t, r) {
  return ca & 21 ? (ai(r, t) || (r = q$(), Wt.lanes |= r, pa |= r, e.baseState = !0), t) : (e.baseState && (e.baseState = !1, Zr = !0), e.memoizedState = r);
}
function u3(e, t) {
  var r = xt;
  xt = r !== 0 && 4 > r ? r : 4, e(!0);
  var n = gv.transition;
  gv.transition = {};
  try {
    e(!1), t();
  } finally {
    xt = r, gv.transition = n;
  }
}
function MR() {
  return jn().memoizedState;
}
function c3(e, t, r) {
  var n = ns(e);
  if (r = { lane: n, action: r, hasEagerState: !1, eagerState: null, next: null }, DR(e)) FR(t, r);
  else if (r = bR(e, t, r, n), r !== null) {
    var i = Br();
    ti(r, e, n, i), zR(r, t, n);
  }
}
function p3(e, t, r) {
  var n = ns(e), i = { lane: n, action: r, hasEagerState: !1, eagerState: null, next: null };
  if (DR(e)) FR(t, i);
  else {
    var s = e.alternate;
    if (e.lanes === 0 && (s === null || s.lanes === 0) && (s = t.lastRenderedReducer, s !== null)) try {
      var o = t.lastRenderedState, a = s(o, r);
      if (i.hasEagerState = !0, i.eagerState = a, ai(a, o)) {
        var l = t.interleaved;
        l === null ? (i.next = i, uS(t)) : (i.next = l.next, l.next = i), t.interleaved = i;
        return;
      }
    } catch {
    } finally {
    }
    r = bR(e, t, i, n), r !== null && (i = Br(), ti(r, e, n, i), zR(r, t, n));
  }
}
function DR(e) {
  var t = e.alternate;
  return e === Wt || t !== null && t === Wt;
}
function FR(e, t) {
  Tc = bm = !0;
  var r = e.pending;
  r === null ? t.next = t : (t.next = r.next, r.next = t), e.pending = t;
}
function zR(e, t, r) {
  if (r & 4194240) {
    var n = t.lanes;
    n &= e.pendingLanes, r |= n, t.lanes = r, Gw(e, r);
  }
}
var wm = { readContext: Nn, useCallback: Tr, useContext: Tr, useEffect: Tr, useImperativeHandle: Tr, useInsertionEffect: Tr, useLayoutEffect: Tr, useMemo: Tr, useReducer: Tr, useRef: Tr, useState: Tr, useDebugValue: Tr, useDeferredValue: Tr, useTransition: Tr, useMutableSource: Tr, useSyncExternalStore: Tr, useId: Tr, unstable_isNewReconciler: !1 }, f3 = { readContext: Nn, useCallback: function(e, t) {
  return Ei().memoizedState = [e, t === void 0 ? null : t], e;
}, useContext: Nn, useEffect: dO, useImperativeHandle: function(e, t, r) {
  return r = r != null ? r.concat([e]) : null, Lh(
    4194308,
    4,
    RR.bind(null, t, e),
    r
  );
}, useLayoutEffect: function(e, t) {
  return Lh(4194308, 4, e, t);
}, useInsertionEffect: function(e, t) {
  return Lh(4, 2, e, t);
}, useMemo: function(e, t) {
  var r = Ei();
  return t = t === void 0 ? null : t, e = e(), r.memoizedState = [e, t], e;
}, useReducer: function(e, t, r) {
  var n = Ei();
  return t = r !== void 0 ? r(t) : t, n.memoizedState = n.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, n.queue = e, e = e.dispatch = c3.bind(null, Wt, e), [n.memoizedState, e];
}, useRef: function(e) {
  var t = Ei();
  return e = { current: e }, t.memoizedState = e;
}, useState: fO, useDebugValue: vS, useDeferredValue: function(e) {
  return Ei().memoizedState = e;
}, useTransition: function() {
  var e = fO(!1), t = e[0];
  return e = u3.bind(null, e[1]), Ei().memoizedState = e, [t, e];
}, useMutableSource: function() {
}, useSyncExternalStore: function(e, t, r) {
  var n = Wt, i = Ei();
  if (Ft) {
    if (r === void 0) throw Error(Ne(407));
    r = r();
  } else {
    if (r = t(), gr === null) throw Error(Ne(349));
    ca & 30 || _R(n, t, r);
  }
  i.memoizedState = r;
  var s = { value: r, getSnapshot: t };
  return i.queue = s, dO(kR.bind(
    null,
    n,
    s,
    e
  ), [e]), n.flags |= 2048, tp(9, OR.bind(null, n, s, r, t), void 0, null), r;
}, useId: function() {
  var e = Ei(), t = gr.identifierPrefix;
  if (Ft) {
    var r = ao, n = so;
    r = (n & ~(1 << 32 - ei(n) - 1)).toString(32) + r, t = ":" + t + "R" + r, r = Zc++, 0 < r && (t += "H" + r.toString(32)), t += ":";
  } else r = l3++, t = ":" + t + "r" + r.toString(32) + ":";
  return e.memoizedState = t;
}, unstable_isNewReconciler: !1 }, d3 = {
  readContext: Nn,
  useCallback: NR,
  useContext: Nn,
  useEffect: yS,
  useImperativeHandle: IR,
  useInsertionEffect: CR,
  useLayoutEffect: $R,
  useMemo: jR,
  useReducer: yv,
  useRef: TR,
  useState: function() {
    return yv(ep);
  },
  useDebugValue: vS,
  useDeferredValue: function(e) {
    var t = jn();
    return LR(t, ur.memoizedState, e);
  },
  useTransition: function() {
    var e = yv(ep)[0], t = jn().memoizedState;
    return [e, t];
  },
  useMutableSource: xR,
  useSyncExternalStore: ER,
  useId: MR,
  unstable_isNewReconciler: !1
}, h3 = { readContext: Nn, useCallback: NR, useContext: Nn, useEffect: yS, useImperativeHandle: IR, useInsertionEffect: CR, useLayoutEffect: $R, useMemo: jR, useReducer: vv, useRef: TR, useState: function() {
  return vv(ep);
}, useDebugValue: vS, useDeferredValue: function(e) {
  var t = jn();
  return ur === null ? t.memoizedState = e : LR(t, ur.memoizedState, e);
}, useTransition: function() {
  var e = vv(ep)[0], t = jn().memoizedState;
  return [e, t];
}, useMutableSource: xR, useSyncExternalStore: ER, useId: MR, unstable_isNewReconciler: !1 };
function Kn(e, t) {
  if (e && e.defaultProps) {
    t = Ht({}, t), e = e.defaultProps;
    for (var r in e) t[r] === void 0 && (t[r] = e[r]);
    return t;
  }
  return t;
}
function C0(e, t, r, n) {
  t = e.memoizedState, r = r(n, t), r = r == null ? t : Ht({}, t, r), e.memoizedState = r, e.lanes === 0 && (e.updateQueue.baseState = r);
}
var hg = { isMounted: function(e) {
  return (e = e._reactInternals) ? Sa(e) === e : !1;
}, enqueueSetState: function(e, t, r) {
  e = e._reactInternals;
  var n = Br(), i = ns(e), s = lo(n, i);
  s.payload = t, r != null && (s.callback = r), t = ts(e, s, i), t !== null && (ti(t, e, i, n), Nh(t, e, i));
}, enqueueReplaceState: function(e, t, r) {
  e = e._reactInternals;
  var n = Br(), i = ns(e), s = lo(n, i);
  s.tag = 1, s.payload = t, r != null && (s.callback = r), t = ts(e, s, i), t !== null && (ti(t, e, i, n), Nh(t, e, i));
}, enqueueForceUpdate: function(e, t) {
  e = e._reactInternals;
  var r = Br(), n = ns(e), i = lo(r, n);
  i.tag = 2, t != null && (i.callback = t), t = ts(e, i, n), t !== null && (ti(t, e, n, r), Nh(t, e, n));
} };
function hO(e, t, r, n, i, s, o) {
  return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(n, s, o) : t.prototype && t.prototype.isPureReactComponent ? !Qc(r, n) || !Qc(i, s) : !0;
}
function qR(e, t, r) {
  var n = !1, i = us, s = t.contextType;
  return typeof s == "object" && s !== null ? s = Nn(s) : (i = nn(t) ? la : Lr.current, n = t.contextTypes, s = (n = n != null) ? Il(e, i) : us), t = new t(r, s), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = hg, e.stateNode = t, t._reactInternals = e, n && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = s), t;
}
function mO(e, t, r, n) {
  e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(r, n), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(r, n), t.state !== e && hg.enqueueReplaceState(t, t.state, null);
}
function $0(e, t, r, n) {
  var i = e.stateNode;
  i.props = r, i.state = e.memoizedState, i.refs = {}, cS(e);
  var s = t.contextType;
  typeof s == "object" && s !== null ? i.context = Nn(s) : (s = nn(t) ? la : Lr.current, i.context = Il(e, s)), i.state = e.memoizedState, s = t.getDerivedStateFromProps, typeof s == "function" && (C0(e, t, s, r), i.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (t = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), t !== i.state && hg.enqueueReplaceState(i, i.state, null), ym(e, r, i, n), i.state = e.memoizedState), typeof i.componentDidMount == "function" && (e.flags |= 4194308);
}
function Ml(e, t) {
  try {
    var r = "", n = t;
    do
      r += Bq(n), n = n.return;
    while (n);
    var i = r;
  } catch (s) {
    i = `
Error generating stack: ` + s.message + `
` + s.stack;
  }
  return { value: e, source: t, stack: i, digest: null };
}
function bv(e, t, r) {
  return { value: e, source: null, stack: r ?? null, digest: t ?? null };
}
function R0(e, t) {
  try {
    console.error(t.value);
  } catch (r) {
    setTimeout(function() {
      throw r;
    });
  }
}
var m3 = typeof WeakMap == "function" ? WeakMap : Map;
function BR(e, t, r) {
  r = lo(-1, r), r.tag = 3, r.payload = { element: null };
  var n = t.value;
  return r.callback = function() {
    xm || (xm = !0, B0 = n), R0(e, t);
  }, r;
}
function UR(e, t, r) {
  r = lo(-1, r), r.tag = 3;
  var n = e.type.getDerivedStateFromError;
  if (typeof n == "function") {
    var i = t.value;
    r.payload = function() {
      return n(i);
    }, r.callback = function() {
      R0(e, t);
    };
  }
  var s = e.stateNode;
  return s !== null && typeof s.componentDidCatch == "function" && (r.callback = function() {
    R0(e, t), typeof n != "function" && (rs === null ? rs = /* @__PURE__ */ new Set([this]) : rs.add(this));
    var o = t.stack;
    this.componentDidCatch(t.value, { componentStack: o !== null ? o : "" });
  }), r;
}
function gO(e, t, r) {
  var n = e.pingCache;
  if (n === null) {
    n = e.pingCache = new m3();
    var i = /* @__PURE__ */ new Set();
    n.set(t, i);
  } else i = n.get(t), i === void 0 && (i = /* @__PURE__ */ new Set(), n.set(t, i));
  i.has(r) || (i.add(r), e = T3.bind(null, e, t, r), t.then(e, e));
}
function yO(e) {
  do {
    var t;
    if ((t = e.tag === 13) && (t = e.memoizedState, t = t !== null ? t.dehydrated !== null : !0), t) return e;
    e = e.return;
  } while (e !== null);
  return null;
}
function vO(e, t, r, n, i) {
  return e.mode & 1 ? (e.flags |= 65536, e.lanes = i, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, r.flags |= 131072, r.flags &= -52805, r.tag === 1 && (r.alternate === null ? r.tag = 17 : (t = lo(-1, 1), t.tag = 2, ts(r, t, 1))), r.lanes |= 1), e);
}
var g3 = Oo.ReactCurrentOwner, Zr = !1;
function qr(e, t, r, n) {
  t.child = e === null ? vR(t, null, r, n) : jl(t, e.child, r, n);
}
function bO(e, t, r, n, i) {
  r = r.render;
  var s = t.ref;
  return Tl(t, i), n = mS(e, t, r, n, s, i), r = gS(), e !== null && !Zr ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, yo(e, t, i)) : (Ft && r && nS(t), t.flags |= 1, qr(e, t, n, i), t.child);
}
function wO(e, t, r, n, i) {
  if (e === null) {
    var s = r.type;
    return typeof s == "function" && !kS(s) && s.defaultProps === void 0 && r.compare === null && r.defaultProps === void 0 ? (t.tag = 15, t.type = s, VR(e, t, s, n, i)) : (e = zh(r.type, null, n, t, t.mode, i), e.ref = t.ref, e.return = t, t.child = e);
  }
  if (s = e.child, !(e.lanes & i)) {
    var o = s.memoizedProps;
    if (r = r.compare, r = r !== null ? r : Qc, r(o, n) && e.ref === t.ref) return yo(e, t, i);
  }
  return t.flags |= 1, e = is(s, n), e.ref = t.ref, e.return = t, t.child = e;
}
function VR(e, t, r, n, i) {
  if (e !== null) {
    var s = e.memoizedProps;
    if (Qc(s, n) && e.ref === t.ref) if (Zr = !1, t.pendingProps = n = s, (e.lanes & i) !== 0) e.flags & 131072 && (Zr = !0);
    else return t.lanes = e.lanes, yo(e, t, i);
  }
  return I0(e, t, r, n, i);
}
function WR(e, t, r) {
  var n = t.pendingProps, i = n.children, s = e !== null ? e.memoizedState : null;
  if (n.mode === "hidden") if (!(t.mode & 1)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Rt(vl, cn), cn |= r;
  else {
    if (!(r & 1073741824)) return e = s !== null ? s.baseLanes | r : r, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, Rt(vl, cn), cn |= e, null;
    t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, n = s !== null ? s.baseLanes : r, Rt(vl, cn), cn |= n;
  }
  else s !== null ? (n = s.baseLanes | r, t.memoizedState = null) : n = r, Rt(vl, cn), cn |= n;
  return qr(e, t, i, r), t.child;
}
function HR(e, t) {
  var r = t.ref;
  (e === null && r !== null || e !== null && e.ref !== r) && (t.flags |= 512, t.flags |= 2097152);
}
function I0(e, t, r, n, i) {
  var s = nn(r) ? la : Lr.current;
  return s = Il(t, s), Tl(t, i), r = mS(e, t, r, n, s, i), n = gS(), e !== null && !Zr ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, yo(e, t, i)) : (Ft && n && nS(t), t.flags |= 1, qr(e, t, r, i), t.child);
}
function SO(e, t, r, n, i) {
  if (nn(r)) {
    var s = !0;
    fm(t);
  } else s = !1;
  if (Tl(t, i), t.stateNode === null) Mh(e, t), qR(t, r, n), $0(t, r, n, i), n = !0;
  else if (e === null) {
    var o = t.stateNode, a = t.memoizedProps;
    o.props = a;
    var l = o.context, u = r.contextType;
    typeof u == "object" && u !== null ? u = Nn(u) : (u = nn(r) ? la : Lr.current, u = Il(t, u));
    var f = r.getDerivedStateFromProps, d = typeof f == "function" || typeof o.getSnapshotBeforeUpdate == "function";
    d || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== n || l !== u) && mO(t, o, n, u), qo = !1;
    var m = t.memoizedState;
    o.state = m, ym(t, n, o, i), l = t.memoizedState, a !== n || m !== l || rn.current || qo ? (typeof f == "function" && (C0(t, r, f, n), l = t.memoizedState), (a = qo || hO(t, r, a, n, m, l, u)) ? (d || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = n, t.memoizedState = l), o.props = n, o.state = l, o.context = u, n = a) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), n = !1);
  } else {
    o = t.stateNode, wR(e, t), a = t.memoizedProps, u = t.type === t.elementType ? a : Kn(t.type, a), o.props = u, d = t.pendingProps, m = o.context, l = r.contextType, typeof l == "object" && l !== null ? l = Nn(l) : (l = nn(r) ? la : Lr.current, l = Il(t, l));
    var v = r.getDerivedStateFromProps;
    (f = typeof v == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== d || m !== l) && mO(t, o, n, l), qo = !1, m = t.memoizedState, o.state = m, ym(t, n, o, i);
    var S = t.memoizedState;
    a !== d || m !== S || rn.current || qo ? (typeof v == "function" && (C0(t, r, v, n), S = t.memoizedState), (u = qo || hO(t, r, u, n, m, S, l) || !1) ? (f || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(n, S, l), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(n, S, l)), typeof o.componentDidUpdate == "function" && (t.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && m === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && m === e.memoizedState || (t.flags |= 1024), t.memoizedProps = n, t.memoizedState = S), o.props = n, o.state = S, o.context = l, n = u) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && m === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && m === e.memoizedState || (t.flags |= 1024), n = !1);
  }
  return N0(e, t, r, n, s, i);
}
function N0(e, t, r, n, i, s) {
  HR(e, t);
  var o = (t.flags & 128) !== 0;
  if (!n && !o) return i && sO(t, r, !1), yo(e, t, s);
  n = t.stateNode, g3.current = t;
  var a = o && typeof r.getDerivedStateFromError != "function" ? null : n.render();
  return t.flags |= 1, e !== null && o ? (t.child = jl(t, e.child, null, s), t.child = jl(t, null, a, s)) : qr(e, t, a, s), t.memoizedState = n.state, i && sO(t, r, !0), t.child;
}
function QR(e) {
  var t = e.stateNode;
  t.pendingContext ? oO(e, t.pendingContext, t.pendingContext !== t.context) : t.context && oO(e, t.context, !1), pS(e, t.containerInfo);
}
function xO(e, t, r, n, i) {
  return Nl(), oS(i), t.flags |= 256, qr(e, t, r, n), t.child;
}
var j0 = { dehydrated: null, treeContext: null, retryLane: 0 };
function L0(e) {
  return { baseLanes: e, cachePool: null, transitions: null };
}
function YR(e, t, r) {
  var n = t.pendingProps, i = Vt.current, s = !1, o = (t.flags & 128) !== 0, a;
  if ((a = o) || (a = e !== null && e.memoizedState === null ? !1 : (i & 2) !== 0), a ? (s = !0, t.flags &= -129) : (e === null || e.memoizedState !== null) && (i |= 1), Rt(Vt, i & 1), e === null)
    return P0(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (o = n.children, e = n.fallback, s ? (n = t.mode, s = t.child, o = { mode: "hidden", children: o }, !(n & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = o) : s = yg(o, n, 0, null), e = ia(e, n, r, null), s.return = t, e.return = t, s.sibling = e, t.child = s, t.child.memoizedState = L0(r), t.memoizedState = j0, e) : bS(t, o));
  if (i = e.memoizedState, i !== null && (a = i.dehydrated, a !== null)) return y3(e, t, o, n, a, i, r);
  if (s) {
    s = n.fallback, o = t.mode, i = e.child, a = i.sibling;
    var l = { mode: "hidden", children: n.children };
    return !(o & 1) && t.child !== i ? (n = t.child, n.childLanes = 0, n.pendingProps = l, t.deletions = null) : (n = is(i, l), n.subtreeFlags = i.subtreeFlags & 14680064), a !== null ? s = is(a, s) : (s = ia(s, o, r, null), s.flags |= 2), s.return = t, n.return = t, n.sibling = s, t.child = n, n = s, s = t.child, o = e.child.memoizedState, o = o === null ? L0(r) : { baseLanes: o.baseLanes | r, cachePool: null, transitions: o.transitions }, s.memoizedState = o, s.childLanes = e.childLanes & ~r, t.memoizedState = j0, n;
  }
  return s = e.child, e = s.sibling, n = is(s, { mode: "visible", children: n.children }), !(t.mode & 1) && (n.lanes = r), n.return = t, n.sibling = null, e !== null && (r = t.deletions, r === null ? (t.deletions = [e], t.flags |= 16) : r.push(e)), t.child = n, t.memoizedState = null, n;
}
function bS(e, t) {
  return t = yg({ mode: "visible", children: t }, e.mode, 0, null), t.return = e, e.child = t;
}
function sd(e, t, r, n) {
  return n !== null && oS(n), jl(t, e.child, null, r), e = bS(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e;
}
function y3(e, t, r, n, i, s, o) {
  if (r)
    return t.flags & 256 ? (t.flags &= -257, n = bv(Error(Ne(422))), sd(e, t, o, n)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (s = n.fallback, i = t.mode, n = yg({ mode: "visible", children: n.children }, i, 0, null), s = ia(s, i, o, null), s.flags |= 2, n.return = t, s.return = t, n.sibling = s, t.child = n, t.mode & 1 && jl(t, e.child, null, o), t.child.memoizedState = L0(o), t.memoizedState = j0, s);
  if (!(t.mode & 1)) return sd(e, t, o, null);
  if (i.data === "$!") {
    if (n = i.nextSibling && i.nextSibling.dataset, n) var a = n.dgst;
    return n = a, s = Error(Ne(419)), n = bv(s, n, void 0), sd(e, t, o, n);
  }
  if (a = (o & e.childLanes) !== 0, Zr || a) {
    if (n = gr, n !== null) {
      switch (o & -o) {
        case 4:
          i = 2;
          break;
        case 16:
          i = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          i = 32;
          break;
        case 536870912:
          i = 268435456;
          break;
        default:
          i = 0;
      }
      i = i & (n.suspendedLanes | o) ? 0 : i, i !== 0 && i !== s.retryLane && (s.retryLane = i, go(e, i), ti(n, e, i, -1));
    }
    return OS(), n = bv(Error(Ne(421))), sd(e, t, o, n);
  }
  return i.data === "$?" ? (t.flags |= 128, t.child = e.child, t = C3.bind(null, e), i._reactRetry = t, null) : (e = s.treeContext, dn = es(i.nextSibling), hn = t, Ft = !0, Jn = null, e !== null && (An[Pn++] = so, An[Pn++] = ao, An[Pn++] = ua, so = e.id, ao = e.overflow, ua = t), t = bS(t, n.children), t.flags |= 4096, t);
}
function EO(e, t, r) {
  e.lanes |= t;
  var n = e.alternate;
  n !== null && (n.lanes |= t), T0(e.return, t, r);
}
function wv(e, t, r, n, i) {
  var s = e.memoizedState;
  s === null ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: n, tail: r, tailMode: i } : (s.isBackwards = t, s.rendering = null, s.renderingStartTime = 0, s.last = n, s.tail = r, s.tailMode = i);
}
function GR(e, t, r) {
  var n = t.pendingProps, i = n.revealOrder, s = n.tail;
  if (qr(e, t, n.children, r), n = Vt.current, n & 2) n = n & 1 | 2, t.flags |= 128;
  else {
    if (e !== null && e.flags & 128) e: for (e = t.child; e !== null; ) {
      if (e.tag === 13) e.memoizedState !== null && EO(e, r, t);
      else if (e.tag === 19) EO(e, r, t);
      else if (e.child !== null) {
        e.child.return = e, e = e.child;
        continue;
      }
      if (e === t) break e;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === t) break e;
        e = e.return;
      }
      e.sibling.return = e.return, e = e.sibling;
    }
    n &= 1;
  }
  if (Rt(Vt, n), !(t.mode & 1)) t.memoizedState = null;
  else switch (i) {
    case "forwards":
      for (r = t.child, i = null; r !== null; ) e = r.alternate, e !== null && vm(e) === null && (i = r), r = r.sibling;
      r = i, r === null ? (i = t.child, t.child = null) : (i = r.sibling, r.sibling = null), wv(t, !1, i, r, s);
      break;
    case "backwards":
      for (r = null, i = t.child, t.child = null; i !== null; ) {
        if (e = i.alternate, e !== null && vm(e) === null) {
          t.child = i;
          break;
        }
        e = i.sibling, i.sibling = r, r = i, i = e;
      }
      wv(t, !0, r, null, s);
      break;
    case "together":
      wv(t, !1, null, null, void 0);
      break;
    default:
      t.memoizedState = null;
  }
  return t.child;
}
function Mh(e, t) {
  !(t.mode & 1) && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2);
}
function yo(e, t, r) {
  if (e !== null && (t.dependencies = e.dependencies), pa |= t.lanes, !(r & t.childLanes)) return null;
  if (e !== null && t.child !== e.child) throw Error(Ne(153));
  if (t.child !== null) {
    for (e = t.child, r = is(e, e.pendingProps), t.child = r, r.return = t; e.sibling !== null; ) e = e.sibling, r = r.sibling = is(e, e.pendingProps), r.return = t;
    r.sibling = null;
  }
  return t.child;
}
function v3(e, t, r) {
  switch (t.tag) {
    case 3:
      QR(t), Nl();
      break;
    case 5:
      SR(t);
      break;
    case 1:
      nn(t.type) && fm(t);
      break;
    case 4:
      pS(t, t.stateNode.containerInfo);
      break;
    case 10:
      var n = t.type._context, i = t.memoizedProps.value;
      Rt(mm, n._currentValue), n._currentValue = i;
      break;
    case 13:
      if (n = t.memoizedState, n !== null)
        return n.dehydrated !== null ? (Rt(Vt, Vt.current & 1), t.flags |= 128, null) : r & t.child.childLanes ? YR(e, t, r) : (Rt(Vt, Vt.current & 1), e = yo(e, t, r), e !== null ? e.sibling : null);
      Rt(Vt, Vt.current & 1);
      break;
    case 19:
      if (n = (r & t.childLanes) !== 0, e.flags & 128) {
        if (n) return GR(e, t, r);
        t.flags |= 128;
      }
      if (i = t.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), Rt(Vt, Vt.current), n) break;
      return null;
    case 22:
    case 23:
      return t.lanes = 0, WR(e, t, r);
  }
  return yo(e, t, r);
}
var KR, M0, XR, JR;
KR = function(e, t) {
  for (var r = t.child; r !== null; ) {
    if (r.tag === 5 || r.tag === 6) e.appendChild(r.stateNode);
    else if (r.tag !== 4 && r.child !== null) {
      r.child.return = r, r = r.child;
      continue;
    }
    if (r === t) break;
    for (; r.sibling === null; ) {
      if (r.return === null || r.return === t) return;
      r = r.return;
    }
    r.sibling.return = r.return, r = r.sibling;
  }
};
M0 = function() {
};
XR = function(e, t, r, n) {
  var i = e.memoizedProps;
  if (i !== n) {
    e = t.stateNode, Zs(Ri.current);
    var s = null;
    switch (r) {
      case "input":
        i = o0(e, i), n = o0(e, n), s = [];
        break;
      case "select":
        i = Ht({}, i, { value: void 0 }), n = Ht({}, n, { value: void 0 }), s = [];
        break;
      case "textarea":
        i = l0(e, i), n = l0(e, n), s = [];
        break;
      default:
        typeof i.onClick != "function" && typeof n.onClick == "function" && (e.onclick = cm);
    }
    c0(r, n);
    var o;
    r = null;
    for (u in i) if (!n.hasOwnProperty(u) && i.hasOwnProperty(u) && i[u] != null) if (u === "style") {
      var a = i[u];
      for (o in a) a.hasOwnProperty(o) && (r || (r = {}), r[o] = "");
    } else u !== "dangerouslySetInnerHTML" && u !== "children" && u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && u !== "autoFocus" && (zc.hasOwnProperty(u) ? s || (s = []) : (s = s || []).push(u, null));
    for (u in n) {
      var l = n[u];
      if (a = i != null ? i[u] : void 0, n.hasOwnProperty(u) && l !== a && (l != null || a != null)) if (u === "style") if (a) {
        for (o in a) !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (r || (r = {}), r[o] = "");
        for (o in l) l.hasOwnProperty(o) && a[o] !== l[o] && (r || (r = {}), r[o] = l[o]);
      } else r || (s || (s = []), s.push(
        u,
        r
      )), r = l;
      else u === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (s = s || []).push(u, l)) : u === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(u, "" + l) : u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && (zc.hasOwnProperty(u) ? (l != null && u === "onScroll" && jt("scroll", e), s || a === l || (s = [])) : (s = s || []).push(u, l));
    }
    r && (s = s || []).push("style", r);
    var u = s;
    (t.updateQueue = u) && (t.flags |= 4);
  }
};
JR = function(e, t, r, n) {
  r !== n && (t.flags |= 4);
};
function Qu(e, t) {
  if (!Ft) switch (e.tailMode) {
    case "hidden":
      t = e.tail;
      for (var r = null; t !== null; ) t.alternate !== null && (r = t), t = t.sibling;
      r === null ? e.tail = null : r.sibling = null;
      break;
    case "collapsed":
      r = e.tail;
      for (var n = null; r !== null; ) r.alternate !== null && (n = r), r = r.sibling;
      n === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : n.sibling = null;
  }
}
function Cr(e) {
  var t = e.alternate !== null && e.alternate.child === e.child, r = 0, n = 0;
  if (t) for (var i = e.child; i !== null; ) r |= i.lanes | i.childLanes, n |= i.subtreeFlags & 14680064, n |= i.flags & 14680064, i.return = e, i = i.sibling;
  else for (i = e.child; i !== null; ) r |= i.lanes | i.childLanes, n |= i.subtreeFlags, n |= i.flags, i.return = e, i = i.sibling;
  return e.subtreeFlags |= n, e.childLanes = r, t;
}
function b3(e, t, r) {
  var n = t.pendingProps;
  switch (iS(t), t.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return Cr(t), null;
    case 1:
      return nn(t.type) && pm(), Cr(t), null;
    case 3:
      return n = t.stateNode, Ll(), Mt(rn), Mt(Lr), dS(), n.pendingContext && (n.context = n.pendingContext, n.pendingContext = null), (e === null || e.child === null) && (id(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, Jn !== null && (W0(Jn), Jn = null))), M0(e, t), Cr(t), null;
    case 5:
      fS(t);
      var i = Zs(Jc.current);
      if (r = t.type, e !== null && t.stateNode != null) XR(e, t, r, n, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152);
      else {
        if (!n) {
          if (t.stateNode === null) throw Error(Ne(166));
          return Cr(t), null;
        }
        if (e = Zs(Ri.current), id(t)) {
          n = t.stateNode, r = t.type;
          var s = t.memoizedProps;
          switch (n[Oi] = t, n[Kc] = s, e = (t.mode & 1) !== 0, r) {
            case "dialog":
              jt("cancel", n), jt("close", n);
              break;
            case "iframe":
            case "object":
            case "embed":
              jt("load", n);
              break;
            case "video":
            case "audio":
              for (i = 0; i < vc.length; i++) jt(vc[i], n);
              break;
            case "source":
              jt("error", n);
              break;
            case "img":
            case "image":
            case "link":
              jt(
                "error",
                n
              ), jt("load", n);
              break;
            case "details":
              jt("toggle", n);
              break;
            case "input":
              R_(n, s), jt("invalid", n);
              break;
            case "select":
              n._wrapperState = { wasMultiple: !!s.multiple }, jt("invalid", n);
              break;
            case "textarea":
              N_(n, s), jt("invalid", n);
          }
          c0(r, s), i = null;
          for (var o in s) if (s.hasOwnProperty(o)) {
            var a = s[o];
            o === "children" ? typeof a == "string" ? n.textContent !== a && (s.suppressHydrationWarning !== !0 && nd(n.textContent, a, e), i = ["children", a]) : typeof a == "number" && n.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && nd(
              n.textContent,
              a,
              e
            ), i = ["children", "" + a]) : zc.hasOwnProperty(o) && a != null && o === "onScroll" && jt("scroll", n);
          }
          switch (r) {
            case "input":
              Gf(n), I_(n, s, !0);
              break;
            case "textarea":
              Gf(n), j_(n);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof s.onClick == "function" && (n.onclick = cm);
          }
          n = i, t.updateQueue = n, n !== null && (t.flags |= 4);
        } else {
          o = i.nodeType === 9 ? i : i.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = k$(r)), e === "http://www.w3.org/1999/xhtml" ? r === "script" ? (e = o.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof n.is == "string" ? e = o.createElement(r, { is: n.is }) : (e = o.createElement(r), r === "select" && (o = e, n.multiple ? o.multiple = !0 : n.size && (o.size = n.size))) : e = o.createElementNS(e, r), e[Oi] = t, e[Kc] = n, KR(e, t, !1, !1), t.stateNode = e;
          e: {
            switch (o = p0(r, n), r) {
              case "dialog":
                jt("cancel", e), jt("close", e), i = n;
                break;
              case "iframe":
              case "object":
              case "embed":
                jt("load", e), i = n;
                break;
              case "video":
              case "audio":
                for (i = 0; i < vc.length; i++) jt(vc[i], e);
                i = n;
                break;
              case "source":
                jt("error", e), i = n;
                break;
              case "img":
              case "image":
              case "link":
                jt(
                  "error",
                  e
                ), jt("load", e), i = n;
                break;
              case "details":
                jt("toggle", e), i = n;
                break;
              case "input":
                R_(e, n), i = o0(e, n), jt("invalid", e);
                break;
              case "option":
                i = n;
                break;
              case "select":
                e._wrapperState = { wasMultiple: !!n.multiple }, i = Ht({}, n, { value: void 0 }), jt("invalid", e);
                break;
              case "textarea":
                N_(e, n), i = l0(e, n), jt("invalid", e);
                break;
              default:
                i = n;
            }
            c0(r, i), a = i;
            for (s in a) if (a.hasOwnProperty(s)) {
              var l = a[s];
              s === "style" ? T$(e, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && A$(e, l)) : s === "children" ? typeof l == "string" ? (r !== "textarea" || l !== "") && qc(e, l) : typeof l == "number" && qc(e, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (zc.hasOwnProperty(s) ? l != null && s === "onScroll" && jt("scroll", e) : l != null && Uw(e, s, l, o));
            }
            switch (r) {
              case "input":
                Gf(e), I_(e, n, !1);
                break;
              case "textarea":
                Gf(e), j_(e);
                break;
              case "option":
                n.value != null && e.setAttribute("value", "" + ls(n.value));
                break;
              case "select":
                e.multiple = !!n.multiple, s = n.value, s != null ? Ol(e, !!n.multiple, s, !1) : n.defaultValue != null && Ol(
                  e,
                  !!n.multiple,
                  n.defaultValue,
                  !0
                );
                break;
              default:
                typeof i.onClick == "function" && (e.onclick = cm);
            }
            switch (r) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                n = !!n.autoFocus;
                break e;
              case "img":
                n = !0;
                break e;
              default:
                n = !1;
            }
          }
          n && (t.flags |= 4);
        }
        t.ref !== null && (t.flags |= 512, t.flags |= 2097152);
      }
      return Cr(t), null;
    case 6:
      if (e && t.stateNode != null) JR(e, t, e.memoizedProps, n);
      else {
        if (typeof n != "string" && t.stateNode === null) throw Error(Ne(166));
        if (r = Zs(Jc.current), Zs(Ri.current), id(t)) {
          if (n = t.stateNode, r = t.memoizedProps, n[Oi] = t, (s = n.nodeValue !== r) && (e = hn, e !== null)) switch (e.tag) {
            case 3:
              nd(n.nodeValue, r, (e.mode & 1) !== 0);
              break;
            case 5:
              e.memoizedProps.suppressHydrationWarning !== !0 && nd(n.nodeValue, r, (e.mode & 1) !== 0);
          }
          s && (t.flags |= 4);
        } else n = (r.nodeType === 9 ? r : r.ownerDocument).createTextNode(n), n[Oi] = t, t.stateNode = n;
      }
      return Cr(t), null;
    case 13:
      if (Mt(Vt), n = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
        if (Ft && dn !== null && t.mode & 1 && !(t.flags & 128)) gR(), Nl(), t.flags |= 98560, s = !1;
        else if (s = id(t), n !== null && n.dehydrated !== null) {
          if (e === null) {
            if (!s) throw Error(Ne(318));
            if (s = t.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(Ne(317));
            s[Oi] = t;
          } else Nl(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4;
          Cr(t), s = !1;
        } else Jn !== null && (W0(Jn), Jn = null), s = !0;
        if (!s) return t.flags & 65536 ? t : null;
      }
      return t.flags & 128 ? (t.lanes = r, t) : (n = n !== null, n !== (e !== null && e.memoizedState !== null) && n && (t.child.flags |= 8192, t.mode & 1 && (e === null || Vt.current & 1 ? pr === 0 && (pr = 3) : OS())), t.updateQueue !== null && (t.flags |= 4), Cr(t), null);
    case 4:
      return Ll(), M0(e, t), e === null && Yc(t.stateNode.containerInfo), Cr(t), null;
    case 10:
      return lS(t.type._context), Cr(t), null;
    case 17:
      return nn(t.type) && pm(), Cr(t), null;
    case 19:
      if (Mt(Vt), s = t.memoizedState, s === null) return Cr(t), null;
      if (n = (t.flags & 128) !== 0, o = s.rendering, o === null) if (n) Qu(s, !1);
      else {
        if (pr !== 0 || e !== null && e.flags & 128) for (e = t.child; e !== null; ) {
          if (o = vm(e), o !== null) {
            for (t.flags |= 128, Qu(s, !1), n = o.updateQueue, n !== null && (t.updateQueue = n, t.flags |= 4), t.subtreeFlags = 0, n = r, r = t.child; r !== null; ) s = r, e = n, s.flags &= 14680066, o = s.alternate, o === null ? (s.childLanes = 0, s.lanes = e, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = o.childLanes, s.lanes = o.lanes, s.child = o.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = o.memoizedProps, s.memoizedState = o.memoizedState, s.updateQueue = o.updateQueue, s.type = o.type, e = o.dependencies, s.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), r = r.sibling;
            return Rt(Vt, Vt.current & 1 | 2), t.child;
          }
          e = e.sibling;
        }
        s.tail !== null && er() > Dl && (t.flags |= 128, n = !0, Qu(s, !1), t.lanes = 4194304);
      }
      else {
        if (!n) if (e = vm(o), e !== null) {
          if (t.flags |= 128, n = !0, r = e.updateQueue, r !== null && (t.updateQueue = r, t.flags |= 4), Qu(s, !0), s.tail === null && s.tailMode === "hidden" && !o.alternate && !Ft) return Cr(t), null;
        } else 2 * er() - s.renderingStartTime > Dl && r !== 1073741824 && (t.flags |= 128, n = !0, Qu(s, !1), t.lanes = 4194304);
        s.isBackwards ? (o.sibling = t.child, t.child = o) : (r = s.last, r !== null ? r.sibling = o : t.child = o, s.last = o);
      }
      return s.tail !== null ? (t = s.tail, s.rendering = t, s.tail = t.sibling, s.renderingStartTime = er(), t.sibling = null, r = Vt.current, Rt(Vt, n ? r & 1 | 2 : r & 1), t) : (Cr(t), null);
    case 22:
    case 23:
      return _S(), n = t.memoizedState !== null, e !== null && e.memoizedState !== null !== n && (t.flags |= 8192), n && t.mode & 1 ? cn & 1073741824 && (Cr(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : Cr(t), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(Ne(156, t.tag));
}
function w3(e, t) {
  switch (iS(t), t.tag) {
    case 1:
      return nn(t.type) && pm(), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
    case 3:
      return Ll(), Mt(rn), Mt(Lr), dS(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null;
    case 5:
      return fS(t), null;
    case 13:
      if (Mt(Vt), e = t.memoizedState, e !== null && e.dehydrated !== null) {
        if (t.alternate === null) throw Error(Ne(340));
        Nl();
      }
      return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
    case 19:
      return Mt(Vt), null;
    case 4:
      return Ll(), null;
    case 10:
      return lS(t.type._context), null;
    case 22:
    case 23:
      return _S(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var ad = !1, Ir = !1, S3 = typeof WeakSet == "function" ? WeakSet : Set, qe = null;
function yl(e, t) {
  var r = e.ref;
  if (r !== null) if (typeof r == "function") try {
    r(null);
  } catch (n) {
    Kt(e, t, n);
  }
  else r.current = null;
}
function D0(e, t, r) {
  try {
    r();
  } catch (n) {
    Kt(e, t, n);
  }
}
var _O = !1;
function x3(e, t) {
  if (S0 = am, e = nR(), rS(e)) {
    if ("selectionStart" in e) var r = { start: e.selectionStart, end: e.selectionEnd };
    else e: {
      r = (r = e.ownerDocument) && r.defaultView || window;
      var n = r.getSelection && r.getSelection();
      if (n && n.rangeCount !== 0) {
        r = n.anchorNode;
        var i = n.anchorOffset, s = n.focusNode;
        n = n.focusOffset;
        try {
          r.nodeType, s.nodeType;
        } catch {
          r = null;
          break e;
        }
        var o = 0, a = -1, l = -1, u = 0, f = 0, d = e, m = null;
        t: for (; ; ) {
          for (var v; d !== r || i !== 0 && d.nodeType !== 3 || (a = o + i), d !== s || n !== 0 && d.nodeType !== 3 || (l = o + n), d.nodeType === 3 && (o += d.nodeValue.length), (v = d.firstChild) !== null; )
            m = d, d = v;
          for (; ; ) {
            if (d === e) break t;
            if (m === r && ++u === i && (a = o), m === s && ++f === n && (l = o), (v = d.nextSibling) !== null) break;
            d = m, m = d.parentNode;
          }
          d = v;
        }
        r = a === -1 || l === -1 ? null : { start: a, end: l };
      } else r = null;
    }
    r = r || { start: 0, end: 0 };
  } else r = null;
  for (x0 = { focusedElem: e, selectionRange: r }, am = !1, qe = t; qe !== null; ) if (t = qe, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, qe = e;
  else for (; qe !== null; ) {
    t = qe;
    try {
      var S = t.alternate;
      if (t.flags & 1024) switch (t.tag) {
        case 0:
        case 11:
        case 15:
          break;
        case 1:
          if (S !== null) {
            var y = S.memoizedProps, E = S.memoizedState, x = t.stateNode, g = x.getSnapshotBeforeUpdate(t.elementType === t.type ? y : Kn(t.type, y), E);
            x.__reactInternalSnapshotBeforeUpdate = g;
          }
          break;
        case 3:
          var b = t.stateNode.containerInfo;
          b.nodeType === 1 ? b.textContent = "" : b.nodeType === 9 && b.documentElement && b.removeChild(b.documentElement);
          break;
        case 5:
        case 6:
        case 4:
        case 17:
          break;
        default:
          throw Error(Ne(163));
      }
    } catch (A) {
      Kt(t, t.return, A);
    }
    if (e = t.sibling, e !== null) {
      e.return = t.return, qe = e;
      break;
    }
    qe = t.return;
  }
  return S = _O, _O = !1, S;
}
function Cc(e, t, r) {
  var n = t.updateQueue;
  if (n = n !== null ? n.lastEffect : null, n !== null) {
    var i = n = n.next;
    do {
      if ((i.tag & e) === e) {
        var s = i.destroy;
        i.destroy = void 0, s !== void 0 && D0(t, r, s);
      }
      i = i.next;
    } while (i !== n);
  }
}
function mg(e, t) {
  if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) {
    var r = t = t.next;
    do {
      if ((r.tag & e) === e) {
        var n = r.create;
        r.destroy = n();
      }
      r = r.next;
    } while (r !== t);
  }
}
function F0(e) {
  var t = e.ref;
  if (t !== null) {
    var r = e.stateNode;
    switch (e.tag) {
      case 5:
        e = r;
        break;
      default:
        e = r;
    }
    typeof t == "function" ? t(e) : t.current = e;
  }
}
function ZR(e) {
  var t = e.alternate;
  t !== null && (e.alternate = null, ZR(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[Oi], delete t[Kc], delete t[O0], delete t[i3], delete t[o3])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null;
}
function eI(e) {
  return e.tag === 5 || e.tag === 3 || e.tag === 4;
}
function OO(e) {
  e: for (; ; ) {
    for (; e.sibling === null; ) {
      if (e.return === null || eI(e.return)) return null;
      e = e.return;
    }
    for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18; ) {
      if (e.flags & 2 || e.child === null || e.tag === 4) continue e;
      e.child.return = e, e = e.child;
    }
    if (!(e.flags & 2)) return e.stateNode;
  }
}
function z0(e, t, r) {
  var n = e.tag;
  if (n === 5 || n === 6) e = e.stateNode, t ? r.nodeType === 8 ? r.parentNode.insertBefore(e, t) : r.insertBefore(e, t) : (r.nodeType === 8 ? (t = r.parentNode, t.insertBefore(e, r)) : (t = r, t.appendChild(e)), r = r._reactRootContainer, r != null || t.onclick !== null || (t.onclick = cm));
  else if (n !== 4 && (e = e.child, e !== null)) for (z0(e, t, r), e = e.sibling; e !== null; ) z0(e, t, r), e = e.sibling;
}
function q0(e, t, r) {
  var n = e.tag;
  if (n === 5 || n === 6) e = e.stateNode, t ? r.insertBefore(e, t) : r.appendChild(e);
  else if (n !== 4 && (e = e.child, e !== null)) for (q0(e, t, r), e = e.sibling; e !== null; ) q0(e, t, r), e = e.sibling;
}
var xr = null, Xn = !1;
function jo(e, t, r) {
  for (r = r.child; r !== null; ) tI(e, t, r), r = r.sibling;
}
function tI(e, t, r) {
  if ($i && typeof $i.onCommitFiberUnmount == "function") try {
    $i.onCommitFiberUnmount(ag, r);
  } catch {
  }
  switch (r.tag) {
    case 5:
      Ir || yl(r, t);
    case 6:
      var n = xr, i = Xn;
      xr = null, jo(e, t, r), xr = n, Xn = i, xr !== null && (Xn ? (e = xr, r = r.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(r) : e.removeChild(r)) : xr.removeChild(r.stateNode));
      break;
    case 18:
      xr !== null && (Xn ? (e = xr, r = r.stateNode, e.nodeType === 8 ? dv(e.parentNode, r) : e.nodeType === 1 && dv(e, r), Wc(e)) : dv(xr, r.stateNode));
      break;
    case 4:
      n = xr, i = Xn, xr = r.stateNode.containerInfo, Xn = !0, jo(e, t, r), xr = n, Xn = i;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!Ir && (n = r.updateQueue, n !== null && (n = n.lastEffect, n !== null))) {
        i = n = n.next;
        do {
          var s = i, o = s.destroy;
          s = s.tag, o !== void 0 && (s & 2 || s & 4) && D0(r, t, o), i = i.next;
        } while (i !== n);
      }
      jo(e, t, r);
      break;
    case 1:
      if (!Ir && (yl(r, t), n = r.stateNode, typeof n.componentWillUnmount == "function")) try {
        n.props = r.memoizedProps, n.state = r.memoizedState, n.componentWillUnmount();
      } catch (a) {
        Kt(r, t, a);
      }
      jo(e, t, r);
      break;
    case 21:
      jo(e, t, r);
      break;
    case 22:
      r.mode & 1 ? (Ir = (n = Ir) || r.memoizedState !== null, jo(e, t, r), Ir = n) : jo(e, t, r);
      break;
    default:
      jo(e, t, r);
  }
}
function kO(e) {
  var t = e.updateQueue;
  if (t !== null) {
    e.updateQueue = null;
    var r = e.stateNode;
    r === null && (r = e.stateNode = new S3()), t.forEach(function(n) {
      var i = $3.bind(null, e, n);
      r.has(n) || (r.add(n), n.then(i, i));
    });
  }
}
function Hn(e, t) {
  var r = t.deletions;
  if (r !== null) for (var n = 0; n < r.length; n++) {
    var i = r[n];
    try {
      var s = e, o = t, a = o;
      e: for (; a !== null; ) {
        switch (a.tag) {
          case 5:
            xr = a.stateNode, Xn = !1;
            break e;
          case 3:
            xr = a.stateNode.containerInfo, Xn = !0;
            break e;
          case 4:
            xr = a.stateNode.containerInfo, Xn = !0;
            break e;
        }
        a = a.return;
      }
      if (xr === null) throw Error(Ne(160));
      tI(s, o, i), xr = null, Xn = !1;
      var l = i.alternate;
      l !== null && (l.return = null), i.return = null;
    } catch (u) {
      Kt(i, t, u);
    }
  }
  if (t.subtreeFlags & 12854) for (t = t.child; t !== null; ) rI(t, e), t = t.sibling;
}
function rI(e, t) {
  var r = e.alternate, n = e.flags;
  switch (e.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if (Hn(t, e), wi(e), n & 4) {
        try {
          Cc(3, e, e.return), mg(3, e);
        } catch (y) {
          Kt(e, e.return, y);
        }
        try {
          Cc(5, e, e.return);
        } catch (y) {
          Kt(e, e.return, y);
        }
      }
      break;
    case 1:
      Hn(t, e), wi(e), n & 512 && r !== null && yl(r, r.return);
      break;
    case 5:
      if (Hn(t, e), wi(e), n & 512 && r !== null && yl(r, r.return), e.flags & 32) {
        var i = e.stateNode;
        try {
          qc(i, "");
        } catch (y) {
          Kt(e, e.return, y);
        }
      }
      if (n & 4 && (i = e.stateNode, i != null)) {
        var s = e.memoizedProps, o = r !== null ? r.memoizedProps : s, a = e.type, l = e.updateQueue;
        if (e.updateQueue = null, l !== null) try {
          a === "input" && s.type === "radio" && s.name != null && _$(i, s), p0(a, o);
          var u = p0(a, s);
          for (o = 0; o < l.length; o += 2) {
            var f = l[o], d = l[o + 1];
            f === "style" ? T$(i, d) : f === "dangerouslySetInnerHTML" ? A$(i, d) : f === "children" ? qc(i, d) : Uw(i, f, d, u);
          }
          switch (a) {
            case "input":
              s0(i, s);
              break;
            case "textarea":
              O$(i, s);
              break;
            case "select":
              var m = i._wrapperState.wasMultiple;
              i._wrapperState.wasMultiple = !!s.multiple;
              var v = s.value;
              v != null ? Ol(i, !!s.multiple, v, !1) : m !== !!s.multiple && (s.defaultValue != null ? Ol(
                i,
                !!s.multiple,
                s.defaultValue,
                !0
              ) : Ol(i, !!s.multiple, s.multiple ? [] : "", !1));
          }
          i[Kc] = s;
        } catch (y) {
          Kt(e, e.return, y);
        }
      }
      break;
    case 6:
      if (Hn(t, e), wi(e), n & 4) {
        if (e.stateNode === null) throw Error(Ne(162));
        i = e.stateNode, s = e.memoizedProps;
        try {
          i.nodeValue = s;
        } catch (y) {
          Kt(e, e.return, y);
        }
      }
      break;
    case 3:
      if (Hn(t, e), wi(e), n & 4 && r !== null && r.memoizedState.isDehydrated) try {
        Wc(t.containerInfo);
      } catch (y) {
        Kt(e, e.return, y);
      }
      break;
    case 4:
      Hn(t, e), wi(e);
      break;
    case 13:
      Hn(t, e), wi(e), i = e.child, i.flags & 8192 && (s = i.memoizedState !== null, i.stateNode.isHidden = s, !s || i.alternate !== null && i.alternate.memoizedState !== null || (xS = er())), n & 4 && kO(e);
      break;
    case 22:
      if (f = r !== null && r.memoizedState !== null, e.mode & 1 ? (Ir = (u = Ir) || f, Hn(t, e), Ir = u) : Hn(t, e), wi(e), n & 8192) {
        if (u = e.memoizedState !== null, (e.stateNode.isHidden = u) && !f && e.mode & 1) for (qe = e, f = e.child; f !== null; ) {
          for (d = qe = f; qe !== null; ) {
            switch (m = qe, v = m.child, m.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                Cc(4, m, m.return);
                break;
              case 1:
                yl(m, m.return);
                var S = m.stateNode;
                if (typeof S.componentWillUnmount == "function") {
                  n = m, r = m.return;
                  try {
                    t = n, S.props = t.memoizedProps, S.state = t.memoizedState, S.componentWillUnmount();
                  } catch (y) {
                    Kt(n, r, y);
                  }
                }
                break;
              case 5:
                yl(m, m.return);
                break;
              case 22:
                if (m.memoizedState !== null) {
                  PO(d);
                  continue;
                }
            }
            v !== null ? (v.return = m, qe = v) : PO(d);
          }
          f = f.sibling;
        }
        e: for (f = null, d = e; ; ) {
          if (d.tag === 5) {
            if (f === null) {
              f = d;
              try {
                i = d.stateNode, u ? (s = i.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = d.stateNode, l = d.memoizedProps.style, o = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = P$("display", o));
              } catch (y) {
                Kt(e, e.return, y);
              }
            }
          } else if (d.tag === 6) {
            if (f === null) try {
              d.stateNode.nodeValue = u ? "" : d.memoizedProps;
            } catch (y) {
              Kt(e, e.return, y);
            }
          } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === e) && d.child !== null) {
            d.child.return = d, d = d.child;
            continue;
          }
          if (d === e) break e;
          for (; d.sibling === null; ) {
            if (d.return === null || d.return === e) break e;
            f === d && (f = null), d = d.return;
          }
          f === d && (f = null), d.sibling.return = d.return, d = d.sibling;
        }
      }
      break;
    case 19:
      Hn(t, e), wi(e), n & 4 && kO(e);
      break;
    case 21:
      break;
    default:
      Hn(
        t,
        e
      ), wi(e);
  }
}
function wi(e) {
  var t = e.flags;
  if (t & 2) {
    try {
      e: {
        for (var r = e.return; r !== null; ) {
          if (eI(r)) {
            var n = r;
            break e;
          }
          r = r.return;
        }
        throw Error(Ne(160));
      }
      switch (n.tag) {
        case 5:
          var i = n.stateNode;
          n.flags & 32 && (qc(i, ""), n.flags &= -33);
          var s = OO(e);
          q0(e, s, i);
          break;
        case 3:
        case 4:
          var o = n.stateNode.containerInfo, a = OO(e);
          z0(e, a, o);
          break;
        default:
          throw Error(Ne(161));
      }
    } catch (l) {
      Kt(e, e.return, l);
    }
    e.flags &= -3;
  }
  t & 4096 && (e.flags &= -4097);
}
function E3(e, t, r) {
  qe = e, nI(e);
}
function nI(e, t, r) {
  for (var n = (e.mode & 1) !== 0; qe !== null; ) {
    var i = qe, s = i.child;
    if (i.tag === 22 && n) {
      var o = i.memoizedState !== null || ad;
      if (!o) {
        var a = i.alternate, l = a !== null && a.memoizedState !== null || Ir;
        a = ad;
        var u = Ir;
        if (ad = o, (Ir = l) && !u) for (qe = i; qe !== null; ) o = qe, l = o.child, o.tag === 22 && o.memoizedState !== null ? TO(i) : l !== null ? (l.return = o, qe = l) : TO(i);
        for (; s !== null; ) qe = s, nI(s), s = s.sibling;
        qe = i, ad = a, Ir = u;
      }
      AO(e);
    } else i.subtreeFlags & 8772 && s !== null ? (s.return = i, qe = s) : AO(e);
  }
}
function AO(e) {
  for (; qe !== null; ) {
    var t = qe;
    if (t.flags & 8772) {
      var r = t.alternate;
      try {
        if (t.flags & 8772) switch (t.tag) {
          case 0:
          case 11:
          case 15:
            Ir || mg(5, t);
            break;
          case 1:
            var n = t.stateNode;
            if (t.flags & 4 && !Ir) if (r === null) n.componentDidMount();
            else {
              var i = t.elementType === t.type ? r.memoizedProps : Kn(t.type, r.memoizedProps);
              n.componentDidUpdate(i, r.memoizedState, n.__reactInternalSnapshotBeforeUpdate);
            }
            var s = t.updateQueue;
            s !== null && pO(t, s, n);
            break;
          case 3:
            var o = t.updateQueue;
            if (o !== null) {
              if (r = null, t.child !== null) switch (t.child.tag) {
                case 5:
                  r = t.child.stateNode;
                  break;
                case 1:
                  r = t.child.stateNode;
              }
              pO(t, o, r);
            }
            break;
          case 5:
            var a = t.stateNode;
            if (r === null && t.flags & 4) {
              r = a;
              var l = t.memoizedProps;
              switch (t.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  l.autoFocus && r.focus();
                  break;
                case "img":
                  l.src && (r.src = l.src);
              }
            }
            break;
          case 6:
            break;
          case 4:
            break;
          case 12:
            break;
          case 13:
            if (t.memoizedState === null) {
              var u = t.alternate;
              if (u !== null) {
                var f = u.memoizedState;
                if (f !== null) {
                  var d = f.dehydrated;
                  d !== null && Wc(d);
                }
              }
            }
            break;
          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;
          default:
            throw Error(Ne(163));
        }
        Ir || t.flags & 512 && F0(t);
      } catch (m) {
        Kt(t, t.return, m);
      }
    }
    if (t === e) {
      qe = null;
      break;
    }
    if (r = t.sibling, r !== null) {
      r.return = t.return, qe = r;
      break;
    }
    qe = t.return;
  }
}
function PO(e) {
  for (; qe !== null; ) {
    var t = qe;
    if (t === e) {
      qe = null;
      break;
    }
    var r = t.sibling;
    if (r !== null) {
      r.return = t.return, qe = r;
      break;
    }
    qe = t.return;
  }
}
function TO(e) {
  for (; qe !== null; ) {
    var t = qe;
    try {
      switch (t.tag) {
        case 0:
        case 11:
        case 15:
          var r = t.return;
          try {
            mg(4, t);
          } catch (l) {
            Kt(t, r, l);
          }
          break;
        case 1:
          var n = t.stateNode;
          if (typeof n.componentDidMount == "function") {
            var i = t.return;
            try {
              n.componentDidMount();
            } catch (l) {
              Kt(t, i, l);
            }
          }
          var s = t.return;
          try {
            F0(t);
          } catch (l) {
            Kt(t, s, l);
          }
          break;
        case 5:
          var o = t.return;
          try {
            F0(t);
          } catch (l) {
            Kt(t, o, l);
          }
      }
    } catch (l) {
      Kt(t, t.return, l);
    }
    if (t === e) {
      qe = null;
      break;
    }
    var a = t.sibling;
    if (a !== null) {
      a.return = t.return, qe = a;
      break;
    }
    qe = t.return;
  }
}
var _3 = Math.ceil, Sm = Oo.ReactCurrentDispatcher, wS = Oo.ReactCurrentOwner, In = Oo.ReactCurrentBatchConfig, mt = 0, gr = null, sr = null, Or = 0, cn = 0, vl = vs(0), pr = 0, rp = null, pa = 0, gg = 0, SS = 0, $c = null, Gr = null, xS = 0, Dl = 1 / 0, ro = null, xm = !1, B0 = null, rs = null, ld = !1, Ho = null, Em = 0, Rc = 0, U0 = null, Dh = -1, Fh = 0;
function Br() {
  return mt & 6 ? er() : Dh !== -1 ? Dh : Dh = er();
}
function ns(e) {
  return e.mode & 1 ? mt & 2 && Or !== 0 ? Or & -Or : a3.transition !== null ? (Fh === 0 && (Fh = q$()), Fh) : (e = xt, e !== 0 || (e = window.event, e = e === void 0 ? 16 : Y$(e.type)), e) : 1;
}
function ti(e, t, r, n) {
  if (50 < Rc) throw Rc = 0, U0 = null, Error(Ne(185));
  wp(e, r, n), (!(mt & 2) || e !== gr) && (e === gr && (!(mt & 2) && (gg |= r), pr === 4 && Vo(e, Or)), on(e, n), r === 1 && mt === 0 && !(t.mode & 1) && (Dl = er() + 500, fg && bs()));
}
function on(e, t) {
  var r = e.callbackNode;
  aB(e, t);
  var n = sm(e, e === gr ? Or : 0);
  if (n === 0) r !== null && D_(r), e.callbackNode = null, e.callbackPriority = 0;
  else if (t = n & -n, e.callbackPriority !== t) {
    if (r != null && D_(r), t === 1) e.tag === 0 ? s3(CO.bind(null, e)) : dR(CO.bind(null, e)), r3(function() {
      !(mt & 6) && bs();
    }), r = null;
    else {
      switch (B$(n)) {
        case 1:
          r = Yw;
          break;
        case 4:
          r = F$;
          break;
        case 16:
          r = om;
          break;
        case 536870912:
          r = z$;
          break;
        default:
          r = om;
      }
      r = pI(r, iI.bind(null, e));
    }
    e.callbackPriority = t, e.callbackNode = r;
  }
}
function iI(e, t) {
  if (Dh = -1, Fh = 0, mt & 6) throw Error(Ne(327));
  var r = e.callbackNode;
  if (Cl() && e.callbackNode !== r) return null;
  var n = sm(e, e === gr ? Or : 0);
  if (n === 0) return null;
  if (n & 30 || n & e.expiredLanes || t) t = _m(e, n);
  else {
    t = n;
    var i = mt;
    mt |= 2;
    var s = sI();
    (gr !== e || Or !== t) && (ro = null, Dl = er() + 500, na(e, t));
    do
      try {
        A3();
        break;
      } catch (a) {
        oI(e, a);
      }
    while (!0);
    aS(), Sm.current = s, mt = i, sr !== null ? t = 0 : (gr = null, Or = 0, t = pr);
  }
  if (t !== 0) {
    if (t === 2 && (i = g0(e), i !== 0 && (n = i, t = V0(e, i))), t === 1) throw r = rp, na(e, 0), Vo(e, n), on(e, er()), r;
    if (t === 6) Vo(e, n);
    else {
      if (i = e.current.alternate, !(n & 30) && !O3(i) && (t = _m(e, n), t === 2 && (s = g0(e), s !== 0 && (n = s, t = V0(e, s))), t === 1)) throw r = rp, na(e, 0), Vo(e, n), on(e, er()), r;
      switch (e.finishedWork = i, e.finishedLanes = n, t) {
        case 0:
        case 1:
          throw Error(Ne(345));
        case 2:
          Ys(e, Gr, ro);
          break;
        case 3:
          if (Vo(e, n), (n & 130023424) === n && (t = xS + 500 - er(), 10 < t)) {
            if (sm(e, 0) !== 0) break;
            if (i = e.suspendedLanes, (i & n) !== n) {
              Br(), e.pingedLanes |= e.suspendedLanes & i;
              break;
            }
            e.timeoutHandle = _0(Ys.bind(null, e, Gr, ro), t);
            break;
          }
          Ys(e, Gr, ro);
          break;
        case 4:
          if (Vo(e, n), (n & 4194240) === n) break;
          for (t = e.eventTimes, i = -1; 0 < n; ) {
            var o = 31 - ei(n);
            s = 1 << o, o = t[o], o > i && (i = o), n &= ~s;
          }
          if (n = i, n = er() - n, n = (120 > n ? 120 : 480 > n ? 480 : 1080 > n ? 1080 : 1920 > n ? 1920 : 3e3 > n ? 3e3 : 4320 > n ? 4320 : 1960 * _3(n / 1960)) - n, 10 < n) {
            e.timeoutHandle = _0(Ys.bind(null, e, Gr, ro), n);
            break;
          }
          Ys(e, Gr, ro);
          break;
        case 5:
          Ys(e, Gr, ro);
          break;
        default:
          throw Error(Ne(329));
      }
    }
  }
  return on(e, er()), e.callbackNode === r ? iI.bind(null, e) : null;
}
function V0(e, t) {
  var r = $c;
  return e.current.memoizedState.isDehydrated && (na(e, t).flags |= 256), e = _m(e, t), e !== 2 && (t = Gr, Gr = r, t !== null && W0(t)), e;
}
function W0(e) {
  Gr === null ? Gr = e : Gr.push.apply(Gr, e);
}
function O3(e) {
  for (var t = e; ; ) {
    if (t.flags & 16384) {
      var r = t.updateQueue;
      if (r !== null && (r = r.stores, r !== null)) for (var n = 0; n < r.length; n++) {
        var i = r[n], s = i.getSnapshot;
        i = i.value;
        try {
          if (!ai(s(), i)) return !1;
        } catch {
          return !1;
        }
      }
    }
    if (r = t.child, t.subtreeFlags & 16384 && r !== null) r.return = t, t = r;
    else {
      if (t === e) break;
      for (; t.sibling === null; ) {
        if (t.return === null || t.return === e) return !0;
        t = t.return;
      }
      t.sibling.return = t.return, t = t.sibling;
    }
  }
  return !0;
}
function Vo(e, t) {
  for (t &= ~SS, t &= ~gg, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t; ) {
    var r = 31 - ei(t), n = 1 << r;
    e[r] = -1, t &= ~n;
  }
}
function CO(e) {
  if (mt & 6) throw Error(Ne(327));
  Cl();
  var t = sm(e, 0);
  if (!(t & 1)) return on(e, er()), null;
  var r = _m(e, t);
  if (e.tag !== 0 && r === 2) {
    var n = g0(e);
    n !== 0 && (t = n, r = V0(e, n));
  }
  if (r === 1) throw r = rp, na(e, 0), Vo(e, t), on(e, er()), r;
  if (r === 6) throw Error(Ne(345));
  return e.finishedWork = e.current.alternate, e.finishedLanes = t, Ys(e, Gr, ro), on(e, er()), null;
}
function ES(e, t) {
  var r = mt;
  mt |= 1;
  try {
    return e(t);
  } finally {
    mt = r, mt === 0 && (Dl = er() + 500, fg && bs());
  }
}
function fa(e) {
  Ho !== null && Ho.tag === 0 && !(mt & 6) && Cl();
  var t = mt;
  mt |= 1;
  var r = In.transition, n = xt;
  try {
    if (In.transition = null, xt = 1, e) return e();
  } finally {
    xt = n, In.transition = r, mt = t, !(mt & 6) && bs();
  }
}
function _S() {
  cn = vl.current, Mt(vl);
}
function na(e, t) {
  e.finishedWork = null, e.finishedLanes = 0;
  var r = e.timeoutHandle;
  if (r !== -1 && (e.timeoutHandle = -1, t3(r)), sr !== null) for (r = sr.return; r !== null; ) {
    var n = r;
    switch (iS(n), n.tag) {
      case 1:
        n = n.type.childContextTypes, n != null && pm();
        break;
      case 3:
        Ll(), Mt(rn), Mt(Lr), dS();
        break;
      case 5:
        fS(n);
        break;
      case 4:
        Ll();
        break;
      case 13:
        Mt(Vt);
        break;
      case 19:
        Mt(Vt);
        break;
      case 10:
        lS(n.type._context);
        break;
      case 22:
      case 23:
        _S();
    }
    r = r.return;
  }
  if (gr = e, sr = e = is(e.current, null), Or = cn = t, pr = 0, rp = null, SS = gg = pa = 0, Gr = $c = null, Js !== null) {
    for (t = 0; t < Js.length; t++) if (r = Js[t], n = r.interleaved, n !== null) {
      r.interleaved = null;
      var i = n.next, s = r.pending;
      if (s !== null) {
        var o = s.next;
        s.next = i, n.next = o;
      }
      r.pending = n;
    }
    Js = null;
  }
  return e;
}
function oI(e, t) {
  do {
    var r = sr;
    try {
      if (aS(), jh.current = wm, bm) {
        for (var n = Wt.memoizedState; n !== null; ) {
          var i = n.queue;
          i !== null && (i.pending = null), n = n.next;
        }
        bm = !1;
      }
      if (ca = 0, hr = ur = Wt = null, Tc = !1, Zc = 0, wS.current = null, r === null || r.return === null) {
        pr = 1, rp = t, sr = null;
        break;
      }
      e: {
        var s = e, o = r.return, a = r, l = t;
        if (t = Or, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") {
          var u = l, f = a, d = f.tag;
          if (!(f.mode & 1) && (d === 0 || d === 11 || d === 15)) {
            var m = f.alternate;
            m ? (f.updateQueue = m.updateQueue, f.memoizedState = m.memoizedState, f.lanes = m.lanes) : (f.updateQueue = null, f.memoizedState = null);
          }
          var v = yO(o);
          if (v !== null) {
            v.flags &= -257, vO(v, o, a, s, t), v.mode & 1 && gO(s, u, t), t = v, l = u;
            var S = t.updateQueue;
            if (S === null) {
              var y = /* @__PURE__ */ new Set();
              y.add(l), t.updateQueue = y;
            } else S.add(l);
            break e;
          } else {
            if (!(t & 1)) {
              gO(s, u, t), OS();
              break e;
            }
            l = Error(Ne(426));
          }
        } else if (Ft && a.mode & 1) {
          var E = yO(o);
          if (E !== null) {
            !(E.flags & 65536) && (E.flags |= 256), vO(E, o, a, s, t), oS(Ml(l, a));
            break e;
          }
        }
        s = l = Ml(l, a), pr !== 4 && (pr = 2), $c === null ? $c = [s] : $c.push(s), s = o;
        do {
          switch (s.tag) {
            case 3:
              s.flags |= 65536, t &= -t, s.lanes |= t;
              var x = BR(s, l, t);
              cO(s, x);
              break e;
            case 1:
              a = l;
              var g = s.type, b = s.stateNode;
              if (!(s.flags & 128) && (typeof g.getDerivedStateFromError == "function" || b !== null && typeof b.componentDidCatch == "function" && (rs === null || !rs.has(b)))) {
                s.flags |= 65536, t &= -t, s.lanes |= t;
                var A = UR(s, a, t);
                cO(s, A);
                break e;
              }
          }
          s = s.return;
        } while (s !== null);
      }
      lI(r);
    } catch (P) {
      t = P, sr === r && r !== null && (sr = r = r.return);
      continue;
    }
    break;
  } while (!0);
}
function sI() {
  var e = Sm.current;
  return Sm.current = wm, e === null ? wm : e;
}
function OS() {
  (pr === 0 || pr === 3 || pr === 2) && (pr = 4), gr === null || !(pa & 268435455) && !(gg & 268435455) || Vo(gr, Or);
}
function _m(e, t) {
  var r = mt;
  mt |= 2;
  var n = sI();
  (gr !== e || Or !== t) && (ro = null, na(e, t));
  do
    try {
      k3();
      break;
    } catch (i) {
      oI(e, i);
    }
  while (!0);
  if (aS(), mt = r, Sm.current = n, sr !== null) throw Error(Ne(261));
  return gr = null, Or = 0, pr;
}
function k3() {
  for (; sr !== null; ) aI(sr);
}
function A3() {
  for (; sr !== null && !Jq(); ) aI(sr);
}
function aI(e) {
  var t = cI(e.alternate, e, cn);
  e.memoizedProps = e.pendingProps, t === null ? lI(e) : sr = t, wS.current = null;
}
function lI(e) {
  var t = e;
  do {
    var r = t.alternate;
    if (e = t.return, t.flags & 32768) {
      if (r = w3(r, t), r !== null) {
        r.flags &= 32767, sr = r;
        return;
      }
      if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null;
      else {
        pr = 6, sr = null;
        return;
      }
    } else if (r = b3(r, t, cn), r !== null) {
      sr = r;
      return;
    }
    if (t = t.sibling, t !== null) {
      sr = t;
      return;
    }
    sr = t = e;
  } while (t !== null);
  pr === 0 && (pr = 5);
}
function Ys(e, t, r) {
  var n = xt, i = In.transition;
  try {
    In.transition = null, xt = 1, P3(e, t, r, n);
  } finally {
    In.transition = i, xt = n;
  }
  return null;
}
function P3(e, t, r, n) {
  do
    Cl();
  while (Ho !== null);
  if (mt & 6) throw Error(Ne(327));
  r = e.finishedWork;
  var i = e.finishedLanes;
  if (r === null) return null;
  if (e.finishedWork = null, e.finishedLanes = 0, r === e.current) throw Error(Ne(177));
  e.callbackNode = null, e.callbackPriority = 0;
  var s = r.lanes | r.childLanes;
  if (lB(e, s), e === gr && (sr = gr = null, Or = 0), !(r.subtreeFlags & 2064) && !(r.flags & 2064) || ld || (ld = !0, pI(om, function() {
    return Cl(), null;
  })), s = (r.flags & 15990) !== 0, r.subtreeFlags & 15990 || s) {
    s = In.transition, In.transition = null;
    var o = xt;
    xt = 1;
    var a = mt;
    mt |= 4, wS.current = null, x3(e, r), rI(r, e), YB(x0), am = !!S0, x0 = S0 = null, e.current = r, E3(r), Zq(), mt = a, xt = o, In.transition = s;
  } else e.current = r;
  if (ld && (ld = !1, Ho = e, Em = i), s = e.pendingLanes, s === 0 && (rs = null), rB(r.stateNode), on(e, er()), t !== null) for (n = e.onRecoverableError, r = 0; r < t.length; r++) i = t[r], n(i.value, { componentStack: i.stack, digest: i.digest });
  if (xm) throw xm = !1, e = B0, B0 = null, e;
  return Em & 1 && e.tag !== 0 && Cl(), s = e.pendingLanes, s & 1 ? e === U0 ? Rc++ : (Rc = 0, U0 = e) : Rc = 0, bs(), null;
}
function Cl() {
  if (Ho !== null) {
    var e = B$(Em), t = In.transition, r = xt;
    try {
      if (In.transition = null, xt = 16 > e ? 16 : e, Ho === null) var n = !1;
      else {
        if (e = Ho, Ho = null, Em = 0, mt & 6) throw Error(Ne(331));
        var i = mt;
        for (mt |= 4, qe = e.current; qe !== null; ) {
          var s = qe, o = s.child;
          if (qe.flags & 16) {
            var a = s.deletions;
            if (a !== null) {
              for (var l = 0; l < a.length; l++) {
                var u = a[l];
                for (qe = u; qe !== null; ) {
                  var f = qe;
                  switch (f.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Cc(8, f, s);
                  }
                  var d = f.child;
                  if (d !== null) d.return = f, qe = d;
                  else for (; qe !== null; ) {
                    f = qe;
                    var m = f.sibling, v = f.return;
                    if (ZR(f), f === u) {
                      qe = null;
                      break;
                    }
                    if (m !== null) {
                      m.return = v, qe = m;
                      break;
                    }
                    qe = v;
                  }
                }
              }
              var S = s.alternate;
              if (S !== null) {
                var y = S.child;
                if (y !== null) {
                  S.child = null;
                  do {
                    var E = y.sibling;
                    y.sibling = null, y = E;
                  } while (y !== null);
                }
              }
              qe = s;
            }
          }
          if (s.subtreeFlags & 2064 && o !== null) o.return = s, qe = o;
          else e: for (; qe !== null; ) {
            if (s = qe, s.flags & 2048) switch (s.tag) {
              case 0:
              case 11:
              case 15:
                Cc(9, s, s.return);
            }
            var x = s.sibling;
            if (x !== null) {
              x.return = s.return, qe = x;
              break e;
            }
            qe = s.return;
          }
        }
        var g = e.current;
        for (qe = g; qe !== null; ) {
          o = qe;
          var b = o.child;
          if (o.subtreeFlags & 2064 && b !== null) b.return = o, qe = b;
          else e: for (o = g; qe !== null; ) {
            if (a = qe, a.flags & 2048) try {
              switch (a.tag) {
                case 0:
                case 11:
                case 15:
                  mg(9, a);
              }
            } catch (P) {
              Kt(a, a.return, P);
            }
            if (a === o) {
              qe = null;
              break e;
            }
            var A = a.sibling;
            if (A !== null) {
              A.return = a.return, qe = A;
              break e;
            }
            qe = a.return;
          }
        }
        if (mt = i, bs(), $i && typeof $i.onPostCommitFiberRoot == "function") try {
          $i.onPostCommitFiberRoot(ag, e);
        } catch {
        }
        n = !0;
      }
      return n;
    } finally {
      xt = r, In.transition = t;
    }
  }
  return !1;
}
function $O(e, t, r) {
  t = Ml(r, t), t = BR(e, t, 1), e = ts(e, t, 1), t = Br(), e !== null && (wp(e, 1, t), on(e, t));
}
function Kt(e, t, r) {
  if (e.tag === 3) $O(e, e, r);
  else for (; t !== null; ) {
    if (t.tag === 3) {
      $O(t, e, r);
      break;
    } else if (t.tag === 1) {
      var n = t.stateNode;
      if (typeof t.type.getDerivedStateFromError == "function" || typeof n.componentDidCatch == "function" && (rs === null || !rs.has(n))) {
        e = Ml(r, e), e = UR(t, e, 1), t = ts(t, e, 1), e = Br(), t !== null && (wp(t, 1, e), on(t, e));
        break;
      }
    }
    t = t.return;
  }
}
function T3(e, t, r) {
  var n = e.pingCache;
  n !== null && n.delete(t), t = Br(), e.pingedLanes |= e.suspendedLanes & r, gr === e && (Or & r) === r && (pr === 4 || pr === 3 && (Or & 130023424) === Or && 500 > er() - xS ? na(e, 0) : SS |= r), on(e, t);
}
function uI(e, t) {
  t === 0 && (e.mode & 1 ? (t = Jf, Jf <<= 1, !(Jf & 130023424) && (Jf = 4194304)) : t = 1);
  var r = Br();
  e = go(e, t), e !== null && (wp(e, t, r), on(e, r));
}
function C3(e) {
  var t = e.memoizedState, r = 0;
  t !== null && (r = t.retryLane), uI(e, r);
}
function $3(e, t) {
  var r = 0;
  switch (e.tag) {
    case 13:
      var n = e.stateNode, i = e.memoizedState;
      i !== null && (r = i.retryLane);
      break;
    case 19:
      n = e.stateNode;
      break;
    default:
      throw Error(Ne(314));
  }
  n !== null && n.delete(t), uI(e, r);
}
var cI;
cI = function(e, t, r) {
  if (e !== null) if (e.memoizedProps !== t.pendingProps || rn.current) Zr = !0;
  else {
    if (!(e.lanes & r) && !(t.flags & 128)) return Zr = !1, v3(e, t, r);
    Zr = !!(e.flags & 131072);
  }
  else Zr = !1, Ft && t.flags & 1048576 && hR(t, hm, t.index);
  switch (t.lanes = 0, t.tag) {
    case 2:
      var n = t.type;
      Mh(e, t), e = t.pendingProps;
      var i = Il(t, Lr.current);
      Tl(t, r), i = mS(null, t, n, e, i, r);
      var s = gS();
      return t.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, nn(n) ? (s = !0, fm(t)) : s = !1, t.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, cS(t), i.updater = hg, t.stateNode = i, i._reactInternals = t, $0(t, n, e, r), t = N0(null, t, n, !0, s, r)) : (t.tag = 0, Ft && s && nS(t), qr(null, t, i, r), t = t.child), t;
    case 16:
      n = t.elementType;
      e: {
        switch (Mh(e, t), e = t.pendingProps, i = n._init, n = i(n._payload), t.type = n, i = t.tag = I3(n), e = Kn(n, e), i) {
          case 0:
            t = I0(null, t, n, e, r);
            break e;
          case 1:
            t = SO(null, t, n, e, r);
            break e;
          case 11:
            t = bO(null, t, n, e, r);
            break e;
          case 14:
            t = wO(null, t, n, Kn(n.type, e), r);
            break e;
        }
        throw Error(Ne(
          306,
          n,
          ""
        ));
      }
      return t;
    case 0:
      return n = t.type, i = t.pendingProps, i = t.elementType === n ? i : Kn(n, i), I0(e, t, n, i, r);
    case 1:
      return n = t.type, i = t.pendingProps, i = t.elementType === n ? i : Kn(n, i), SO(e, t, n, i, r);
    case 3:
      e: {
        if (QR(t), e === null) throw Error(Ne(387));
        n = t.pendingProps, s = t.memoizedState, i = s.element, wR(e, t), ym(t, n, null, r);
        var o = t.memoizedState;
        if (n = o.element, s.isDehydrated) if (s = { element: n, isDehydrated: !1, cache: o.cache, pendingSuspenseBoundaries: o.pendingSuspenseBoundaries, transitions: o.transitions }, t.updateQueue.baseState = s, t.memoizedState = s, t.flags & 256) {
          i = Ml(Error(Ne(423)), t), t = xO(e, t, n, r, i);
          break e;
        } else if (n !== i) {
          i = Ml(Error(Ne(424)), t), t = xO(e, t, n, r, i);
          break e;
        } else for (dn = es(t.stateNode.containerInfo.firstChild), hn = t, Ft = !0, Jn = null, r = vR(t, null, n, r), t.child = r; r; ) r.flags = r.flags & -3 | 4096, r = r.sibling;
        else {
          if (Nl(), n === i) {
            t = yo(e, t, r);
            break e;
          }
          qr(e, t, n, r);
        }
        t = t.child;
      }
      return t;
    case 5:
      return SR(t), e === null && P0(t), n = t.type, i = t.pendingProps, s = e !== null ? e.memoizedProps : null, o = i.children, E0(n, i) ? o = null : s !== null && E0(n, s) && (t.flags |= 32), HR(e, t), qr(e, t, o, r), t.child;
    case 6:
      return e === null && P0(t), null;
    case 13:
      return YR(e, t, r);
    case 4:
      return pS(t, t.stateNode.containerInfo), n = t.pendingProps, e === null ? t.child = jl(t, null, n, r) : qr(e, t, n, r), t.child;
    case 11:
      return n = t.type, i = t.pendingProps, i = t.elementType === n ? i : Kn(n, i), bO(e, t, n, i, r);
    case 7:
      return qr(e, t, t.pendingProps, r), t.child;
    case 8:
      return qr(e, t, t.pendingProps.children, r), t.child;
    case 12:
      return qr(e, t, t.pendingProps.children, r), t.child;
    case 10:
      e: {
        if (n = t.type._context, i = t.pendingProps, s = t.memoizedProps, o = i.value, Rt(mm, n._currentValue), n._currentValue = o, s !== null) if (ai(s.value, o)) {
          if (s.children === i.children && !rn.current) {
            t = yo(e, t, r);
            break e;
          }
        } else for (s = t.child, s !== null && (s.return = t); s !== null; ) {
          var a = s.dependencies;
          if (a !== null) {
            o = s.child;
            for (var l = a.firstContext; l !== null; ) {
              if (l.context === n) {
                if (s.tag === 1) {
                  l = lo(-1, r & -r), l.tag = 2;
                  var u = s.updateQueue;
                  if (u !== null) {
                    u = u.shared;
                    var f = u.pending;
                    f === null ? l.next = l : (l.next = f.next, f.next = l), u.pending = l;
                  }
                }
                s.lanes |= r, l = s.alternate, l !== null && (l.lanes |= r), T0(
                  s.return,
                  r,
                  t
                ), a.lanes |= r;
                break;
              }
              l = l.next;
            }
          } else if (s.tag === 10) o = s.type === t.type ? null : s.child;
          else if (s.tag === 18) {
            if (o = s.return, o === null) throw Error(Ne(341));
            o.lanes |= r, a = o.alternate, a !== null && (a.lanes |= r), T0(o, r, t), o = s.sibling;
          } else o = s.child;
          if (o !== null) o.return = s;
          else for (o = s; o !== null; ) {
            if (o === t) {
              o = null;
              break;
            }
            if (s = o.sibling, s !== null) {
              s.return = o.return, o = s;
              break;
            }
            o = o.return;
          }
          s = o;
        }
        qr(e, t, i.children, r), t = t.child;
      }
      return t;
    case 9:
      return i = t.type, n = t.pendingProps.children, Tl(t, r), i = Nn(i), n = n(i), t.flags |= 1, qr(e, t, n, r), t.child;
    case 14:
      return n = t.type, i = Kn(n, t.pendingProps), i = Kn(n.type, i), wO(e, t, n, i, r);
    case 15:
      return VR(e, t, t.type, t.pendingProps, r);
    case 17:
      return n = t.type, i = t.pendingProps, i = t.elementType === n ? i : Kn(n, i), Mh(e, t), t.tag = 1, nn(n) ? (e = !0, fm(t)) : e = !1, Tl(t, r), qR(t, n, i), $0(t, n, i, r), N0(null, t, n, !0, e, r);
    case 19:
      return GR(e, t, r);
    case 22:
      return WR(e, t, r);
  }
  throw Error(Ne(156, t.tag));
};
function pI(e, t) {
  return D$(e, t);
}
function R3(e, t, r, n) {
  this.tag = e, this.key = r, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = n, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
}
function $n(e, t, r, n) {
  return new R3(e, t, r, n);
}
function kS(e) {
  return e = e.prototype, !(!e || !e.isReactComponent);
}
function I3(e) {
  if (typeof e == "function") return kS(e) ? 1 : 0;
  if (e != null) {
    if (e = e.$$typeof, e === Ww) return 11;
    if (e === Hw) return 14;
  }
  return 2;
}
function is(e, t) {
  var r = e.alternate;
  return r === null ? (r = $n(e.tag, t, e.key, e.mode), r.elementType = e.elementType, r.type = e.type, r.stateNode = e.stateNode, r.alternate = e, e.alternate = r) : (r.pendingProps = t, r.type = e.type, r.flags = 0, r.subtreeFlags = 0, r.deletions = null), r.flags = e.flags & 14680064, r.childLanes = e.childLanes, r.lanes = e.lanes, r.child = e.child, r.memoizedProps = e.memoizedProps, r.memoizedState = e.memoizedState, r.updateQueue = e.updateQueue, t = e.dependencies, r.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }, r.sibling = e.sibling, r.index = e.index, r.ref = e.ref, r;
}
function zh(e, t, r, n, i, s) {
  var o = 2;
  if (n = e, typeof e == "function") kS(e) && (o = 1);
  else if (typeof e == "string") o = 5;
  else e: switch (e) {
    case ll:
      return ia(r.children, i, s, t);
    case Vw:
      o = 8, i |= 8;
      break;
    case t0:
      return e = $n(12, r, t, i | 2), e.elementType = t0, e.lanes = s, e;
    case r0:
      return e = $n(13, r, t, i), e.elementType = r0, e.lanes = s, e;
    case n0:
      return e = $n(19, r, t, i), e.elementType = n0, e.lanes = s, e;
    case S$:
      return yg(r, i, s, t);
    default:
      if (typeof e == "object" && e !== null) switch (e.$$typeof) {
        case b$:
          o = 10;
          break e;
        case w$:
          o = 9;
          break e;
        case Ww:
          o = 11;
          break e;
        case Hw:
          o = 14;
          break e;
        case zo:
          o = 16, n = null;
          break e;
      }
      throw Error(Ne(130, e == null ? e : typeof e, ""));
  }
  return t = $n(o, r, t, i), t.elementType = e, t.type = n, t.lanes = s, t;
}
function ia(e, t, r, n) {
  return e = $n(7, e, n, t), e.lanes = r, e;
}
function yg(e, t, r, n) {
  return e = $n(22, e, n, t), e.elementType = S$, e.lanes = r, e.stateNode = { isHidden: !1 }, e;
}
function Sv(e, t, r) {
  return e = $n(6, e, null, t), e.lanes = r, e;
}
function xv(e, t, r) {
  return t = $n(4, e.children !== null ? e.children : [], e.key, t), t.lanes = r, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t;
}
function N3(e, t, r, n, i) {
  this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = rv(0), this.expirationTimes = rv(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = rv(0), this.identifierPrefix = n, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null;
}
function AS(e, t, r, n, i, s, o, a, l) {
  return e = new N3(e, t, r, a, l), t === 1 ? (t = 1, s === !0 && (t |= 8)) : t = 0, s = $n(3, null, null, t), e.current = s, s.stateNode = e, s.memoizedState = { element: n, isDehydrated: r, cache: null, transitions: null, pendingSuspenseBoundaries: null }, cS(s), e;
}
function j3(e, t, r) {
  var n = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return { $$typeof: al, key: n == null ? null : "" + n, children: e, containerInfo: t, implementation: r };
}
function fI(e) {
  if (!e) return us;
  e = e._reactInternals;
  e: {
    if (Sa(e) !== e || e.tag !== 1) throw Error(Ne(170));
    var t = e;
    do {
      switch (t.tag) {
        case 3:
          t = t.stateNode.context;
          break e;
        case 1:
          if (nn(t.type)) {
            t = t.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      t = t.return;
    } while (t !== null);
    throw Error(Ne(171));
  }
  if (e.tag === 1) {
    var r = e.type;
    if (nn(r)) return fR(e, r, t);
  }
  return t;
}
function dI(e, t, r, n, i, s, o, a, l) {
  return e = AS(r, n, !0, e, i, s, o, a, l), e.context = fI(null), r = e.current, n = Br(), i = ns(r), s = lo(n, i), s.callback = t ?? null, ts(r, s, i), e.current.lanes = i, wp(e, i, n), on(e, n), e;
}
function vg(e, t, r, n) {
  var i = t.current, s = Br(), o = ns(i);
  return r = fI(r), t.context === null ? t.context = r : t.pendingContext = r, t = lo(s, o), t.payload = { element: e }, n = n === void 0 ? null : n, n !== null && (t.callback = n), e = ts(i, t, o), e !== null && (ti(e, i, o, s), Nh(e, i, o)), o;
}
function Om(e) {
  if (e = e.current, !e.child) return null;
  switch (e.child.tag) {
    case 5:
      return e.child.stateNode;
    default:
      return e.child.stateNode;
  }
}
function RO(e, t) {
  if (e = e.memoizedState, e !== null && e.dehydrated !== null) {
    var r = e.retryLane;
    e.retryLane = r !== 0 && r < t ? r : t;
  }
}
function PS(e, t) {
  RO(e, t), (e = e.alternate) && RO(e, t);
}
function L3() {
  return null;
}
var hI = typeof reportError == "function" ? reportError : function(e) {
  console.error(e);
};
function TS(e) {
  this._internalRoot = e;
}
bg.prototype.render = TS.prototype.render = function(e) {
  var t = this._internalRoot;
  if (t === null) throw Error(Ne(409));
  vg(e, t, null, null);
};
bg.prototype.unmount = TS.prototype.unmount = function() {
  var e = this._internalRoot;
  if (e !== null) {
    this._internalRoot = null;
    var t = e.containerInfo;
    fa(function() {
      vg(null, e, null, null);
    }), t[mo] = null;
  }
};
function bg(e) {
  this._internalRoot = e;
}
bg.prototype.unstable_scheduleHydration = function(e) {
  if (e) {
    var t = W$();
    e = { blockedOn: null, target: e, priority: t };
    for (var r = 0; r < Uo.length && t !== 0 && t < Uo[r].priority; r++) ;
    Uo.splice(r, 0, e), r === 0 && Q$(e);
  }
};
function CS(e) {
  return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11);
}
function wg(e) {
  return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable "));
}
function IO() {
}
function M3(e, t, r, n, i) {
  if (i) {
    if (typeof n == "function") {
      var s = n;
      n = function() {
        var u = Om(o);
        s.call(u);
      };
    }
    var o = dI(t, n, e, 0, null, !1, !1, "", IO);
    return e._reactRootContainer = o, e[mo] = o.current, Yc(e.nodeType === 8 ? e.parentNode : e), fa(), o;
  }
  for (; i = e.lastChild; ) e.removeChild(i);
  if (typeof n == "function") {
    var a = n;
    n = function() {
      var u = Om(l);
      a.call(u);
    };
  }
  var l = AS(e, 0, !1, null, null, !1, !1, "", IO);
  return e._reactRootContainer = l, e[mo] = l.current, Yc(e.nodeType === 8 ? e.parentNode : e), fa(function() {
    vg(t, l, r, n);
  }), l;
}
function Sg(e, t, r, n, i) {
  var s = r._reactRootContainer;
  if (s) {
    var o = s;
    if (typeof i == "function") {
      var a = i;
      i = function() {
        var l = Om(o);
        a.call(l);
      };
    }
    vg(t, o, e, i);
  } else o = M3(r, t, e, i, n);
  return Om(o);
}
U$ = function(e) {
  switch (e.tag) {
    case 3:
      var t = e.stateNode;
      if (t.current.memoizedState.isDehydrated) {
        var r = yc(t.pendingLanes);
        r !== 0 && (Gw(t, r | 1), on(t, er()), !(mt & 6) && (Dl = er() + 500, bs()));
      }
      break;
    case 13:
      fa(function() {
        var n = go(e, 1);
        if (n !== null) {
          var i = Br();
          ti(n, e, 1, i);
        }
      }), PS(e, 1);
  }
};
Kw = function(e) {
  if (e.tag === 13) {
    var t = go(e, 134217728);
    if (t !== null) {
      var r = Br();
      ti(t, e, 134217728, r);
    }
    PS(e, 134217728);
  }
};
V$ = function(e) {
  if (e.tag === 13) {
    var t = ns(e), r = go(e, t);
    if (r !== null) {
      var n = Br();
      ti(r, e, t, n);
    }
    PS(e, t);
  }
};
W$ = function() {
  return xt;
};
H$ = function(e, t) {
  var r = xt;
  try {
    return xt = e, t();
  } finally {
    xt = r;
  }
};
d0 = function(e, t, r) {
  switch (t) {
    case "input":
      if (s0(e, r), t = r.name, r.type === "radio" && t != null) {
        for (r = e; r.parentNode; ) r = r.parentNode;
        for (r = r.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < r.length; t++) {
          var n = r[t];
          if (n !== e && n.form === e.form) {
            var i = pg(n);
            if (!i) throw Error(Ne(90));
            E$(n), s0(n, i);
          }
        }
      }
      break;
    case "textarea":
      O$(e, r);
      break;
    case "select":
      t = r.value, t != null && Ol(e, !!r.multiple, t, !1);
  }
};
R$ = ES;
I$ = fa;
var D3 = { usingClientEntryPoint: !1, Events: [xp, fl, pg, C$, $$, ES] }, Yu = { findFiberByHostInstance: Xs, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, F3 = { bundleType: Yu.bundleType, version: Yu.version, rendererPackageName: Yu.rendererPackageName, rendererConfig: Yu.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Oo.ReactCurrentDispatcher, findHostInstanceByFiber: function(e) {
  return e = L$(e), e === null ? null : e.stateNode;
}, findFiberByHostInstance: Yu.findFiberByHostInstance || L3, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var ud = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!ud.isDisabled && ud.supportsFiber) try {
    ag = ud.inject(F3), $i = ud;
  } catch {
  }
}
vn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = D3;
vn.createPortal = function(e, t) {
  var r = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!CS(t)) throw Error(Ne(200));
  return j3(e, t, null, r);
};
vn.createRoot = function(e, t) {
  if (!CS(e)) throw Error(Ne(299));
  var r = !1, n = "", i = hI;
  return t != null && (t.unstable_strictMode === !0 && (r = !0), t.identifierPrefix !== void 0 && (n = t.identifierPrefix), t.onRecoverableError !== void 0 && (i = t.onRecoverableError)), t = AS(e, 1, !1, null, null, r, !1, n, i), e[mo] = t.current, Yc(e.nodeType === 8 ? e.parentNode : e), new TS(t);
};
vn.findDOMNode = function(e) {
  if (e == null) return null;
  if (e.nodeType === 1) return e;
  var t = e._reactInternals;
  if (t === void 0)
    throw typeof e.render == "function" ? Error(Ne(188)) : (e = Object.keys(e).join(","), Error(Ne(268, e)));
  return e = L$(t), e = e === null ? null : e.stateNode, e;
};
vn.flushSync = function(e) {
  return fa(e);
};
vn.hydrate = function(e, t, r) {
  if (!wg(t)) throw Error(Ne(200));
  return Sg(null, e, t, !0, r);
};
vn.hydrateRoot = function(e, t, r) {
  if (!CS(e)) throw Error(Ne(405));
  var n = r != null && r.hydratedSources || null, i = !1, s = "", o = hI;
  if (r != null && (r.unstable_strictMode === !0 && (i = !0), r.identifierPrefix !== void 0 && (s = r.identifierPrefix), r.onRecoverableError !== void 0 && (o = r.onRecoverableError)), t = dI(t, null, e, 1, r ?? null, i, !1, s, o), e[mo] = t.current, Yc(e), n) for (e = 0; e < n.length; e++) r = n[e], i = r._getVersion, i = i(r._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [r, i] : t.mutableSourceEagerHydrationData.push(
    r,
    i
  );
  return new bg(t);
};
vn.render = function(e, t, r) {
  if (!wg(t)) throw Error(Ne(200));
  return Sg(null, e, t, !1, r);
};
vn.unmountComponentAtNode = function(e) {
  if (!wg(e)) throw Error(Ne(40));
  return e._reactRootContainer ? (fa(function() {
    Sg(null, null, e, !1, function() {
      e._reactRootContainer = null, e[mo] = null;
    });
  }), !0) : !1;
};
vn.unstable_batchedUpdates = ES;
vn.unstable_renderSubtreeIntoContainer = function(e, t, r, n) {
  if (!wg(r)) throw Error(Ne(200));
  if (e == null || e._reactInternals === void 0) throw Error(Ne(38));
  return Sg(e, t, r, !1, n);
};
vn.version = "18.3.1-next-f1338f8080-20240426";
function mI() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(mI);
    } catch (e) {
      console.error(e);
    }
}
mI(), m$.exports = vn;
var gI = m$.exports, yI = { exports: {} }, Ev = { exports: {} };
/**
 * lunr - http://lunrjs.com - A bit like Solr, but much smaller and not as bright - 2.3.9
 * Copyright (C) 2020 Oliver Nightingale
 * @license MIT
 */
var NO;
function z3() {
  return NO || (NO = 1, function(e, t) {
    (function() {
      var r = function(n) {
        var i = new r.Builder();
        return i.pipeline.add(
          r.trimmer,
          r.stopWordFilter,
          r.stemmer
        ), i.searchPipeline.add(
          r.stemmer
        ), n.call(i, i), i.build();
      };
      r.version = "2.3.9";
      /*!
       * lunr.utils
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.utils = {}, r.utils.warn = /* @__PURE__ */ function(n) {
        return function(i) {
          n.console && console.warn && console.warn(i);
        };
      }(this), r.utils.asString = function(n) {
        return n == null ? "" : n.toString();
      }, r.utils.clone = function(n) {
        if (n == null)
          return n;
        for (var i = /* @__PURE__ */ Object.create(null), s = Object.keys(n), o = 0; o < s.length; o++) {
          var a = s[o], l = n[a];
          if (Array.isArray(l)) {
            i[a] = l.slice();
            continue;
          }
          if (typeof l == "string" || typeof l == "number" || typeof l == "boolean") {
            i[a] = l;
            continue;
          }
          throw new TypeError("clone is not deep and does not support nested objects");
        }
        return i;
      }, r.FieldRef = function(n, i, s) {
        this.docRef = n, this.fieldName = i, this._stringValue = s;
      }, r.FieldRef.joiner = "/", r.FieldRef.fromString = function(n) {
        var i = n.indexOf(r.FieldRef.joiner);
        if (i === -1)
          throw "malformed field ref string";
        var s = n.slice(0, i), o = n.slice(i + 1);
        return new r.FieldRef(o, s, n);
      }, r.FieldRef.prototype.toString = function() {
        return this._stringValue == null && (this._stringValue = this.fieldName + r.FieldRef.joiner + this.docRef), this._stringValue;
      };
      /*!
       * lunr.Set
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.Set = function(n) {
        if (this.elements = /* @__PURE__ */ Object.create(null), n) {
          this.length = n.length;
          for (var i = 0; i < this.length; i++)
            this.elements[n[i]] = !0;
        } else
          this.length = 0;
      }, r.Set.complete = {
        intersect: function(n) {
          return n;
        },
        union: function() {
          return this;
        },
        contains: function() {
          return !0;
        }
      }, r.Set.empty = {
        intersect: function() {
          return this;
        },
        union: function(n) {
          return n;
        },
        contains: function() {
          return !1;
        }
      }, r.Set.prototype.contains = function(n) {
        return !!this.elements[n];
      }, r.Set.prototype.intersect = function(n) {
        var i, s, o, a = [];
        if (n === r.Set.complete)
          return this;
        if (n === r.Set.empty)
          return n;
        this.length < n.length ? (i = this, s = n) : (i = n, s = this), o = Object.keys(i.elements);
        for (var l = 0; l < o.length; l++) {
          var u = o[l];
          u in s.elements && a.push(u);
        }
        return new r.Set(a);
      }, r.Set.prototype.union = function(n) {
        return n === r.Set.complete ? r.Set.complete : n === r.Set.empty ? this : new r.Set(Object.keys(this.elements).concat(Object.keys(n.elements)));
      }, r.idf = function(n, i) {
        var s = 0;
        for (var o in n)
          o != "_index" && (s += Object.keys(n[o]).length);
        var a = (i - s + 0.5) / (s + 0.5);
        return Math.log(1 + Math.abs(a));
      }, r.Token = function(n, i) {
        this.str = n || "", this.metadata = i || {};
      }, r.Token.prototype.toString = function() {
        return this.str;
      }, r.Token.prototype.update = function(n) {
        return this.str = n(this.str, this.metadata), this;
      }, r.Token.prototype.clone = function(n) {
        return n = n || function(i) {
          return i;
        }, new r.Token(n(this.str, this.metadata), this.metadata);
      };
      /*!
       * lunr.tokenizer
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.tokenizer = function(n, i) {
        if (n == null || n == null)
          return [];
        if (Array.isArray(n))
          return n.map(function(v) {
            return new r.Token(
              r.utils.asString(v).toLowerCase(),
              r.utils.clone(i)
            );
          });
        for (var s = n.toString().toLowerCase(), o = s.length, a = [], l = 0, u = 0; l <= o; l++) {
          var f = s.charAt(l), d = l - u;
          if (f.match(r.tokenizer.separator) || l == o) {
            if (d > 0) {
              var m = r.utils.clone(i) || {};
              m.position = [u, d], m.index = a.length, a.push(
                new r.Token(
                  s.slice(u, l),
                  m
                )
              );
            }
            u = l + 1;
          }
        }
        return a;
      }, r.tokenizer.separator = /[\s\-]+/;
      /*!
       * lunr.Pipeline
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.Pipeline = function() {
        this._stack = [];
      }, r.Pipeline.registeredFunctions = /* @__PURE__ */ Object.create(null), r.Pipeline.registerFunction = function(n, i) {
        i in this.registeredFunctions && r.utils.warn("Overwriting existing registered function: " + i), n.label = i, r.Pipeline.registeredFunctions[n.label] = n;
      }, r.Pipeline.warnIfFunctionNotRegistered = function(n) {
        var i = n.label && n.label in this.registeredFunctions;
        i || r.utils.warn(`Function is not registered with pipeline. This may cause problems when serialising the index.
`, n);
      }, r.Pipeline.load = function(n) {
        var i = new r.Pipeline();
        return n.forEach(function(s) {
          var o = r.Pipeline.registeredFunctions[s];
          if (o)
            i.add(o);
          else
            throw new Error("Cannot load unregistered function: " + s);
        }), i;
      }, r.Pipeline.prototype.add = function() {
        var n = Array.prototype.slice.call(arguments);
        n.forEach(function(i) {
          r.Pipeline.warnIfFunctionNotRegistered(i), this._stack.push(i);
        }, this);
      }, r.Pipeline.prototype.after = function(n, i) {
        r.Pipeline.warnIfFunctionNotRegistered(i);
        var s = this._stack.indexOf(n);
        if (s == -1)
          throw new Error("Cannot find existingFn");
        s = s + 1, this._stack.splice(s, 0, i);
      }, r.Pipeline.prototype.before = function(n, i) {
        r.Pipeline.warnIfFunctionNotRegistered(i);
        var s = this._stack.indexOf(n);
        if (s == -1)
          throw new Error("Cannot find existingFn");
        this._stack.splice(s, 0, i);
      }, r.Pipeline.prototype.remove = function(n) {
        var i = this._stack.indexOf(n);
        i != -1 && this._stack.splice(i, 1);
      }, r.Pipeline.prototype.run = function(n) {
        for (var i = this._stack.length, s = 0; s < i; s++) {
          for (var o = this._stack[s], a = [], l = 0; l < n.length; l++) {
            var u = o(n[l], l, n);
            if (!(u == null || u === ""))
              if (Array.isArray(u))
                for (var f = 0; f < u.length; f++)
                  a.push(u[f]);
              else
                a.push(u);
          }
          n = a;
        }
        return n;
      }, r.Pipeline.prototype.runString = function(n, i) {
        var s = new r.Token(n, i);
        return this.run([s]).map(function(o) {
          return o.toString();
        });
      }, r.Pipeline.prototype.reset = function() {
        this._stack = [];
      }, r.Pipeline.prototype.toJSON = function() {
        return this._stack.map(function(n) {
          return r.Pipeline.warnIfFunctionNotRegistered(n), n.label;
        });
      };
      /*!
       * lunr.Vector
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.Vector = function(n) {
        this._magnitude = 0, this.elements = n || [];
      }, r.Vector.prototype.positionForIndex = function(n) {
        if (this.elements.length == 0)
          return 0;
        for (var i = 0, s = this.elements.length / 2, o = s - i, a = Math.floor(o / 2), l = this.elements[a * 2]; o > 1 && (l < n && (i = a), l > n && (s = a), l != n); )
          o = s - i, a = i + Math.floor(o / 2), l = this.elements[a * 2];
        if (l == n || l > n)
          return a * 2;
        if (l < n)
          return (a + 1) * 2;
      }, r.Vector.prototype.insert = function(n, i) {
        this.upsert(n, i, function() {
          throw "duplicate index";
        });
      }, r.Vector.prototype.upsert = function(n, i, s) {
        this._magnitude = 0;
        var o = this.positionForIndex(n);
        this.elements[o] == n ? this.elements[o + 1] = s(this.elements[o + 1], i) : this.elements.splice(o, 0, n, i);
      }, r.Vector.prototype.magnitude = function() {
        if (this._magnitude) return this._magnitude;
        for (var n = 0, i = this.elements.length, s = 1; s < i; s += 2) {
          var o = this.elements[s];
          n += o * o;
        }
        return this._magnitude = Math.sqrt(n);
      }, r.Vector.prototype.dot = function(n) {
        for (var i = 0, s = this.elements, o = n.elements, a = s.length, l = o.length, u = 0, f = 0, d = 0, m = 0; d < a && m < l; )
          u = s[d], f = o[m], u < f ? d += 2 : u > f ? m += 2 : u == f && (i += s[d + 1] * o[m + 1], d += 2, m += 2);
        return i;
      }, r.Vector.prototype.similarity = function(n) {
        return this.dot(n) / this.magnitude() || 0;
      }, r.Vector.prototype.toArray = function() {
        for (var n = new Array(this.elements.length / 2), i = 1, s = 0; i < this.elements.length; i += 2, s++)
          n[s] = this.elements[i];
        return n;
      }, r.Vector.prototype.toJSON = function() {
        return this.elements;
      };
      /*!
       * lunr.stemmer
       * Copyright (C) 2020 Oliver Nightingale
       * Includes code from - http://tartarus.org/~martin/PorterStemmer/js.txt
       */
      r.stemmer = function() {
        var n = {
          ational: "ate",
          tional: "tion",
          enci: "ence",
          anci: "ance",
          izer: "ize",
          bli: "ble",
          alli: "al",
          entli: "ent",
          eli: "e",
          ousli: "ous",
          ization: "ize",
          ation: "ate",
          ator: "ate",
          alism: "al",
          iveness: "ive",
          fulness: "ful",
          ousness: "ous",
          aliti: "al",
          iviti: "ive",
          biliti: "ble",
          logi: "log"
        }, i = {
          icate: "ic",
          ative: "",
          alize: "al",
          iciti: "ic",
          ical: "ic",
          ful: "",
          ness: ""
        }, s = "[^aeiou]", o = "[aeiouy]", a = s + "[^aeiouy]*", l = o + "[aeiou]*", u = "^(" + a + ")?" + l + a, f = "^(" + a + ")?" + l + a + "(" + l + ")?$", d = "^(" + a + ")?" + l + a + l + a, m = "^(" + a + ")?" + o, v = new RegExp(u), S = new RegExp(d), y = new RegExp(f), E = new RegExp(m), x = /^(.+?)(ss|i)es$/, g = /^(.+?)([^s])s$/, b = /^(.+?)eed$/, A = /^(.+?)(ed|ing)$/, P = /.$/, k = /(at|bl|iz)$/, $ = new RegExp("([^aeiouylsz])\\1$"), I = new RegExp("^" + a + o + "[^aeiouwxy]$"), F = /^(.+?[^aeiou])y$/, L = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/, Q = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/, Y = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/, ae = /^(.+?)(s|t)(ion)$/, le = /^(.+?)e$/, ue = /ll$/, ce = new RegExp("^" + a + o + "[^aeiouwxy]$"), be = function(ee) {
          var K, z, te, q, j, H, B;
          if (ee.length < 3)
            return ee;
          if (te = ee.substr(0, 1), te == "y" && (ee = te.toUpperCase() + ee.substr(1)), q = x, j = g, q.test(ee) ? ee = ee.replace(q, "$1$2") : j.test(ee) && (ee = ee.replace(j, "$1$2")), q = b, j = A, q.test(ee)) {
            var pe = q.exec(ee);
            q = v, q.test(pe[1]) && (q = P, ee = ee.replace(q, ""));
          } else if (j.test(ee)) {
            var pe = j.exec(ee);
            K = pe[1], j = E, j.test(K) && (ee = K, j = k, H = $, B = I, j.test(ee) ? ee = ee + "e" : H.test(ee) ? (q = P, ee = ee.replace(q, "")) : B.test(ee) && (ee = ee + "e"));
          }
          if (q = F, q.test(ee)) {
            var pe = q.exec(ee);
            K = pe[1], ee = K + "i";
          }
          if (q = L, q.test(ee)) {
            var pe = q.exec(ee);
            K = pe[1], z = pe[2], q = v, q.test(K) && (ee = K + n[z]);
          }
          if (q = Q, q.test(ee)) {
            var pe = q.exec(ee);
            K = pe[1], z = pe[2], q = v, q.test(K) && (ee = K + i[z]);
          }
          if (q = Y, j = ae, q.test(ee)) {
            var pe = q.exec(ee);
            K = pe[1], q = S, q.test(K) && (ee = K);
          } else if (j.test(ee)) {
            var pe = j.exec(ee);
            K = pe[1] + pe[2], j = S, j.test(K) && (ee = K);
          }
          if (q = le, q.test(ee)) {
            var pe = q.exec(ee);
            K = pe[1], q = S, j = y, H = ce, (q.test(K) || j.test(K) && !H.test(K)) && (ee = K);
          }
          return q = ue, j = S, q.test(ee) && j.test(ee) && (q = P, ee = ee.replace(q, "")), te == "y" && (ee = te.toLowerCase() + ee.substr(1)), ee;
        };
        return function(G) {
          return G.update(be);
        };
      }(), r.Pipeline.registerFunction(r.stemmer, "stemmer");
      /*!
       * lunr.stopWordFilter
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.generateStopWordFilter = function(n) {
        var i = n.reduce(function(s, o) {
          return s[o] = o, s;
        }, {});
        return function(s) {
          if (s && i[s.toString()] !== s.toString()) return s;
        };
      }, r.stopWordFilter = r.generateStopWordFilter([
        "a",
        "able",
        "about",
        "across",
        "after",
        "all",
        "almost",
        "also",
        "am",
        "among",
        "an",
        "and",
        "any",
        "are",
        "as",
        "at",
        "be",
        "because",
        "been",
        "but",
        "by",
        "can",
        "cannot",
        "could",
        "dear",
        "did",
        "do",
        "does",
        "either",
        "else",
        "ever",
        "every",
        "for",
        "from",
        "get",
        "got",
        "had",
        "has",
        "have",
        "he",
        "her",
        "hers",
        "him",
        "his",
        "how",
        "however",
        "i",
        "if",
        "in",
        "into",
        "is",
        "it",
        "its",
        "just",
        "least",
        "let",
        "like",
        "likely",
        "may",
        "me",
        "might",
        "most",
        "must",
        "my",
        "neither",
        "no",
        "nor",
        "not",
        "of",
        "off",
        "often",
        "on",
        "only",
        "or",
        "other",
        "our",
        "own",
        "rather",
        "said",
        "say",
        "says",
        "she",
        "should",
        "since",
        "so",
        "some",
        "than",
        "that",
        "the",
        "their",
        "them",
        "then",
        "there",
        "these",
        "they",
        "this",
        "tis",
        "to",
        "too",
        "twas",
        "us",
        "wants",
        "was",
        "we",
        "were",
        "what",
        "when",
        "where",
        "which",
        "while",
        "who",
        "whom",
        "why",
        "will",
        "with",
        "would",
        "yet",
        "you",
        "your"
      ]), r.Pipeline.registerFunction(r.stopWordFilter, "stopWordFilter");
      /*!
       * lunr.trimmer
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.trimmer = function(n) {
        return n.update(function(i) {
          return i.replace(/^\W+/, "").replace(/\W+$/, "");
        });
      }, r.Pipeline.registerFunction(r.trimmer, "trimmer");
      /*!
       * lunr.TokenSet
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.TokenSet = function() {
        this.final = !1, this.edges = {}, this.id = r.TokenSet._nextId, r.TokenSet._nextId += 1;
      }, r.TokenSet._nextId = 1, r.TokenSet.fromArray = function(n) {
        for (var i = new r.TokenSet.Builder(), s = 0, o = n.length; s < o; s++)
          i.insert(n[s]);
        return i.finish(), i.root;
      }, r.TokenSet.fromClause = function(n) {
        return "editDistance" in n ? r.TokenSet.fromFuzzyString(n.term, n.editDistance) : r.TokenSet.fromString(n.term);
      }, r.TokenSet.fromFuzzyString = function(n, i) {
        for (var s = new r.TokenSet(), o = [{
          node: s,
          editsRemaining: i,
          str: n
        }]; o.length; ) {
          var a = o.pop();
          if (a.str.length > 0) {
            var l = a.str.charAt(0), u;
            l in a.node.edges ? u = a.node.edges[l] : (u = new r.TokenSet(), a.node.edges[l] = u), a.str.length == 1 && (u.final = !0), o.push({
              node: u,
              editsRemaining: a.editsRemaining,
              str: a.str.slice(1)
            });
          }
          if (a.editsRemaining != 0) {
            if ("*" in a.node.edges)
              var f = a.node.edges["*"];
            else {
              var f = new r.TokenSet();
              a.node.edges["*"] = f;
            }
            if (a.str.length == 0 && (f.final = !0), o.push({
              node: f,
              editsRemaining: a.editsRemaining - 1,
              str: a.str
            }), a.str.length > 1 && o.push({
              node: a.node,
              editsRemaining: a.editsRemaining - 1,
              str: a.str.slice(1)
            }), a.str.length == 1 && (a.node.final = !0), a.str.length >= 1) {
              if ("*" in a.node.edges)
                var d = a.node.edges["*"];
              else {
                var d = new r.TokenSet();
                a.node.edges["*"] = d;
              }
              a.str.length == 1 && (d.final = !0), o.push({
                node: d,
                editsRemaining: a.editsRemaining - 1,
                str: a.str.slice(1)
              });
            }
            if (a.str.length > 1) {
              var m = a.str.charAt(0), v = a.str.charAt(1), S;
              v in a.node.edges ? S = a.node.edges[v] : (S = new r.TokenSet(), a.node.edges[v] = S), a.str.length == 1 && (S.final = !0), o.push({
                node: S,
                editsRemaining: a.editsRemaining - 1,
                str: m + a.str.slice(2)
              });
            }
          }
        }
        return s;
      }, r.TokenSet.fromString = function(n) {
        for (var i = new r.TokenSet(), s = i, o = 0, a = n.length; o < a; o++) {
          var l = n[o], u = o == a - 1;
          if (l == "*")
            i.edges[l] = i, i.final = u;
          else {
            var f = new r.TokenSet();
            f.final = u, i.edges[l] = f, i = f;
          }
        }
        return s;
      }, r.TokenSet.prototype.toArray = function() {
        for (var n = [], i = [{
          prefix: "",
          node: this
        }]; i.length; ) {
          var s = i.pop(), o = Object.keys(s.node.edges), a = o.length;
          s.node.final && (s.prefix.charAt(0), n.push(s.prefix));
          for (var l = 0; l < a; l++) {
            var u = o[l];
            i.push({
              prefix: s.prefix.concat(u),
              node: s.node.edges[u]
            });
          }
        }
        return n;
      }, r.TokenSet.prototype.toString = function() {
        if (this._str)
          return this._str;
        for (var n = this.final ? "1" : "0", i = Object.keys(this.edges).sort(), s = i.length, o = 0; o < s; o++) {
          var a = i[o], l = this.edges[a];
          n = n + a + l.id;
        }
        return n;
      }, r.TokenSet.prototype.intersect = function(n) {
        for (var i = new r.TokenSet(), s = void 0, o = [{
          qNode: n,
          output: i,
          node: this
        }]; o.length; ) {
          s = o.pop();
          for (var a = Object.keys(s.qNode.edges), l = a.length, u = Object.keys(s.node.edges), f = u.length, d = 0; d < l; d++)
            for (var m = a[d], v = 0; v < f; v++) {
              var S = u[v];
              if (S == m || m == "*") {
                var y = s.node.edges[S], E = s.qNode.edges[m], x = y.final && E.final, g = void 0;
                S in s.output.edges ? (g = s.output.edges[S], g.final = g.final || x) : (g = new r.TokenSet(), g.final = x, s.output.edges[S] = g), o.push({
                  qNode: E,
                  output: g,
                  node: y
                });
              }
            }
        }
        return i;
      }, r.TokenSet.Builder = function() {
        this.previousWord = "", this.root = new r.TokenSet(), this.uncheckedNodes = [], this.minimizedNodes = {};
      }, r.TokenSet.Builder.prototype.insert = function(n) {
        var i, s = 0;
        if (n < this.previousWord)
          throw new Error("Out of order word insertion");
        for (var o = 0; o < n.length && o < this.previousWord.length && n[o] == this.previousWord[o]; o++)
          s++;
        this.minimize(s), this.uncheckedNodes.length == 0 ? i = this.root : i = this.uncheckedNodes[this.uncheckedNodes.length - 1].child;
        for (var o = s; o < n.length; o++) {
          var a = new r.TokenSet(), l = n[o];
          i.edges[l] = a, this.uncheckedNodes.push({
            parent: i,
            char: l,
            child: a
          }), i = a;
        }
        i.final = !0, this.previousWord = n;
      }, r.TokenSet.Builder.prototype.finish = function() {
        this.minimize(0);
      }, r.TokenSet.Builder.prototype.minimize = function(n) {
        for (var i = this.uncheckedNodes.length - 1; i >= n; i--) {
          var s = this.uncheckedNodes[i], o = s.child.toString();
          o in this.minimizedNodes ? s.parent.edges[s.char] = this.minimizedNodes[o] : (s.child._str = o, this.minimizedNodes[o] = s.child), this.uncheckedNodes.pop();
        }
      };
      /*!
       * lunr.Index
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.Index = function(n) {
        this.invertedIndex = n.invertedIndex, this.fieldVectors = n.fieldVectors, this.tokenSet = n.tokenSet, this.fields = n.fields, this.pipeline = n.pipeline;
      }, r.Index.prototype.search = function(n) {
        return this.query(function(i) {
          var s = new r.QueryParser(n, i);
          s.parse();
        });
      }, r.Index.prototype.query = function(n) {
        for (var i = new r.Query(this.fields), s = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ Object.create(null), l = /* @__PURE__ */ Object.create(null), u = /* @__PURE__ */ Object.create(null), f = 0; f < this.fields.length; f++)
          o[this.fields[f]] = new r.Vector();
        n.call(i, i);
        for (var f = 0; f < i.clauses.length; f++) {
          var d = i.clauses[f], m = null, v = r.Set.empty;
          d.usePipeline ? m = this.pipeline.runString(d.term, {
            fields: d.fields
          }) : m = [d.term];
          for (var S = 0; S < m.length; S++) {
            var y = m[S];
            d.term = y;
            var E = r.TokenSet.fromClause(d), x = this.tokenSet.intersect(E).toArray();
            if (x.length === 0 && d.presence === r.Query.presence.REQUIRED) {
              for (var g = 0; g < d.fields.length; g++) {
                var b = d.fields[g];
                l[b] = r.Set.empty;
              }
              break;
            }
            for (var A = 0; A < x.length; A++)
              for (var P = x[A], k = this.invertedIndex[P], $ = k._index, g = 0; g < d.fields.length; g++) {
                var b = d.fields[g], I = k[b], F = Object.keys(I), L = P + "/" + b, Q = new r.Set(F);
                if (d.presence == r.Query.presence.REQUIRED && (v = v.union(Q), l[b] === void 0 && (l[b] = r.Set.complete)), d.presence == r.Query.presence.PROHIBITED) {
                  u[b] === void 0 && (u[b] = r.Set.empty), u[b] = u[b].union(Q);
                  continue;
                }
                if (o[b].upsert($, d.boost, function(N, J) {
                  return N + J;
                }), !a[L]) {
                  for (var Y = 0; Y < F.length; Y++) {
                    var ae = F[Y], le = new r.FieldRef(ae, b), ue = I[ae], ce;
                    (ce = s[le]) === void 0 ? s[le] = new r.MatchData(P, b, ue) : ce.add(P, b, ue);
                  }
                  a[L] = !0;
                }
              }
          }
          if (d.presence === r.Query.presence.REQUIRED)
            for (var g = 0; g < d.fields.length; g++) {
              var b = d.fields[g];
              l[b] = l[b].intersect(v);
            }
        }
        for (var be = r.Set.complete, G = r.Set.empty, f = 0; f < this.fields.length; f++) {
          var b = this.fields[f];
          l[b] && (be = be.intersect(l[b])), u[b] && (G = G.union(u[b]));
        }
        var ee = Object.keys(s), K = [], z = /* @__PURE__ */ Object.create(null);
        if (i.isNegated()) {
          ee = Object.keys(this.fieldVectors);
          for (var f = 0; f < ee.length; f++) {
            var le = ee[f], te = r.FieldRef.fromString(le);
            s[le] = new r.MatchData();
          }
        }
        for (var f = 0; f < ee.length; f++) {
          var te = r.FieldRef.fromString(ee[f]), q = te.docRef;
          if (be.contains(q) && !G.contains(q)) {
            var j = this.fieldVectors[te], H = o[te.fieldName].similarity(j), B;
            if ((B = z[q]) !== void 0)
              B.score += H, B.matchData.combine(s[te]);
            else {
              var pe = {
                ref: q,
                score: H,
                matchData: s[te]
              };
              z[q] = pe, K.push(pe);
            }
          }
        }
        return K.sort(function(he, Ae) {
          return Ae.score - he.score;
        });
      }, r.Index.prototype.toJSON = function() {
        var n = Object.keys(this.invertedIndex).sort().map(function(s) {
          return [s, this.invertedIndex[s]];
        }, this), i = Object.keys(this.fieldVectors).map(function(s) {
          return [s, this.fieldVectors[s].toJSON()];
        }, this);
        return {
          version: r.version,
          fields: this.fields,
          fieldVectors: i,
          invertedIndex: n,
          pipeline: this.pipeline.toJSON()
        };
      }, r.Index.load = function(n) {
        var i = {}, s = {}, o = n.fieldVectors, a = /* @__PURE__ */ Object.create(null), l = n.invertedIndex, u = new r.TokenSet.Builder(), f = r.Pipeline.load(n.pipeline);
        n.version != r.version && r.utils.warn("Version mismatch when loading serialised index. Current version of lunr '" + r.version + "' does not match serialized index '" + n.version + "'");
        for (var d = 0; d < o.length; d++) {
          var m = o[d], v = m[0], S = m[1];
          s[v] = new r.Vector(S);
        }
        for (var d = 0; d < l.length; d++) {
          var m = l[d], y = m[0], E = m[1];
          u.insert(y), a[y] = E;
        }
        return u.finish(), i.fields = n.fields, i.fieldVectors = s, i.invertedIndex = a, i.tokenSet = u.root, i.pipeline = f, new r.Index(i);
      };
      /*!
       * lunr.Builder
       * Copyright (C) 2020 Oliver Nightingale
       */
      r.Builder = function() {
        this._ref = "id", this._fields = /* @__PURE__ */ Object.create(null), this._documents = /* @__PURE__ */ Object.create(null), this.invertedIndex = /* @__PURE__ */ Object.create(null), this.fieldTermFrequencies = {}, this.fieldLengths = {}, this.tokenizer = r.tokenizer, this.pipeline = new r.Pipeline(), this.searchPipeline = new r.Pipeline(), this.documentCount = 0, this._b = 0.75, this._k1 = 1.2, this.termIndex = 0, this.metadataWhitelist = [];
      }, r.Builder.prototype.ref = function(n) {
        this._ref = n;
      }, r.Builder.prototype.field = function(n, i) {
        if (/\//.test(n))
          throw new RangeError("Field '" + n + "' contains illegal character '/'");
        this._fields[n] = i || {};
      }, r.Builder.prototype.b = function(n) {
        n < 0 ? this._b = 0 : n > 1 ? this._b = 1 : this._b = n;
      }, r.Builder.prototype.k1 = function(n) {
        this._k1 = n;
      }, r.Builder.prototype.add = function(n, i) {
        var s = n[this._ref], o = Object.keys(this._fields);
        this._documents[s] = i || {}, this.documentCount += 1;
        for (var a = 0; a < o.length; a++) {
          var l = o[a], u = this._fields[l].extractor, f = u ? u(n) : n[l], d = this.tokenizer(f, {
            fields: [l]
          }), m = this.pipeline.run(d), v = new r.FieldRef(s, l), S = /* @__PURE__ */ Object.create(null);
          this.fieldTermFrequencies[v] = S, this.fieldLengths[v] = 0, this.fieldLengths[v] += m.length;
          for (var y = 0; y < m.length; y++) {
            var E = m[y];
            if (S[E] == null && (S[E] = 0), S[E] += 1, this.invertedIndex[E] == null) {
              var x = /* @__PURE__ */ Object.create(null);
              x._index = this.termIndex, this.termIndex += 1;
              for (var g = 0; g < o.length; g++)
                x[o[g]] = /* @__PURE__ */ Object.create(null);
              this.invertedIndex[E] = x;
            }
            this.invertedIndex[E][l][s] == null && (this.invertedIndex[E][l][s] = /* @__PURE__ */ Object.create(null));
            for (var b = 0; b < this.metadataWhitelist.length; b++) {
              var A = this.metadataWhitelist[b], P = E.metadata[A];
              this.invertedIndex[E][l][s][A] == null && (this.invertedIndex[E][l][s][A] = []), this.invertedIndex[E][l][s][A].push(P);
            }
          }
        }
      }, r.Builder.prototype.calculateAverageFieldLengths = function() {
        for (var n = Object.keys(this.fieldLengths), i = n.length, s = {}, o = {}, a = 0; a < i; a++) {
          var l = r.FieldRef.fromString(n[a]), u = l.fieldName;
          o[u] || (o[u] = 0), o[u] += 1, s[u] || (s[u] = 0), s[u] += this.fieldLengths[l];
        }
        for (var f = Object.keys(this._fields), a = 0; a < f.length; a++) {
          var d = f[a];
          s[d] = s[d] / o[d];
        }
        this.averageFieldLength = s;
      }, r.Builder.prototype.createFieldVectors = function() {
        for (var n = {}, i = Object.keys(this.fieldTermFrequencies), s = i.length, o = /* @__PURE__ */ Object.create(null), a = 0; a < s; a++) {
          for (var l = r.FieldRef.fromString(i[a]), u = l.fieldName, f = this.fieldLengths[l], d = new r.Vector(), m = this.fieldTermFrequencies[l], v = Object.keys(m), S = v.length, y = this._fields[u].boost || 1, E = this._documents[l.docRef].boost || 1, x = 0; x < S; x++) {
            var g = v[x], b = m[g], A = this.invertedIndex[g]._index, P, k, $;
            o[g] === void 0 ? (P = r.idf(this.invertedIndex[g], this.documentCount), o[g] = P) : P = o[g], k = P * ((this._k1 + 1) * b) / (this._k1 * (1 - this._b + this._b * (f / this.averageFieldLength[u])) + b), k *= y, k *= E, $ = Math.round(k * 1e3) / 1e3, d.insert(A, $);
          }
          n[l] = d;
        }
        this.fieldVectors = n;
      }, r.Builder.prototype.createTokenSet = function() {
        this.tokenSet = r.TokenSet.fromArray(
          Object.keys(this.invertedIndex).sort()
        );
      }, r.Builder.prototype.build = function() {
        return this.calculateAverageFieldLengths(), this.createFieldVectors(), this.createTokenSet(), new r.Index({
          invertedIndex: this.invertedIndex,
          fieldVectors: this.fieldVectors,
          tokenSet: this.tokenSet,
          fields: Object.keys(this._fields),
          pipeline: this.searchPipeline
        });
      }, r.Builder.prototype.use = function(n) {
        var i = Array.prototype.slice.call(arguments, 1);
        i.unshift(this), n.apply(this, i);
      }, r.MatchData = function(n, i, s) {
        for (var o = /* @__PURE__ */ Object.create(null), a = Object.keys(s || {}), l = 0; l < a.length; l++) {
          var u = a[l];
          o[u] = s[u].slice();
        }
        this.metadata = /* @__PURE__ */ Object.create(null), n !== void 0 && (this.metadata[n] = /* @__PURE__ */ Object.create(null), this.metadata[n][i] = o);
      }, r.MatchData.prototype.combine = function(n) {
        for (var i = Object.keys(n.metadata), s = 0; s < i.length; s++) {
          var o = i[s], a = Object.keys(n.metadata[o]);
          this.metadata[o] == null && (this.metadata[o] = /* @__PURE__ */ Object.create(null));
          for (var l = 0; l < a.length; l++) {
            var u = a[l], f = Object.keys(n.metadata[o][u]);
            this.metadata[o][u] == null && (this.metadata[o][u] = /* @__PURE__ */ Object.create(null));
            for (var d = 0; d < f.length; d++) {
              var m = f[d];
              this.metadata[o][u][m] == null ? this.metadata[o][u][m] = n.metadata[o][u][m] : this.metadata[o][u][m] = this.metadata[o][u][m].concat(n.metadata[o][u][m]);
            }
          }
        }
      }, r.MatchData.prototype.add = function(n, i, s) {
        if (!(n in this.metadata)) {
          this.metadata[n] = /* @__PURE__ */ Object.create(null), this.metadata[n][i] = s;
          return;
        }
        if (!(i in this.metadata[n])) {
          this.metadata[n][i] = s;
          return;
        }
        for (var o = Object.keys(s), a = 0; a < o.length; a++) {
          var l = o[a];
          l in this.metadata[n][i] ? this.metadata[n][i][l] = this.metadata[n][i][l].concat(s[l]) : this.metadata[n][i][l] = s[l];
        }
      }, r.Query = function(n) {
        this.clauses = [], this.allFields = n;
      }, r.Query.wildcard = new String("*"), r.Query.wildcard.NONE = 0, r.Query.wildcard.LEADING = 1, r.Query.wildcard.TRAILING = 2, r.Query.presence = {
        /**
         * Term's presence in a document is optional, this is the default value.
         */
        OPTIONAL: 1,
        /**
         * Term's presence in a document is required, documents that do not contain
         * this term will not be returned.
         */
        REQUIRED: 2,
        /**
         * Term's presence in a document is prohibited, documents that do contain
         * this term will not be returned.
         */
        PROHIBITED: 3
      }, r.Query.prototype.clause = function(n) {
        return "fields" in n || (n.fields = this.allFields), "boost" in n || (n.boost = 1), "usePipeline" in n || (n.usePipeline = !0), "wildcard" in n || (n.wildcard = r.Query.wildcard.NONE), n.wildcard & r.Query.wildcard.LEADING && n.term.charAt(0) != r.Query.wildcard && (n.term = "*" + n.term), n.wildcard & r.Query.wildcard.TRAILING && n.term.slice(-1) != r.Query.wildcard && (n.term = "" + n.term + "*"), "presence" in n || (n.presence = r.Query.presence.OPTIONAL), this.clauses.push(n), this;
      }, r.Query.prototype.isNegated = function() {
        for (var n = 0; n < this.clauses.length; n++)
          if (this.clauses[n].presence != r.Query.presence.PROHIBITED)
            return !1;
        return !0;
      }, r.Query.prototype.term = function(n, i) {
        if (Array.isArray(n))
          return n.forEach(function(o) {
            this.term(o, r.utils.clone(i));
          }, this), this;
        var s = i || {};
        return s.term = n.toString(), this.clause(s), this;
      }, r.QueryParseError = function(n, i, s) {
        this.name = "QueryParseError", this.message = n, this.start = i, this.end = s;
      }, r.QueryParseError.prototype = new Error(), r.QueryLexer = function(n) {
        this.lexemes = [], this.str = n, this.length = n.length, this.pos = 0, this.start = 0, this.escapeCharPositions = [];
      }, r.QueryLexer.prototype.run = function() {
        for (var n = r.QueryLexer.lexText; n; )
          n = n(this);
      }, r.QueryLexer.prototype.sliceString = function() {
        for (var n = [], i = this.start, s = this.pos, o = 0; o < this.escapeCharPositions.length; o++)
          s = this.escapeCharPositions[o], n.push(this.str.slice(i, s)), i = s + 1;
        return n.push(this.str.slice(i, this.pos)), this.escapeCharPositions.length = 0, n.join("");
      }, r.QueryLexer.prototype.emit = function(n) {
        this.lexemes.push({
          type: n,
          str: this.sliceString(),
          start: this.start,
          end: this.pos
        }), this.start = this.pos;
      }, r.QueryLexer.prototype.escapeCharacter = function() {
        this.escapeCharPositions.push(this.pos - 1), this.pos += 1;
      }, r.QueryLexer.prototype.next = function() {
        if (this.pos >= this.length)
          return r.QueryLexer.EOS;
        var n = this.str.charAt(this.pos);
        return this.pos += 1, n;
      }, r.QueryLexer.prototype.width = function() {
        return this.pos - this.start;
      }, r.QueryLexer.prototype.ignore = function() {
        this.start == this.pos && (this.pos += 1), this.start = this.pos;
      }, r.QueryLexer.prototype.backup = function() {
        this.pos -= 1;
      }, r.QueryLexer.prototype.acceptDigitRun = function() {
        var n, i;
        do
          n = this.next(), i = n.charCodeAt(0);
        while (i > 47 && i < 58);
        n != r.QueryLexer.EOS && this.backup();
      }, r.QueryLexer.prototype.more = function() {
        return this.pos < this.length;
      }, r.QueryLexer.EOS = "EOS", r.QueryLexer.FIELD = "FIELD", r.QueryLexer.TERM = "TERM", r.QueryLexer.EDIT_DISTANCE = "EDIT_DISTANCE", r.QueryLexer.BOOST = "BOOST", r.QueryLexer.PRESENCE = "PRESENCE", r.QueryLexer.lexField = function(n) {
        return n.backup(), n.emit(r.QueryLexer.FIELD), n.ignore(), r.QueryLexer.lexText;
      }, r.QueryLexer.lexTerm = function(n) {
        if (n.width() > 1 && (n.backup(), n.emit(r.QueryLexer.TERM)), n.ignore(), n.more())
          return r.QueryLexer.lexText;
      }, r.QueryLexer.lexEditDistance = function(n) {
        return n.ignore(), n.acceptDigitRun(), n.emit(r.QueryLexer.EDIT_DISTANCE), r.QueryLexer.lexText;
      }, r.QueryLexer.lexBoost = function(n) {
        return n.ignore(), n.acceptDigitRun(), n.emit(r.QueryLexer.BOOST), r.QueryLexer.lexText;
      }, r.QueryLexer.lexEOS = function(n) {
        n.width() > 0 && n.emit(r.QueryLexer.TERM);
      }, r.QueryLexer.termSeparator = r.tokenizer.separator, r.QueryLexer.lexText = function(n) {
        for (; ; ) {
          var i = n.next();
          if (i == r.QueryLexer.EOS)
            return r.QueryLexer.lexEOS;
          if (i.charCodeAt(0) == 92) {
            n.escapeCharacter();
            continue;
          }
          if (i == ":")
            return r.QueryLexer.lexField;
          if (i == "~")
            return n.backup(), n.width() > 0 && n.emit(r.QueryLexer.TERM), r.QueryLexer.lexEditDistance;
          if (i == "^")
            return n.backup(), n.width() > 0 && n.emit(r.QueryLexer.TERM), r.QueryLexer.lexBoost;
          if (i == "+" && n.width() === 1 || i == "-" && n.width() === 1)
            return n.emit(r.QueryLexer.PRESENCE), r.QueryLexer.lexText;
          if (i.match(r.QueryLexer.termSeparator))
            return r.QueryLexer.lexTerm;
        }
      }, r.QueryParser = function(n, i) {
        this.lexer = new r.QueryLexer(n), this.query = i, this.currentClause = {}, this.lexemeIdx = 0;
      }, r.QueryParser.prototype.parse = function() {
        this.lexer.run(), this.lexemes = this.lexer.lexemes;
        for (var n = r.QueryParser.parseClause; n; )
          n = n(this);
        return this.query;
      }, r.QueryParser.prototype.peekLexeme = function() {
        return this.lexemes[this.lexemeIdx];
      }, r.QueryParser.prototype.consumeLexeme = function() {
        var n = this.peekLexeme();
        return this.lexemeIdx += 1, n;
      }, r.QueryParser.prototype.nextClause = function() {
        var n = this.currentClause;
        this.query.clause(n), this.currentClause = {};
      }, r.QueryParser.parseClause = function(n) {
        var i = n.peekLexeme();
        if (i != null)
          switch (i.type) {
            case r.QueryLexer.PRESENCE:
              return r.QueryParser.parsePresence;
            case r.QueryLexer.FIELD:
              return r.QueryParser.parseField;
            case r.QueryLexer.TERM:
              return r.QueryParser.parseTerm;
            default:
              var s = "expected either a field or a term, found " + i.type;
              throw i.str.length >= 1 && (s += " with value '" + i.str + "'"), new r.QueryParseError(s, i.start, i.end);
          }
      }, r.QueryParser.parsePresence = function(n) {
        var i = n.consumeLexeme();
        if (i != null) {
          switch (i.str) {
            case "-":
              n.currentClause.presence = r.Query.presence.PROHIBITED;
              break;
            case "+":
              n.currentClause.presence = r.Query.presence.REQUIRED;
              break;
            default:
              var s = "unrecognised presence operator'" + i.str + "'";
              throw new r.QueryParseError(s, i.start, i.end);
          }
          var o = n.peekLexeme();
          if (o == null) {
            var s = "expecting term or field, found nothing";
            throw new r.QueryParseError(s, i.start, i.end);
          }
          switch (o.type) {
            case r.QueryLexer.FIELD:
              return r.QueryParser.parseField;
            case r.QueryLexer.TERM:
              return r.QueryParser.parseTerm;
            default:
              var s = "expecting term or field, found '" + o.type + "'";
              throw new r.QueryParseError(s, o.start, o.end);
          }
        }
      }, r.QueryParser.parseField = function(n) {
        var i = n.consumeLexeme();
        if (i != null) {
          if (n.query.allFields.indexOf(i.str) == -1) {
            var s = n.query.allFields.map(function(l) {
              return "'" + l + "'";
            }).join(", "), o = "unrecognised field '" + i.str + "', possible fields: " + s;
            throw new r.QueryParseError(o, i.start, i.end);
          }
          n.currentClause.fields = [i.str];
          var a = n.peekLexeme();
          if (a == null) {
            var o = "expecting term, found nothing";
            throw new r.QueryParseError(o, i.start, i.end);
          }
          switch (a.type) {
            case r.QueryLexer.TERM:
              return r.QueryParser.parseTerm;
            default:
              var o = "expecting term, found '" + a.type + "'";
              throw new r.QueryParseError(o, a.start, a.end);
          }
        }
      }, r.QueryParser.parseTerm = function(n) {
        var i = n.consumeLexeme();
        if (i != null) {
          n.currentClause.term = i.str.toLowerCase(), i.str.indexOf("*") != -1 && (n.currentClause.usePipeline = !1);
          var s = n.peekLexeme();
          if (s == null) {
            n.nextClause();
            return;
          }
          switch (s.type) {
            case r.QueryLexer.TERM:
              return n.nextClause(), r.QueryParser.parseTerm;
            case r.QueryLexer.FIELD:
              return n.nextClause(), r.QueryParser.parseField;
            case r.QueryLexer.EDIT_DISTANCE:
              return r.QueryParser.parseEditDistance;
            case r.QueryLexer.BOOST:
              return r.QueryParser.parseBoost;
            case r.QueryLexer.PRESENCE:
              return n.nextClause(), r.QueryParser.parsePresence;
            default:
              var o = "Unexpected lexeme type '" + s.type + "'";
              throw new r.QueryParseError(o, s.start, s.end);
          }
        }
      }, r.QueryParser.parseEditDistance = function(n) {
        var i = n.consumeLexeme();
        if (i != null) {
          var s = parseInt(i.str, 10);
          if (isNaN(s)) {
            var o = "edit distance must be numeric";
            throw new r.QueryParseError(o, i.start, i.end);
          }
          n.currentClause.editDistance = s;
          var a = n.peekLexeme();
          if (a == null) {
            n.nextClause();
            return;
          }
          switch (a.type) {
            case r.QueryLexer.TERM:
              return n.nextClause(), r.QueryParser.parseTerm;
            case r.QueryLexer.FIELD:
              return n.nextClause(), r.QueryParser.parseField;
            case r.QueryLexer.EDIT_DISTANCE:
              return r.QueryParser.parseEditDistance;
            case r.QueryLexer.BOOST:
              return r.QueryParser.parseBoost;
            case r.QueryLexer.PRESENCE:
              return n.nextClause(), r.QueryParser.parsePresence;
            default:
              var o = "Unexpected lexeme type '" + a.type + "'";
              throw new r.QueryParseError(o, a.start, a.end);
          }
        }
      }, r.QueryParser.parseBoost = function(n) {
        var i = n.consumeLexeme();
        if (i != null) {
          var s = parseInt(i.str, 10);
          if (isNaN(s)) {
            var o = "boost must be numeric";
            throw new r.QueryParseError(o, i.start, i.end);
          }
          n.currentClause.boost = s;
          var a = n.peekLexeme();
          if (a == null) {
            n.nextClause();
            return;
          }
          switch (a.type) {
            case r.QueryLexer.TERM:
              return n.nextClause(), r.QueryParser.parseTerm;
            case r.QueryLexer.FIELD:
              return n.nextClause(), r.QueryParser.parseField;
            case r.QueryLexer.EDIT_DISTANCE:
              return r.QueryParser.parseEditDistance;
            case r.QueryLexer.BOOST:
              return r.QueryParser.parseBoost;
            case r.QueryLexer.PRESENCE:
              return n.nextClause(), r.QueryParser.parsePresence;
            default:
              var o = "Unexpected lexeme type '" + a.type + "'";
              throw new r.QueryParseError(o, a.start, a.end);
          }
        }
      }, function(n, i) {
        e.exports = i();
      }(this, function() {
        return r;
      });
    })();
  }(Ev)), Ev.exports;
}
var _v, jO;
function q3() {
  if (jO) return _v;
  jO = 1;
  function e() {
    return typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : typeof setImmediate == "function" ? setImmediate : function(r) {
      setTimeout(r, 0);
    };
  }
  return _v = e(), _v;
}
var Ov, LO;
function B3() {
  if (LO) return Ov;
  LO = 1;
  var e = q3();
  return Ov = function(r, n) {
    if (r) {
      n.then(function(i) {
        e(function() {
          r(null, i);
        });
      }, function(i) {
        e(function() {
          r(i);
        });
      });
      return;
    } else
      return n;
  }, Ov;
}
var kv, MO;
function U3() {
  if (MO) return kv;
  MO = 1, kv = s, s.default = s, s.stable = u, s.stableStringify = u;
  var e = "[...]", t = "[Circular]", r = [], n = [];
  function i() {
    return {
      depthLimit: Number.MAX_SAFE_INTEGER,
      edgesLimit: Number.MAX_SAFE_INTEGER
    };
  }
  function s(m, v, S, y) {
    typeof y > "u" && (y = i()), a(m, "", 0, [], void 0, 0, y);
    var E;
    try {
      n.length === 0 ? E = JSON.stringify(m, v, S) : E = JSON.stringify(m, d(v), S);
    } catch {
      return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      for (; r.length !== 0; ) {
        var x = r.pop();
        x.length === 4 ? Object.defineProperty(x[0], x[1], x[3]) : x[0][x[1]] = x[2];
      }
    }
    return E;
  }
  function o(m, v, S, y) {
    var E = Object.getOwnPropertyDescriptor(y, S);
    E.get !== void 0 ? E.configurable ? (Object.defineProperty(y, S, { value: m }), r.push([y, S, v, E])) : n.push([v, S, m]) : (y[S] = m, r.push([y, S, v]));
  }
  function a(m, v, S, y, E, x, g) {
    x += 1;
    var b;
    if (typeof m == "object" && m !== null) {
      for (b = 0; b < y.length; b++)
        if (y[b] === m) {
          o(t, m, v, E);
          return;
        }
      if (typeof g.depthLimit < "u" && x > g.depthLimit) {
        o(e, m, v, E);
        return;
      }
      if (typeof g.edgesLimit < "u" && S + 1 > g.edgesLimit) {
        o(e, m, v, E);
        return;
      }
      if (y.push(m), Array.isArray(m))
        for (b = 0; b < m.length; b++)
          a(m[b], b, b, y, m, x, g);
      else {
        var A = Object.keys(m);
        for (b = 0; b < A.length; b++) {
          var P = A[b];
          a(m[P], P, b, y, m, x, g);
        }
      }
      y.pop();
    }
  }
  function l(m, v) {
    return m < v ? -1 : m > v ? 1 : 0;
  }
  function u(m, v, S, y) {
    typeof y > "u" && (y = i());
    var E = f(m, "", 0, [], void 0, 0, y) || m, x;
    try {
      n.length === 0 ? x = JSON.stringify(E, v, S) : x = JSON.stringify(E, d(v), S);
    } catch {
      return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      for (; r.length !== 0; ) {
        var g = r.pop();
        g.length === 4 ? Object.defineProperty(g[0], g[1], g[3]) : g[0][g[1]] = g[2];
      }
    }
    return x;
  }
  function f(m, v, S, y, E, x, g) {
    x += 1;
    var b;
    if (typeof m == "object" && m !== null) {
      for (b = 0; b < y.length; b++)
        if (y[b] === m) {
          o(t, m, v, E);
          return;
        }
      try {
        if (typeof m.toJSON == "function")
          return;
      } catch {
        return;
      }
      if (typeof g.depthLimit < "u" && x > g.depthLimit) {
        o(e, m, v, E);
        return;
      }
      if (typeof g.edgesLimit < "u" && S + 1 > g.edgesLimit) {
        o(e, m, v, E);
        return;
      }
      if (y.push(m), Array.isArray(m))
        for (b = 0; b < m.length; b++)
          f(m[b], b, b, y, m, x, g);
      else {
        var A = {}, P = Object.keys(m).sort(l);
        for (b = 0; b < P.length; b++) {
          var k = P[b];
          f(m[k], k, b, y, m, x, g), A[k] = m[k];
        }
        if (typeof E < "u")
          r.push([E, v, m]), E[v] = A;
        else
          return A;
      }
      y.pop();
    }
  }
  function d(m) {
    return m = typeof m < "u" ? m : function(v, S) {
      return S;
    }, function(v, S) {
      if (n.length > 0)
        for (var y = 0; y < n.length; y++) {
          var E = n[y];
          if (E[1] === v && E[0] === S) {
            S = E[2], n.splice(y, 1);
            break;
          }
        }
      return m.call(this, v, S);
    };
  }
  return kv;
}
/*!
 * Stickyfill -- `position: sticky` polyfill
 * v. 1.1.1 | https://github.com/wilddeer/stickyfill
 * Copyright Oleg Korsunsky | http://wd.dizaina.net/
 *
 * MIT License
 */
var Av, DO;
function V3() {
  return DO || (DO = 1, Av = function(e, t) {
    e || (e = document), t || (t = window);
    var r = [], n, i = !1, s = e.documentElement, o = function() {
    }, a, l = "hidden", u = "visibilitychange";
    e.webkitHidden !== void 0 && (l = "webkitHidden", u = "webkitvisibilitychange"), t.getComputedStyle || v();
    for (var f = ["", "-webkit-", "-moz-", "-ms-"], d = document.createElement("div"), m = f.length - 1; m >= 0; m--) {
      try {
        d.style.position = f[m] + "sticky";
      } catch {
      }
      d.style.position != "" && v();
    }
    E();
    function v() {
      ee = j = K = z = te = q = o;
    }
    function S(B, pe) {
      for (key in pe)
        pe.hasOwnProperty(key) && (B[key] = pe[key]);
    }
    function y(B) {
      return parseFloat(B) || 0;
    }
    function E() {
      n = {
        top: t.pageYOffset,
        left: t.pageXOffset
      };
    }
    function x() {
      if (t.pageXOffset != n.left) {
        E(), K();
        return;
      }
      t.pageYOffset != n.top && (E(), b());
    }
    function g(B) {
      setTimeout(function() {
        t.pageYOffset != n.top && (n.top = t.pageYOffset, b());
      }, 0);
    }
    function b() {
      for (var B = r.length - 1; B >= 0; B--)
        A(r[B]);
    }
    function A(B) {
      if (B.inited) {
        var pe = n.top <= B.limit.start ? 0 : n.top >= B.limit.end ? 2 : 1;
        B.mode != pe && L(B, pe);
      }
    }
    function P() {
      for (var B = r.length - 1; B >= 0; B--)
        if (r[B].inited) {
          var pe = Math.abs(le(r[B].clone) - r[B].docOffsetTop), he = Math.abs(r[B].parent.node.offsetHeight - r[B].parent.height);
          if (pe >= 2 || he >= 2) return !1;
        }
      return !0;
    }
    function k(B) {
      isNaN(parseFloat(B.computed.top)) || B.isCell || (B.inited = !0, B.clone || Q(B), B.parent.computed.position != "absolute" && B.parent.computed.position != "relative" && (B.parent.node.style.position = "relative"), A(B), B.parent.height = B.parent.node.offsetHeight, B.docOffsetTop = le(B.clone));
    }
    function $(B) {
      var pe = !0;
      B.clone && Y(B), S(B.node.style, B.css);
      for (var he = r.length - 1; he >= 0; he--)
        if (r[he].node !== B.node && r[he].parent.node === B.parent.node) {
          pe = !1;
          break;
        }
      pe && (B.parent.node.style.position = B.parent.css.position), B.mode = -1;
    }
    function I() {
      for (var B = r.length - 1; B >= 0; B--)
        k(r[B]);
    }
    function F() {
      for (var B = r.length - 1; B >= 0; B--)
        $(r[B]);
    }
    function L(B, pe) {
      var he = B.node.style;
      switch (pe) {
        case 0:
          he.position = "absolute", he.left = B.offset.left + "px", he.right = B.offset.right + "px", he.top = B.offset.top + "px", he.bottom = "auto", he.width = "auto", he.marginLeft = 0, he.marginRight = 0, he.marginTop = 0;
          break;
        case 1:
          he.position = "fixed", he.left = B.box.left + "px", he.right = B.box.right + "px", he.top = B.css.top, he.bottom = "auto", he.width = "auto", he.marginLeft = 0, he.marginRight = 0, he.marginTop = 0;
          break;
        case 2:
          he.position = "absolute", he.left = B.offset.left + "px", he.right = B.offset.right + "px", he.top = "auto", he.bottom = 0, he.width = "auto", he.marginLeft = 0, he.marginRight = 0;
          break;
      }
      B.mode = pe;
    }
    function Q(B) {
      B.clone = document.createElement("div");
      var pe = B.node.nextSibling || B.node, he = B.clone.style;
      he.height = B.height + "px", he.width = B.width + "px", he.marginTop = B.computed.marginTop, he.marginBottom = B.computed.marginBottom, he.marginLeft = B.computed.marginLeft, he.marginRight = B.computed.marginRight, he.padding = he.border = he.borderSpacing = 0, he.fontSize = "1em", he.position = "static", he.cssFloat = B.computed.cssFloat, B.node.parentNode.insertBefore(B.clone, pe);
    }
    function Y(B) {
      B.clone.parentNode.removeChild(B.clone), B.clone = void 0;
    }
    function ae(B) {
      var pe = getComputedStyle(B), he = B.parentNode, Ae = getComputedStyle(he), C = B.style.position;
      B.style.position = "relative";
      var N = {
        top: pe.top,
        marginTop: pe.marginTop,
        marginBottom: pe.marginBottom,
        marginLeft: pe.marginLeft,
        marginRight: pe.marginRight,
        cssFloat: pe.cssFloat
      }, J = {
        top: y(pe.top),
        marginBottom: y(pe.marginBottom),
        paddingLeft: y(pe.paddingLeft),
        paddingRight: y(pe.paddingRight),
        borderLeftWidth: y(pe.borderLeftWidth),
        borderRightWidth: y(pe.borderRightWidth)
      };
      B.style.position = C;
      var X = {
        position: B.style.position,
        top: B.style.top,
        bottom: B.style.bottom,
        left: B.style.left,
        right: B.style.right,
        width: B.style.width,
        marginTop: B.style.marginTop,
        marginLeft: B.style.marginLeft,
        marginRight: B.style.marginRight
      }, oe = ue(B), U = ue(he), V = {
        node: he,
        css: {
          position: he.style.position
        },
        computed: {
          position: Ae.position
        },
        numeric: {
          borderLeftWidth: y(Ae.borderLeftWidth),
          borderRightWidth: y(Ae.borderRightWidth),
          borderTopWidth: y(Ae.borderTopWidth),
          borderBottomWidth: y(Ae.borderBottomWidth)
        }
      }, ye = {
        node: B,
        box: {
          left: oe.win.left,
          right: s.clientWidth - oe.win.right
        },
        offset: {
          top: oe.win.top - U.win.top - V.numeric.borderTopWidth,
          left: oe.win.left - U.win.left - V.numeric.borderLeftWidth,
          right: -oe.win.right + U.win.right - V.numeric.borderRightWidth
        },
        css: X,
        isCell: pe.display == "table-cell",
        computed: N,
        numeric: J,
        width: oe.win.right - oe.win.left,
        height: oe.win.bottom - oe.win.top,
        mode: -1,
        inited: !1,
        parent: V,
        limit: {
          start: oe.doc.top - J.top,
          end: U.doc.top + he.offsetHeight - V.numeric.borderBottomWidth - B.offsetHeight - J.top - J.marginBottom
        }
      };
      return ye;
    }
    function le(B) {
      for (var pe = 0; B; )
        pe += B.offsetTop, B = B.offsetParent;
      return pe;
    }
    function ue(B) {
      var pe = B.getBoundingClientRect();
      return {
        doc: {
          top: pe.top + t.pageYOffset,
          left: pe.left + t.pageXOffset
        },
        win: pe
      };
    }
    function ce() {
      a = setInterval(function() {
        !P() && K();
      }, 500);
    }
    function be() {
      clearInterval(a);
    }
    function G() {
      i && (document[l] ? be() : ce());
    }
    function ee() {
      i || (E(), I(), t.addEventListener("scroll", x), t.addEventListener("wheel", g), t.addEventListener("resize", K), t.addEventListener("orientationchange", K), e.addEventListener(u, G), ce(), i = !0);
    }
    function K() {
      if (i) {
        F();
        for (var B = r.length - 1; B >= 0; B--)
          r[B] = ae(r[B].node);
        I();
      }
    }
    function z() {
      t.removeEventListener("scroll", x), t.removeEventListener("wheel", g), t.removeEventListener("resize", K), t.removeEventListener("orientationchange", K), e.removeEventListener(u, G), be(), i = !1;
    }
    function te() {
      z(), F();
    }
    function q() {
      for (te(); r.length; )
        r.pop();
    }
    function j(B) {
      for (var pe = r.length - 1; pe >= 0; pe--)
        if (r[pe].node === B) return;
      var he = ae(B);
      r.push(he), i ? k(he) : ee();
    }
    function H(B) {
      for (var pe = r.length - 1; pe >= 0; pe--)
        r[pe].node === B && ($(r[pe]), r.splice(pe, 1));
    }
    return {
      stickies: r,
      add: j,
      remove: H,
      init: ee,
      rebuild: K,
      pause: z,
      stop: te,
      kill: q
    };
  }), Av;
}
function mn(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? mn = function(t) {
    return typeof t;
  } : mn = function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, mn(e);
}
function dt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function FO(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function _t(e, t, r) {
  return t && FO(e.prototype, t), r && FO(e, r), e;
}
function Nr(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
function Ct(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), t && np(e, t);
}
function Ar(e) {
  return Ar = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Ar(e);
}
function np(e, t) {
  return np = Object.setPrototypeOf || function(n, i) {
    return n.__proto__ = i, n;
  }, np(e, t);
}
function vI() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function qh(e, t, r) {
  return vI() ? qh = Reflect.construct : qh = function(i, s, o) {
    var a = [null];
    a.push.apply(a, s);
    var l = Function.bind.apply(i, a), u = new l();
    return o && np(u, o.prototype), u;
  }, qh.apply(null, arguments);
}
function W3(e) {
  return Function.toString.call(e).indexOf("[native code]") !== -1;
}
function H0(e) {
  var t = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return H0 = function(n) {
    if (n === null || !W3(n)) return n;
    if (typeof n != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (typeof t < "u") {
      if (t.has(n)) return t.get(n);
      t.set(n, i);
    }
    function i() {
      return qh(n, arguments, Ar(this).constructor);
    }
    return i.prototype = Object.create(n.prototype, {
      constructor: {
        value: i,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), np(i, n);
  }, H0(e);
}
function kn(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function bI(e, t) {
  return t && (typeof t == "object" || typeof t == "function") ? t : kn(e);
}
function $t(e) {
  var t = vI();
  return function() {
    var n = Ar(e), i;
    if (t) {
      var s = Ar(this).constructor;
      i = Reflect.construct(n, arguments, s);
    } else
      i = n.apply(this, arguments);
    return bI(this, i);
  };
}
function H3(e, t) {
  for (; !Object.prototype.hasOwnProperty.call(e, t) && (e = Ar(e), e !== null); )
    ;
  return e;
}
function sn(e, t, r) {
  return typeof Reflect < "u" && Reflect.get ? sn = Reflect.get : sn = function(i, s, o) {
    var a = H3(i, s);
    if (a) {
      var l = Object.getOwnPropertyDescriptor(a, s);
      return l.get ? l.get.call(o) : l.value;
    }
  }, sn(e, t, r || e);
}
function _p(e, t) {
  return wI(e) || Y3(e, t) || $S(e, t) || SI();
}
function Gu(e) {
  return wI(e) || Q3(e) || $S(e) || SI();
}
function wI(e) {
  if (Array.isArray(e)) return e;
}
function Q3(e) {
  if (typeof Symbol < "u" && Symbol.iterator in Object(e)) return Array.from(e);
}
function Y3(e, t) {
  if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(e)))) {
    var r = [], n = !0, i = !1, s = void 0;
    try {
      for (var o = e[Symbol.iterator](), a; !(n = (a = o.next()).done) && (r.push(a.value), !(t && r.length === t)); n = !0)
        ;
    } catch (l) {
      i = !0, s = l;
    } finally {
      try {
        !n && o.return != null && o.return();
      } finally {
        if (i) throw s;
      }
    }
    return r;
  }
}
function $S(e, t) {
  if (e) {
    if (typeof e == "string") return zO(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return zO(e, t);
  }
}
function zO(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function SI() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Tt(e, t) {
  var r;
  if (typeof Symbol > "u" || e[Symbol.iterator] == null) {
    if (Array.isArray(e) || (r = $S(e)) || t) {
      r && (e = r);
      var n = 0, i = function() {
      };
      return {
        s: i,
        n: function() {
          return n >= e.length ? {
            done: !0
          } : {
            done: !1,
            value: e[n++]
          };
        },
        e: function(l) {
          throw l;
        },
        f: i
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var s = !0, o = !1, a;
  return {
    s: function() {
      r = e[Symbol.iterator]();
    },
    n: function() {
      var l = r.next();
      return s = l.done, l;
    },
    e: function(l) {
      o = !0, a = l;
    },
    f: function() {
      try {
        !s && r.return != null && r.return();
      } finally {
        if (o) throw a;
      }
    }
  };
}
var nr = {
  ANCHOR: "&",
  COMMENT: "#",
  TAG: "!",
  DIRECTIVES_END: "-",
  DOCUMENT_END: "."
}, xe = {
  ALIAS: "ALIAS",
  BLANK_LINE: "BLANK_LINE",
  BLOCK_FOLDED: "BLOCK_FOLDED",
  BLOCK_LITERAL: "BLOCK_LITERAL",
  COMMENT: "COMMENT",
  DIRECTIVE: "DIRECTIVE",
  DOCUMENT: "DOCUMENT",
  FLOW_MAP: "FLOW_MAP",
  FLOW_SEQ: "FLOW_SEQ",
  MAP: "MAP",
  MAP_KEY: "MAP_KEY",
  MAP_VALUE: "MAP_VALUE",
  PLAIN: "PLAIN",
  QUOTE_DOUBLE: "QUOTE_DOUBLE",
  QUOTE_SINGLE: "QUOTE_SINGLE",
  SEQ: "SEQ",
  SEQ_ITEM: "SEQ_ITEM"
}, Bh = "tag:yaml.org,2002:", Qo = {
  MAP: "tag:yaml.org,2002:map",
  SEQ: "tag:yaml.org,2002:seq",
  STR: "tag:yaml.org,2002:str"
};
function qO(e) {
  for (var t = [0], r = e.indexOf(`
`); r !== -1; )
    r += 1, t.push(r), r = e.indexOf(`
`, r);
  return t;
}
function xI(e) {
  var t, r;
  return typeof e == "string" ? (t = qO(e), r = e) : (Array.isArray(e) && (e = e[0]), e && e.context && (e.lineStarts || (e.lineStarts = qO(e.context.src)), t = e.lineStarts, r = e.context.src)), {
    lineStarts: t,
    src: r
  };
}
function Q0(e, t) {
  if (typeof e != "number" || e < 0) return null;
  var r = xI(t), n = r.lineStarts, i = r.src;
  if (!n || !i || e > i.length) return null;
  for (var s = 0; s < n.length; ++s) {
    var o = n[s];
    if (e < o)
      return {
        line: s,
        col: e - n[s - 1] + 1
      };
    if (e === o) return {
      line: s + 1,
      col: 1
    };
  }
  var a = n.length;
  return {
    line: a,
    col: e - n[a - 1] + 1
  };
}
function G3(e, t) {
  var r = xI(t), n = r.lineStarts, i = r.src;
  if (!n || !(e >= 1) || e > n.length) return null;
  for (var s = n[e - 1], o = n[e]; o && o > s && i[o - 1] === `
`; )
    --o;
  return i.slice(s, o);
}
function K3(e, t) {
  var r = e.start, n = e.end, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 80, s = G3(r.line, t);
  if (!s) return null;
  var o = r.col;
  if (s.length > i)
    if (o <= i - 10)
      s = s.substr(0, i - 1) + "";
    else {
      var a = Math.round(i / 2);
      s.length > o + a && (s = s.substr(0, o + a - 1) + ""), o -= s.length - i, s = "" + s.substr(1 - i);
    }
  var l = 1, u = "";
  n && (n.line === r.line && o + (n.col - r.col) <= i + 1 ? l = n.col - r.col : (l = Math.min(s.length + 1, i) - o, u = ""));
  var f = o > 1 ? " ".repeat(o - 1) : "", d = "^".repeat(l);
  return "".concat(s, `
`).concat(f).concat(d).concat(u);
}
var zt = /* @__PURE__ */ function() {
  function e(t, r) {
    dt(this, e), this.start = t, this.end = r || t;
  }
  return _t(e, [{
    key: "isEmpty",
    value: function() {
      return typeof this.start != "number" || !this.end || this.end <= this.start;
    }
    /**
     * Set `origStart` and `origEnd` to point to the original source range for
     * this node, which may differ due to dropped CR characters.
     *
     * @param {number[]} cr - Positions of dropped CR characters
     * @param {number} offset - Starting index of `cr` from the last call
     * @returns {number} - The next offset, matching the one found for `origStart`
     */
  }, {
    key: "setOrigRange",
    value: function(r, n) {
      var i = this.start, s = this.end;
      if (r.length === 0 || s <= r[0])
        return this.origStart = i, this.origEnd = s, n;
      for (var o = n; o < r.length && !(r[o] > i); )
        ++o;
      this.origStart = i + o;
      for (var a = o; o < r.length && !(r[o] >= s); )
        ++o;
      return this.origEnd = s + o, a;
    }
  }], [{
    key: "copy",
    value: function(r) {
      return new e(r.start, r.end);
    }
  }]), e;
}(), De = /* @__PURE__ */ function() {
  function e(t, r, n) {
    dt(this, e), Object.defineProperty(this, "context", {
      value: n || null,
      writable: !0
    }), this.error = null, this.range = null, this.valueRange = null, this.props = r || [], this.type = t, this.value = null;
  }
  return _t(e, [{
    key: "getPropValue",
    value: function(r, n, i) {
      if (!this.context) return null;
      var s = this.context.src, o = this.props[r];
      return o && s[o.start] === n ? s.slice(o.start + (i ? 1 : 0), o.end) : null;
    }
  }, {
    key: "anchor",
    get: function() {
      for (var r = 0; r < this.props.length; ++r) {
        var n = this.getPropValue(r, nr.ANCHOR, !0);
        if (n != null) return n;
      }
      return null;
    }
  }, {
    key: "comment",
    get: function() {
      for (var r = [], n = 0; n < this.props.length; ++n) {
        var i = this.getPropValue(n, nr.COMMENT, !0);
        i != null && r.push(i);
      }
      return r.length > 0 ? r.join(`
`) : null;
    }
  }, {
    key: "commentHasRequiredWhitespace",
    value: function(r) {
      var n = this.context.src;
      if (this.header && r === this.header.end || !this.valueRange) return !1;
      var i = this.valueRange.end;
      return r !== i || e.atBlank(n, i - 1);
    }
  }, {
    key: "hasComment",
    get: function() {
      if (this.context) {
        for (var r = this.context.src, n = 0; n < this.props.length; ++n)
          if (r[this.props[n].start] === nr.COMMENT) return !0;
      }
      return !1;
    }
  }, {
    key: "hasProps",
    get: function() {
      if (this.context) {
        for (var r = this.context.src, n = 0; n < this.props.length; ++n)
          if (r[this.props[n].start] !== nr.COMMENT) return !0;
      }
      return !1;
    }
  }, {
    key: "includesTrailingLines",
    get: function() {
      return !1;
    }
  }, {
    key: "jsonLike",
    get: function() {
      var r = [xe.FLOW_MAP, xe.FLOW_SEQ, xe.QUOTE_DOUBLE, xe.QUOTE_SINGLE];
      return r.indexOf(this.type) !== -1;
    }
  }, {
    key: "rangeAsLinePos",
    get: function() {
      if (!(!this.range || !this.context)) {
        var r = Q0(this.range.start, this.context.root);
        if (r) {
          var n = Q0(this.range.end, this.context.root);
          return {
            start: r,
            end: n
          };
        }
      }
    }
  }, {
    key: "rawValue",
    get: function() {
      if (!this.valueRange || !this.context) return null;
      var r = this.valueRange, n = r.start, i = r.end;
      return this.context.src.slice(n, i);
    }
  }, {
    key: "tag",
    get: function() {
      for (var r = 0; r < this.props.length; ++r) {
        var n = this.getPropValue(r, nr.TAG, !1);
        if (n != null) {
          if (n[1] === "<")
            return {
              verbatim: n.slice(2, -1)
            };
          var i = n.match(/^(.*!)([^!]*)$/), s = _p(i, 3);
          s[0];
          var o = s[1], a = s[2];
          return {
            handle: o,
            suffix: a
          };
        }
      }
      return null;
    }
  }, {
    key: "valueRangeContainsNewline",
    get: function() {
      if (!this.valueRange || !this.context) return !1;
      for (var r = this.valueRange, n = r.start, i = r.end, s = this.context.src, o = n; o < i; ++o)
        if (s[o] === `
`) return !0;
      return !1;
    }
  }, {
    key: "parseComment",
    value: function(r) {
      var n = this.context.src;
      if (n[r] === nr.COMMENT) {
        var i = e.endOfLine(n, r + 1), s = new zt(r, i);
        return this.props.push(s), i;
      }
      return r;
    }
    /**
     * Populates the `origStart` and `origEnd` values of all ranges for this
     * node. Extended by child classes to handle descendant nodes.
     *
     * @param {number[]} cr - Positions of dropped CR characters
     * @param {number} offset - Starting index of `cr` from the last call
     * @returns {number} - The next offset, matching the one found for `origStart`
     */
  }, {
    key: "setOrigRanges",
    value: function(r, n) {
      return this.range && (n = this.range.setOrigRange(r, n)), this.valueRange && this.valueRange.setOrigRange(r, n), this.props.forEach(function(i) {
        return i.setOrigRange(r, n);
      }), n;
    }
  }, {
    key: "toString",
    value: function() {
      var r = this.context.src, n = this.range, i = this.value;
      if (i != null) return i;
      var s = r.slice(n.start, n.end);
      return e.addStringTerminator(r, n.end, s);
    }
  }], [{
    key: "addStringTerminator",
    value: function(r, n, i) {
      if (i[i.length - 1] === `
`) return i;
      var s = e.endOfWhiteSpace(r, n);
      return s >= r.length || r[s] === `
` ? i + `
` : i;
    }
    // ^(---|...)
  }, {
    key: "atDocumentBoundary",
    value: function(r, n, i) {
      var s = r[n];
      if (!s) return !0;
      var o = r[n - 1];
      if (o && o !== `
`) return !1;
      if (i) {
        if (s !== i) return !1;
      } else if (s !== nr.DIRECTIVES_END && s !== nr.DOCUMENT_END) return !1;
      var a = r[n + 1], l = r[n + 2];
      if (a !== s || l !== s) return !1;
      var u = r[n + 3];
      return !u || u === `
` || u === "	" || u === " ";
    }
  }, {
    key: "endOfIdentifier",
    value: function(r, n) {
      for (var i = r[n], s = i === "<", o = s ? [`
`, "	", " ", ">"] : [`
`, "	", " ", "[", "]", "{", "}", ","]; i && o.indexOf(i) === -1; )
        i = r[n += 1];
      return s && i === ">" && (n += 1), n;
    }
  }, {
    key: "endOfIndent",
    value: function(r, n) {
      for (var i = r[n]; i === " "; )
        i = r[n += 1];
      return n;
    }
  }, {
    key: "endOfLine",
    value: function(r, n) {
      for (var i = r[n]; i && i !== `
`; )
        i = r[n += 1];
      return n;
    }
  }, {
    key: "endOfWhiteSpace",
    value: function(r, n) {
      for (var i = r[n]; i === "	" || i === " "; )
        i = r[n += 1];
      return n;
    }
  }, {
    key: "startOfLine",
    value: function(r, n) {
      var i = r[n - 1];
      if (i === `
`) return n;
      for (; i && i !== `
`; )
        i = r[n -= 1];
      return n + 1;
    }
    /**
     * End of indentation, or null if the line's indent level is not more
     * than `indent`
     *
     * @param {string} src
     * @param {number} indent
     * @param {number} lineStart
     * @returns {?number}
     */
  }, {
    key: "endOfBlockIndent",
    value: function(r, n, i) {
      var s = e.endOfIndent(r, i);
      if (s > i + n)
        return s;
      var o = e.endOfWhiteSpace(r, s), a = r[o];
      return !a || a === `
` ? o : null;
    }
  }, {
    key: "atBlank",
    value: function(r, n, i) {
      var s = r[n];
      return s === `
` || s === "	" || s === " " || i && !s;
    }
  }, {
    key: "nextNodeIsIndented",
    value: function(r, n, i) {
      return !r || n < 0 ? !1 : n > 0 ? !0 : i && r === "-";
    }
    // should be at line or string end, or at next non-whitespace char
  }, {
    key: "normalizeOffset",
    value: function(r, n) {
      var i = r[n];
      return i ? i !== `
` && r[n - 1] === `
` ? n - 1 : e.endOfWhiteSpace(r, n) : n;
    }
    // fold single newline into space, multiple newlines to N - 1 newlines
    // presumes src[offset] === '\n'
  }, {
    key: "foldNewline",
    value: function(r, n, i) {
      for (var s = 0, o = !1, a = "", l = r[n + 1]; l === " " || l === "	" || l === `
`; ) {
        switch (l) {
          case `
`:
            s = 0, n += 1, a += `
`;
            break;
          case "	":
            s <= i && (o = !0), n = e.endOfWhiteSpace(r, n + 2) - 1;
            break;
          case " ":
            s += 1, n += 1;
            break;
        }
        l = r[n + 1];
      }
      return a || (a = " "), l && s <= i && (o = !0), {
        fold: a,
        offset: n,
        error: o
      };
    }
  }]), e;
}(), Fl = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r(n, i, s) {
    var o;
    if (dt(this, r), !s || !(i instanceof De)) throw new Error("Invalid arguments for new ".concat(n));
    return o = t.call(this), o.name = n, o.message = s, o.source = i, o;
  }
  return _t(r, [{
    key: "makePretty",
    value: function() {
      if (this.source) {
        this.nodeType = this.source.type;
        var i = this.source.context && this.source.context.root;
        if (typeof this.offset == "number") {
          this.range = new zt(this.offset, this.offset + 1);
          var s = i && Q0(this.offset, i);
          if (s) {
            var o = {
              line: s.line,
              col: s.col + 1
            };
            this.linePos = {
              start: s,
              end: o
            };
          }
          delete this.offset;
        } else
          this.range = this.source.range, this.linePos = this.source.rangeAsLinePos;
        if (this.linePos) {
          var a = this.linePos.start, l = a.line, u = a.col;
          this.message += " at line ".concat(l, ", column ").concat(u);
          var f = i && K3(this.linePos, i);
          f && (this.message += `:

`.concat(f, `
`));
        }
        delete this.source;
      }
    }
  }]), r;
}(/* @__PURE__ */ H0(Error)), ip = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r(n, i) {
    return dt(this, r), t.call(this, "YAMLReferenceError", n, i);
  }
  return r;
}(Fl), nt = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r(n, i) {
    return dt(this, r), t.call(this, "YAMLSemanticError", n, i);
  }
  return r;
}(Fl), jr = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r(n, i) {
    return dt(this, r), t.call(this, "YAMLSyntaxError", n, i);
  }
  return r;
}(Fl), tu = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r(n, i) {
    return dt(this, r), t.call(this, "YAMLWarning", n, i);
  }
  return r;
}(Fl), EI = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r() {
    return dt(this, r), t.apply(this, arguments);
  }
  return _t(r, [{
    key: "strValue",
    get: function() {
      if (!this.valueRange || !this.context) return null;
      for (var i = this.valueRange, s = i.start, o = i.end, a = this.context.src, l = a[o - 1]; s < o && (l === `
` || l === "	" || l === " "); )
        l = a[--o - 1];
      for (var u = "", f = s; f < o; ++f) {
        var d = a[f];
        if (d === `
`) {
          var m = De.foldNewline(a, f, -1), v = m.fold, S = m.offset;
          u += v, f = S;
        } else if (d === " " || d === "	") {
          for (var y = f, E = a[f + 1]; f < o && (E === " " || E === "	"); )
            f += 1, E = a[f + 1];
          E !== `
` && (u += f > y ? a.slice(y, f + 1) : d);
        } else
          u += d;
      }
      var x = a[s];
      switch (x) {
        case "	": {
          var g = "Plain value cannot start with a tab character", b = [new nt(this, g)];
          return {
            errors: b,
            str: u
          };
        }
        case "@":
        case "`": {
          var A = "Plain value cannot start with reserved character ".concat(x), P = [new nt(this, A)];
          return {
            errors: P,
            str: u
          };
        }
        default:
          return u;
      }
    }
  }, {
    key: "parseBlockValue",
    value: function(i) {
      for (var s = this.context, o = s.indent, a = s.inFlow, l = s.src, u = i, f = i, d = l[u]; d === `
` && !De.atDocumentBoundary(l, u + 1); d = l[u]) {
        var m = De.endOfBlockIndent(l, o, u + 1);
        if (m === null || l[m] === "#") break;
        l[m] === `
` ? u = m : (f = r.endOfLine(l, m, a), u = f);
      }
      return this.valueRange.isEmpty() && (this.valueRange.start = i), this.valueRange.end = f, f;
    }
    /**
     * Parses a plain value from the source
     *
     * Accepted forms are:
     * ```
     * #comment
     *
     * first line
     *
     * first line #comment
     *
     * first line
     * block
     * lines
     *
     * #comment
     * block
     * lines
     * ```
     * where block lines are empty or have an indent level greater than `indent`.
     *
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this scalar, may be `\n`
     */
  }, {
    key: "parse",
    value: function(i, s) {
      this.context = i;
      var o = i.inFlow, a = i.src, l = s, u = a[l];
      return u && u !== "#" && u !== `
` && (l = r.endOfLine(a, s, o)), this.valueRange = new zt(s, l), l = De.endOfWhiteSpace(a, l), l = this.parseComment(l), (!this.hasComment || this.valueRange.isEmpty()) && (l = this.parseBlockValue(l)), l;
    }
  }], [{
    key: "endOfLine",
    value: function(i, s, o) {
      for (var a = i[s], l = s; a && a !== `
` && !(o && (a === "[" || a === "]" || a === "{" || a === "}" || a === ",")); ) {
        var u = i[l + 1];
        if (a === ":" && (!u || u === `
` || u === "	" || u === " " || o && u === ",") || (a === " " || a === "	") && u === "#") break;
        l += 1, a = u;
      }
      return l;
    }
  }]), r;
}(De), op = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r() {
    return dt(this, r), t.call(this, xe.BLANK_LINE);
  }
  return _t(r, [{
    key: "includesTrailingLines",
    get: function() {
      return !0;
    }
    /**
     * Parses a blank line from the source
     *
     * @param {ParseContext} context
     * @param {number} start - Index of first \n character
     * @returns {number} - Index of the character after this
     */
  }, {
    key: "parse",
    value: function(i, s) {
      return this.context = i, this.range = new zt(s, s + 1), s + 1;
    }
  }]), r;
}(De), RS = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r(n, i) {
    var s;
    return dt(this, r), s = t.call(this, n, i), s.node = null, s;
  }
  return _t(r, [{
    key: "includesTrailingLines",
    get: function() {
      return !!this.node && this.node.includesTrailingLines;
    }
    /**
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this
     */
  }, {
    key: "parse",
    value: function(i, s) {
      this.context = i;
      var o = i.parseNode, a = i.src, l = i.atLineStart, u = i.lineStart;
      !l && this.type === xe.SEQ_ITEM && (this.error = new nt(this, "Sequence items must not have preceding content on the same line"));
      for (var f = l ? s - u : i.indent, d = De.endOfWhiteSpace(a, s + 1), m = a[d], v = m === "#", S = [], y = null; m === `
` || m === "#"; ) {
        if (m === "#") {
          var E = De.endOfLine(a, d + 1);
          S.push(new zt(d, E)), d = E;
        } else {
          l = !0, u = d + 1;
          var x = De.endOfWhiteSpace(a, u);
          a[x] === `
` && S.length === 0 && (y = new op(), u = y.parse({
            src: a
          }, u)), d = De.endOfIndent(a, u);
        }
        m = a[d];
      }
      if (De.nextNodeIsIndented(m, d - (u + f), this.type !== xe.SEQ_ITEM) ? this.node = o({
        atLineStart: l,
        inCollection: !1,
        indent: f,
        lineStart: u,
        parent: this
      }, d) : m && u > s + 1 && (d = u - 1), this.node) {
        if (y) {
          var g = i.parent.items || i.parent.contents;
          g && g.push(y);
        }
        S.length && Array.prototype.push.apply(this.props, S), d = this.node.range.end;
      } else if (v) {
        var b = S[0];
        this.props.push(b), d = b.end;
      } else
        d = De.endOfLine(a, s + 1);
      var A = this.node ? this.node.valueRange.end : d;
      return this.valueRange = new zt(s, A), d;
    }
  }, {
    key: "setOrigRanges",
    value: function(i, s) {
      return s = sn(Ar(r.prototype), "setOrigRanges", this).call(this, i, s), this.node ? this.node.setOrigRanges(i, s) : s;
    }
  }, {
    key: "toString",
    value: function() {
      var i = this.context.src, s = this.node, o = this.range, a = this.value;
      if (a != null) return a;
      var l = s ? i.slice(o.start, s.range.start) + String(s) : i.slice(o.start, o.end);
      return De.addStringTerminator(i, o.end, l);
    }
  }]), r;
}(De), Ic = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r() {
    return dt(this, r), t.call(this, xe.COMMENT);
  }
  return _t(r, [{
    key: "parse",
    value: function(i, s) {
      this.context = i;
      var o = this.parseComment(s);
      return this.range = new zt(s, o), o;
    }
  }]), r;
}(De);
function Y0(e) {
  for (var t = e; t instanceof RS; )
    t = t.node;
  if (!(t instanceof _I)) return null;
  for (var r = t.items.length, n = -1, i = r - 1; i >= 0; --i) {
    var s = t.items[i];
    if (s.type === xe.COMMENT) {
      var o = s.context, a = o.indent, l = o.lineStart;
      if (a > 0 && s.range.start >= l + a) break;
      n = i;
    } else if (s.type === xe.BLANK_LINE) n = i;
    else break;
  }
  if (n === -1) return null;
  for (var u = t.items.splice(n, r - n), f = u[0].range.start; t.range.end = f, t.valueRange && t.valueRange.end > f && (t.valueRange.end = f), t !== e; )
    t = t.context.parent;
  return u;
}
var _I = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r(n) {
    var i;
    dt(this, r), i = t.call(this, n.type === xe.SEQ_ITEM ? xe.SEQ : xe.MAP);
    for (var s = n.props.length - 1; s >= 0; --s)
      if (n.props[s].start < n.context.lineStart) {
        i.props = n.props.slice(0, s + 1), n.props = n.props.slice(s + 1);
        var o = n.props[0] || n.valueRange;
        n.range.start = o.start;
        break;
      }
    i.items = [n];
    var a = Y0(n);
    return a && Array.prototype.push.apply(i.items, a), i;
  }
  return _t(r, [{
    key: "includesTrailingLines",
    get: function() {
      return this.items.length > 0;
    }
    /**
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this
     */
  }, {
    key: "parse",
    value: function(i, s) {
      this.context = i;
      var o = i.parseNode, a = i.src, l = De.startOfLine(a, s), u = this.items[0];
      u.context.parent = this, this.valueRange = zt.copy(u.valueRange);
      var f = u.range.start - u.context.lineStart, d = s;
      d = De.normalizeOffset(a, d);
      for (var m = a[d], v = De.endOfWhiteSpace(a, l) === d, S = !1; m; ) {
        for (; m === `
` || m === "#"; ) {
          if (v && m === `
` && !S) {
            var y = new op();
            if (d = y.parse({
              src: a
            }, d), this.valueRange.end = d, d >= a.length) {
              m = null;
              break;
            }
            this.items.push(y), d -= 1;
          } else if (m === "#") {
            if (d < l + f && !r.nextContentHasIndent(a, d, f))
              return d;
            var E = new Ic();
            if (d = E.parse({
              indent: f,
              lineStart: l,
              src: a
            }, d), this.items.push(E), this.valueRange.end = d, d >= a.length) {
              m = null;
              break;
            }
          }
          if (l = d + 1, d = De.endOfIndent(a, l), De.atBlank(a, d)) {
            var x = De.endOfWhiteSpace(a, d), g = a[x];
            (!g || g === `
` || g === "#") && (d = x);
          }
          m = a[d], v = !0;
        }
        if (!m)
          break;
        if (d !== l + f && (v || m !== ":")) {
          if (d < l + f) {
            l > s && (d = l);
            break;
          } else if (!this.error) {
            var b = "All collection items must start at the same column";
            this.error = new jr(this, b);
          }
        }
        if (u.type === xe.SEQ_ITEM) {
          if (m !== "-") {
            l > s && (d = l);
            break;
          }
        } else if (m === "-" && !this.error) {
          var A = a[d + 1];
          if (!A || A === `
` || A === "	" || A === " ") {
            var P = "A collection cannot be both a mapping and a sequence";
            this.error = new jr(this, P);
          }
        }
        var k = o({
          atLineStart: v,
          inCollection: !0,
          indent: f,
          lineStart: l,
          parent: this
        }, d);
        if (!k) return d;
        if (this.items.push(k), this.valueRange.end = k.valueRange.end, d = De.normalizeOffset(a, k.range.end), m = a[d], v = !1, S = k.includesTrailingLines, m) {
          for (var $ = d - 1, I = a[$]; I === " " || I === "	"; )
            I = a[--$];
          I === `
` && (l = $ + 1, v = !0);
        }
        var F = Y0(k);
        F && Array.prototype.push.apply(this.items, F);
      }
      return d;
    }
  }, {
    key: "setOrigRanges",
    value: function(i, s) {
      return s = sn(Ar(r.prototype), "setOrigRanges", this).call(this, i, s), this.items.forEach(function(o) {
        s = o.setOrigRanges(i, s);
      }), s;
    }
  }, {
    key: "toString",
    value: function() {
      var i = this.context.src, s = this.items, o = this.range, a = this.value;
      if (a != null) return a;
      for (var l = i.slice(o.start, s[0].range.start) + String(s[0]), u = 1; u < s.length; ++u) {
        var f = s[u], d = f.context, m = d.atLineStart, v = d.indent;
        if (m) for (var S = 0; S < v; ++S)
          l += " ";
        l += String(f);
      }
      return De.addStringTerminator(i, o.end, l);
    }
  }], [{
    key: "nextContentHasIndent",
    value: function(i, s, o) {
      var a = De.endOfLine(i, s) + 1;
      s = De.endOfWhiteSpace(i, a);
      var l = i[s];
      return l ? s >= a + o ? !0 : l !== "#" && l !== `
` ? !1 : r.nextContentHasIndent(i, s, o) : !1;
    }
  }]), r;
}(De), X3 = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r() {
    var n;
    return dt(this, r), n = t.call(this, xe.DIRECTIVE), n.name = null, n;
  }
  return _t(r, [{
    key: "parameters",
    get: function() {
      var i = this.rawValue;
      return i ? i.trim().split(/[ \t]+/) : [];
    }
  }, {
    key: "parseName",
    value: function(i) {
      for (var s = this.context.src, o = i, a = s[o]; a && a !== `
` && a !== "	" && a !== " "; )
        a = s[o += 1];
      return this.name = s.slice(i, o), o;
    }
  }, {
    key: "parseParameters",
    value: function(i) {
      for (var s = this.context.src, o = i, a = s[o]; a && a !== `
` && a !== "#"; )
        a = s[o += 1];
      return this.valueRange = new zt(i, o), o;
    }
  }, {
    key: "parse",
    value: function(i, s) {
      this.context = i;
      var o = this.parseName(s + 1);
      return o = this.parseParameters(o), o = this.parseComment(o), this.range = new zt(s, o), o;
    }
  }]), r;
}(De), J3 = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r() {
    var n;
    return dt(this, r), n = t.call(this, xe.DOCUMENT), n.directives = null, n.contents = null, n.directivesEndMarker = null, n.documentEndMarker = null, n;
  }
  return _t(r, [{
    key: "parseDirectives",
    value: function(i) {
      var s = this.context.src;
      this.directives = [];
      for (var o = !0, a = !1, l = i; !De.atDocumentBoundary(s, l, nr.DIRECTIVES_END); )
        switch (l = r.startCommentOrEndBlankLine(s, l), s[l]) {
          case `
`:
            if (o) {
              var u = new op();
              l = u.parse({
                src: s
              }, l), l < s.length && this.directives.push(u);
            } else
              l += 1, o = !0;
            break;
          case "#":
            {
              var f = new Ic();
              l = f.parse({
                src: s
              }, l), this.directives.push(f), o = !1;
            }
            break;
          case "%":
            {
              var d = new X3();
              l = d.parse({
                parent: this,
                src: s
              }, l), this.directives.push(d), a = !0, o = !1;
            }
            break;
          default:
            return a ? this.error = new nt(this, "Missing directives-end indicator line") : this.directives.length > 0 && (this.contents = this.directives, this.directives = []), l;
        }
      return s[l] ? (this.directivesEndMarker = new zt(l, l + 3), l + 3) : (a ? this.error = new nt(this, "Missing directives-end indicator line") : this.directives.length > 0 && (this.contents = this.directives, this.directives = []), l);
    }
  }, {
    key: "parseContents",
    value: function(i) {
      var s = this.context, o = s.parseNode, a = s.src;
      this.contents || (this.contents = []);
      for (var l = i; a[l - 1] === "-"; )
        l -= 1;
      var u = De.endOfWhiteSpace(a, i), f = l === i;
      for (this.valueRange = new zt(u); !De.atDocumentBoundary(a, u, nr.DOCUMENT_END); ) {
        switch (a[u]) {
          case `
`:
            if (f) {
              var d = new op();
              u = d.parse({
                src: a
              }, u), u < a.length && this.contents.push(d);
            } else
              u += 1, f = !0;
            l = u;
            break;
          case "#":
            {
              var m = new Ic();
              u = m.parse({
                src: a
              }, u), this.contents.push(m), f = !1;
            }
            break;
          default: {
            var v = De.endOfIndent(a, u), S = {
              atLineStart: f,
              indent: -1,
              inFlow: !1,
              inCollection: !1,
              lineStart: l,
              parent: this
            }, y = o(S, v);
            if (!y) return this.valueRange.end = v;
            this.contents.push(y), u = y.range.end, f = !1;
            var E = Y0(y);
            E && Array.prototype.push.apply(this.contents, E);
          }
        }
        u = r.startCommentOrEndBlankLine(a, u);
      }
      if (this.valueRange.end = u, a[u] && (this.documentEndMarker = new zt(u, u + 3), u += 3, a[u])) {
        if (u = De.endOfWhiteSpace(a, u), a[u] === "#") {
          var x = new Ic();
          u = x.parse({
            src: a
          }, u), this.contents.push(x);
        }
        switch (a[u]) {
          case `
`:
            u += 1;
            break;
          case void 0:
            break;
          default:
            this.error = new jr(this, "Document end marker line cannot have a non-comment suffix");
        }
      }
      return u;
    }
    /**
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this
     */
  }, {
    key: "parse",
    value: function(i, s) {
      i.root = this, this.context = i;
      var o = i.src, a = o.charCodeAt(s) === 65279 ? s + 1 : s;
      return a = this.parseDirectives(a), a = this.parseContents(a), a;
    }
  }, {
    key: "setOrigRanges",
    value: function(i, s) {
      return s = sn(Ar(r.prototype), "setOrigRanges", this).call(this, i, s), this.directives.forEach(function(o) {
        s = o.setOrigRanges(i, s);
      }), this.directivesEndMarker && (s = this.directivesEndMarker.setOrigRange(i, s)), this.contents.forEach(function(o) {
        s = o.setOrigRanges(i, s);
      }), this.documentEndMarker && (s = this.documentEndMarker.setOrigRange(i, s)), s;
    }
  }, {
    key: "toString",
    value: function() {
      var i = this.contents, s = this.directives, o = this.value;
      if (o != null) return o;
      var a = s.join("");
      return i.length > 0 && ((s.length > 0 || i[0].type === xe.COMMENT) && (a += `---
`), a += i.join("")), a[a.length - 1] !== `
` && (a += `
`), a;
    }
  }], [{
    key: "startCommentOrEndBlankLine",
    value: function(i, s) {
      var o = De.endOfWhiteSpace(i, s), a = i[o];
      return a === "#" || a === `
` ? o : s;
    }
  }]), r;
}(De), Z3 = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r() {
    return dt(this, r), t.apply(this, arguments);
  }
  return _t(r, [{
    key: "parse",
    value: (
      /**
       * Parses an *alias from the source
       *
       * @param {ParseContext} context
       * @param {number} start - Index of first character
       * @returns {number} - Index of the character after this scalar
       */
      function(i, s) {
        this.context = i;
        var o = i.src, a = De.endOfIdentifier(o, s + 1);
        return this.valueRange = new zt(s + 1, a), a = De.endOfWhiteSpace(o, a), a = this.parseComment(a), a;
      }
    )
  }]), r;
}(De), Lo = {
  CLIP: "CLIP",
  KEEP: "KEEP",
  STRIP: "STRIP"
}, eU = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r(n, i) {
    var s;
    return dt(this, r), s = t.call(this, n, i), s.blockIndent = null, s.chomping = Lo.CLIP, s.header = null, s;
  }
  return _t(r, [{
    key: "includesTrailingLines",
    get: function() {
      return this.chomping === Lo.KEEP;
    }
  }, {
    key: "strValue",
    get: function() {
      if (!this.valueRange || !this.context) return null;
      var i = this.valueRange, s = i.start, o = i.end, a = this.context, l = a.indent, u = a.src;
      if (this.valueRange.isEmpty()) return "";
      for (var f = null, d = u[o - 1]; d === `
` || d === "	" || d === " "; ) {
        if (o -= 1, o <= s) {
          if (this.chomping === Lo.KEEP) break;
          return "";
        }
        d === `
` && (f = o), d = u[o - 1];
      }
      var m = o + 1;
      f && (this.chomping === Lo.KEEP ? (m = f, o = this.valueRange.end) : o = f);
      for (var v = l + this.blockIndent, S = this.type === xe.BLOCK_FOLDED, y = !0, E = "", x = "", g = !1, b = s; b < o; ++b) {
        for (var A = 0; A < v && u[b] === " "; ++A)
          b += 1;
        var P = u[b];
        if (P === `
`)
          x === `
` ? E += `
` : x = `
`;
        else {
          var k = De.endOfLine(u, b), $ = u.slice(b, k);
          b = k, S && (P === " " || P === "	") && b < m ? (x === " " ? x = `
` : !g && !y && x === `
` && (x = `

`), E += x + $, x = k < o && u[k] || "", g = !0) : (E += x + $, x = S && b < m ? " " : `
`, g = !1), y && $ !== "" && (y = !1);
        }
      }
      return this.chomping === Lo.STRIP ? E : E + `
`;
    }
  }, {
    key: "parseBlockHeader",
    value: function(i) {
      for (var s = this.context.src, o = i + 1, a = ""; ; ) {
        var l = s[o];
        switch (l) {
          case "-":
            this.chomping = Lo.STRIP;
            break;
          case "+":
            this.chomping = Lo.KEEP;
            break;
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            a += l;
            break;
          default:
            return this.blockIndent = Number(a) || null, this.header = new zt(i, o), o;
        }
        o += 1;
      }
    }
  }, {
    key: "parseBlockValue",
    value: function(i) {
      for (var s = this.context, o = s.indent, a = s.src, l = !!this.blockIndent, u = i, f = i, d = 1, m = a[u]; m === `
` && (u += 1, !De.atDocumentBoundary(a, u)); m = a[u]) {
        var v = De.endOfBlockIndent(a, o, u);
        if (v === null) break;
        var S = a[v], y = v - (u + o);
        if (this.blockIndent) {
          if (S && S !== `
` && y < this.blockIndent) {
            if (a[v] === "#") break;
            if (!this.error) {
              var x = l ? "explicit indentation indicator" : "first line", g = "Block scalars must not be less indented than their ".concat(x);
              this.error = new nt(this, g);
            }
          }
        } else if (a[v] !== `
`) {
          if (y < d) {
            var E = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
            this.error = new nt(this, E);
          }
          this.blockIndent = y;
        } else y > d && (d = y);
        a[v] === `
` ? u = v : u = f = De.endOfLine(a, v);
      }
      return this.chomping !== Lo.KEEP && (u = a[f] ? f + 1 : f), this.valueRange = new zt(i + 1, u), u;
    }
    /**
     * Parses a block value from the source
     *
     * Accepted forms are:
     * ```
     * BS
     * block
     * lines
     *
     * BS #comment
     * block
     * lines
     * ```
     * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines
     * are empty or have an indent level greater than `indent`.
     *
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this block
     */
  }, {
    key: "parse",
    value: function(i, s) {
      this.context = i;
      var o = i.src, a = this.parseBlockHeader(s);
      return a = De.endOfWhiteSpace(o, a), a = this.parseComment(a), a = this.parseBlockValue(a), a;
    }
  }, {
    key: "setOrigRanges",
    value: function(i, s) {
      return s = sn(Ar(r.prototype), "setOrigRanges", this).call(this, i, s), this.header ? this.header.setOrigRange(i, s) : s;
    }
  }]), r;
}(De), tU = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r(n, i) {
    var s;
    return dt(this, r), s = t.call(this, n, i), s.items = null, s;
  }
  return _t(r, [{
    key: "prevNodeIsJsonLike",
    value: function() {
      var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.items.length, s = this.items[i - 1];
      return !!s && (s.jsonLike || s.type === xe.COMMENT && this.prevNodeIsJsonLike(i - 1));
    }
    /**
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this
     */
  }, {
    key: "parse",
    value: function(i, s) {
      this.context = i;
      var o = i.parseNode, a = i.src, l = i.indent, u = i.lineStart, f = a[s];
      this.items = [{
        char: f,
        offset: s
      }];
      var d = De.endOfWhiteSpace(a, s + 1);
      for (f = a[d]; f && f !== "]" && f !== "}"; ) {
        switch (f) {
          case `
`:
            {
              u = d + 1;
              var m = De.endOfWhiteSpace(a, u);
              if (a[m] === `
`) {
                var v = new op();
                u = v.parse({
                  src: a
                }, u), this.items.push(v);
              }
              if (d = De.endOfIndent(a, u), d <= u + l && (f = a[d], d < u + l || f !== "]" && f !== "}")) {
                var S = "Insufficient indentation in flow collection";
                this.error = new nt(this, S);
              }
            }
            break;
          case ",":
            this.items.push({
              char: f,
              offset: d
            }), d += 1;
            break;
          case "#":
            {
              var y = new Ic();
              d = y.parse({
                src: a
              }, d), this.items.push(y);
            }
            break;
          case "?":
          case ":": {
            var E = a[d + 1];
            if (E === `
` || E === "	" || E === " " || E === "," || // in-flow : after JSON-like key does not need to be followed by whitespace
            f === ":" && this.prevNodeIsJsonLike()) {
              this.items.push({
                char: f,
                offset: d
              }), d += 1;
              break;
            }
          }
          default: {
            var x = o({
              atLineStart: !1,
              inCollection: !1,
              inFlow: !0,
              indent: -1,
              lineStart: u,
              parent: this
            }, d);
            if (!x)
              return this.valueRange = new zt(s, d), d;
            this.items.push(x), d = De.normalizeOffset(a, x.range.end);
          }
        }
        d = De.endOfWhiteSpace(a, d), f = a[d];
      }
      return this.valueRange = new zt(s, d + 1), f && (this.items.push({
        char: f,
        offset: d
      }), d = De.endOfWhiteSpace(a, d + 1), d = this.parseComment(d)), d;
    }
  }, {
    key: "setOrigRanges",
    value: function(i, s) {
      return s = sn(Ar(r.prototype), "setOrigRanges", this).call(this, i, s), this.items.forEach(function(o) {
        if (o instanceof De)
          s = o.setOrigRanges(i, s);
        else if (i.length === 0)
          o.origOffset = o.offset;
        else {
          for (var a = s; a < i.length && !(i[a] > o.offset); )
            ++a;
          o.origOffset = o.offset + a, s = a;
        }
      }), s;
    }
  }, {
    key: "toString",
    value: function() {
      var i = this.context.src, s = this.items, o = this.range, a = this.value;
      if (a != null) return a;
      var l = s.filter(function(d) {
        return d instanceof De;
      }), u = "", f = o.start;
      return l.forEach(function(d) {
        var m = i.slice(f, d.range.start);
        f = d.range.end, u += m + String(d), u[u.length - 1] === `
` && i[f - 1] !== `
` && i[f] === `
` && (f += 1);
      }), u += i.slice(f, o.end), De.addStringTerminator(i, o.end, u);
    }
  }]), r;
}(De), rU = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r() {
    return dt(this, r), t.apply(this, arguments);
  }
  return _t(r, [{
    key: "strValue",
    get: (
      /**
       * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
       */
      function() {
        if (!this.valueRange || !this.context) return null;
        var i = [], s = this.valueRange, o = s.start, a = s.end, l = this.context, u = l.indent, f = l.src;
        f[a - 1] !== '"' && i.push(new jr(this, 'Missing closing "quote'));
        for (var d = "", m = o + 1; m < a - 1; ++m) {
          var v = f[m];
          if (v === `
`) {
            De.atDocumentBoundary(f, m + 1) && i.push(new nt(this, "Document boundary indicators are not allowed within string values"));
            var S = De.foldNewline(f, m, u), y = S.fold, E = S.offset, x = S.error;
            d += y, m = E, x && i.push(new nt(this, "Multi-line double-quoted string needs to be sufficiently indented"));
          } else if (v === "\\")
            switch (m += 1, f[m]) {
              case "0":
                d += "\0";
                break;
              case "a":
                d += "\x07";
                break;
              case "b":
                d += "\b";
                break;
              case "e":
                d += "\x1B";
                break;
              case "f":
                d += "\f";
                break;
              case "n":
                d += `
`;
                break;
              case "r":
                d += "\r";
                break;
              case "t":
                d += "	";
                break;
              case "v":
                d += "\v";
                break;
              case "N":
                d += "";
                break;
              case "_":
                d += "";
                break;
              case "L":
                d += "\u2028";
                break;
              case "P":
                d += "\u2029";
                break;
              case " ":
                d += " ";
                break;
              case '"':
                d += '"';
                break;
              case "/":
                d += "/";
                break;
              case "\\":
                d += "\\";
                break;
              case "	":
                d += "	";
                break;
              case "x":
                d += this.parseCharCode(m + 1, 2, i), m += 2;
                break;
              case "u":
                d += this.parseCharCode(m + 1, 4, i), m += 4;
                break;
              case "U":
                d += this.parseCharCode(m + 1, 8, i), m += 8;
                break;
              case `
`:
                for (; f[m + 1] === " " || f[m + 1] === "	"; )
                  m += 1;
                break;
              default:
                i.push(new jr(this, "Invalid escape sequence ".concat(f.substr(m - 1, 2)))), d += "\\" + f[m];
            }
          else if (v === " " || v === "	") {
            for (var g = m, b = f[m + 1]; b === " " || b === "	"; )
              m += 1, b = f[m + 1];
            b !== `
` && (d += m > g ? f.slice(g, m + 1) : v);
          } else
            d += v;
        }
        return i.length > 0 ? {
          errors: i,
          str: d
        } : d;
      }
    )
  }, {
    key: "parseCharCode",
    value: function(i, s, o) {
      var a = this.context.src, l = a.substr(i, s), u = l.length === s && /^[0-9a-fA-F]+$/.test(l), f = u ? parseInt(l, 16) : NaN;
      return isNaN(f) ? (o.push(new jr(this, "Invalid escape sequence ".concat(a.substr(i - 2, s + 2)))), a.substr(i - 2, s + 2)) : String.fromCodePoint(f);
    }
    /**
     * Parses a "double quoted" value from the source
     *
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this scalar
     */
  }, {
    key: "parse",
    value: function(i, s) {
      this.context = i;
      var o = i.src, a = r.endOfQuote(o, s + 1);
      return this.valueRange = new zt(s, a), a = De.endOfWhiteSpace(o, a), a = this.parseComment(a), a;
    }
  }], [{
    key: "endOfQuote",
    value: function(i, s) {
      for (var o = i[s]; o && o !== '"'; )
        s += o === "\\" ? 2 : 1, o = i[s];
      return s + 1;
    }
  }]), r;
}(De), nU = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r() {
    return dt(this, r), t.apply(this, arguments);
  }
  return _t(r, [{
    key: "strValue",
    get: (
      /**
       * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
       */
      function() {
        if (!this.valueRange || !this.context) return null;
        var i = [], s = this.valueRange, o = s.start, a = s.end, l = this.context, u = l.indent, f = l.src;
        f[a - 1] !== "'" && i.push(new jr(this, "Missing closing 'quote"));
        for (var d = "", m = o + 1; m < a - 1; ++m) {
          var v = f[m];
          if (v === `
`) {
            De.atDocumentBoundary(f, m + 1) && i.push(new nt(this, "Document boundary indicators are not allowed within string values"));
            var S = De.foldNewline(f, m, u), y = S.fold, E = S.offset, x = S.error;
            d += y, m = E, x && i.push(new nt(this, "Multi-line single-quoted string needs to be sufficiently indented"));
          } else if (v === "'")
            d += v, m += 1, f[m] !== "'" && i.push(new jr(this, "Unescaped single quote? This should not happen."));
          else if (v === " " || v === "	") {
            for (var g = m, b = f[m + 1]; b === " " || b === "	"; )
              m += 1, b = f[m + 1];
            b !== `
` && (d += m > g ? f.slice(g, m + 1) : v);
          } else
            d += v;
        }
        return i.length > 0 ? {
          errors: i,
          str: d
        } : d;
      }
    )
    /**
     * Parses a 'single quoted' value from the source
     *
     * @param {ParseContext} context
     * @param {number} start - Index of first character
     * @returns {number} - Index of the character after this scalar
     */
  }, {
    key: "parse",
    value: function(i, s) {
      this.context = i;
      var o = i.src, a = r.endOfQuote(o, s + 1);
      return this.valueRange = new zt(s, a), a = De.endOfWhiteSpace(o, a), a = this.parseComment(a), a;
    }
  }], [{
    key: "endOfQuote",
    value: function(i, s) {
      for (var o = i[s]; o; )
        if (o === "'") {
          if (i[s + 1] !== "'") break;
          o = i[s += 2];
        } else
          o = i[s += 1];
      return s + 1;
    }
  }]), r;
}(De);
function iU(e, t) {
  switch (e) {
    case xe.ALIAS:
      return new Z3(e, t);
    case xe.BLOCK_FOLDED:
    case xe.BLOCK_LITERAL:
      return new eU(e, t);
    case xe.FLOW_MAP:
    case xe.FLOW_SEQ:
      return new tU(e, t);
    case xe.MAP_KEY:
    case xe.MAP_VALUE:
    case xe.SEQ_ITEM:
      return new RS(e, t);
    case xe.COMMENT:
    case xe.PLAIN:
      return new EI(e, t);
    case xe.QUOTE_DOUBLE:
      return new rU(e, t);
    case xe.QUOTE_SINGLE:
      return new nU(e, t);
    default:
      return null;
  }
}
var oU = /* @__PURE__ */ function() {
  function e() {
    var t = this, r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = n.atLineStart, s = n.inCollection, o = n.inFlow, a = n.indent, l = n.lineStart, u = n.parent;
    dt(this, e), Nr(this, "parseNode", function(f, d) {
      if (De.atDocumentBoundary(t.src, d)) return null;
      var m = new e(t, f), v = m.parseProps(d), S = v.props, y = v.type, E = v.valueStart, x = iU(y, S), g = x.parse(m, E);
      if (x.range = new zt(d, g), g <= d && (x.error = new Error("Node#parse consumed no characters"), x.error.parseEnd = g, x.error.source = x, x.range.end = d + 1), m.nodeStartsCollection(x)) {
        !x.error && !m.atLineStart && m.parent.type === xe.DOCUMENT && (x.error = new jr(x, "Block collection must not have preceding content here (e.g. directives-end indicator)"));
        var b = new _I(x);
        return g = b.parse(new e(m), g), b.range = new zt(d, g), b;
      }
      return x;
    }), this.atLineStart = i ?? (r.atLineStart || !1), this.inCollection = s ?? (r.inCollection || !1), this.inFlow = o ?? (r.inFlow || !1), this.indent = a ?? r.indent, this.lineStart = l ?? r.lineStart, this.parent = u ?? (r.parent || {}), this.root = r.root, this.src = r.src;
  }
  return _t(e, [{
    key: "nodeStartsCollection",
    value: function(r) {
      var n = this.inCollection, i = this.inFlow, s = this.src;
      if (n || i) return !1;
      if (r instanceof RS) return !0;
      var o = r.range.end;
      return s[o] === `
` || s[o - 1] === `
` ? !1 : (o = De.endOfWhiteSpace(s, o), s[o] === ":");
    }
    // Anchor and tag are before type, which determines the node implementation
    // class; hence this intermediate step.
  }, {
    key: "parseProps",
    value: function(r) {
      var n = this.inFlow, i = this.parent, s = this.src, o = [], a = !1;
      r = this.atLineStart ? De.endOfIndent(s, r) : De.endOfWhiteSpace(s, r);
      for (var l = s[r]; l === nr.ANCHOR || l === nr.COMMENT || l === nr.TAG || l === `
`; ) {
        if (l === `
`) {
          var u = r, f = void 0;
          do
            f = u + 1, u = De.endOfIndent(s, f);
          while (s[u] === `
`);
          var d = u - (f + this.indent), m = i.type === xe.SEQ_ITEM && i.context.atLineStart;
          if (s[u] !== "#" && !De.nextNodeIsIndented(s[u], d, !m)) break;
          this.atLineStart = !0, this.lineStart = f, a = !1, r = u;
        } else if (l === nr.COMMENT) {
          var v = De.endOfLine(s, r + 1);
          o.push(new zt(r, v)), r = v;
        } else {
          var S = De.endOfIdentifier(s, r + 1);
          l === nr.TAG && s[S] === "," && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(s.slice(r + 1, S + 13)) && (S = De.endOfIdentifier(s, S + 5)), o.push(new zt(r, S)), a = !0, r = De.endOfWhiteSpace(s, S);
        }
        l = s[r];
      }
      a && l === ":" && De.atBlank(s, r + 1, !0) && (r -= 1);
      var y = e.parseType(s, r, n);
      return {
        props: o,
        type: y,
        valueStart: r
      };
    }
    /**
     * Parses a node from the source
     * @param {ParseContext} overlay
     * @param {number} start - Index of first non-whitespace character for the node
     * @returns {?Node} - null if at a document boundary
     */
  }], [{
    key: "parseType",
    value: function(r, n, i) {
      switch (r[n]) {
        case "*":
          return xe.ALIAS;
        case ">":
          return xe.BLOCK_FOLDED;
        case "|":
          return xe.BLOCK_LITERAL;
        case "{":
          return xe.FLOW_MAP;
        case "[":
          return xe.FLOW_SEQ;
        case "?":
          return !i && De.atBlank(r, n + 1, !0) ? xe.MAP_KEY : xe.PLAIN;
        case ":":
          return !i && De.atBlank(r, n + 1, !0) ? xe.MAP_VALUE : xe.PLAIN;
        case "-":
          return !i && De.atBlank(r, n + 1, !0) ? xe.SEQ_ITEM : xe.PLAIN;
        case '"':
          return xe.QUOTE_DOUBLE;
        case "'":
          return xe.QUOTE_SINGLE;
        default:
          return xe.PLAIN;
      }
    }
  }]), e;
}();
function IS(e) {
  var t = [];
  e.indexOf("\r") !== -1 && (e = e.replace(/\r\n?/g, function(o, a) {
    return o.length > 1 && t.push(a), `
`;
  }));
  var r = [], n = 0;
  do {
    var i = new J3(), s = new oU({
      src: e
    });
    n = i.parse(s, n), r.push(i);
  } while (n < e.length);
  return r.setOrigRanges = function() {
    if (t.length === 0) return !1;
    for (var o = 1; o < t.length; ++o)
      t[o] -= o;
    for (var a = 0, l = 0; l < r.length; ++l)
      a = r[l].setOrigRanges(t, a);
    return t.splice(0, t.length), !0;
  }, r.toString = function() {
    return r.join(`...
`);
  }, r;
}
function sU(e, t, r) {
  if (!r) return e;
  var n = r.replace(/[\s\S]^/gm, "$&".concat(t, "#"));
  return "#".concat(n, `
`).concat(t).concat(e);
}
function bl(e, t, r) {
  return r ? r.indexOf(`
`) === -1 ? "".concat(e, " #").concat(r) : "".concat(e, `
`) + r.replace(/^/gm, "".concat(t || "", "#")) : e;
}
var Kr = function e() {
  dt(this, e);
};
function ri(e, t, r) {
  if (Array.isArray(e)) return e.map(function(s, o) {
    return ri(s, String(o), r);
  });
  if (e && typeof e.toJSON == "function") {
    var n = r && r.anchors && r.anchors.get(e);
    n && (r.onCreate = function(s) {
      n.res = s, delete r.onCreate;
    });
    var i = e.toJSON(t, r);
    return n && r.onCreate && r.onCreate(i), i;
  }
  return (!r || !r.keep) && typeof e == "bigint" ? Number(e) : e;
}
var Et = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r(n) {
    var i;
    return dt(this, r), i = t.call(this), i.value = n, i;
  }
  return _t(r, [{
    key: "toJSON",
    value: function(i, s) {
      return s && s.keep ? this.value : ri(this.value, i, s);
    }
  }, {
    key: "toString",
    value: function() {
      return String(this.value);
    }
  }]), r;
}(Kr);
function BO(e, t, r) {
  for (var n = r, i = t.length - 1; i >= 0; --i) {
    var s = t[i];
    if (Number.isInteger(s) && s >= 0) {
      var o = [];
      o[s] = n, n = o;
    } else {
      var a = {};
      Object.defineProperty(a, s, {
        value: n,
        writable: !0,
        enumerable: !0,
        configurable: !0
      }), n = a;
    }
  }
  return e.createNode(n, !1);
}
var bc = function(t) {
  return t == null || mn(t) === "object" && t[Symbol.iterator]().next().done;
}, Er = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r(n) {
    var i;
    return dt(this, r), i = t.call(this), Nr(kn(i), "items", []), i.schema = n, i;
  }
  return _t(r, [{
    key: "addIn",
    value: function(i, s) {
      if (bc(i)) this.add(s);
      else {
        var o = Gu(i), a = o[0], l = o.slice(1), u = this.get(a, !0);
        if (u instanceof r) u.addIn(l, s);
        else if (u === void 0 && this.schema) this.set(a, BO(this.schema, l, s));
        else throw new Error("Expected YAML collection at ".concat(a, ". Remaining path: ").concat(l));
      }
    }
  }, {
    key: "deleteIn",
    value: function(i) {
      var s = Gu(i), o = s[0], a = s.slice(1);
      if (a.length === 0) return this.delete(o);
      var l = this.get(o, !0);
      if (l instanceof r) return l.deleteIn(a);
      throw new Error("Expected YAML collection at ".concat(o, ". Remaining path: ").concat(a));
    }
  }, {
    key: "getIn",
    value: function(i, s) {
      var o = Gu(i), a = o[0], l = o.slice(1), u = this.get(a, !0);
      return l.length === 0 ? !s && u instanceof Et ? u.value : u : u instanceof r ? u.getIn(l, s) : void 0;
    }
  }, {
    key: "hasAllNullValues",
    value: function() {
      return this.items.every(function(i) {
        if (!i || i.type !== "PAIR") return !1;
        var s = i.value;
        return s == null || s instanceof Et && s.value == null && !s.commentBefore && !s.comment && !s.tag;
      });
    }
  }, {
    key: "hasIn",
    value: function(i) {
      var s = Gu(i), o = s[0], a = s.slice(1);
      if (a.length === 0) return this.has(o);
      var l = this.get(o, !0);
      return l instanceof r ? l.hasIn(a) : !1;
    }
  }, {
    key: "setIn",
    value: function(i, s) {
      var o = Gu(i), a = o[0], l = o.slice(1);
      if (l.length === 0)
        this.set(a, s);
      else {
        var u = this.get(a, !0);
        if (u instanceof r) u.setIn(l, s);
        else if (u === void 0 && this.schema) this.set(a, BO(this.schema, l, s));
        else throw new Error("Expected YAML collection at ".concat(a, ". Remaining path: ").concat(l));
      }
    }
    // overridden in implementations
    /* istanbul ignore next */
  }, {
    key: "toJSON",
    value: function() {
      return null;
    }
  }, {
    key: "toString",
    value: function(i, s, o, a) {
      var l = this, u = s.blockItem, f = s.flowChars, d = s.isMap, m = s.itemIndent, v = i, S = v.indent, y = v.indentStep, E = v.stringify, x = this.type === xe.FLOW_MAP || this.type === xe.FLOW_SEQ || i.inFlow;
      x && (m += y);
      var g = d && this.hasAllNullValues();
      i = Object.assign({}, i, {
        allNullValues: g,
        indent: m,
        inFlow: x,
        type: null
      });
      var b = !1, A = !1, P = this.items.reduce(function(be, G, ee) {
        var K;
        G && (!b && G.spaceBefore && be.push({
          type: "comment",
          str: ""
        }), G.commentBefore && G.commentBefore.match(/^.*$/gm).forEach(function(te) {
          be.push({
            type: "comment",
            str: "#".concat(te)
          });
        }), G.comment && (K = G.comment), x && (!b && G.spaceBefore || G.commentBefore || G.comment || G.key && (G.key.commentBefore || G.key.comment) || G.value && (G.value.commentBefore || G.value.comment)) && (A = !0)), b = !1;
        var z = E(G, i, function() {
          return K = null;
        }, function() {
          return b = !0;
        });
        return x && !A && z.includes(`
`) && (A = !0), x && ee < l.items.length - 1 && (z += ","), z = bl(z, m, K), b && (K || x) && (b = !1), be.push({
          type: "item",
          str: z
        }), be;
      }, []), k;
      if (P.length === 0)
        k = f.start + f.end;
      else if (x) {
        var $ = f.start, I = f.end, F = P.map(function(be) {
          return be.str;
        });
        if (A || F.reduce(function(be, G) {
          return be + G.length + 2;
        }, 2) > r.maxFlowStringSingleLineLength) {
          k = $;
          var L = Tt(F), Q;
          try {
            for (L.s(); !(Q = L.n()).done; ) {
              var Y = Q.value;
              k += Y ? `
`.concat(y).concat(S).concat(Y) : `
`;
            }
          } catch (be) {
            L.e(be);
          } finally {
            L.f();
          }
          k += `
`.concat(S).concat(I);
        } else
          k = "".concat($, " ").concat(F.join(" "), " ").concat(I);
      } else {
        var ae = P.map(u);
        k = ae.shift();
        var le = Tt(ae), ue;
        try {
          for (le.s(); !(ue = le.n()).done; ) {
            var ce = ue.value;
            k += ce ? `
`.concat(S).concat(ce) : `
`;
          }
        } catch (be) {
          le.e(be);
        } finally {
          le.f();
        }
      }
      return this.comment ? (k += `
` + this.comment.replace(/^/gm, "".concat(S, "#")), o && o()) : b && a && a(), k;
    }
  }]), r;
}(Kr);
Nr(Er, "maxFlowStringSingleLineLength", 60);
function cd(e) {
  var t = e instanceof Et ? e.value : e;
  return t && typeof t == "string" && (t = Number(t)), Number.isInteger(t) && t >= 0 ? t : null;
}
var Ii = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r() {
    return dt(this, r), t.apply(this, arguments);
  }
  return _t(r, [{
    key: "add",
    value: function(i) {
      this.items.push(i);
    }
  }, {
    key: "delete",
    value: function(i) {
      var s = cd(i);
      if (typeof s != "number") return !1;
      var o = this.items.splice(s, 1);
      return o.length > 0;
    }
  }, {
    key: "get",
    value: function(i, s) {
      var o = cd(i);
      if (typeof o == "number") {
        var a = this.items[o];
        return !s && a instanceof Et ? a.value : a;
      }
    }
  }, {
    key: "has",
    value: function(i) {
      var s = cd(i);
      return typeof s == "number" && s < this.items.length;
    }
  }, {
    key: "set",
    value: function(i, s) {
      var o = cd(i);
      if (typeof o != "number") throw new Error("Expected a valid index, not ".concat(i, "."));
      this.items[o] = s;
    }
  }, {
    key: "toJSON",
    value: function(i, s) {
      var o = [];
      s && s.onCreate && s.onCreate(o);
      var a = 0, l = Tt(this.items), u;
      try {
        for (l.s(); !(u = l.n()).done; ) {
          var f = u.value;
          o.push(ri(f, String(a++), s));
        }
      } catch (d) {
        l.e(d);
      } finally {
        l.f();
      }
      return o;
    }
  }, {
    key: "toString",
    value: function(i, s, o) {
      return i ? sn(Ar(r.prototype), "toString", this).call(this, i, {
        blockItem: function(l) {
          return l.type === "comment" ? l.str : "- ".concat(l.str);
        },
        flowChars: {
          start: "[",
          end: "]"
        },
        isMap: !1,
        itemIndent: (i.indent || "") + "  "
      }, s, o) : JSON.stringify(this);
    }
  }]), r;
}(Er), aU = function(t, r, n) {
  return r === null ? "" : mn(r) !== "object" ? String(r) : t instanceof Kr && n && n.doc ? t.toString({
    anchors: /* @__PURE__ */ Object.create(null),
    doc: n.doc,
    indent: "",
    indentStep: n.indentStep,
    inFlow: !0,
    inStringifyKey: !0,
    stringify: n.stringify
  }) : JSON.stringify(r);
}, pt = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r(n) {
    var i, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    return dt(this, r), i = t.call(this), i.key = n, i.value = s, i.type = r.Type.PAIR, i;
  }
  return _t(r, [{
    key: "commentBefore",
    get: function() {
      return this.key instanceof Kr ? this.key.commentBefore : void 0;
    },
    set: function(i) {
      if (this.key == null && (this.key = new Et(null)), this.key instanceof Kr) this.key.commentBefore = i;
      else {
        var s = "Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.";
        throw new Error(s);
      }
    }
  }, {
    key: "addToJSMap",
    value: function(i, s) {
      var o = ri(this.key, "", i);
      if (s instanceof Map) {
        var a = ri(this.value, o, i);
        s.set(o, a);
      } else if (s instanceof Set)
        s.add(o);
      else {
        var l = aU(this.key, o, i), u = ri(this.value, l, i);
        l in s ? Object.defineProperty(s, l, {
          value: u,
          writable: !0,
          enumerable: !0,
          configurable: !0
        }) : s[l] = u;
      }
      return s;
    }
  }, {
    key: "toJSON",
    value: function(i, s) {
      var o = s && s.mapAsMap ? /* @__PURE__ */ new Map() : {};
      return this.addToJSMap(s, o);
    }
  }, {
    key: "toString",
    value: function(i, s, o) {
      if (!i || !i.doc) return JSON.stringify(this);
      var a = i.doc.options, l = a.indent, u = a.indentSeq, f = a.simpleKeys, d = this.key, m = this.value, v = d instanceof Kr && d.comment;
      if (f) {
        if (v)
          throw new Error("With simple keys, key nodes cannot have comments");
        if (d instanceof Er) {
          var S = "With simple keys, collection cannot be used as a key value";
          throw new Error(S);
        }
      }
      var y = !f && (!d || v || (d instanceof Kr ? d instanceof Er || d.type === xe.BLOCK_FOLDED || d.type === xe.BLOCK_LITERAL : mn(d) === "object")), E = i, x = E.doc, g = E.indent, b = E.indentStep, A = E.stringify;
      i = Object.assign({}, i, {
        implicitKey: !y,
        indent: g + b
      });
      var P = !1, k = A(d, i, function() {
        return v = null;
      }, function() {
        return P = !0;
      });
      if (k = bl(k, i.indent, v), !y && k.length > 1024) {
        if (f) throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
        y = !0;
      }
      if (i.allNullValues && !f)
        return this.comment ? (k = bl(k, i.indent, this.comment), s && s()) : P && !v && o && o(), i.inFlow && !y ? k : "? ".concat(k);
      k = y ? "? ".concat(k, `
`).concat(g, ":") : "".concat(k, ":"), this.comment && (k = bl(k, i.indent, this.comment), s && s());
      var $ = "", I = null;
      if (m instanceof Kr) {
        if (m.spaceBefore && ($ = `
`), m.commentBefore) {
          var F = m.commentBefore.replace(/^/gm, "".concat(i.indent, "#"));
          $ += `
`.concat(F);
        }
        I = m.comment;
      } else m && mn(m) === "object" && (m = x.schema.createNode(m, !0));
      i.implicitKey = !1, !y && !this.comment && m instanceof Et && (i.indentAtStart = k.length + 1), P = !1, !u && l >= 2 && !i.inFlow && !y && m instanceof Ii && m.type !== xe.FLOW_SEQ && !m.tag && !x.anchors.getName(m) && (i.indent = i.indent.substr(2));
      var L = A(m, i, function() {
        return I = null;
      }, function() {
        return P = !0;
      }), Q = " ";
      if ($ || this.comment)
        Q = "".concat($, `
`).concat(i.indent);
      else if (!y && m instanceof Er) {
        var Y = L[0] === "[" || L[0] === "{";
        (!Y || L.includes(`
`)) && (Q = `
`.concat(i.indent));
      } else L[0] === `
` && (Q = "");
      return P && !I && o && o(), bl(k + Q + L, i.indent, I);
    }
  }]), r;
}(Kr);
Nr(pt, "Type", {
  PAIR: "PAIR",
  MERGE_PAIR: "MERGE_PAIR"
});
var lU = function e(t, r) {
  if (t instanceof vo) {
    var n = r.get(t.source);
    return n.count * n.aliasCount;
  } else if (t instanceof Er) {
    var i = 0, s = Tt(t.items), o;
    try {
      for (s.s(); !(o = s.n()).done; ) {
        var a = o.value, l = e(a, r);
        l > i && (i = l);
      }
    } catch (d) {
      s.e(d);
    } finally {
      s.f();
    }
    return i;
  } else if (t instanceof pt) {
    var u = e(t.key, r), f = e(t.value, r);
    return Math.max(u, f);
  }
  return 1;
}, vo = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r(n) {
    var i;
    return dt(this, r), i = t.call(this), i.source = n, i.type = xe.ALIAS, i;
  }
  return _t(r, [{
    key: "tag",
    set: function(i) {
      throw new Error("Alias nodes cannot have tags");
    }
  }, {
    key: "toJSON",
    value: function(i, s) {
      if (!s) return ri(this.source, i, s);
      var o = s.anchors, a = s.maxAliasCount, l = o.get(this.source);
      if (!l || l.res === void 0) {
        var u = "This should not happen: Alias anchor was not resolved?";
        throw this.cstNode ? new ip(this.cstNode, u) : new ReferenceError(u);
      }
      if (a >= 0 && (l.count += 1, l.aliasCount === 0 && (l.aliasCount = lU(this.source, o)), l.count * l.aliasCount > a)) {
        var f = "Excessive alias count indicates a resource exhaustion attack";
        throw this.cstNode ? new ip(this.cstNode, f) : new ReferenceError(f);
      }
      return l.res;
    }
    // Only called when stringifying an alias mapping key while constructing
    // Object output.
  }, {
    key: "toString",
    value: function(i) {
      return r.stringify(this, i);
    }
  }], [{
    key: "stringify",
    value: function(i, s) {
      var o = i.range, a = i.source, l = s.anchors, u = s.doc, f = s.implicitKey, d = s.inStringifyKey, m = Object.keys(l).find(function(S) {
        return l[S] === a;
      });
      if (!m && d && (m = u.anchors.getName(a) || u.anchors.newName()), m) return "*".concat(m).concat(f ? " " : "");
      var v = u.anchors.getName(a) ? "Alias node must be after source node" : "Source node not found for alias node";
      throw new Error("".concat(v, " [").concat(o, "]"));
    }
  }]), r;
}(Kr);
Nr(vo, "default", !0);
function ea(e, t) {
  var r = t instanceof Et ? t.value : t, n = Tt(e), i;
  try {
    for (n.s(); !(i = n.n()).done; ) {
      var s = i.value;
      if (s instanceof pt && (s.key === t || s.key === r || s.key && s.key.value === r))
        return s;
    }
  } catch (o) {
    n.e(o);
  } finally {
    n.f();
  }
}
var Jr = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r() {
    return dt(this, r), t.apply(this, arguments);
  }
  return _t(r, [{
    key: "add",
    value: function(i, s) {
      i ? i instanceof pt || (i = new pt(i.key || i, i.value)) : i = new pt(i);
      var o = ea(this.items, i.key), a = this.schema && this.schema.sortMapEntries;
      if (o)
        if (s) o.value = i.value;
        else throw new Error("Key ".concat(i.key, " already set"));
      else if (a) {
        var l = this.items.findIndex(function(u) {
          return a(i, u) < 0;
        });
        l === -1 ? this.items.push(i) : this.items.splice(l, 0, i);
      } else
        this.items.push(i);
    }
  }, {
    key: "delete",
    value: function(i) {
      var s = ea(this.items, i);
      if (!s) return !1;
      var o = this.items.splice(this.items.indexOf(s), 1);
      return o.length > 0;
    }
  }, {
    key: "get",
    value: function(i, s) {
      var o = ea(this.items, i), a = o && o.value;
      return !s && a instanceof Et ? a.value : a;
    }
  }, {
    key: "has",
    value: function(i) {
      return !!ea(this.items, i);
    }
  }, {
    key: "set",
    value: function(i, s) {
      this.add(new pt(i, s), !0);
    }
    /**
     * @param {*} arg ignored
     * @param {*} ctx Conversion context, originally set in Document#toJSON()
     * @param {Class} Type If set, forces the returned collection type
     * @returns {*} Instance of Type, Map, or Object
     */
  }, {
    key: "toJSON",
    value: function(i, s, o) {
      var a = o ? new o() : s && s.mapAsMap ? /* @__PURE__ */ new Map() : {};
      s && s.onCreate && s.onCreate(a);
      var l = Tt(this.items), u;
      try {
        for (l.s(); !(u = l.n()).done; ) {
          var f = u.value;
          f.addToJSMap(s, a);
        }
      } catch (d) {
        l.e(d);
      } finally {
        l.f();
      }
      return a;
    }
  }, {
    key: "toString",
    value: function(i, s, o) {
      if (!i) return JSON.stringify(this);
      var a = Tt(this.items), l;
      try {
        for (a.s(); !(l = a.n()).done; ) {
          var u = l.value;
          if (!(u instanceof pt)) throw new Error("Map items must all be pairs; found ".concat(JSON.stringify(u), " instead"));
        }
      } catch (f) {
        a.e(f);
      } finally {
        a.f();
      }
      return sn(Ar(r.prototype), "toString", this).call(this, i, {
        blockItem: function(d) {
          return d.str;
        },
        flowChars: {
          start: "{",
          end: "}"
        },
        isMap: !0,
        itemIndent: i.indent || ""
      }, s, o);
    }
  }]), r;
}(Er), OI = "<<", kI = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r(n) {
    var i;
    if (dt(this, r), n instanceof pt) {
      var s = n.value;
      s instanceof Ii || (s = new Ii(), s.items.push(n.value), s.range = n.value.range), i = t.call(this, n.key, s), i.range = n.range;
    } else
      i = t.call(this, new Et(OI), new Ii());
    return i.type = pt.Type.MERGE_PAIR, bI(i);
  }
  return _t(r, [{
    key: "addToJSMap",
    value: function(i, s) {
      var o = Tt(this.value.items), a;
      try {
        for (o.s(); !(a = o.n()).done; ) {
          var l = a.value.source;
          if (!(l instanceof Jr)) throw new Error("Merge sources must be maps");
          var u = l.toJSON(null, i, Map), f = Tt(u), d;
          try {
            for (f.s(); !(d = f.n()).done; ) {
              var m = _p(d.value, 2), v = m[0], S = m[1];
              s instanceof Map ? s.has(v) || s.set(v, S) : s instanceof Set ? s.add(v) : Object.prototype.hasOwnProperty.call(s, v) || Object.defineProperty(s, v, {
                value: S,
                writable: !0,
                enumerable: !0,
                configurable: !0
              });
            }
          } catch (y) {
            f.e(y);
          } finally {
            f.f();
          }
        }
      } catch (y) {
        o.e(y);
      } finally {
        o.f();
      }
      return s;
    }
  }, {
    key: "toString",
    value: function(i, s) {
      var o = this.value;
      if (o.items.length > 1) return sn(Ar(r.prototype), "toString", this).call(this, i, s);
      this.value = o.items[0];
      var a = sn(Ar(r.prototype), "toString", this).call(this, i, s);
      return this.value = o, a;
    }
  }]), r;
}(pt), Nc = {
  defaultType: xe.BLOCK_LITERAL,
  lineWidth: 76
}, uo = {
  trueStr: "true",
  falseStr: "false"
}, cs = {
  asBigInt: !1
}, zl = {
  nullStr: "null"
}, bo = {
  defaultType: xe.PLAIN,
  doubleQuoted: {
    jsonEncoding: !1,
    minMultiLineLength: 40
  },
  fold: {
    lineWidth: 80,
    minContentWidth: 20
  }
};
function NS(e, t, r) {
  var n = Tt(t), i;
  try {
    for (n.s(); !(i = n.n()).done; ) {
      var s = i.value, o = s.format, a = s.test, l = s.resolve;
      if (a) {
        var u = e.match(a);
        if (u) {
          var f = l.apply(null, u);
          return f instanceof Et || (f = new Et(f)), o && (f.format = o), f;
        }
      }
    }
  } catch (d) {
    n.e(d);
  } finally {
    n.f();
  }
  return r && (e = r(e)), new Et(e);
}
var AI = "flow", G0 = "block", Uh = "quoted", UO = function(t, r) {
  for (var n = t[r + 1]; n === " " || n === "	"; ) {
    do
      n = t[r += 1];
    while (n && n !== `
`);
    n = t[r + 1];
  }
  return r;
};
function xg(e, t, r, n) {
  var i = n.indentAtStart, s = n.lineWidth, o = s === void 0 ? 80 : s, a = n.minContentWidth, l = a === void 0 ? 20 : a, u = n.onFold, f = n.onOverflow;
  if (!o || o < 0) return e;
  var d = Math.max(1 + l, 1 + o - t.length);
  if (e.length <= d) return e;
  var m = [], v = {}, S = o - t.length;
  typeof i == "number" && (i > o - Math.max(2, l) ? m.push(0) : S = o - i);
  var y = void 0, E = void 0, x = !1, g = -1, b = -1, A = -1;
  r === G0 && (g = UO(e, g), g !== -1 && (S = g + d));
  for (var P; P = e[g += 1]; ) {
    if (r === Uh && P === "\\") {
      switch (b = g, e[g + 1]) {
        case "x":
          g += 3;
          break;
        case "u":
          g += 5;
          break;
        case "U":
          g += 9;
          break;
        default:
          g += 1;
      }
      A = g;
    }
    if (P === `
`)
      r === G0 && (g = UO(e, g)), S = g + d, y = void 0;
    else {
      if (P === " " && E && E !== " " && E !== `
` && E !== "	") {
        var k = e[g + 1];
        k && k !== " " && k !== `
` && k !== "	" && (y = g);
      }
      if (g >= S)
        if (y)
          m.push(y), S = y + d, y = void 0;
        else if (r === Uh) {
          for (; E === " " || E === "	"; )
            E = P, P = e[g += 1], x = !0;
          var $ = g > A + 1 ? g - 2 : b - 1;
          if (v[$]) return e;
          m.push($), v[$] = !0, S = $ + d, y = void 0;
        } else
          x = !0;
    }
    E = P;
  }
  if (x && f && f(), m.length === 0) return e;
  u && u();
  for (var I = e.slice(0, m[0]), F = 0; F < m.length; ++F) {
    var L = m[F], Q = m[F + 1] || e.length;
    L === 0 ? I = `
`.concat(t).concat(e.slice(0, Q)) : (r === Uh && v[L] && (I += "".concat(e[L], "\\")), I += `
`.concat(t).concat(e.slice(L + 1, Q)));
  }
  return I;
}
var jS = function(t) {
  var r = t.indentAtStart;
  return r ? Object.assign({
    indentAtStart: r
  }, bo.fold) : bo.fold;
}, Eg = function(t) {
  return /^(%|---|\.\.\.)/m.test(t);
};
function uU(e, t, r) {
  if (!t || t < 0) return !1;
  var n = t - r, i = e.length;
  if (i <= n) return !1;
  for (var s = 0, o = 0; s < i; ++s)
    if (e[s] === `
`) {
      if (s - o > n) return !0;
      if (o = s + 1, i - o <= n) return !1;
    }
  return !0;
}
function oa(e, t) {
  var r = t.implicitKey, n = bo.doubleQuoted, i = n.jsonEncoding, s = n.minMultiLineLength, o = JSON.stringify(e);
  if (i) return o;
  for (var a = t.indent || (Eg(e) ? "  " : ""), l = "", u = 0, f = 0, d = o[f]; d; d = o[++f])
    if (d === " " && o[f + 1] === "\\" && o[f + 2] === "n" && (l += o.slice(u, f) + "\\ ", f += 1, u = f, d = "\\"), d === "\\") switch (o[f + 1]) {
      case "u":
        {
          l += o.slice(u, f);
          var m = o.substr(f + 2, 4);
          switch (m) {
            case "0000":
              l += "\\0";
              break;
            case "0007":
              l += "\\a";
              break;
            case "000b":
              l += "\\v";
              break;
            case "001b":
              l += "\\e";
              break;
            case "0085":
              l += "\\N";
              break;
            case "00a0":
              l += "\\_";
              break;
            case "2028":
              l += "\\L";
              break;
            case "2029":
              l += "\\P";
              break;
            default:
              m.substr(0, 2) === "00" ? l += "\\x" + m.substr(2) : l += o.substr(f, 6);
          }
          f += 5, u = f + 1;
        }
        break;
      case "n":
        if (r || o[f + 2] === '"' || o.length < s)
          f += 1;
        else {
          for (l += o.slice(u, f) + `

`; o[f + 2] === "\\" && o[f + 3] === "n" && o[f + 4] !== '"'; )
            l += `
`, f += 2;
          l += a, o[f + 2] === " " && (l += "\\"), f += 1, u = f + 1;
        }
        break;
      default:
        f += 1;
    }
  return l = u ? l + o.slice(u) : o, r ? l : xg(l, a, Uh, jS(t));
}
function PI(e, t) {
  if (t.implicitKey) {
    if (/\n/.test(e)) return oa(e, t);
  } else if (/[ \t]\n|\n[ \t]/.test(e)) return oa(e, t);
  var r = t.indent || (Eg(e) ? "  " : ""), n = "'" + e.replace(/'/g, "''").replace(/\n+/g, `$&
`.concat(r)) + "'";
  return t.implicitKey ? n : xg(n, r, AI, jS(t));
}
function Vh(e, t, r, n) {
  var i = e.comment, s = e.type, o = e.value;
  if (/\n[\t ]+$/.test(o) || /^\s*$/.test(o))
    return oa(o, t);
  var a = t.indent || (t.forceBlockIndent || Eg(o) ? "  " : ""), l = a ? "2" : "1", u = s === xe.BLOCK_FOLDED ? !1 : s === xe.BLOCK_LITERAL ? !0 : !uU(o, bo.fold.lineWidth, a.length), f = u ? "|" : ">";
  if (!o) return f + `
`;
  var d = "", m = "";
  if (o = o.replace(/[\n\t ]*$/, function(S) {
    var y = S.indexOf(`
`);
    return y === -1 ? f += "-" : (o === S || y !== S.length - 1) && (f += "+", n && n()), m = S.replace(/\n$/, ""), "";
  }).replace(/^[\n ]*/, function(S) {
    S.indexOf(" ") !== -1 && (f += l);
    var y = S.match(/ +$/);
    return y ? (d = S.slice(0, -y[0].length), y[0]) : (d = S, "");
  }), m && (m = m.replace(/\n+(?!\n|$)/g, "$&".concat(a))), d && (d = d.replace(/\n+/g, "$&".concat(a))), i && (f += " #" + i.replace(/ ?[\r\n]+/g, " "), r && r()), !o) return "".concat(f).concat(l, `
`).concat(a).concat(m);
  if (u)
    return o = o.replace(/\n+/g, "$&".concat(a)), "".concat(f, `
`).concat(a).concat(d).concat(o).concat(m);
  o = o.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, "$&".concat(a));
  var v = xg("".concat(d).concat(o).concat(m), a, G0, bo.fold);
  return "".concat(f, `
`).concat(a).concat(v);
}
function cU(e, t, r, n) {
  var i = e.comment, s = e.type, o = e.value, a = t.actualString, l = t.implicitKey, u = t.indent, f = t.inFlow;
  if (l && /[\n[\]{},]/.test(o) || f && /[[\]{},]/.test(o))
    return oa(o, t);
  if (!o || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(o))
    return l || f || o.indexOf(`
`) === -1 ? o.indexOf('"') !== -1 && o.indexOf("'") === -1 ? PI(o, t) : oa(o, t) : Vh(e, t, r, n);
  if (!l && !f && s !== xe.PLAIN && o.indexOf(`
`) !== -1)
    return Vh(e, t, r, n);
  if (u === "" && Eg(o))
    return t.forceBlockIndent = !0, Vh(e, t, r, n);
  var d = o.replace(/\n+/g, `$&
`.concat(u));
  if (a) {
    var m = t.doc.schema.tags, v = NS(d, m, m.scalarFallback).value;
    if (typeof v != "string") return oa(o, t);
  }
  var S = l ? d : xg(d, u, AI, jS(t));
  return i && !f && (S.indexOf(`
`) !== -1 || i.indexOf(`
`) !== -1) ? (r && r(), sU(S, u, i)) : S;
}
function LS(e, t, r, n) {
  var i = bo.defaultType, s = t.implicitKey, o = t.inFlow, a = e, l = a.type, u = a.value;
  typeof u != "string" && (u = String(u), e = Object.assign({}, e, {
    value: u
  }));
  var f = function(v) {
    switch (v) {
      case xe.BLOCK_FOLDED:
      case xe.BLOCK_LITERAL:
        return Vh(e, t, r, n);
      case xe.QUOTE_DOUBLE:
        return oa(u, t);
      case xe.QUOTE_SINGLE:
        return PI(u, t);
      case xe.PLAIN:
        return cU(e, t, r, n);
      default:
        return null;
    }
  };
  (l !== xe.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(u) || (s || o) && (l === xe.BLOCK_FOLDED || l === xe.BLOCK_LITERAL)) && (l = xe.QUOTE_DOUBLE);
  var d = f(l);
  if (d === null && (d = f(i), d === null))
    throw new Error("Unsupported default string type ".concat(i));
  return d;
}
function co(e) {
  var t = e.format, r = e.minFractionDigits, n = e.tag, i = e.value;
  if (typeof i == "bigint") return String(i);
  if (!isFinite(i)) return isNaN(i) ? ".nan" : i < 0 ? "-.inf" : ".inf";
  var s = JSON.stringify(i);
  if (!t && r && (!n || n === "tag:yaml.org,2002:float") && /^\d/.test(s)) {
    var o = s.indexOf(".");
    o < 0 && (o = s.length, s += ".");
    for (var a = r - (s.length - o - 1); a-- > 0; )
      s += "0";
  }
  return s;
}
function TI(e, t) {
  var r, n;
  switch (t.type) {
    case xe.FLOW_MAP:
      r = "}", n = "flow map";
      break;
    case xe.FLOW_SEQ:
      r = "]", n = "flow sequence";
      break;
    default:
      e.push(new nt(t, "Not a flow collection!?"));
      return;
  }
  for (var i, s = t.items.length - 1; s >= 0; --s) {
    var o = t.items[s];
    if (!o || o.type !== xe.COMMENT) {
      i = o;
      break;
    }
  }
  if (i && i.char !== r) {
    var a = "Expected ".concat(n, " to end with ").concat(r), l;
    typeof i.offset == "number" ? (l = new nt(t, a), l.offset = i.offset + 1) : (l = new nt(i, a), i.range && i.range.end && (l.offset = i.range.end - i.range.start)), e.push(l);
  }
}
function CI(e, t) {
  var r = t.context.src[t.range.start - 1];
  if (r !== `
` && r !== "	" && r !== " ") {
    var n = "Comments must be separated from other tokens by white space characters";
    e.push(new nt(t, n));
  }
}
function $I(e, t) {
  var r = String(t), n = r.substr(0, 8) + "..." + r.substr(-8);
  return new nt(e, 'The "'.concat(n, '" key is too long'));
}
function RI(e, t) {
  var r = Tt(t), n;
  try {
    for (r.s(); !(n = r.n()).done; ) {
      var i = n.value, s = i.afterKey, o = i.before, a = i.comment, l = e.items[o];
      l ? (s && l.value && (l = l.value), a === void 0 ? (s || !l.commentBefore) && (l.spaceBefore = !0) : l.commentBefore ? l.commentBefore += `
` + a : l.commentBefore = a) : a !== void 0 && (e.comment ? e.comment += `
` + a : e.comment = a);
    }
  } catch (u) {
    r.e(u);
  } finally {
    r.f();
  }
}
function Op(e, t) {
  var r = t.strValue;
  return r ? typeof r == "string" ? r : (r.errors.forEach(function(n) {
    n.source || (n.source = t), e.errors.push(n);
  }), r.str) : "";
}
function pU(e, t) {
  var r = t.tag, n = r.handle, i = r.suffix, s = e.tagPrefixes.find(function(l) {
    return l.handle === n;
  });
  if (!s) {
    var o = e.getDefaults().tagPrefixes;
    if (o && (s = o.find(function(l) {
      return l.handle === n;
    })), !s) throw new nt(t, "The ".concat(n, " tag handle is non-default and was not declared."));
  }
  if (!i) throw new nt(t, "The ".concat(n, " tag has no suffix."));
  if (n === "!" && (e.version || e.options.version) === "1.0") {
    if (i[0] === "^")
      return e.warnings.push(new tu(t, "YAML 1.0 ^ tag expansion is not supported")), i;
    if (/[:/]/.test(i)) {
      var a = i.match(/^([a-z0-9-]+)\/(.*)/i);
      return a ? "tag:".concat(a[1], ".yaml.org,2002:").concat(a[2]) : "tag:".concat(i);
    }
  }
  return s.prefix + decodeURIComponent(i);
}
function fU(e, t) {
  var r = t.tag, n = t.type, i = !1;
  if (r) {
    var s = r.handle, o = r.suffix, a = r.verbatim;
    if (a) {
      if (a !== "!" && a !== "!!") return a;
      var l = "Verbatim tags aren't resolved, so ".concat(a, " is invalid.");
      e.errors.push(new nt(t, l));
    } else if (s === "!" && !o)
      i = !0;
    else
      try {
        return pU(e, t);
      } catch (u) {
        e.errors.push(u);
      }
  }
  switch (n) {
    case xe.BLOCK_FOLDED:
    case xe.BLOCK_LITERAL:
    case xe.QUOTE_DOUBLE:
    case xe.QUOTE_SINGLE:
      return Qo.STR;
    case xe.FLOW_MAP:
    case xe.MAP:
      return Qo.MAP;
    case xe.FLOW_SEQ:
    case xe.SEQ:
      return Qo.SEQ;
    case xe.PLAIN:
      return i ? Qo.STR : null;
    default:
      return null;
  }
}
function VO(e, t, r) {
  var n = e.schema.tags, i = [], s = Tt(n), o;
  try {
    for (s.s(); !(o = s.n()).done; ) {
      var a = o.value;
      if (a.tag === r)
        if (a.test) i.push(a);
        else {
          var l = a.resolve(e, t);
          return l instanceof Er ? l : new Et(l);
        }
    }
  } catch (f) {
    s.e(f);
  } finally {
    s.f();
  }
  var u = Op(e, t);
  return typeof u == "string" && i.length > 0 ? NS(u, i, n.scalarFallback) : null;
}
function dU(e) {
  var t = e.type;
  switch (t) {
    case xe.FLOW_MAP:
    case xe.MAP:
      return Qo.MAP;
    case xe.FLOW_SEQ:
    case xe.SEQ:
      return Qo.SEQ;
    default:
      return Qo.STR;
  }
}
function hU(e, t, r) {
  try {
    var n = VO(e, t, r);
    if (n)
      return r && t.tag && (n.tag = r), n;
  } catch (l) {
    return l.source || (l.source = t), e.errors.push(l), null;
  }
  try {
    var i = dU(t);
    if (!i) throw new Error("The tag ".concat(r, " is unavailable"));
    var s = "The tag ".concat(r, " is unavailable, falling back to ").concat(i);
    e.warnings.push(new tu(t, s));
    var o = VO(e, t, i);
    return o.tag = r, o;
  } catch (l) {
    var a = new ip(t, l.message);
    return a.stack = l.stack, e.errors.push(a), null;
  }
}
var mU = function(t) {
  if (!t) return !1;
  var r = t.type;
  return r === xe.MAP_KEY || r === xe.MAP_VALUE || r === xe.SEQ_ITEM;
};
function gU(e, t) {
  var r = {
    before: [],
    after: []
  }, n = !1, i = !1, s = mU(t.context.parent) ? t.context.parent.props.concat(t.props) : t.props, o = Tt(s), a;
  try {
    for (o.s(); !(a = o.n()).done; ) {
      var l = a.value, u = l.start, f = l.end;
      switch (t.context.src[u]) {
        case nr.COMMENT: {
          if (!t.commentHasRequiredWhitespace(u)) {
            var d = "Comments must be separated from other tokens by white space characters";
            e.push(new nt(t, d));
          }
          var m = t.header, v = t.valueRange, S = v && (u > v.start || m && u > m.start) ? r.after : r.before;
          S.push(t.context.src.slice(u + 1, f));
          break;
        }
        case nr.ANCHOR:
          if (n) {
            var y = "A node can have at most one anchor";
            e.push(new nt(t, y));
          }
          n = !0;
          break;
        case nr.TAG:
          if (i) {
            var E = "A node can have at most one tag";
            e.push(new nt(t, E));
          }
          i = !0;
          break;
      }
    }
  } catch (x) {
    o.e(x);
  } finally {
    o.f();
  }
  return {
    comments: r,
    hasAnchor: n,
    hasTag: i
  };
}
function yU(e, t) {
  var r = e.anchors, n = e.errors, i = e.schema;
  if (t.type === xe.ALIAS) {
    var s = t.rawValue, o = r.getNode(s);
    if (!o) {
      var a = "Aliased anchor not found: ".concat(s);
      return n.push(new ip(t, a)), null;
    }
    var l = new vo(o);
    return r._cstAliases.push(l), l;
  }
  var u = fU(e, t);
  if (u) return hU(e, t, u);
  if (t.type !== xe.PLAIN) {
    var f = "Failed to resolve ".concat(t.type, " node here");
    return n.push(new jr(t, f)), null;
  }
  try {
    var d = Op(e, t);
    return NS(d, i.tags, i.tags.scalarFallback);
  } catch (m) {
    return m.source || (m.source = t), n.push(m), null;
  }
}
function os(e, t) {
  if (!t) return null;
  t.error && e.errors.push(t.error);
  var r = gU(e.errors, t), n = r.comments, i = r.hasAnchor, s = r.hasTag;
  if (i) {
    var o = e.anchors, a = t.anchor, l = o.getNode(a);
    l && (o.map[o.newName(a)] = l), o.map[a] = t;
  }
  if (t.type === xe.ALIAS && (i || s)) {
    var u = "An alias node must not specify any properties";
    e.errors.push(new nt(t, u));
  }
  var f = yU(e, t);
  if (f) {
    f.range = [t.range.start, t.range.end], e.options.keepCstNodes && (f.cstNode = t), e.options.keepNodeTypes && (f.type = t.type);
    var d = n.before.join(`
`);
    d && (f.commentBefore = f.commentBefore ? "".concat(f.commentBefore, `
`).concat(d) : d);
    var m = n.after.join(`
`);
    m && (f.comment = f.comment ? "".concat(f.comment, `
`).concat(m) : m);
  }
  return t.resolved = f;
}
function II(e, t) {
  if (t.type !== xe.MAP && t.type !== xe.FLOW_MAP) {
    var r = "A ".concat(t.type, " node cannot be resolved as a mapping");
    return e.errors.push(new jr(t, r)), null;
  }
  var n = t.type === xe.FLOW_MAP ? SU(e, t) : wU(e, t), i = n.comments, s = n.items, o = new Jr();
  o.items = s, RI(o, i);
  for (var a = !1, l = 0; l < s.length; ++l) {
    var u = s[l].key;
    if (u instanceof Er && (a = !0), e.schema.merge && u && u.value === OI) {
      s[l] = new kI(s[l]);
      var f = s[l].value.items, d = null;
      f.some(function(E) {
        if (E instanceof vo) {
          var x = E.source.type;
          return x === xe.MAP || x === xe.FLOW_MAP ? !1 : d = "Merge nodes aliases can only point to maps";
        }
        return d = "Merge nodes can only have Alias nodes as values";
      }), d && e.errors.push(new nt(t, d));
    } else
      for (var m = l + 1; m < s.length; ++m) {
        var v = s[m].key;
        if (u === v || u && v && Object.prototype.hasOwnProperty.call(u, "value") && u.value === v.value) {
          var S = 'Map keys must be unique; "'.concat(u, '" is repeated');
          e.errors.push(new nt(t, S));
          break;
        }
      }
  }
  if (a && !e.options.mapAsMap) {
    var y = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
    e.warnings.push(new tu(t, y));
  }
  return t.resolved = o, o;
}
var vU = function(t) {
  var r = t.context, n = r.lineStart, i = r.node, s = r.src, o = t.props;
  if (o.length === 0) return !1;
  var a = o[0].start;
  if (i && a > i.valueRange.start || s[a] !== nr.COMMENT) return !1;
  for (var l = n; l < a; ++l)
    if (s[l] === `
`) return !1;
  return !0;
};
function bU(e, t) {
  if (vU(e)) {
    var r = e.getPropValue(0, nr.COMMENT, !0), n = !1, i = t.value.commentBefore;
    if (i && i.startsWith(r))
      t.value.commentBefore = i.substr(r.length + 1), n = !0;
    else {
      var s = t.value.comment;
      !e.node && s && s.startsWith(r) && (t.value.comment = s.substr(r.length + 1), n = !0);
    }
    n && (t.comment = r);
  }
}
function wU(e, t) {
  for (var r = [], n = [], i = void 0, s = null, o = 0; o < t.items.length; ++o) {
    var a = t.items[o];
    switch (a.type) {
      case xe.BLANK_LINE:
        r.push({
          afterKey: !!i,
          before: n.length
        });
        break;
      case xe.COMMENT:
        r.push({
          afterKey: !!i,
          before: n.length,
          comment: a.comment
        });
        break;
      case xe.MAP_KEY:
        i !== void 0 && n.push(new pt(i)), a.error && e.errors.push(a.error), i = os(e, a.node), s = null;
        break;
      case xe.MAP_VALUE:
        {
          if (i === void 0 && (i = null), a.error && e.errors.push(a.error), !a.context.atLineStart && a.node && a.node.type === xe.MAP && !a.node.context.atLineStart) {
            var l = "Nested mappings are not allowed in compact mappings";
            e.errors.push(new nt(a.node, l));
          }
          var u = a.node;
          if (!u && a.props.length > 0) {
            u = new EI(xe.PLAIN, []), u.context = {
              parent: a,
              src: a.context.src
            };
            var f = a.range.start + 1;
            if (u.range = {
              start: f,
              end: f
            }, u.valueRange = {
              start: f,
              end: f
            }, typeof a.range.origStart == "number") {
              var d = a.range.origStart + 1;
              u.range.origStart = u.range.origEnd = d, u.valueRange.origStart = u.valueRange.origEnd = d;
            }
          }
          var m = new pt(i, os(e, u));
          bU(a, m), n.push(m), i && typeof s == "number" && a.range.start > s + 1024 && e.errors.push($I(t, i)), i = void 0, s = null;
        }
        break;
      default:
        i !== void 0 && n.push(new pt(i)), i = os(e, a), s = a.range.start, a.error && e.errors.push(a.error);
        e: for (var v = o + 1; ; ++v) {
          var S = t.items[v];
          switch (S && S.type) {
            case xe.BLANK_LINE:
            case xe.COMMENT:
              continue e;
            case xe.MAP_VALUE:
              break e;
            default: {
              var y = "Implicit map keys need to be followed by map values";
              e.errors.push(new nt(a, y));
              break e;
            }
          }
        }
        if (a.valueRangeContainsNewline) {
          var E = "Implicit map keys need to be on a single line";
          e.errors.push(new nt(a, E));
        }
    }
  }
  return i !== void 0 && n.push(new pt(i)), {
    comments: r,
    items: n
  };
}
function SU(e, t) {
  for (var r = [], n = [], i = void 0, s = !1, o = "{", a = 0; a < t.items.length; ++a) {
    var l = t.items[a];
    if (typeof l.char == "string") {
      var u = l.char, f = l.offset;
      if (u === "?" && i === void 0 && !s) {
        s = !0, o = ":";
        continue;
      }
      if (u === ":") {
        if (i === void 0 && (i = null), o === ":") {
          o = ",";
          continue;
        }
      } else if (s && (i === void 0 && u !== "," && (i = null), s = !1), i !== void 0 && (n.push(new pt(i)), i = void 0, u === ",")) {
        o = ":";
        continue;
      }
      if (u === "}") {
        if (a === t.items.length - 1) continue;
      } else if (u === o) {
        o = ":";
        continue;
      }
      var d = "Flow map contains an unexpected ".concat(u), m = new jr(t, d);
      m.offset = f, e.errors.push(m);
    } else l.type === xe.BLANK_LINE ? r.push({
      afterKey: !!i,
      before: n.length
    }) : l.type === xe.COMMENT ? (CI(e.errors, l), r.push({
      afterKey: !!i,
      before: n.length,
      comment: l.comment
    })) : i === void 0 ? (o === "," && e.errors.push(new nt(l, "Separator , missing in flow map")), i = os(e, l)) : (o !== "," && e.errors.push(new nt(l, "Indicator : missing in flow map entry")), n.push(new pt(i, os(e, l))), i = void 0, s = !1);
  }
  return TI(e.errors, t), i !== void 0 && n.push(new pt(i)), {
    comments: r,
    items: n
  };
}
function NI(e, t) {
  if (t.type !== xe.SEQ && t.type !== xe.FLOW_SEQ) {
    var r = "A ".concat(t.type, " node cannot be resolved as a sequence");
    return e.errors.push(new jr(t, r)), null;
  }
  var n = t.type === xe.FLOW_SEQ ? EU(e, t) : xU(e, t), i = n.comments, s = n.items, o = new Ii();
  if (o.items = s, RI(o, i), !e.options.mapAsMap && s.some(function(l) {
    return l instanceof pt && l.key instanceof Er;
  })) {
    var a = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
    e.warnings.push(new tu(t, a));
  }
  return t.resolved = o, o;
}
function xU(e, t) {
  for (var r = [], n = [], i = 0; i < t.items.length; ++i) {
    var s = t.items[i];
    switch (s.type) {
      case xe.BLANK_LINE:
        r.push({
          before: n.length
        });
        break;
      case xe.COMMENT:
        r.push({
          comment: s.comment,
          before: n.length
        });
        break;
      case xe.SEQ_ITEM:
        if (s.error && e.errors.push(s.error), n.push(os(e, s.node)), s.hasProps) {
          var o = "Sequence items cannot have tags or anchors before the - indicator";
          e.errors.push(new nt(s, o));
        }
        break;
      default:
        s.error && e.errors.push(s.error), e.errors.push(new jr(s, "Unexpected ".concat(s.type, " node in sequence")));
    }
  }
  return {
    comments: r,
    items: n
  };
}
function EU(e, t) {
  for (var r = [], n = [], i = !1, s = void 0, o = null, a = "[", l = null, u = 0; u < t.items.length; ++u) {
    var f = t.items[u];
    if (typeof f.char == "string") {
      var d = f.char, m = f.offset;
      if (d !== ":" && (i || s !== void 0) && (i && s === void 0 && (s = a ? n.pop() : null), n.push(new pt(s)), i = !1, s = void 0, o = null), d === a)
        a = null;
      else if (!a && d === "?")
        i = !0;
      else if (a !== "[" && d === ":" && s === void 0) {
        if (a === ",") {
          if (s = n.pop(), s instanceof pt) {
            var v = "Chaining flow sequence pairs is invalid", S = new nt(t, v);
            S.offset = m, e.errors.push(S);
          }
          if (!i && typeof o == "number") {
            var y = f.range ? f.range.start : f.offset;
            y > o + 1024 && e.errors.push($I(t, s));
            for (var E = l.context.src, x = o; x < y; ++x)
              if (E[x] === `
`) {
                var g = "Implicit keys of flow sequence pairs need to be on a single line";
                e.errors.push(new nt(l, g));
                break;
              }
          }
        } else
          s = null;
        o = null, i = !1, a = null;
      } else if (a === "[" || d !== "]" || u < t.items.length - 1) {
        var b = "Flow sequence contains an unexpected ".concat(d), A = new jr(t, b);
        A.offset = m, e.errors.push(A);
      }
    } else if (f.type === xe.BLANK_LINE)
      r.push({
        before: n.length
      });
    else if (f.type === xe.COMMENT)
      CI(e.errors, f), r.push({
        comment: f.comment,
        before: n.length
      });
    else {
      if (a) {
        var P = "Expected a ".concat(a, " in flow sequence");
        e.errors.push(new nt(f, P));
      }
      var k = os(e, f);
      s === void 0 ? (n.push(k), l = f) : (n.push(new pt(s, k)), s = void 0), o = f.range.start, a = ",";
    }
  }
  return TI(e.errors, t), s !== void 0 && n.push(new pt(s)), {
    comments: r,
    items: n
  };
}
var jI = {
  identify: function(t) {
    return t instanceof Uint8Array;
  },
  // Buffer inherits from Uint8Array
  default: !1,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve: function(t, r) {
    var n = Op(t, r);
    if (typeof Buffer == "function")
      return Buffer.from(n, "base64");
    if (typeof atob == "function") {
      for (var i = atob(n.replace(/[\n\r]/g, "")), s = new Uint8Array(i.length), o = 0; o < i.length; ++o)
        s[o] = i.charCodeAt(o);
      return s;
    } else {
      var a = "This environment does not support reading binary tags; either Buffer or atob is required";
      return t.errors.push(new ip(r, a)), null;
    }
  },
  options: Nc,
  stringify: function(t, r, n, i) {
    var s = t.comment, o = t.type, a = t.value, l;
    if (typeof Buffer == "function")
      l = a instanceof Buffer ? a.toString("base64") : Buffer.from(a.buffer).toString("base64");
    else if (typeof btoa == "function") {
      for (var u = "", f = 0; f < a.length; ++f)
        u += String.fromCharCode(a[f]);
      l = btoa(u);
    } else
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    if (o || (o = Nc.defaultType), o === xe.QUOTE_DOUBLE)
      a = l;
    else {
      for (var d = Nc.lineWidth, m = Math.ceil(l.length / d), v = new Array(m), S = 0, y = 0; S < m; ++S, y += d)
        v[S] = l.substr(y, d);
      a = v.join(o === xe.BLOCK_LITERAL ? `
` : " ");
    }
    return LS({
      comment: s,
      type: o,
      value: a
    }, r, n, i);
  }
};
function LI(e, t) {
  for (var r = NI(e, t), n = 0; n < r.items.length; ++n) {
    var i = r.items[n];
    if (!(i instanceof pt)) {
      if (i instanceof Jr) {
        if (i.items.length > 1) {
          var s = "Each pair must have its own sequence indicator";
          throw new nt(t, s);
        }
        var o = i.items[0] || new pt();
        i.commentBefore && (o.commentBefore = o.commentBefore ? "".concat(i.commentBefore, `
`).concat(o.commentBefore) : i.commentBefore), i.comment && (o.comment = o.comment ? "".concat(i.comment, `
`).concat(o.comment) : i.comment), i = o;
      }
      r.items[n] = i instanceof pt ? i : new pt(i);
    }
  }
  return r;
}
function MI(e, t, r) {
  var n = new Ii(e);
  n.tag = "tag:yaml.org,2002:pairs";
  var i = Tt(t), s;
  try {
    for (i.s(); !(s = i.n()).done; ) {
      var o = s.value, a = void 0, l = void 0;
      if (Array.isArray(o))
        if (o.length === 2)
          a = o[0], l = o[1];
        else throw new TypeError("Expected [key, value] tuple: ".concat(o));
      else if (o && o instanceof Object) {
        var u = Object.keys(o);
        if (u.length === 1)
          a = u[0], l = o[a];
        else throw new TypeError("Expected { key: value } tuple: ".concat(o));
      } else
        a = o;
      var f = e.createPair(a, l, r);
      n.items.push(f);
    }
  } catch (d) {
    i.e(d);
  } finally {
    i.f();
  }
  return n;
}
var DI = {
  default: !1,
  tag: "tag:yaml.org,2002:pairs",
  resolve: LI,
  createNode: MI
}, _g = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r() {
    var n;
    return dt(this, r), n = t.call(this), Nr(kn(n), "add", Jr.prototype.add.bind(kn(n))), Nr(kn(n), "delete", Jr.prototype.delete.bind(kn(n))), Nr(kn(n), "get", Jr.prototype.get.bind(kn(n))), Nr(kn(n), "has", Jr.prototype.has.bind(kn(n))), Nr(kn(n), "set", Jr.prototype.set.bind(kn(n))), n.tag = r.tag, n;
  }
  return _t(r, [{
    key: "toJSON",
    value: function(i, s) {
      var o = /* @__PURE__ */ new Map();
      s && s.onCreate && s.onCreate(o);
      var a = Tt(this.items), l;
      try {
        for (a.s(); !(l = a.n()).done; ) {
          var u = l.value, f = void 0, d = void 0;
          if (u instanceof pt ? (f = ri(u.key, "", s), d = ri(u.value, f, s)) : f = ri(u, "", s), o.has(f)) throw new Error("Ordered maps must not include duplicate keys");
          o.set(f, d);
        }
      } catch (m) {
        a.e(m);
      } finally {
        a.f();
      }
      return o;
    }
  }]), r;
}(Ii);
Nr(_g, "tag", "tag:yaml.org,2002:omap");
function _U(e, t) {
  var r = LI(e, t), n = [], i = Tt(r.items), s;
  try {
    for (i.s(); !(s = i.n()).done; ) {
      var o = s.value.key;
      if (o instanceof Et)
        if (n.includes(o.value)) {
          var a = "Ordered maps must not include duplicate keys";
          throw new nt(t, a);
        } else
          n.push(o.value);
    }
  } catch (l) {
    i.e(l);
  } finally {
    i.f();
  }
  return Object.assign(new _g(), r);
}
function OU(e, t, r) {
  var n = MI(e, t, r), i = new _g();
  return i.items = n.items, i;
}
var FI = {
  identify: function(t) {
    return t instanceof Map;
  },
  nodeClass: _g,
  default: !1,
  tag: "tag:yaml.org,2002:omap",
  resolve: _U,
  createNode: OU
}, Og = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r() {
    var n;
    return dt(this, r), n = t.call(this), n.tag = r.tag, n;
  }
  return _t(r, [{
    key: "add",
    value: function(i) {
      var s = i instanceof pt ? i : new pt(i), o = ea(this.items, s.key);
      o || this.items.push(s);
    }
  }, {
    key: "get",
    value: function(i, s) {
      var o = ea(this.items, i);
      return !s && o instanceof pt ? o.key instanceof Et ? o.key.value : o.key : o;
    }
  }, {
    key: "set",
    value: function(i, s) {
      if (typeof s != "boolean") throw new Error("Expected boolean value for set(key, value) in a YAML set, not ".concat(mn(s)));
      var o = ea(this.items, i);
      o && !s ? this.items.splice(this.items.indexOf(o), 1) : !o && s && this.items.push(new pt(i));
    }
  }, {
    key: "toJSON",
    value: function(i, s) {
      return sn(Ar(r.prototype), "toJSON", this).call(this, i, s, Set);
    }
  }, {
    key: "toString",
    value: function(i, s, o) {
      if (!i) return JSON.stringify(this);
      if (this.hasAllNullValues()) return sn(Ar(r.prototype), "toString", this).call(this, i, s, o);
      throw new Error("Set items must all have null values");
    }
  }]), r;
}(Jr);
Nr(Og, "tag", "tag:yaml.org,2002:set");
function kU(e, t) {
  var r = II(e, t);
  if (!r.hasAllNullValues()) throw new nt(t, "Set items must all have null values");
  return Object.assign(new Og(), r);
}
function AU(e, t, r) {
  var n = new Og(), i = Tt(t), s;
  try {
    for (i.s(); !(s = i.n()).done; ) {
      var o = s.value;
      n.items.push(e.createPair(o, null, r));
    }
  } catch (a) {
    i.e(a);
  } finally {
    i.f();
  }
  return n;
}
var zI = {
  identify: function(t) {
    return t instanceof Set;
  },
  nodeClass: Og,
  default: !1,
  tag: "tag:yaml.org,2002:set",
  resolve: kU,
  createNode: AU
}, MS = function(t, r) {
  var n = r.split(":").reduce(function(i, s) {
    return i * 60 + Number(s);
  }, 0);
  return t === "-" ? -n : n;
}, qI = function(t) {
  var r = t.value;
  if (isNaN(r) || !isFinite(r)) return co(r);
  var n = "";
  r < 0 && (n = "-", r = Math.abs(r));
  var i = [r % 60];
  return r < 60 ? i.unshift(0) : (r = Math.round((r - i[0]) / 60), i.unshift(r % 60), r >= 60 && (r = Math.round((r - i[0]) / 60), i.unshift(r))), n + i.map(function(s) {
    return s < 10 ? "0" + String(s) : String(s);
  }).join(":").replace(/000000\d*$/, "");
}, BI = {
  identify: function(t) {
    return typeof t == "number";
  },
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
  resolve: function(t, r, n) {
    return MS(r, n.replace(/_/g, ""));
  },
  stringify: qI
}, UI = {
  identify: function(t) {
    return typeof t == "number";
  },
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
  resolve: function(t, r, n) {
    return MS(r, n.replace(/_/g, ""));
  },
  stringify: qI
}, VI = {
  identify: function(t) {
    return t instanceof Date;
  },
  default: !0,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^(?:([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?)$"),
  resolve: function(t, r, n, i, s, o, a, l, u) {
    l && (l = (l + "00").substr(1, 3));
    var f = Date.UTC(r, n - 1, i, s || 0, o || 0, a || 0, l || 0);
    if (u && u !== "Z") {
      var d = MS(u[0], u.slice(1));
      Math.abs(d) < 30 && (d *= 60), f -= 6e4 * d;
    }
    return new Date(f);
  },
  stringify: function(t) {
    var r = t.value;
    return r.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "");
  }
};
function WI(e) {
  var t = typeof process < "u" && process.env || {};
  return e ? typeof YAML_SILENCE_DEPRECATION_WARNINGS < "u" ? !YAML_SILENCE_DEPRECATION_WARNINGS : !t.YAML_SILENCE_DEPRECATION_WARNINGS : typeof YAML_SILENCE_WARNINGS < "u" ? !YAML_SILENCE_WARNINGS : !t.YAML_SILENCE_WARNINGS;
}
function HI(e, t) {
  if (WI(!1)) {
    var r = typeof process < "u" && process.emitWarning;
    r ? r(e, t) : console.warn(t ? "".concat(t, ": ").concat(e) : e);
  }
}
var WO = {};
function PU(e, t) {
  if (!WO[e] && WI(!0)) {
    WO[e] = !0;
    var r = "The option '".concat(e, "' will be removed in a future release");
    r += ", use '".concat(t, "' instead."), HI(r, "DeprecationWarning");
  }
}
function TU(e, t, r) {
  var n = new Jr(e);
  if (t instanceof Map) {
    var i = Tt(t), s;
    try {
      for (i.s(); !(s = i.n()).done; ) {
        var o = _p(s.value, 2), a = o[0], l = o[1];
        n.items.push(e.createPair(a, l, r));
      }
    } catch (m) {
      i.e(m);
    } finally {
      i.f();
    }
  } else if (t && mn(t) === "object")
    for (var u = 0, f = Object.keys(t); u < f.length; u++) {
      var d = f[u];
      n.items.push(e.createPair(d, t[d], r));
    }
  return typeof e.sortMapEntries == "function" && n.items.sort(e.sortMapEntries), n;
}
var sp = {
  createNode: TU,
  default: !0,
  nodeClass: Jr,
  tag: "tag:yaml.org,2002:map",
  resolve: II
};
function CU(e, t, r) {
  var n = new Ii(e);
  if (t && t[Symbol.iterator]) {
    var i = Tt(t), s;
    try {
      for (i.s(); !(s = i.n()).done; ) {
        var o = s.value, a = e.createNode(o, r.wrapScalars, null, r);
        n.items.push(a);
      }
    } catch (l) {
      i.e(l);
    } finally {
      i.f();
    }
  }
  return n;
}
var kg = {
  createNode: CU,
  default: !0,
  nodeClass: Ii,
  tag: "tag:yaml.org,2002:seq",
  resolve: NI
}, $U = {
  identify: function(t) {
    return typeof t == "string";
  },
  default: !0,
  tag: "tag:yaml.org,2002:str",
  resolve: Op,
  stringify: function(t, r, n, i) {
    return r = Object.assign({
      actualString: !0
    }, r), LS(t, r, n, i);
  },
  options: bo
}, DS = [sp, kg, $U], Ag = function(t) {
  return typeof t == "bigint" || Number.isInteger(t);
}, FS = function(t, r, n) {
  return cs.asBigInt ? BigInt(t) : parseInt(r, n);
};
function QI(e, t, r) {
  var n = e.value;
  return Ag(n) && n >= 0 ? r + n.toString(t) : co(e);
}
var YI = {
  identify: function(t) {
    return t == null;
  },
  createNode: function(t, r, n) {
    return n.wrapScalars ? new Et(null) : null;
  },
  default: !0,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: function() {
    return null;
  },
  options: zl,
  stringify: function() {
    return zl.nullStr;
  }
}, GI = {
  identify: function(t) {
    return typeof t == "boolean";
  },
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: function(t) {
    return t[0] === "t" || t[0] === "T";
  },
  options: uo,
  stringify: function(t) {
    var r = t.value;
    return r ? uo.trueStr : uo.falseStr;
  }
}, KI = {
  identify: function(t) {
    return Ag(t) && t >= 0;
  },
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o([0-7]+)$/,
  resolve: function(t, r) {
    return FS(t, r, 8);
  },
  options: cs,
  stringify: function(t) {
    return QI(t, 8, "0o");
  }
}, XI = {
  identify: Ag,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: function(t) {
    return FS(t, t, 10);
  },
  options: cs,
  stringify: co
}, JI = {
  identify: function(t) {
    return Ag(t) && t >= 0;
  },
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x([0-9a-fA-F]+)$/,
  resolve: function(t, r) {
    return FS(t, r, 16);
  },
  options: cs,
  stringify: function(t) {
    return QI(t, 16, "0x");
  }
}, ZI = {
  identify: function(t) {
    return typeof t == "number";
  },
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.inf|(\.nan))$/i,
  resolve: function(t, r) {
    return r ? NaN : t[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
  },
  stringify: co
}, eN = {
  identify: function(t) {
    return typeof t == "number";
  },
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: function(t) {
    return parseFloat(t);
  },
  stringify: function(t) {
    var r = t.value;
    return Number(r).toExponential();
  }
}, tN = {
  identify: function(t) {
    return typeof t == "number";
  },
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/,
  resolve: function(t, r, n) {
    var i = r || n, s = new Et(parseFloat(t));
    return i && i[i.length - 1] === "0" && (s.minFractionDigits = i.length), s;
  },
  stringify: co
}, RU = DS.concat([YI, GI, KI, XI, JI, ZI, eN, tN]), HO = function(t) {
  return typeof t == "bigint" || Number.isInteger(t);
}, pd = function(t) {
  var r = t.value;
  return JSON.stringify(r);
}, rN = [sp, kg, {
  identify: function(t) {
    return typeof t == "string";
  },
  default: !0,
  tag: "tag:yaml.org,2002:str",
  resolve: Op,
  stringify: pd
}, {
  identify: function(t) {
    return t == null;
  },
  createNode: function(t, r, n) {
    return n.wrapScalars ? new Et(null) : null;
  },
  default: !0,
  tag: "tag:yaml.org,2002:null",
  test: /^null$/,
  resolve: function() {
    return null;
  },
  stringify: pd
}, {
  identify: function(t) {
    return typeof t == "boolean";
  },
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^true|false$/,
  resolve: function(t) {
    return t === "true";
  },
  stringify: pd
}, {
  identify: HO,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^-?(?:0|[1-9][0-9]*)$/,
  resolve: function(t) {
    return cs.asBigInt ? BigInt(t) : parseInt(t, 10);
  },
  stringify: function(t) {
    var r = t.value;
    return HO(r) ? r.toString() : JSON.stringify(r);
  }
}, {
  identify: function(t) {
    return typeof t == "number";
  },
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
  resolve: function(t) {
    return parseFloat(t);
  },
  stringify: pd
}];
rN.scalarFallback = function(e) {
  throw new SyntaxError("Unresolved plain scalar ".concat(JSON.stringify(e)));
};
var QO = function(t) {
  var r = t.value;
  return r ? uo.trueStr : uo.falseStr;
}, wc = function(t) {
  return typeof t == "bigint" || Number.isInteger(t);
};
function fd(e, t, r) {
  var n = t.replace(/_/g, "");
  if (cs.asBigInt) {
    switch (r) {
      case 2:
        n = "0b".concat(n);
        break;
      case 8:
        n = "0o".concat(n);
        break;
      case 16:
        n = "0x".concat(n);
        break;
    }
    var i = BigInt(n);
    return e === "-" ? BigInt(-1) * i : i;
  }
  var s = parseInt(n, r);
  return e === "-" ? -1 * s : s;
}
function Pv(e, t, r) {
  var n = e.value;
  if (wc(n)) {
    var i = n.toString(t);
    return n < 0 ? "-" + r + i.substr(1) : r + i;
  }
  return co(e);
}
var IU = DS.concat([{
  identify: function(t) {
    return t == null;
  },
  createNode: function(t, r, n) {
    return n.wrapScalars ? new Et(null) : null;
  },
  default: !0,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: function() {
    return null;
  },
  options: zl,
  stringify: function() {
    return zl.nullStr;
  }
}, {
  identify: function(t) {
    return typeof t == "boolean";
  },
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: function() {
    return !0;
  },
  options: uo,
  stringify: QO
}, {
  identify: function(t) {
    return typeof t == "boolean";
  },
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
  resolve: function() {
    return !1;
  },
  options: uo,
  stringify: QO
}, {
  identify: wc,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^([-+]?)0b([0-1_]+)$/,
  resolve: function(t, r, n) {
    return fd(r, n, 2);
  },
  stringify: function(t) {
    return Pv(t, 2, "0b");
  }
}, {
  identify: wc,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^([-+]?)0([0-7_]+)$/,
  resolve: function(t, r, n) {
    return fd(r, n, 8);
  },
  stringify: function(t) {
    return Pv(t, 8, "0");
  }
}, {
  identify: wc,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^([-+]?)([0-9][0-9_]*)$/,
  resolve: function(t, r, n) {
    return fd(r, n, 10);
  },
  stringify: co
}, {
  identify: wc,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^([-+]?)0x([0-9a-fA-F_]+)$/,
  resolve: function(t, r, n) {
    return fd(r, n, 16);
  },
  stringify: function(t) {
    return Pv(t, 16, "0x");
  }
}, {
  identify: function(t) {
    return typeof t == "number";
  },
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.inf|(\.nan))$/i,
  resolve: function(t, r) {
    return r ? NaN : t[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
  },
  stringify: co
}, {
  identify: function(t) {
    return typeof t == "number";
  },
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: function(t) {
    return parseFloat(t.replace(/_/g, ""));
  },
  stringify: function(t) {
    var r = t.value;
    return Number(r).toExponential();
  }
}, {
  identify: function(t) {
    return typeof t == "number";
  },
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,
  resolve: function(t, r) {
    var n = new Et(parseFloat(t.replace(/_/g, "")));
    if (r) {
      var i = r.replace(/_/g, "");
      i[i.length - 1] === "0" && (n.minFractionDigits = i.length);
    }
    return n;
  },
  stringify: co
}], jI, FI, DI, zI, BI, UI, VI), NU = {
  core: RU,
  failsafe: DS,
  json: rN,
  yaml11: IU
}, jU = {
  binary: jI,
  bool: GI,
  float: tN,
  floatExp: eN,
  floatNaN: ZI,
  floatTime: UI,
  int: XI,
  intHex: JI,
  intOct: KI,
  intTime: BI,
  map: sp,
  null: YI,
  omap: FI,
  pairs: DI,
  seq: kg,
  set: zI,
  timestamp: VI
};
function LU(e, t, r) {
  if (t) {
    var n = r.filter(function(s) {
      return s.tag === t;
    }), i = n.find(function(s) {
      return !s.format;
    }) || n[0];
    if (!i) throw new Error("Tag ".concat(t, " not found"));
    return i;
  }
  return r.find(function(s) {
    return (s.identify && s.identify(e) || s.class && e instanceof s.class) && !s.format;
  });
}
function MU(e, t, r) {
  if (e instanceof Kr) return e;
  var n = r.defaultPrefix, i = r.onTagObj, s = r.prevObjects, o = r.schema, a = r.wrapScalars;
  t && t.startsWith("!!") && (t = n + t.slice(2));
  var l = LU(e, t, o.tags);
  if (!l) {
    if (typeof e.toJSON == "function" && (e = e.toJSON()), !e || mn(e) !== "object") return a ? new Et(e) : e;
    l = e instanceof Map ? sp : e[Symbol.iterator] ? kg : sp;
  }
  i && (i(l), delete r.onTagObj);
  var u = {
    value: void 0,
    node: void 0
  };
  if (e && mn(e) === "object" && s) {
    var f = s.get(e);
    if (f) {
      var d = new vo(f);
      return r.aliasNodes.push(d), d;
    }
    u.value = e, s.set(e, u);
  }
  return u.node = l.createNode ? l.createNode(r.schema, e, r) : a ? new Et(e) : e, t && u.node instanceof Kr && (u.node.tag = t), u.node;
}
function DU(e, t, r, n) {
  var i = e[n.replace(/\W/g, "")];
  if (!i) {
    var s = Object.keys(e).map(function(v) {
      return JSON.stringify(v);
    }).join(", ");
    throw new Error('Unknown schema "'.concat(n, '"; use one of ').concat(s));
  }
  if (Array.isArray(r)) {
    var o = Tt(r), a;
    try {
      for (o.s(); !(a = o.n()).done; ) {
        var l = a.value;
        i = i.concat(l);
      }
    } catch (v) {
      o.e(v);
    } finally {
      o.f();
    }
  } else typeof r == "function" && (i = r(i.slice()));
  for (var u = 0; u < i.length; ++u) {
    var f = i[u];
    if (typeof f == "string") {
      var d = t[f];
      if (!d) {
        var m = Object.keys(t).map(function(v) {
          return JSON.stringify(v);
        }).join(", ");
        throw new Error('Unknown custom tag "'.concat(f, '"; use one of ').concat(m));
      }
      i[u] = d;
    }
  }
  return i;
}
var FU = function(t, r) {
  return t.key < r.key ? -1 : t.key > r.key ? 1 : 0;
}, ap = /* @__PURE__ */ function() {
  function e(t) {
    var r = t.customTags, n = t.merge, i = t.schema, s = t.sortMapEntries, o = t.tags;
    dt(this, e), this.merge = !!n, this.name = i, this.sortMapEntries = s === !0 ? FU : s || null, !r && o && PU("tags", "customTags"), this.tags = DU(NU, jU, r || o, i);
  }
  return _t(e, [{
    key: "createNode",
    value: function(r, n, i, s) {
      var o = {
        defaultPrefix: e.defaultPrefix,
        schema: this,
        wrapScalars: n
      }, a = s ? Object.assign(s, o) : o;
      return MU(r, i, a);
    }
  }, {
    key: "createPair",
    value: function(r, n, i) {
      i || (i = {
        wrapScalars: !0
      });
      var s = this.createNode(r, i.wrapScalars, null, i), o = this.createNode(n, i.wrapScalars, null, i);
      return new pt(s, o);
    }
  }]), e;
}();
Nr(ap, "defaultPrefix", Bh);
Nr(ap, "defaultTags", Qo);
var km = {
  anchorPrefix: "a",
  customTags: null,
  indent: 2,
  indentSeq: !0,
  keepCstNodes: !1,
  keepNodeTypes: !0,
  keepBlobsInJSON: !0,
  mapAsMap: !1,
  maxAliasCount: 100,
  prettyErrors: !1,
  // TODO Set true in v2
  simpleKeys: !1,
  version: "1.2"
}, zU = {
  get binary() {
    return Nc;
  },
  set binary(e) {
    Object.assign(Nc, e);
  },
  get bool() {
    return uo;
  },
  set bool(e) {
    Object.assign(uo, e);
  },
  get int() {
    return cs;
  },
  set int(e) {
    Object.assign(cs, e);
  },
  get null() {
    return zl;
  },
  set null(e) {
    Object.assign(zl, e);
  },
  get str() {
    return bo;
  },
  set str(e) {
    Object.assign(bo, e);
  }
}, nN = {
  "1.0": {
    schema: "yaml-1.1",
    merge: !0,
    tagPrefixes: [{
      handle: "!",
      prefix: Bh
    }, {
      handle: "!!",
      prefix: "tag:private.yaml.org,2002:"
    }]
  },
  1.1: {
    schema: "yaml-1.1",
    merge: !0,
    tagPrefixes: [{
      handle: "!",
      prefix: "!"
    }, {
      handle: "!!",
      prefix: Bh
    }]
  },
  1.2: {
    schema: "core",
    merge: !1,
    tagPrefixes: [{
      handle: "!",
      prefix: "!"
    }, {
      handle: "!!",
      prefix: Bh
    }]
  }
};
function YO(e, t) {
  if ((e.version || e.options.version) === "1.0") {
    var r = t.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
    if (r) return "!" + r[1];
    var n = t.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
    return n ? "!".concat(n[1], "/").concat(n[2]) : "!".concat(t.replace(/^tag:/, ""));
  }
  var i = e.tagPrefixes.find(function(a) {
    return t.indexOf(a.prefix) === 0;
  });
  if (!i) {
    var s = e.getDefaults().tagPrefixes;
    i = s && s.find(function(a) {
      return t.indexOf(a.prefix) === 0;
    });
  }
  if (!i) return t[0] === "!" ? t : "!<".concat(t, ">");
  var o = t.substr(i.prefix.length).replace(/[!,[\]{}]/g, function(a) {
    return {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    }[a];
  });
  return i.handle + o;
}
function qU(e, t) {
  if (t instanceof vo) return vo;
  if (t.tag) {
    var r = e.filter(function(a) {
      return a.tag === t.tag;
    });
    if (r.length > 0) return r.find(function(a) {
      return a.format === t.format;
    }) || r[0];
  }
  var n, i;
  if (t instanceof Et) {
    i = t.value;
    var s = e.filter(function(a) {
      return a.identify && a.identify(i) || a.class && i instanceof a.class;
    });
    n = s.find(function(a) {
      return a.format === t.format;
    }) || s.find(function(a) {
      return !a.format;
    });
  } else
    i = t, n = e.find(function(a) {
      return a.nodeClass && i instanceof a.nodeClass;
    });
  if (!n) {
    var o = i && i.constructor ? i.constructor.name : mn(i);
    throw new Error("Tag not resolved for ".concat(o, " value"));
  }
  return n;
}
function BU(e, t, r) {
  var n = r.anchors, i = r.doc, s = [], o = i.anchors.getName(e);
  return o && (n[o] = e, s.push("&".concat(o))), e.tag ? s.push(YO(i, e.tag)) : t.default || s.push(YO(i, t.tag)), s.join(" ");
}
function dd(e, t, r, n) {
  var i = t.doc, s = i.anchors, o = i.schema, a;
  if (!(e instanceof Kr)) {
    var l = {
      aliasNodes: [],
      onTagObj: function(E) {
        return a = E;
      },
      prevObjects: /* @__PURE__ */ new Map()
    };
    e = o.createNode(e, !0, null, l);
    var u = Tt(l.aliasNodes), f;
    try {
      for (u.s(); !(f = u.n()).done; ) {
        var d = f.value;
        d.source = d.source.node;
        var m = s.getName(d.source);
        m || (m = s.newName(), s.map[m] = d.source);
      }
    } catch (y) {
      u.e(y);
    } finally {
      u.f();
    }
  }
  if (e instanceof pt) return e.toString(t, r, n);
  a || (a = qU(o.tags, e));
  var v = BU(e, a, t);
  v.length > 0 && (t.indentAtStart = (t.indentAtStart || 0) + v.length + 1);
  var S = typeof a.stringify == "function" ? a.stringify(e, t, r, n) : e instanceof Et ? LS(e, t, r, n) : e.toString(t, r, n);
  return v ? e instanceof Et || S[0] === "{" || S[0] === "[" ? "".concat(v, " ").concat(S) : "".concat(v, `
`).concat(t.indent).concat(S) : S;
}
var UU = /* @__PURE__ */ function() {
  function e(t) {
    dt(this, e), Nr(this, "map", /* @__PURE__ */ Object.create(null)), this.prefix = t;
  }
  return _t(e, [{
    key: "createAlias",
    value: function(r, n) {
      return this.setAnchor(r, n), new vo(r);
    }
  }, {
    key: "createMergePair",
    value: function() {
      for (var r = this, n = new kI(), i = arguments.length, s = new Array(i), o = 0; o < i; o++)
        s[o] = arguments[o];
      return n.value.items = s.map(function(a) {
        if (a instanceof vo) {
          if (a.source instanceof Jr) return a;
        } else if (a instanceof Jr)
          return r.createAlias(a);
        throw new Error("Merge sources must be Map nodes or their Aliases");
      }), n;
    }
  }, {
    key: "getName",
    value: function(r) {
      var n = this.map;
      return Object.keys(n).find(function(i) {
        return n[i] === r;
      });
    }
  }, {
    key: "getNames",
    value: function() {
      return Object.keys(this.map);
    }
  }, {
    key: "getNode",
    value: function(r) {
      return this.map[r];
    }
  }, {
    key: "newName",
    value: function(r) {
      r || (r = this.prefix);
      for (var n = Object.keys(this.map), i = 1; ; ++i) {
        var s = "".concat(r).concat(i);
        if (!n.includes(s)) return s;
      }
    }
    // During parsing, map & aliases contain CST nodes
  }, {
    key: "resolveNodes",
    value: function() {
      var r = this.map, n = this._cstAliases;
      Object.keys(r).forEach(function(i) {
        r[i] = r[i].resolved;
      }), n.forEach(function(i) {
        i.source = i.source.resolved;
      }), delete this._cstAliases;
    }
  }, {
    key: "setAnchor",
    value: function(r, n) {
      if (r != null && !e.validAnchorNode(r))
        throw new Error("Anchors may only be set for Scalar, Seq and Map nodes");
      if (n && /[\x00-\x19\s,[\]{}]/.test(n))
        throw new Error("Anchor names must not contain whitespace or control characters");
      var i = this.map, s = r && Object.keys(i).find(function(o) {
        return i[o] === r;
      });
      if (s)
        if (n)
          s !== n && (delete i[s], i[n] = r);
        else return s;
      else {
        if (!n) {
          if (!r) return null;
          n = this.newName();
        }
        i[n] = r;
      }
      return n;
    }
  }], [{
    key: "validAnchorNode",
    value: function(r) {
      return r instanceof Et || r instanceof Ii || r instanceof Jr;
    }
  }]), e;
}(), VU = function e(t, r) {
  if (t && mn(t) === "object") {
    var n = t.tag;
    t instanceof Er ? (n && (r[n] = !0), t.items.forEach(function(i) {
      return e(i, r);
    })) : t instanceof pt ? (e(t.key, r), e(t.value, r)) : t instanceof Et && n && (r[n] = !0);
  }
  return r;
}, WU = function(t) {
  return Object.keys(VU(t, {}));
};
function HU(e, t) {
  var r = {
    before: [],
    after: []
  }, n = void 0, i = !1, s = Tt(t), o;
  try {
    for (s.s(); !(o = s.n()).done; ) {
      var a = o.value;
      if (a.valueRange) {
        if (n !== void 0) {
          var l = "Document contains trailing content not separated by a ... or --- line";
          e.errors.push(new jr(a, l));
          break;
        }
        var u = os(e, a);
        i && (u.spaceBefore = !0, i = !1), n = u;
      } else if (a.comment !== null) {
        var f = n === void 0 ? r.before : r.after;
        f.push(a.comment);
      } else a.type === xe.BLANK_LINE && (i = !0, n === void 0 && r.before.length > 0 && !e.commentBefore && (e.commentBefore = r.before.join(`
`), r.before = []));
    }
  } catch (v) {
    s.e(v);
  } finally {
    s.f();
  }
  if (e.contents = n || null, !n)
    e.comment = r.before.concat(r.after).join(`
`) || null;
  else {
    var d = r.before.join(`
`);
    if (d) {
      var m = n instanceof Er && n.items[0] ? n.items[0] : n;
      m.commentBefore = m.commentBefore ? "".concat(d, `
`).concat(m.commentBefore) : d;
    }
    e.comment = r.after.join(`
`) || null;
  }
}
function QU(e, t) {
  var r = e.tagPrefixes, n = _p(t.parameters, 2), i = n[0], s = n[1];
  if (!i || !s) {
    var o = "Insufficient parameters given for %TAG directive";
    throw new nt(t, o);
  }
  if (r.some(function(l) {
    return l.handle === i;
  })) {
    var a = "The %TAG directive must only be given at most once per handle in the same document.";
    throw new nt(t, a);
  }
  return {
    handle: i,
    prefix: s
  };
}
function YU(e, t) {
  var r = _p(t.parameters, 1), n = r[0];
  if (t.name === "YAML:1.0" && (n = "1.0"), !n) {
    var i = "Insufficient parameters given for %YAML directive";
    throw new nt(t, i);
  }
  if (!nN[n]) {
    var s = e.version || e.options.version, o = "Document will be parsed as YAML ".concat(s, " rather than YAML ").concat(n);
    e.warnings.push(new tu(t, o));
  }
  return n;
}
function GU(e, t, r) {
  var n = [], i = !1, s = Tt(t), o;
  try {
    for (s.s(); !(o = s.n()).done; ) {
      var a = o.value, l = a.comment, u = a.name;
      switch (u) {
        case "TAG":
          try {
            e.tagPrefixes.push(QU(e, a));
          } catch (v) {
            e.errors.push(v);
          }
          i = !0;
          break;
        case "YAML":
        case "YAML:1.0":
          if (e.version) {
            var f = "The %YAML directive must only be given at most once per document.";
            e.errors.push(new nt(a, f));
          }
          try {
            e.version = YU(e, a);
          } catch (v) {
            e.errors.push(v);
          }
          i = !0;
          break;
        default:
          if (u) {
            var d = "YAML only supports %TAG and %YAML directives, and not %".concat(u);
            e.warnings.push(new tu(a, d));
          }
      }
      l && n.push(l);
    }
  } catch (v) {
    s.e(v);
  } finally {
    s.f();
  }
  if (r && !i && (e.version || r.version || e.options.version) === "1.1") {
    var m = function(S) {
      var y = S.handle, E = S.prefix;
      return {
        handle: y,
        prefix: E
      };
    };
    e.tagPrefixes = r.tagPrefixes.map(m), e.version = r.version;
  }
  e.commentBefore = n.join(`
`) || null;
}
function Ka(e) {
  if (e instanceof Er) return !0;
  throw new Error("Expected a YAML collection as document contents");
}
var zS = /* @__PURE__ */ function() {
  function e(t) {
    dt(this, e), this.anchors = new UU(t.anchorPrefix), this.commentBefore = null, this.comment = null, this.contents = null, this.directivesEndMarker = null, this.errors = [], this.options = t, this.schema = null, this.tagPrefixes = [], this.version = null, this.warnings = [];
  }
  return _t(e, [{
    key: "add",
    value: function(r) {
      return Ka(this.contents), this.contents.add(r);
    }
  }, {
    key: "addIn",
    value: function(r, n) {
      Ka(this.contents), this.contents.addIn(r, n);
    }
  }, {
    key: "delete",
    value: function(r) {
      return Ka(this.contents), this.contents.delete(r);
    }
  }, {
    key: "deleteIn",
    value: function(r) {
      return bc(r) ? this.contents == null ? !1 : (this.contents = null, !0) : (Ka(this.contents), this.contents.deleteIn(r));
    }
  }, {
    key: "getDefaults",
    value: function() {
      return e.defaults[this.version] || e.defaults[this.options.version] || {};
    }
  }, {
    key: "get",
    value: function(r, n) {
      return this.contents instanceof Er ? this.contents.get(r, n) : void 0;
    }
  }, {
    key: "getIn",
    value: function(r, n) {
      return bc(r) ? !n && this.contents instanceof Et ? this.contents.value : this.contents : this.contents instanceof Er ? this.contents.getIn(r, n) : void 0;
    }
  }, {
    key: "has",
    value: function(r) {
      return this.contents instanceof Er ? this.contents.has(r) : !1;
    }
  }, {
    key: "hasIn",
    value: function(r) {
      return bc(r) ? this.contents !== void 0 : this.contents instanceof Er ? this.contents.hasIn(r) : !1;
    }
  }, {
    key: "set",
    value: function(r, n) {
      Ka(this.contents), this.contents.set(r, n);
    }
  }, {
    key: "setIn",
    value: function(r, n) {
      bc(r) ? this.contents = n : (Ka(this.contents), this.contents.setIn(r, n));
    }
  }, {
    key: "setSchema",
    value: function(r, n) {
      if (!(!r && !n && this.schema)) {
        typeof r == "number" && (r = r.toFixed(1)), r === "1.0" || r === "1.1" || r === "1.2" ? (this.version ? this.version = r : this.options.version = r, delete this.options.schema) : r && typeof r == "string" && (this.options.schema = r), Array.isArray(n) && (this.options.customTags = n);
        var i = Object.assign({}, this.getDefaults(), this.options);
        this.schema = new ap(i);
      }
    }
  }, {
    key: "parse",
    value: function(r, n) {
      this.options.keepCstNodes && (this.cstNode = r), this.options.keepNodeTypes && (this.type = "DOCUMENT");
      var i = r.directives, s = i === void 0 ? [] : i, o = r.contents, a = o === void 0 ? [] : o, l = r.directivesEndMarker, u = r.error, f = r.valueRange;
      if (u && (u.source || (u.source = this), this.errors.push(u)), GU(this, s, n), l && (this.directivesEndMarker = !0), this.range = f ? [f.start, f.end] : null, this.setSchema(), this.anchors._cstAliases = [], HU(this, a), this.anchors.resolveNodes(), this.options.prettyErrors) {
        var d = Tt(this.errors), m;
        try {
          for (d.s(); !(m = d.n()).done; ) {
            var v = m.value;
            v instanceof Fl && v.makePretty();
          }
        } catch (x) {
          d.e(x);
        } finally {
          d.f();
        }
        var S = Tt(this.warnings), y;
        try {
          for (S.s(); !(y = S.n()).done; ) {
            var E = y.value;
            E instanceof Fl && E.makePretty();
          }
        } catch (x) {
          S.e(x);
        } finally {
          S.f();
        }
      }
      return this;
    }
  }, {
    key: "listNonDefaultTags",
    value: function() {
      return WU(this.contents).filter(function(r) {
        return r.indexOf(ap.defaultPrefix) !== 0;
      });
    }
  }, {
    key: "setTagPrefix",
    value: function(r, n) {
      if (r[0] !== "!" || r[r.length - 1] !== "!") throw new Error("Handle must start and end with !");
      if (n) {
        var i = this.tagPrefixes.find(function(s) {
          return s.handle === r;
        });
        i ? i.prefix = n : this.tagPrefixes.push({
          handle: r,
          prefix: n
        });
      } else
        this.tagPrefixes = this.tagPrefixes.filter(function(s) {
          return s.handle !== r;
        });
    }
  }, {
    key: "toJSON",
    value: function(r, n) {
      var i = this, s = this.options, o = s.keepBlobsInJSON, a = s.mapAsMap, l = s.maxAliasCount, u = o && (typeof r != "string" || !(this.contents instanceof Et)), f = {
        doc: this,
        indentStep: "  ",
        keep: u,
        mapAsMap: u && !!a,
        maxAliasCount: l,
        stringify: dd
        // Requiring directly in Pair would create circular dependencies
      }, d = Object.keys(this.anchors.map);
      d.length > 0 && (f.anchors = new Map(d.map(function(g) {
        return [i.anchors.map[g], {
          alias: [],
          aliasCount: 0,
          count: 1
        }];
      })));
      var m = ri(this.contents, r, f);
      if (typeof n == "function" && f.anchors) {
        var v = Tt(f.anchors.values()), S;
        try {
          for (v.s(); !(S = v.n()).done; ) {
            var y = S.value, E = y.count, x = y.res;
            n(x, E);
          }
        } catch (g) {
          v.e(g);
        } finally {
          v.f();
        }
      }
      return m;
    }
  }, {
    key: "toString",
    value: function() {
      if (this.errors.length > 0) throw new Error("Document with errors cannot be stringified");
      var r = this.options.indent;
      if (!Number.isInteger(r) || r <= 0) {
        var n = JSON.stringify(r);
        throw new Error('"indent" option must be a positive integer, not '.concat(n));
      }
      this.setSchema();
      var i = [], s = !1;
      if (this.version) {
        var o = "%YAML 1.2";
        this.schema.name === "yaml-1.1" && (this.version === "1.0" ? o = "%YAML:1.0" : this.version === "1.1" && (o = "%YAML 1.1")), i.push(o), s = !0;
      }
      var a = this.listNonDefaultTags();
      this.tagPrefixes.forEach(function(v) {
        var S = v.handle, y = v.prefix;
        a.some(function(E) {
          return E.indexOf(y) === 0;
        }) && (i.push("%TAG ".concat(S, " ").concat(y)), s = !0);
      }), (s || this.directivesEndMarker) && i.push("---"), this.commentBefore && ((s || !this.directivesEndMarker) && i.unshift(""), i.unshift(this.commentBefore.replace(/^/gm, "#")));
      var l = {
        anchors: /* @__PURE__ */ Object.create(null),
        doc: this,
        indent: "",
        indentStep: " ".repeat(r),
        stringify: dd
        // Requiring directly in nodes would create circular dependencies
      }, u = !1, f = null;
      if (this.contents) {
        this.contents instanceof Kr && (this.contents.spaceBefore && (s || this.directivesEndMarker) && i.push(""), this.contents.commentBefore && i.push(this.contents.commentBefore.replace(/^/gm, "#")), l.forceBlockIndent = !!this.comment, f = this.contents.comment);
        var d = f ? null : function() {
          return u = !0;
        }, m = dd(this.contents, l, function() {
          return f = null;
        }, d);
        i.push(bl(m, "", f));
      } else this.contents !== void 0 && i.push(dd(this.contents, l));
      return this.comment && ((!u || f) && i[i.length - 1] !== "" && i.push(""), i.push(this.comment.replace(/^/gm, "#"))), i.join(`
`) + `
`;
    }
  }]), e;
}();
Nr(zS, "defaults", nN);
function KU(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, r = arguments.length > 2 ? arguments[2] : void 0;
  r === void 0 && typeof t == "string" && (r = t, t = !0);
  var n = Object.assign({}, zS.defaults[km.version], km), i = new ap(n);
  return i.createNode(e, t, r);
}
var Pg = /* @__PURE__ */ function(e) {
  Ct(r, e);
  var t = $t(r);
  function r(n) {
    return dt(this, r), t.call(this, Object.assign({}, km, n));
  }
  return r;
}(zS);
function XU(e, t) {
  var r = [], n, i = Tt(IS(e)), s;
  try {
    for (i.s(); !(s = i.n()).done; ) {
      var o = s.value, a = new Pg(t);
      a.parse(o, n), r.push(a), n = a;
    }
  } catch (l) {
    i.e(l);
  } finally {
    i.f();
  }
  return r;
}
function iN(e, t) {
  var r = IS(e), n = new Pg(t).parse(r[0]);
  if (r.length > 1) {
    var i = "Source contains multiple documents; please use YAML.parseAllDocuments()";
    n.errors.unshift(new nt(r[1], i));
  }
  return n;
}
function JU(e, t) {
  var r = iN(e, t);
  if (r.warnings.forEach(function(n) {
    return HI(n);
  }), r.errors.length > 0) throw r.errors[0];
  return r.toJSON();
}
function ZU(e, t) {
  var r = new Pg(t);
  return r.contents = e, String(r);
}
var e5 = {
  createNode: KU,
  defaultOptions: km,
  Document: Pg,
  parse: JU,
  parseAllDocuments: XU,
  parseCST: IS,
  parseDocument: iN,
  scalarOptions: zU,
  stringify: ZU
};
const t5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  YAML: e5
}, Symbol.toStringTag, { value: "Module" })), r5 = /* @__PURE__ */ Di(t5);
var Tv, GO;
function n5() {
  return GO || (GO = 1, Tv = r5.YAML), Tv;
}
function It() {
  return It = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r) ({}).hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, It.apply(null, arguments);
}
function i5(e) {
  if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function lp(e, t) {
  return lp = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, n) {
    return r.__proto__ = n, r;
  }, lp(e, t);
}
function o5(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, lp(e, t);
}
function K0(e) {
  return K0 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, K0(e);
}
function s5(e) {
  try {
    return Function.toString.call(e).indexOf("[native code]") !== -1;
  } catch {
    return typeof e == "function";
  }
}
function oN() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (oN = function() {
    return !!e;
  })();
}
function a5(e, t, r) {
  if (oN()) return Reflect.construct.apply(null, arguments);
  var n = [null];
  n.push.apply(n, t);
  var i = new (e.bind.apply(e, n))();
  return r && lp(i, r.prototype), i;
}
function X0(e) {
  var t = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return X0 = function(n) {
    if (n === null || !s5(n)) return n;
    if (typeof n != "function") throw new TypeError("Super expression must either be null or a function");
    if (t !== void 0) {
      if (t.has(n)) return t.get(n);
      t.set(n, i);
    }
    function i() {
      return a5(n, arguments, K0(this).constructor);
    }
    return i.prototype = Object.create(n.prototype, {
      constructor: {
        value: i,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), lp(i, n);
  }, X0(e);
}
function sN(e, t) {
  return t || (t = e.slice(0)), e.raw = t, e;
}
function KO() {
  var e;
  return e = arguments.length - 1, e < 0 || arguments.length <= e ? void 0 : arguments[e];
}
function l5(e) {
  return -e;
}
function u5(e, t) {
  return e + t;
}
function c5(e, t) {
  return e - t;
}
function p5(e, t) {
  return e * t;
}
function f5(e, t) {
  return e / t;
}
function d5() {
  return Math.max.apply(Math, arguments);
}
function h5() {
  return Math.min.apply(Math, arguments);
}
function m5() {
  return Array.of.apply(Array, arguments);
}
var g5 = {
  symbols: {
    "*": {
      infix: {
        symbol: "*",
        f: p5,
        notation: "infix",
        precedence: 4,
        rightToLeft: 0,
        argCount: 2
      },
      symbol: "*",
      regSymbol: "\\*"
    },
    "/": {
      infix: {
        symbol: "/",
        f: f5,
        notation: "infix",
        precedence: 4,
        rightToLeft: 0,
        argCount: 2
      },
      symbol: "/",
      regSymbol: "/"
    },
    "+": {
      infix: {
        symbol: "+",
        f: u5,
        notation: "infix",
        precedence: 2,
        rightToLeft: 0,
        argCount: 2
      },
      prefix: {
        symbol: "+",
        f: KO,
        notation: "prefix",
        precedence: 3,
        rightToLeft: 0,
        argCount: 1
      },
      symbol: "+",
      regSymbol: "\\+"
    },
    "-": {
      infix: {
        symbol: "-",
        f: c5,
        notation: "infix",
        precedence: 2,
        rightToLeft: 0,
        argCount: 2
      },
      prefix: {
        symbol: "-",
        f: l5,
        notation: "prefix",
        precedence: 3,
        rightToLeft: 0,
        argCount: 1
      },
      symbol: "-",
      regSymbol: "-"
    },
    ",": {
      infix: {
        symbol: ",",
        f: m5,
        notation: "infix",
        precedence: 1,
        rightToLeft: 0,
        argCount: 2
      },
      symbol: ",",
      regSymbol: ","
    },
    "(": {
      prefix: {
        symbol: "(",
        f: KO,
        notation: "prefix",
        precedence: 0,
        rightToLeft: 0,
        argCount: 1
      },
      symbol: "(",
      regSymbol: "\\("
    },
    ")": {
      postfix: {
        symbol: ")",
        f: void 0,
        notation: "postfix",
        precedence: 0,
        rightToLeft: 0,
        argCount: 1
      },
      symbol: ")",
      regSymbol: "\\)"
    },
    min: {
      func: {
        symbol: "min",
        f: h5,
        notation: "func",
        precedence: 0,
        rightToLeft: 0,
        argCount: 1
      },
      symbol: "min",
      regSymbol: "min\\b"
    },
    max: {
      func: {
        symbol: "max",
        f: d5,
        notation: "func",
        precedence: 0,
        rightToLeft: 0,
        argCount: 1
      },
      symbol: "max",
      regSymbol: "max\\b"
    }
  }
}, XO = g5, Xe = /* @__PURE__ */ function(e) {
  o5(t, e);
  function t(r) {
    var n;
    return n = e.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + r + " for more information.") || this, i5(n);
  }
  return t;
}(/* @__PURE__ */ X0(Error)), JO = /((?!\w)a|na|hc|mc|dg|me[r]?|xe|ni(?![a-zA-Z])|mm|cp|tp|xp|q(?!s)|hv|xamv|nimv|wv|sm|s(?!\D|$)|ged|darg?|nrut)/g;
function y5(e) {
  var t = {};
  return t.symbols = e ? It({}, XO.symbols, e.symbols) : It({}, XO.symbols), t;
}
function ZO(e, t) {
  var r, n = e.pop();
  return t.push(n.f.apply(n, (r = []).concat.apply(r, t.splice(-n.argCount)))), n.precedence;
}
function v5(e, t) {
  var r = y5(t), n, i = [r.symbols["("].prefix], s = [], o = new RegExp(
    // Pattern for numbers
    "\\d+(?:\\.\\d+)?|" + // ...and patterns for individual operators/function names
    Object.keys(r.symbols).map(function(E) {
      return r.symbols[E];
    }).sort(function(E, x) {
      return x.symbol.length - E.symbol.length;
    }).map(function(E) {
      return E.regSymbol;
    }).join("|") + "|(\\S)",
    "g"
  );
  o.lastIndex = 0;
  var a = !1;
  do {
    n = o.exec(e);
    var l = n || [")", void 0], u = l[0], f = l[1], d = r.symbols[u], m = d && !d.prefix && !d.func, v = !d || !d.postfix && !d.infix;
    if (f || (a ? v : m))
      throw new Xe(37, n ? n.index : e.length, e);
    if (a) {
      var S = d.postfix || d.infix;
      do {
        var y = i[i.length - 1];
        if ((S.precedence - y.precedence || y.rightToLeft) > 0) break;
      } while (ZO(i, s));
      a = S.notation === "postfix", S.symbol !== ")" && (i.push(S), a && ZO(i, s));
    } else if (d) {
      if (i.push(d.prefix || d.func), d.func && (n = o.exec(e), !n || n[0] !== "("))
        throw new Xe(38, n ? n.index : e.length, e);
    } else
      s.push(+u), a = !0;
  } while (n && i.length);
  if (i.length)
    throw new Xe(39, n ? n.index : e.length, e);
  if (n)
    throw new Xe(40, n ? n.index : e.length, e);
  return s.pop();
}
function Cv(e) {
  return e.split("").reverse().join("");
}
function b5(e, t) {
  var r = Cv(e), n = r.match(JO);
  if (n && !n.every(function(s) {
    return s === n[0];
  }))
    throw new Xe(41);
  var i = Cv(r.replace(JO, ""));
  return "" + v5(i, t) + (n ? Cv(n[0]) : "");
}
var w5 = /--[\S]*/g;
function S5(e, t) {
  if (!e || !e.match(w5))
    throw new Xe(73);
  var r;
  if (typeof document < "u" && document.documentElement !== null && (r = getComputedStyle(document.documentElement).getPropertyValue(e)), r)
    return r.trim();
  if (t)
    return t;
  throw new Xe(74);
}
function jc(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
var x5 = ["Top", "Right", "Bottom", "Left"];
function E5(e, t) {
  if (!e) return t.toLowerCase();
  var r = e.split("-");
  if (r.length > 1)
    return r.splice(1, 0, t), r.reduce(function(i, s) {
      return "" + i + jc(s);
    });
  var n = e.replace(/([a-z])([A-Z])/g, "$1" + t + "$2");
  return e === n ? "" + e + t : n;
}
function _5(e, t) {
  for (var r = {}, n = 0; n < t.length; n += 1)
    (t[n] || t[n] === 0) && (r[E5(e, x5[n])] = t[n]);
  return r;
}
function ps(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    r[n - 1] = arguments[n];
  var i = r[0], s = r[1], o = s === void 0 ? i : s, a = r[2], l = a === void 0 ? i : a, u = r[3], f = u === void 0 ? o : u, d = [i, o, l, f];
  return _5(e, d);
}
function ek(e, t) {
  return e.substr(-t.length) === t;
}
var O5 = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/;
function J0(e) {
  if (typeof e != "string") return e;
  var t = e.match(O5);
  return t ? parseFloat(e) : e;
}
var k5 = function(t) {
  return function(r, n) {
    n === void 0 && (n = "16px");
    var i = r, s = n;
    if (typeof r == "string") {
      if (!ek(r, "px"))
        throw new Xe(69, t, r);
      i = J0(r);
    }
    if (typeof n == "string") {
      if (!ek(n, "px"))
        throw new Xe(70, t, n);
      s = J0(n);
    }
    if (typeof i == "string")
      throw new Xe(71, r, t);
    if (typeof s == "string")
      throw new Xe(72, n, t);
    return "" + i / s + t;
  };
}, aN = k5, A5 = aN("em"), P5 = A5, T5 = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/;
function Ai(e) {
  if (typeof e != "string") return [e, ""];
  var t = e.match(T5);
  return t ? [parseFloat(e), t[2]] : [e, void 0];
}
function lN(e, t) {
  if (typeof e != "object" || e === null)
    throw new Xe(75, typeof e);
  var r = {};
  return Object.keys(e).forEach(function(n) {
    typeof e[n] == "object" && e[n] !== null ? r[n] = lN(e[n], t) : !t || t && (t === n || t.indexOf(n) >= 0) ? r[n] = e[n] + " !important" : r[n] = e[n];
  }), r;
}
var uN = {
  minorSecond: 1.067,
  majorSecond: 1.125,
  minorThird: 1.2,
  majorThird: 1.25,
  perfectFourth: 1.333,
  augFourth: 1.414,
  perfectFifth: 1.5,
  minorSixth: 1.6,
  goldenSection: 1.618,
  majorSixth: 1.667,
  minorSeventh: 1.778,
  majorSeventh: 1.875,
  octave: 2,
  majorTenth: 2.5,
  majorEleventh: 2.667,
  majorTwelfth: 3,
  doubleOctave: 4
};
function C5(e) {
  return uN[e];
}
function $5(e, t, r) {
  if (t === void 0 && (t = "1em"), r === void 0 && (r = 1.333), typeof e != "number")
    throw new Xe(42);
  if (typeof r == "string" && !uN[r])
    throw new Xe(43);
  var n = typeof t == "string" ? Ai(t) : [t, ""], i = n[0], s = n[1], o = typeof r == "string" ? C5(r) : r;
  if (typeof i == "string")
    throw new Xe(44, t);
  return "" + i * Math.pow(o, e) + (s || "");
}
var R5 = aN("rem"), I5 = R5, Z0 = 16;
function cN(e) {
  var t = Ai(e);
  if (t[1] === "px")
    return parseFloat(e);
  if (t[1] === "%")
    return parseFloat(e) / 100 * Z0;
  throw new Xe(78, t[1]);
}
function N5() {
  if (typeof document < "u" && document.documentElement !== null) {
    var e = getComputedStyle(document.documentElement).fontSize;
    return e ? cN(e) : Z0;
  }
  return Z0;
}
function j5(e, t) {
  var r = Ai(e);
  if (r[1] !== "rem" && r[1] !== "")
    throw new Xe(77, r[1]);
  var n = t ? cN(t) : N5();
  return r[0] * n + "px";
}
var L5 = {
  back: "cubic-bezier(0.600, -0.280, 0.735, 0.045)",
  circ: "cubic-bezier(0.600,  0.040, 0.980, 0.335)",
  cubic: "cubic-bezier(0.550,  0.055, 0.675, 0.190)",
  expo: "cubic-bezier(0.950,  0.050, 0.795, 0.035)",
  quad: "cubic-bezier(0.550,  0.085, 0.680, 0.530)",
  quart: "cubic-bezier(0.895,  0.030, 0.685, 0.220)",
  quint: "cubic-bezier(0.755,  0.050, 0.855, 0.060)",
  sine: "cubic-bezier(0.470,  0.000, 0.745, 0.715)"
};
function M5(e) {
  return L5[e.toLowerCase().trim()];
}
var D5 = {
  back: "cubic-bezier(0.680, -0.550, 0.265, 1.550)",
  circ: "cubic-bezier(0.785,  0.135, 0.150, 0.860)",
  cubic: "cubic-bezier(0.645,  0.045, 0.355, 1.000)",
  expo: "cubic-bezier(1.000,  0.000, 0.000, 1.000)",
  quad: "cubic-bezier(0.455,  0.030, 0.515, 0.955)",
  quart: "cubic-bezier(0.770,  0.000, 0.175, 1.000)",
  quint: "cubic-bezier(0.860,  0.000, 0.070, 1.000)",
  sine: "cubic-bezier(0.445,  0.050, 0.550, 0.950)"
};
function F5(e) {
  return D5[e.toLowerCase().trim()];
}
var z5 = {
  back: "cubic-bezier(0.175,  0.885, 0.320, 1.275)",
  cubic: "cubic-bezier(0.215,  0.610, 0.355, 1.000)",
  circ: "cubic-bezier(0.075,  0.820, 0.165, 1.000)",
  expo: "cubic-bezier(0.190,  1.000, 0.220, 1.000)",
  quad: "cubic-bezier(0.250,  0.460, 0.450, 0.940)",
  quart: "cubic-bezier(0.165,  0.840, 0.440, 1.000)",
  quint: "cubic-bezier(0.230,  1.000, 0.320, 1.000)",
  sine: "cubic-bezier(0.390,  0.575, 0.565, 1.000)"
};
function q5(e) {
  return z5[e.toLowerCase().trim()];
}
function ew(e, t, r, n) {
  r === void 0 && (r = "320px"), n === void 0 && (n = "1200px");
  var i = Ai(e), s = i[0], o = i[1], a = Ai(t), l = a[0], u = a[1], f = Ai(r), d = f[0], m = f[1], v = Ai(n), S = v[0], y = v[1];
  if (typeof d != "number" || typeof S != "number" || !m || !y || m !== y)
    throw new Xe(47);
  if (typeof s != "number" || typeof l != "number" || o !== u)
    throw new Xe(48);
  if (o !== m || u !== y)
    throw new Xe(76);
  var E = (s - l) / (d - S), x = l - E * S;
  return "calc(" + x.toFixed(2) + (o || "") + " + " + (100 * E).toFixed(2) + "vw)";
}
function B5(e) {
  var t;
  e === void 0 && (e = "&");
  var r = e + "::after";
  return t = {}, t[r] = {
    clear: "both",
    content: '""',
    display: "table"
  }, t;
}
function U5(e) {
  return e === void 0 && (e = 0), {
    position: "absolute",
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function V5(e, t) {
  t === void 0 && (t = 1);
  var r = {
    display: "inline-block",
    maxWidth: e || "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    wordWrap: "normal"
  };
  return t > 1 ? It({}, r, {
    WebkitBoxOrient: "vertical",
    WebkitLineClamp: t,
    display: "-webkit-box",
    whiteSpace: "normal"
  }) : r;
}
function W5(e, t) {
  var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r) return (r = r.call(e)).next.bind(r);
  if (Array.isArray(e) || (r = H5(e)) || t) {
    r && (e = r);
    var n = 0;
    return function() {
      return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
    };
  }
  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function H5(e, t) {
  if (e) {
    if (typeof e == "string") return tk(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return tk(e, t);
  }
}
function tk(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function Q5(e, t, r) {
  if (t === void 0 && (t = "320px"), r === void 0 && (r = "1200px"), !Array.isArray(e) && typeof e != "object" || e === null)
    throw new Xe(49);
  if (Array.isArray(e)) {
    for (var n = {}, i = {}, s = W5(e), o; !(o = s()).done; ) {
      var a, l, u = o.value;
      if (!u.prop || !u.fromSize || !u.toSize)
        throw new Xe(50);
      i[u.prop] = u.fromSize, n["@media (min-width: " + t + ")"] = It({}, n["@media (min-width: " + t + ")"], (a = {}, a[u.prop] = ew(u.fromSize, u.toSize, t, r), a)), n["@media (min-width: " + r + ")"] = It({}, n["@media (min-width: " + r + ")"], (l = {}, l[u.prop] = u.toSize, l));
    }
    return It({}, i, n);
  } else {
    var f, d, m;
    if (!e.prop || !e.fromSize || !e.toSize)
      throw new Xe(51);
    return m = {}, m[e.prop] = e.fromSize, m["@media (min-width: " + t + ")"] = (f = {}, f[e.prop] = ew(e.fromSize, e.toSize, t, r), f), m["@media (min-width: " + r + ")"] = (d = {}, d[e.prop] = e.toSize, d), m;
  }
}
var Y5 = /^\s*data:([a-z]+\/[a-z-]+(;[a-z-]+=[a-z-]+)?)?(;charset=[a-z0-9-]+)?(;base64)?,[a-z0-9!$&',()*+,;=\-._~:@/?%\s]*\s*$/i, G5 = {
  woff: "woff",
  woff2: "woff2",
  ttf: "truetype",
  otf: "opentype",
  eot: "embedded-opentype",
  svg: "svg",
  svgz: "svg"
};
function rk(e, t) {
  return t ? ' format("' + G5[e] + '")' : "";
}
function K5(e) {
  return !!e.replace(/\s+/g, " ").match(Y5);
}
function X5(e, t, r) {
  if (K5(e))
    return 'url("' + e + '")' + rk(t[0], r);
  var n = t.map(function(i) {
    return 'url("' + e + "." + i + '")' + rk(i, r);
  });
  return n.join(", ");
}
function J5(e) {
  var t = e.map(function(r) {
    return 'local("' + r + '")';
  });
  return t.join(", ");
}
function Z5(e, t, r, n) {
  var i = [];
  return t && i.push(J5(t)), e && i.push(X5(e, r, n)), i.join(", ");
}
function e4(e) {
  var t = e.fontFamily, r = e.fontFilePath, n = e.fontStretch, i = e.fontStyle, s = e.fontVariant, o = e.fontWeight, a = e.fileFormats, l = a === void 0 ? ["eot", "woff2", "woff", "ttf", "svg"] : a, u = e.formatHint, f = u === void 0 ? !1 : u, d = e.localFonts, m = d === void 0 ? [t] : d, v = e.unicodeRange, S = e.fontDisplay, y = e.fontVariationSettings, E = e.fontFeatureSettings;
  if (!t) throw new Xe(55);
  if (!r && !m)
    throw new Xe(52);
  if (m && !Array.isArray(m))
    throw new Xe(53);
  if (!Array.isArray(l))
    throw new Xe(54);
  var x = {
    "@font-face": {
      fontFamily: t,
      src: Z5(r, m, l, f),
      unicodeRange: v,
      fontStretch: n,
      fontStyle: i,
      fontVariant: s,
      fontWeight: o,
      fontDisplay: S,
      fontVariationSettings: y,
      fontFeatureSettings: E
    }
  };
  return JSON.parse(JSON.stringify(x));
}
function t4() {
  return {
    textIndent: "101%",
    overflow: "hidden",
    whiteSpace: "nowrap"
  };
}
function r4() {
  return {
    border: "0",
    clip: "rect(0 0 0 0)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: "0",
    position: "absolute",
    whiteSpace: "nowrap",
    width: "1px"
  };
}
function pN(e) {
  return e === void 0 && (e = 1.3), `
    @media only screen and (-webkit-min-device-pixel-ratio: ` + e + `),
    only screen and (min--moz-device-pixel-ratio: ` + e + `),
    only screen and (-o-min-device-pixel-ratio: ` + e + `/1),
    only screen and (min-resolution: ` + Math.round(e * 96) + `dpi),
    only screen and (min-resolution: ` + e + `dppx)
  `;
}
function fN(e) {
  for (var t = "", r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++)
    n[i - 1] = arguments[i];
  for (var s = 0; s < e.length; s += 1)
    if (t += e[s], s === n.length - 1 && n[s]) {
      var o = n.filter(function(a) {
        return !!a;
      });
      o.length > 1 ? (t = t.slice(0, -1), t += ", " + n[s]) : o.length === 1 && (t += "" + n[s]);
    } else n[s] && (t += n[s] + " ");
  return t.trim();
}
var nk;
function n4(e) {
  var t = e.colorStops, r = e.fallback, n = e.toDirection, i = n === void 0 ? "" : n;
  if (!t || t.length < 2)
    throw new Xe(56);
  return {
    backgroundColor: r || t[0].replace(/,\s+/g, ",").split(" ")[0].replace(/,(?=\S)/g, ", "),
    backgroundImage: fN(nk || (nk = sN(["linear-gradient(", "", ")"])), i, t.join(", ").replace(/,(?=\S)/g, ", "))
  };
}
function i4() {
  var e;
  return [(e = {
    html: {
      lineHeight: "1.15",
      textSizeAdjust: "100%"
    },
    body: {
      margin: "0"
    },
    main: {
      display: "block"
    },
    h1: {
      fontSize: "2em",
      margin: "0.67em 0"
    },
    hr: {
      boxSizing: "content-box",
      height: "0",
      overflow: "visible"
    },
    pre: {
      fontFamily: "monospace, monospace",
      fontSize: "1em"
    },
    a: {
      backgroundColor: "transparent"
    },
    "abbr[title]": {
      borderBottom: "none",
      textDecoration: "underline"
    }
  }, e[`b,
    strong`] = {
    fontWeight: "bolder"
  }, e[`code,
    kbd,
    samp`] = {
    fontFamily: "monospace, monospace",
    fontSize: "1em"
  }, e.small = {
    fontSize: "80%"
  }, e[`sub,
    sup`] = {
    fontSize: "75%",
    lineHeight: "0",
    position: "relative",
    verticalAlign: "baseline"
  }, e.sub = {
    bottom: "-0.25em"
  }, e.sup = {
    top: "-0.5em"
  }, e.img = {
    borderStyle: "none"
  }, e[`button,
    input,
    optgroup,
    select,
    textarea`] = {
    fontFamily: "inherit",
    fontSize: "100%",
    lineHeight: "1.15",
    margin: "0"
  }, e[`button,
    input`] = {
    overflow: "visible"
  }, e[`button,
    select`] = {
    textTransform: "none"
  }, e[`button,
    html [type="button"],
    [type="reset"],
    [type="submit"]`] = {
    WebkitAppearance: "button"
  }, e[`button::-moz-focus-inner,
    [type="button"]::-moz-focus-inner,
    [type="reset"]::-moz-focus-inner,
    [type="submit"]::-moz-focus-inner`] = {
    borderStyle: "none",
    padding: "0"
  }, e[`button:-moz-focusring,
    [type="button"]:-moz-focusring,
    [type="reset"]:-moz-focusring,
    [type="submit"]:-moz-focusring`] = {
    outline: "1px dotted ButtonText"
  }, e.fieldset = {
    padding: "0.35em 0.625em 0.75em"
  }, e.legend = {
    boxSizing: "border-box",
    color: "inherit",
    display: "table",
    maxWidth: "100%",
    padding: "0",
    whiteSpace: "normal"
  }, e.progress = {
    verticalAlign: "baseline"
  }, e.textarea = {
    overflow: "auto"
  }, e[`[type="checkbox"],
    [type="radio"]`] = {
    boxSizing: "border-box",
    padding: "0"
  }, e[`[type="number"]::-webkit-inner-spin-button,
    [type="number"]::-webkit-outer-spin-button`] = {
    height: "auto"
  }, e['[type="search"]'] = {
    WebkitAppearance: "textfield",
    outlineOffset: "-2px"
  }, e['[type="search"]::-webkit-search-decoration'] = {
    WebkitAppearance: "none"
  }, e["::-webkit-file-upload-button"] = {
    WebkitAppearance: "button",
    font: "inherit"
  }, e.details = {
    display: "block"
  }, e.summary = {
    display: "list-item"
  }, e.template = {
    display: "none"
  }, e["[hidden]"] = {
    display: "none"
  }, e), {
    "abbr[title]": {
      textDecoration: "underline dotted"
    }
  }];
}
var ik;
function o4(e) {
  var t = e.colorStops, r = e.extent, n = r === void 0 ? "" : r, i = e.fallback, s = e.position, o = s === void 0 ? "" : s, a = e.shape, l = a === void 0 ? "" : a;
  if (!t || t.length < 2)
    throw new Xe(57);
  return {
    backgroundColor: i || t[0].split(" ")[0],
    backgroundImage: fN(ik || (ik = sN(["radial-gradient(", "", "", "", ")"])), o, l, n, t.join(", "))
  };
}
function s4(e, t, r, n, i) {
  var s;
  if (r === void 0 && (r = "png"), i === void 0 && (i = "_2x"), !e)
    throw new Xe(58);
  var o = r.replace(/^\./, ""), a = n ? n + "." + o : "" + e + i + "." + o;
  return s = {
    backgroundImage: "url(" + e + "." + o + ")"
  }, s[pN()] = It({
    backgroundImage: "url(" + a + ")"
  }, t ? {
    backgroundSize: t
  } : {}), s;
}
var a4 = {
  easeInBack: "cubic-bezier(0.600, -0.280, 0.735, 0.045)",
  easeInCirc: "cubic-bezier(0.600,  0.040, 0.980, 0.335)",
  easeInCubic: "cubic-bezier(0.550,  0.055, 0.675, 0.190)",
  easeInExpo: "cubic-bezier(0.950,  0.050, 0.795, 0.035)",
  easeInQuad: "cubic-bezier(0.550,  0.085, 0.680, 0.530)",
  easeInQuart: "cubic-bezier(0.895,  0.030, 0.685, 0.220)",
  easeInQuint: "cubic-bezier(0.755,  0.050, 0.855, 0.060)",
  easeInSine: "cubic-bezier(0.470,  0.000, 0.745, 0.715)",
  easeOutBack: "cubic-bezier(0.175,  0.885, 0.320, 1.275)",
  easeOutCubic: "cubic-bezier(0.215,  0.610, 0.355, 1.000)",
  easeOutCirc: "cubic-bezier(0.075,  0.820, 0.165, 1.000)",
  easeOutExpo: "cubic-bezier(0.190,  1.000, 0.220, 1.000)",
  easeOutQuad: "cubic-bezier(0.250,  0.460, 0.450, 0.940)",
  easeOutQuart: "cubic-bezier(0.165,  0.840, 0.440, 1.000)",
  easeOutQuint: "cubic-bezier(0.230,  1.000, 0.320, 1.000)",
  easeOutSine: "cubic-bezier(0.390,  0.575, 0.565, 1.000)",
  easeInOutBack: "cubic-bezier(0.680, -0.550, 0.265, 1.550)",
  easeInOutCirc: "cubic-bezier(0.785,  0.135, 0.150, 0.860)",
  easeInOutCubic: "cubic-bezier(0.645,  0.045, 0.355, 1.000)",
  easeInOutExpo: "cubic-bezier(1.000,  0.000, 0.000, 1.000)",
  easeInOutQuad: "cubic-bezier(0.455,  0.030, 0.515, 0.955)",
  easeInOutQuart: "cubic-bezier(0.770,  0.000, 0.175, 1.000)",
  easeInOutQuint: "cubic-bezier(0.860,  0.000, 0.070, 1.000)",
  easeInOutSine: "cubic-bezier(0.445,  0.050, 0.550, 0.950)"
};
function l4(e) {
  return a4[e];
}
function u4(e) {
  return l4(e);
}
var c4 = function(t, r, n) {
  var i = "" + n[0] + (n[1] || ""), s = "" + n[0] / 2 + (n[1] || ""), o = "" + r[0] + (r[1] || ""), a = "" + r[0] / 2 + (r[1] || "");
  switch (t) {
    case "top":
      return "0 " + s + " " + o + " " + s;
    case "topLeft":
      return i + " " + o + " 0 0";
    case "left":
      return a + " " + i + " " + a + " 0";
    case "bottomLeft":
      return i + " 0 0 " + o;
    case "bottom":
      return o + " " + s + " 0 " + s;
    case "bottomRight":
      return "0 0 " + i + " " + o;
    case "right":
      return a + " 0 " + a + " " + i;
    case "topRight":
    default:
      return "0 " + i + " " + o + " 0";
  }
}, p4 = function(t, r) {
  switch (t) {
    case "top":
    case "bottomRight":
      return {
        borderBottomColor: r
      };
    case "right":
    case "bottomLeft":
      return {
        borderLeftColor: r
      };
    case "bottom":
    case "topLeft":
      return {
        borderTopColor: r
      };
    case "left":
    case "topRight":
      return {
        borderRightColor: r
      };
    default:
      throw new Xe(59);
  }
};
function f4(e) {
  var t = e.pointingDirection, r = e.height, n = e.width, i = e.foregroundColor, s = e.backgroundColor, o = s === void 0 ? "transparent" : s, a = Ai(n), l = Ai(r);
  if (isNaN(l[0]) || isNaN(a[0]))
    throw new Xe(60);
  return It({
    width: "0",
    height: "0",
    borderColor: o
  }, p4(t, i), {
    borderStyle: "solid",
    borderWidth: c4(t, l, a)
  });
}
function d4(e) {
  e === void 0 && (e = "break-word");
  var t = e === "break-word" ? "break-all" : e;
  return {
    overflowWrap: e,
    wordWrap: e,
    wordBreak: t
  };
}
function $v(e) {
  return Math.round(e * 255);
}
function h4(e, t, r) {
  return $v(e) + "," + $v(t) + "," + $v(r);
}
function up(e, t, r, n) {
  if (n === void 0 && (n = h4), t === 0)
    return n(r, r, r);
  var i = (e % 360 + 360) % 360 / 60, s = (1 - Math.abs(2 * r - 1)) * t, o = s * (1 - Math.abs(i % 2 - 1)), a = 0, l = 0, u = 0;
  i >= 0 && i < 1 ? (a = s, l = o) : i >= 1 && i < 2 ? (a = o, l = s) : i >= 2 && i < 3 ? (l = s, u = o) : i >= 3 && i < 4 ? (l = o, u = s) : i >= 4 && i < 5 ? (a = o, u = s) : i >= 5 && i < 6 && (a = s, u = o);
  var f = r - s / 2, d = a + f, m = l + f, v = u + f;
  return n(d, m, v);
}
var ok = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "00ffff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "0000ff",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "00ffff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "ff00ff",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "639",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
function m4(e) {
  if (typeof e != "string") return e;
  var t = e.toLowerCase();
  return ok[t] ? "#" + ok[t] : e;
}
var g4 = /^#[a-fA-F0-9]{6}$/, y4 = /^#[a-fA-F0-9]{8}$/, v4 = /^#[a-fA-F0-9]{3}$/, b4 = /^#[a-fA-F0-9]{4}$/, Rv = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i, w4 = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i, S4 = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i, x4 = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
function wo(e) {
  if (typeof e != "string")
    throw new Xe(3);
  var t = m4(e);
  if (t.match(g4))
    return {
      red: parseInt("" + t[1] + t[2], 16),
      green: parseInt("" + t[3] + t[4], 16),
      blue: parseInt("" + t[5] + t[6], 16)
    };
  if (t.match(y4)) {
    var r = parseFloat((parseInt("" + t[7] + t[8], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + t[1] + t[2], 16),
      green: parseInt("" + t[3] + t[4], 16),
      blue: parseInt("" + t[5] + t[6], 16),
      alpha: r
    };
  }
  if (t.match(v4))
    return {
      red: parseInt("" + t[1] + t[1], 16),
      green: parseInt("" + t[2] + t[2], 16),
      blue: parseInt("" + t[3] + t[3], 16)
    };
  if (t.match(b4)) {
    var n = parseFloat((parseInt("" + t[4] + t[4], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + t[1] + t[1], 16),
      green: parseInt("" + t[2] + t[2], 16),
      blue: parseInt("" + t[3] + t[3], 16),
      alpha: n
    };
  }
  var i = Rv.exec(t);
  if (i)
    return {
      red: parseInt("" + i[1], 10),
      green: parseInt("" + i[2], 10),
      blue: parseInt("" + i[3], 10)
    };
  var s = w4.exec(t.substring(0, 50));
  if (s)
    return {
      red: parseInt("" + s[1], 10),
      green: parseInt("" + s[2], 10),
      blue: parseInt("" + s[3], 10),
      alpha: parseFloat("" + s[4]) > 1 ? parseFloat("" + s[4]) / 100 : parseFloat("" + s[4])
    };
  var o = S4.exec(t);
  if (o) {
    var a = parseInt("" + o[1], 10), l = parseInt("" + o[2], 10) / 100, u = parseInt("" + o[3], 10) / 100, f = "rgb(" + up(a, l, u) + ")", d = Rv.exec(f);
    if (!d)
      throw new Xe(4, t, f);
    return {
      red: parseInt("" + d[1], 10),
      green: parseInt("" + d[2], 10),
      blue: parseInt("" + d[3], 10)
    };
  }
  var m = x4.exec(t.substring(0, 50));
  if (m) {
    var v = parseInt("" + m[1], 10), S = parseInt("" + m[2], 10) / 100, y = parseInt("" + m[3], 10) / 100, E = "rgb(" + up(v, S, y) + ")", x = Rv.exec(E);
    if (!x)
      throw new Xe(4, t, E);
    return {
      red: parseInt("" + x[1], 10),
      green: parseInt("" + x[2], 10),
      blue: parseInt("" + x[3], 10),
      alpha: parseFloat("" + m[4]) > 1 ? parseFloat("" + m[4]) / 100 : parseFloat("" + m[4])
    };
  }
  throw new Xe(5);
}
function E4(e) {
  var t = e.red / 255, r = e.green / 255, n = e.blue / 255, i = Math.max(t, r, n), s = Math.min(t, r, n), o = (i + s) / 2;
  if (i === s)
    return e.alpha !== void 0 ? {
      hue: 0,
      saturation: 0,
      lightness: o,
      alpha: e.alpha
    } : {
      hue: 0,
      saturation: 0,
      lightness: o
    };
  var a, l = i - s, u = o > 0.5 ? l / (2 - i - s) : l / (i + s);
  switch (i) {
    case t:
      a = (r - n) / l + (r < n ? 6 : 0);
      break;
    case r:
      a = (n - t) / l + 2;
      break;
    default:
      a = (t - r) / l + 4;
      break;
  }
  return a *= 60, e.alpha !== void 0 ? {
    hue: a,
    saturation: u,
    lightness: o,
    alpha: e.alpha
  } : {
    hue: a,
    saturation: u,
    lightness: o
  };
}
function ui(e) {
  return E4(wo(e));
}
var _4 = function(t) {
  return t.length === 7 && t[1] === t[2] && t[3] === t[4] && t[5] === t[6] ? "#" + t[1] + t[3] + t[5] : t;
}, tw = _4;
function Gs(e) {
  var t = e.toString(16);
  return t.length === 1 ? "0" + t : t;
}
function Iv(e) {
  return Gs(Math.round(e * 255));
}
function O4(e, t, r) {
  return tw("#" + Iv(e) + Iv(t) + Iv(r));
}
function Am(e, t, r) {
  return up(e, t, r, O4);
}
function qS(e, t, r) {
  if (typeof e == "number" && typeof t == "number" && typeof r == "number")
    return Am(e, t, r);
  if (typeof e == "object" && t === void 0 && r === void 0)
    return Am(e.hue, e.saturation, e.lightness);
  throw new Xe(1);
}
function BS(e, t, r, n) {
  if (typeof e == "number" && typeof t == "number" && typeof r == "number" && typeof n == "number")
    return n >= 1 ? Am(e, t, r) : "rgba(" + up(e, t, r) + "," + n + ")";
  if (typeof e == "object" && t === void 0 && r === void 0 && n === void 0)
    return e.alpha >= 1 ? Am(e.hue, e.saturation, e.lightness) : "rgba(" + up(e.hue, e.saturation, e.lightness) + "," + e.alpha + ")";
  throw new Xe(2);
}
function cp(e, t, r) {
  if (typeof e == "number" && typeof t == "number" && typeof r == "number")
    return tw("#" + Gs(e) + Gs(t) + Gs(r));
  if (typeof e == "object" && t === void 0 && r === void 0)
    return tw("#" + Gs(e.red) + Gs(e.green) + Gs(e.blue));
  throw new Xe(6);
}
function ru(e, t, r, n) {
  if (typeof e == "string" && typeof t == "number") {
    var i = wo(e);
    return "rgba(" + i.red + "," + i.green + "," + i.blue + "," + t + ")";
  } else {
    if (typeof e == "number" && typeof t == "number" && typeof r == "number" && typeof n == "number")
      return n >= 1 ? cp(e, t, r) : "rgba(" + e + "," + t + "," + r + "," + n + ")";
    if (typeof e == "object" && t === void 0 && r === void 0 && n === void 0)
      return e.alpha >= 1 ? cp(e.red, e.green, e.blue) : "rgba(" + e.red + "," + e.green + "," + e.blue + "," + e.alpha + ")";
  }
  throw new Xe(7);
}
var k4 = function(t) {
  return typeof t.red == "number" && typeof t.green == "number" && typeof t.blue == "number" && (typeof t.alpha != "number" || typeof t.alpha > "u");
}, A4 = function(t) {
  return typeof t.red == "number" && typeof t.green == "number" && typeof t.blue == "number" && typeof t.alpha == "number";
}, P4 = function(t) {
  return typeof t.hue == "number" && typeof t.saturation == "number" && typeof t.lightness == "number" && (typeof t.alpha != "number" || typeof t.alpha > "u");
}, T4 = function(t) {
  return typeof t.hue == "number" && typeof t.saturation == "number" && typeof t.lightness == "number" && typeof t.alpha == "number";
};
function Dn(e) {
  if (typeof e != "object") throw new Xe(8);
  if (A4(e)) return ru(e);
  if (k4(e)) return cp(e);
  if (T4(e)) return BS(e);
  if (P4(e)) return qS(e);
  throw new Xe(8);
}
function dN(e, t, r) {
  return function() {
    var i = r.concat(Array.prototype.slice.call(arguments));
    return i.length >= t ? e.apply(this, i) : dN(e, t, i);
  };
}
function wn(e) {
  return dN(e, e.length, []);
}
function C4(e, t) {
  if (t === "transparent") return t;
  var r = ui(t);
  return Dn(It({}, r, {
    hue: r.hue + parseFloat(e)
  }));
}
var $4 = wn(C4), R4 = $4;
function I4(e) {
  if (e === "transparent") return e;
  var t = ui(e);
  return Dn(It({}, t, {
    hue: (t.hue + 180) % 360
  }));
}
function nu(e, t, r) {
  return Math.max(e, Math.min(t, r));
}
function N4(e, t) {
  if (t === "transparent") return t;
  var r = ui(t);
  return Dn(It({}, r, {
    lightness: nu(0, 1, r.lightness - parseFloat(e))
  }));
}
var j4 = wn(N4), L4 = j4;
function M4(e, t) {
  if (t === "transparent") return t;
  var r = ui(t);
  return Dn(It({}, r, {
    saturation: nu(0, 1, r.saturation - parseFloat(e))
  }));
}
var D4 = wn(M4), F4 = D4;
function Pm(e) {
  if (e === "transparent") return 0;
  var t = wo(e), r = Object.keys(t).map(function(o) {
    var a = t[o] / 255;
    return a <= 0.03928 ? a / 12.92 : Math.pow((a + 0.055) / 1.055, 2.4);
  }), n = r[0], i = r[1], s = r[2];
  return parseFloat((0.2126 * n + 0.7152 * i + 0.0722 * s).toFixed(3));
}
function US(e, t) {
  var r = Pm(e), n = Pm(t);
  return parseFloat((r > n ? (r + 0.05) / (n + 0.05) : (n + 0.05) / (r + 0.05)).toFixed(2));
}
function z4(e) {
  return e === "transparent" ? e : Dn(It({}, ui(e), {
    saturation: 0
  }));
}
function q4(e) {
  if (typeof e == "object" && typeof e.hue == "number" && typeof e.saturation == "number" && typeof e.lightness == "number")
    return e.alpha && typeof e.alpha == "number" ? BS({
      hue: e.hue,
      saturation: e.saturation,
      lightness: e.lightness,
      alpha: e.alpha
    }) : qS({
      hue: e.hue,
      saturation: e.saturation,
      lightness: e.lightness
    });
  throw new Xe(45);
}
function B4(e) {
  if (e === "transparent") return e;
  var t = wo(e);
  return Dn(It({}, t, {
    red: 255 - t.red,
    green: 255 - t.green,
    blue: 255 - t.blue
  }));
}
function U4(e, t) {
  if (t === "transparent") return t;
  var r = ui(t);
  return Dn(It({}, r, {
    lightness: nu(0, 1, r.lightness + parseFloat(e))
  }));
}
var V4 = wn(U4), W4 = V4;
function H4(e, t) {
  var r = US(e, t);
  return {
    AA: r >= 4.5,
    AALarge: r >= 3,
    AAA: r >= 7,
    AAALarge: r >= 4.5
  };
}
function Q4(e, t, r) {
  if (t === "transparent") return r;
  if (r === "transparent") return t;
  if (e === 0) return r;
  var n = wo(t), i = It({}, n, {
    alpha: typeof n.alpha == "number" ? n.alpha : 1
  }), s = wo(r), o = It({}, s, {
    alpha: typeof s.alpha == "number" ? s.alpha : 1
  }), a = i.alpha - o.alpha, l = parseFloat(e) * 2 - 1, u = l * a === -1 ? l : l + a, f = 1 + l * a, d = (u / f + 1) / 2, m = 1 - d, v = {
    red: Math.floor(i.red * d + o.red * m),
    green: Math.floor(i.green * d + o.green * m),
    blue: Math.floor(i.blue * d + o.blue * m),
    alpha: i.alpha * parseFloat(e) + o.alpha * (1 - parseFloat(e))
  };
  return ru(v);
}
var Y4 = wn(Q4), VS = Y4;
function G4(e, t) {
  if (t === "transparent") return t;
  var r = wo(t), n = typeof r.alpha == "number" ? r.alpha : 1, i = It({}, r, {
    alpha: nu(0, 1, (n * 100 + parseFloat(e) * 100) / 100)
  });
  return ru(i);
}
var K4 = wn(G4), X4 = K4, sk = "#000", ak = "#fff";
function J4(e, t, r, n) {
  t === void 0 && (t = sk), r === void 0 && (r = ak), n === void 0 && (n = !0);
  var i = Pm(e) > 0.179, s = i ? t : r;
  return !n || US(e, s) >= 4.5 ? s : i ? sk : ak;
}
function Z4(e) {
  if (typeof e == "object" && typeof e.red == "number" && typeof e.green == "number" && typeof e.blue == "number")
    return typeof e.alpha == "number" ? ru({
      red: e.red,
      green: e.green,
      blue: e.blue,
      alpha: e.alpha
    }) : cp({
      red: e.red,
      green: e.green,
      blue: e.blue
    });
  throw new Xe(46);
}
function e6(e, t) {
  if (t === "transparent") return t;
  var r = ui(t);
  return Dn(It({}, r, {
    saturation: nu(0, 1, r.saturation + parseFloat(e))
  }));
}
var t6 = wn(e6), r6 = t6;
function n6(e, t) {
  return t === "transparent" ? t : Dn(It({}, ui(t), {
    hue: parseFloat(e)
  }));
}
var i6 = wn(n6), o6 = i6;
function s6(e, t) {
  return t === "transparent" ? t : Dn(It({}, ui(t), {
    lightness: parseFloat(e)
  }));
}
var a6 = wn(s6), l6 = a6;
function u6(e, t) {
  return t === "transparent" ? t : Dn(It({}, ui(t), {
    saturation: parseFloat(e)
  }));
}
var c6 = wn(u6), p6 = c6;
function f6(e, t) {
  return t === "transparent" ? t : VS(parseFloat(e), "rgb(0, 0, 0)", t);
}
var d6 = wn(f6), h6 = d6;
function m6(e, t) {
  return t === "transparent" ? t : VS(parseFloat(e), "rgb(255, 255, 255)", t);
}
var g6 = wn(m6), y6 = g6;
function v6(e, t) {
  if (t === "transparent") return t;
  var r = wo(t), n = typeof r.alpha == "number" ? r.alpha : 1, i = It({}, r, {
    alpha: nu(0, 1, +(n * 100 - parseFloat(e) * 100).toFixed(2) / 100)
  });
  return ru(i);
}
var b6 = wn(v6), w6 = b6;
function S6() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  var n = Array.isArray(t[0]);
  if (!n && t.length > 8)
    throw new Xe(64);
  var i = t.map(function(s) {
    if (n && !Array.isArray(s) || !n && Array.isArray(s))
      throw new Xe(65);
    if (Array.isArray(s) && s.length > 8)
      throw new Xe(66);
    return Array.isArray(s) ? s.join(" ") : s;
  }).join(", ");
  return {
    animation: i
  };
}
function x6() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return {
    backgroundImage: t.join(", ")
  };
}
function E6() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return {
    background: t.join(", ")
  };
}
var _6 = ["top", "right", "bottom", "left"];
function O6(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    r[n - 1] = arguments[n];
  if (typeof e == "string" && _6.indexOf(e) >= 0) {
    var i;
    return i = {}, i["border" + jc(e) + "Width"] = r[0], i["border" + jc(e) + "Style"] = r[1], i["border" + jc(e) + "Color"] = r[2], i;
  } else
    return r.unshift(e), {
      borderWidth: r[0],
      borderStyle: r[1],
      borderColor: r[2]
    };
}
function k6() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return ps.apply(void 0, ["borderColor"].concat(t));
}
function A6(e, t) {
  var r = jc(e);
  if (!t && t !== 0)
    throw new Xe(62);
  if (r === "Top" || r === "Bottom") {
    var n;
    return n = {}, n["border" + r + "RightRadius"] = t, n["border" + r + "LeftRadius"] = t, n;
  }
  if (r === "Left" || r === "Right") {
    var i;
    return i = {}, i["borderTop" + r + "Radius"] = t, i["borderBottom" + r + "Radius"] = t, i;
  }
  throw new Xe(63);
}
function P6() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return ps.apply(void 0, ["borderStyle"].concat(t));
}
function T6() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return ps.apply(void 0, ["borderWidth"].concat(t));
}
function lk(e, t) {
  var r = t ? ":" + t : "";
  return e(r);
}
function hN(e, t, r) {
  if (!t) throw new Xe(67);
  if (e.length === 0) return lk(t, null);
  for (var n = [], i = 0; i < e.length; i += 1) {
    if (r && r.indexOf(e[i]) < 0)
      throw new Xe(68);
    n.push(lk(t, e[i]));
  }
  return n = n.join(","), n;
}
var C6 = [void 0, null, "active", "focus", "hover"];
function $6(e) {
  return "button" + e + `,
  input[type="button"]` + e + `,
  input[type="reset"]` + e + `,
  input[type="submit"]` + e;
}
function R6() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return hN(t, $6, C6);
}
function I6() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return ps.apply(void 0, ["margin"].concat(t));
}
function N6() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return ps.apply(void 0, ["padding"].concat(t));
}
var j6 = ["absolute", "fixed", "relative", "static", "sticky"];
function L6(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    r[n - 1] = arguments[n];
  return j6.indexOf(e) >= 0 && e ? It({}, ps.apply(void 0, [""].concat(r)), {
    position: e
  }) : ps.apply(void 0, ["", e].concat(r));
}
function M6(e, t) {
  return t === void 0 && (t = e), {
    height: e,
    width: t
  };
}
var D6 = [void 0, null, "active", "focus", "hover"];
function F6(e) {
  return 'input[type="color"]' + e + `,
    input[type="date"]` + e + `,
    input[type="datetime"]` + e + `,
    input[type="datetime-local"]` + e + `,
    input[type="email"]` + e + `,
    input[type="month"]` + e + `,
    input[type="number"]` + e + `,
    input[type="password"]` + e + `,
    input[type="search"]` + e + `,
    input[type="tel"]` + e + `,
    input[type="text"]` + e + `,
    input[type="time"]` + e + `,
    input[type="url"]` + e + `,
    input[type="week"]` + e + `,
    input:not([type])` + e + `,
    textarea` + e;
}
function z6() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return hN(t, F6, D6);
}
function q6() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  if (Array.isArray(t[0]) && t.length === 2) {
    var n = t[1];
    if (typeof n != "string")
      throw new Xe(61);
    var i = t[0].map(function(s) {
      return s + " " + n;
    }).join(", ");
    return {
      transition: i
    };
  } else
    return {
      transition: t.join(", ")
    };
}
const B6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  adjustHue: R4,
  animation: S6,
  backgroundImages: x6,
  backgrounds: E6,
  between: ew,
  border: O6,
  borderColor: k6,
  borderRadius: A6,
  borderStyle: P6,
  borderWidth: T6,
  buttons: R6,
  clearFix: B5,
  complement: I4,
  cover: U5,
  cssVar: S5,
  darken: L4,
  desaturate: F4,
  directionalProperty: ps,
  easeIn: M5,
  easeInOut: F5,
  easeOut: q5,
  ellipsis: V5,
  em: P5,
  fluidRange: Q5,
  fontFace: e4,
  getContrast: US,
  getLuminance: Pm,
  getValueAndUnit: Ai,
  grayscale: z4,
  hiDPI: pN,
  hideText: t4,
  hideVisually: r4,
  hsl: qS,
  hslToColorString: q4,
  hsla: BS,
  important: lN,
  invert: B4,
  lighten: W4,
  linearGradient: n4,
  margin: I6,
  math: b5,
  meetsContrastGuidelines: H4,
  mix: VS,
  modularScale: $5,
  normalize: i4,
  opacify: X4,
  padding: N6,
  parseToHsl: ui,
  parseToRgb: wo,
  position: L6,
  radialGradient: o4,
  readableColor: J4,
  rem: I5,
  remToPx: j5,
  retinaImage: s4,
  rgb: cp,
  rgbToColorString: Z4,
  rgba: ru,
  saturate: r6,
  setHue: o6,
  setLightness: l6,
  setSaturation: p6,
  shade: h6,
  size: M6,
  stripUnit: J0,
  textInputs: z6,
  timingFunctions: u4,
  tint: y6,
  toColorString: Dn,
  transitions: q6,
  transparentize: w6,
  triangle: f4,
  wordWrap: d4
}, Symbol.toStringTag, { value: "Module" })), U6 = /* @__PURE__ */ Di(B6);
var Nv = { exports: {} }, uk;
function V6() {
  return uk || (uk = 1, function(e, t) {
    (function(r, n, i) {
      e.exports = i(), e.exports.default = i();
    })("slugify", ft, function() {
      var r = JSON.parse(`{"$":"dollar","%":"percent","&":"and","<":"less",">":"greater","|":"or","":"cent","":"pound","":"currency","":"yen","":"(c)","":"a","":"(r)","":"o","":"A","":"A","":"A","":"A","":"A","":"A","":"AE","":"C","":"E","":"E","":"E","":"E","":"I","":"I","":"I","":"I","":"D","":"N","":"O","":"O","":"O","":"O","":"O","":"O","":"U","":"U","":"U","":"U","":"Y","":"TH","":"ss","":"a","":"a","":"a","":"a","":"a","":"a","":"ae","":"c","":"e","":"e","":"e","":"e","":"i","":"i","":"i","":"i","":"d","":"n","":"o","":"o","":"o","":"o","":"o","":"o","":"u","":"u","":"u","":"u","":"y","":"th","":"y","":"A","":"a","":"A","":"a","":"A","":"a","":"C","":"c","":"C","":"c","":"D","":"d","":"DJ","":"dj","":"E","":"e","":"E","":"e","":"e","":"e","":"E","":"e","":"G","":"g","":"G","":"g","":"I","":"i","":"i","":"i","":"I","":"i","":"I","":"i","":"k","":"k","":"L","":"l","":"L","":"l","":"L","":"l","":"N","":"n","":"N","":"n","":"N","":"n","":"O","":"o","":"O","":"o","":"OE","":"oe","":"R","":"r","":"R","":"r","":"S","":"s","":"S","":"s","":"S","":"s","":"T","":"t","":"T","":"t","":"U","":"u","":"u","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"W","":"w","":"Y","":"y","":"Y","":"Z","":"z","":"Z","":"z","":"Z","":"z","":"E","":"f","":"O","":"o","":"U","":"u","":"LJ","":"lj","":"NJ","":"nj","":"S","":"s","":"T","":"t","":"e","":"o","":"A","":"E","":"H","":"I","":"O","":"Y","":"W","":"i","":"A","":"B","":"G","":"D","":"E","":"Z","":"H","":"8","":"I","":"K","":"L","":"M","":"N","":"3","":"O","":"P","":"R","":"S","":"T","":"Y","":"F","":"X","":"PS","":"W","":"I","":"Y","":"a","":"e","":"h","":"i","":"y","":"a","":"b","":"g","":"d","":"e","":"z","":"h","":"8","":"i","":"k","":"l","":"m","":"n","":"3","":"o","":"p","":"r","":"s","":"s","":"t","":"y","":"f","":"x","":"ps","":"w","":"i","":"y","":"o","":"y","":"w","":"Yo","":"DJ","":"Ye","":"I","":"Yi","":"J","":"LJ","":"NJ","":"C","":"DZ","":"A","":"B","":"V","":"G","":"D","":"E","":"Zh","":"Z","":"I","":"J","":"K","":"L","":"M","":"N","":"O","":"P","":"R","":"S","":"T","":"U","":"F","":"H","":"C","":"Ch","":"Sh","":"Sh","":"U","":"Y","":"","":"E","":"Yu","":"Ya","":"a","":"b","":"v","":"g","":"d","":"e","":"zh","":"z","":"i","":"j","":"k","":"l","":"m","":"n","":"o","":"p","":"r","":"s","":"t","":"u","":"f","":"h","":"c","":"ch","":"sh","":"sh","":"u","":"y","":"","":"e","":"yu","":"ya","":"yo","":"dj","":"ye","":"i","":"yi","":"j","":"lj","":"nj","":"c","":"u","":"dz","":"G","":"g","":"GH","":"gh","":"KH","":"kh","":"NG","":"ng","":"UE","":"ue","":"U","":"u","":"H","":"h","":"AE","":"ae","":"OE","":"oe","":"baht","":"a","":"b","":"g","":"d","":"e","":"v","":"z","":"t","":"i","":"k","":"l","":"m","":"n","":"o","":"p","":"zh","":"r","":"s","":"t","":"u","":"f","":"k","":"gh","":"q","":"sh","":"ch","":"ts","":"dz","":"ts","":"ch","":"kh","":"j","":"h","":"W","":"w","":"W","":"w","":"W","":"w","":"SS","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"I","":"i","":"I","":"i","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"Y","":"y","":"Y","":"y","":"Y","":"y","":"Y","":"y","":"'","":"'","":"\\"","":"\\"","":"+","":"*","":"...","":"ecu","":"cruzeiro","":"french franc","":"lira","":"mill","":"naira","":"peseta","":"rupee","":"won","":"new shequel","":"dong","":"euro","":"kip","":"tugrik","":"drachma","":"penny","":"peso","":"guarani","":"austral","":"hryvnia","":"cedi","":"kazakhstani tenge","":"indian rupee","":"turkish lira","":"russian ruble","":"bitcoin","":"sm","":"tm","":"d","":"delta","":"sum","":"infinity","":"love","":"yuan","":"yen","":"rial"}`), n = JSON.parse('{"de":{"":"AE","":"ae","":"OE","":"oe","":"UE","":"ue","%":"prozent","&":"und","|":"oder","":"summe","":"unendlich","":"liebe"},"vi":{"":"D","":"d"},"fr":{"%":"pourcent","&":"et","<":"plus petit",">":"plus grand","|":"ou","":"centime","":"livre","":"devise","":"franc","":"somme","":"infini","":"amour"}}');
      function i(s, o) {
        if (typeof s != "string")
          throw new Error("slugify: string argument expected");
        o = typeof o == "string" ? { replacement: o } : o || {};
        var a = n[o.locale] || {}, l = o.replacement === void 0 ? "-" : o.replacement, u = s.split("").reduce(function(f, d) {
          return f + (a[d] || r[d] || d).replace(o.remove || /[^\w\s$*_+~.()'"!\-:@]+/g, "");
        }, "").trim().replace(new RegExp("[\\s" + l + "]+", "g"), l);
        return o.lower && (u = u.toLowerCase()), o.strict && (u = u.replace(new RegExp("[^a-zA-Z0-9" + l + "]", "g"), "").replace(new RegExp("[\\s" + l + "]+", "g"), l)), u;
      }
      return i.extend = function(s) {
        for (var o in s)
          r[o] = s[o];
      }, i;
    });
  }(Nv)), Nv.exports;
}
var ar = function() {
  return ar = Object.assign || function(t) {
    for (var r, n = 1, i = arguments.length; n < i; n++) {
      r = arguments[n];
      for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (t[s] = r[s]);
    }
    return t;
  }, ar.apply(this, arguments);
};
function ql(e, t, r) {
  if (r || arguments.length === 2) for (var n = 0, i = t.length, s; n < i; n++)
    (s || !(n in t)) && (s || (s = Array.prototype.slice.call(t, 0, n)), s[n] = t[n]);
  return e.concat(s || Array.prototype.slice.call(t));
}
var W6 = function(t, r, n, i) {
  var s = n ? n.call(i, t, r) : void 0;
  if (s !== void 0)
    return !!s;
  if (t === r)
    return !0;
  if (typeof t != "object" || !t || typeof r != "object" || !r)
    return !1;
  var o = Object.keys(t), a = Object.keys(r);
  if (o.length !== a.length)
    return !1;
  for (var l = Object.prototype.hasOwnProperty.bind(r), u = 0; u < o.length; u++) {
    var f = o[u];
    if (!l(f))
      return !1;
    var d = t[f], m = r[f];
    if (s = n ? n.call(i, d, m, f) : void 0, s === !1 || s === void 0 && d !== m)
      return !1;
  }
  return !0;
};
const H6 = /* @__PURE__ */ og(W6);
var Lt = "-ms-", Lc = "-moz-", St = "-webkit-", mN = "comm", Tg = "rule", WS = "decl", Q6 = "@import", gN = "@keyframes", Y6 = "@layer", yN = Math.abs, HS = String.fromCharCode, rw = Object.assign;
function G6(e, t) {
  return mr(e, 0) ^ 45 ? (((t << 2 ^ mr(e, 0)) << 2 ^ mr(e, 1)) << 2 ^ mr(e, 2)) << 2 ^ mr(e, 3) : 0;
}
function vN(e) {
  return e.trim();
}
function no(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function st(e, t, r) {
  return e.replace(t, r);
}
function Wh(e, t, r) {
  return e.indexOf(t, r);
}
function mr(e, t) {
  return e.charCodeAt(t) | 0;
}
function Bl(e, t, r) {
  return e.slice(t, r);
}
function _i(e) {
  return e.length;
}
function bN(e) {
  return e.length;
}
function Sc(e, t) {
  return t.push(e), e;
}
function K6(e, t) {
  return e.map(t).join("");
}
function ck(e, t) {
  return e.filter(function(r) {
    return !no(r, t);
  });
}
var Cg = 1, Ul = 1, wN = 0, Ln = 0, or = 0, iu = "";
function $g(e, t, r, n, i, s, o, a) {
  return { value: e, root: t, parent: r, type: n, props: i, children: s, line: Cg, column: Ul, length: o, return: "", siblings: a };
}
function Fo(e, t) {
  return rw($g("", null, null, "", null, null, 0, e.siblings), e, { length: -e.length }, t);
}
function Xa(e) {
  for (; e.root; )
    e = Fo(e.root, { children: [e] });
  Sc(e, e.siblings);
}
function X6() {
  return or;
}
function J6() {
  return or = Ln > 0 ? mr(iu, --Ln) : 0, Ul--, or === 10 && (Ul = 1, Cg--), or;
}
function ni() {
  return or = Ln < wN ? mr(iu, Ln++) : 0, Ul++, or === 10 && (Ul = 1, Cg++), or;
}
function sa() {
  return mr(iu, Ln);
}
function Hh() {
  return Ln;
}
function Rg(e, t) {
  return Bl(iu, e, t);
}
function nw(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function Z6(e) {
  return Cg = Ul = 1, wN = _i(iu = e), Ln = 0, [];
}
function eV(e) {
  return iu = "", e;
}
function jv(e) {
  return vN(Rg(Ln - 1, iw(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function tV(e) {
  for (; (or = sa()) && or < 33; )
    ni();
  return nw(e) > 2 || nw(or) > 3 ? "" : " ";
}
function rV(e, t) {
  for (; --t && ni() && !(or < 48 || or > 102 || or > 57 && or < 65 || or > 70 && or < 97); )
    ;
  return Rg(e, Hh() + (t < 6 && sa() == 32 && ni() == 32));
}
function iw(e) {
  for (; ni(); )
    switch (or) {
      case e:
        return Ln;
      case 34:
      case 39:
        e !== 34 && e !== 39 && iw(or);
        break;
      case 40:
        e === 41 && iw(e);
        break;
      case 92:
        ni();
        break;
    }
  return Ln;
}
function nV(e, t) {
  for (; ni() && e + or !== 57; )
    if (e + or === 84 && sa() === 47)
      break;
  return "/*" + Rg(t, Ln - 1) + "*" + HS(e === 47 ? e : ni());
}
function iV(e) {
  for (; !nw(sa()); )
    ni();
  return Rg(e, Ln);
}
function oV(e) {
  return eV(Qh("", null, null, null, [""], e = Z6(e), 0, [0], e));
}
function Qh(e, t, r, n, i, s, o, a, l) {
  for (var u = 0, f = 0, d = o, m = 0, v = 0, S = 0, y = 1, E = 1, x = 1, g = 0, b = "", A = i, P = s, k = n, $ = b; E; )
    switch (S = g, g = ni()) {
      case 40:
        if (S != 108 && mr($, d - 1) == 58) {
          Wh($ += st(jv(g), "&", "&\f"), "&\f", yN(u ? a[u - 1] : 0)) != -1 && (x = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        $ += jv(g);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        $ += tV(S);
        break;
      case 92:
        $ += rV(Hh() - 1, 7);
        continue;
      case 47:
        switch (sa()) {
          case 42:
          case 47:
            Sc(sV(nV(ni(), Hh()), t, r, l), l);
            break;
          default:
            $ += "/";
        }
        break;
      case 123 * y:
        a[u++] = _i($) * x;
      case 125 * y:
      case 59:
      case 0:
        switch (g) {
          case 0:
          case 125:
            E = 0;
          case 59 + f:
            x == -1 && ($ = st($, /\f/g, "")), v > 0 && _i($) - d && Sc(v > 32 ? fk($ + ";", n, r, d - 1, l) : fk(st($, " ", "") + ";", n, r, d - 2, l), l);
            break;
          case 59:
            $ += ";";
          default:
            if (Sc(k = pk($, t, r, u, f, i, a, b, A = [], P = [], d, s), s), g === 123)
              if (f === 0)
                Qh($, t, k, k, A, s, d, a, P);
              else
                switch (m === 99 && mr($, 3) === 110 ? 100 : m) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Qh(e, k, k, n && Sc(pk(e, k, k, 0, 0, i, a, b, i, A = [], d, P), P), i, P, d, a, n ? A : P);
                    break;
                  default:
                    Qh($, k, k, k, [""], P, 0, a, P);
                }
        }
        u = f = v = 0, y = x = 1, b = $ = "", d = o;
        break;
      case 58:
        d = 1 + _i($), v = S;
      default:
        if (y < 1) {
          if (g == 123)
            --y;
          else if (g == 125 && y++ == 0 && J6() == 125)
            continue;
        }
        switch ($ += HS(g), g * y) {
          case 38:
            x = f > 0 ? 1 : ($ += "\f", -1);
            break;
          case 44:
            a[u++] = (_i($) - 1) * x, x = 1;
            break;
          case 64:
            sa() === 45 && ($ += jv(ni())), m = sa(), f = d = _i(b = $ += iV(Hh())), g++;
            break;
          case 45:
            S === 45 && _i($) == 2 && (y = 0);
        }
    }
  return s;
}
function pk(e, t, r, n, i, s, o, a, l, u, f, d) {
  for (var m = i - 1, v = i === 0 ? s : [""], S = bN(v), y = 0, E = 0, x = 0; y < n; ++y)
    for (var g = 0, b = Bl(e, m + 1, m = yN(E = o[y])), A = e; g < S; ++g)
      (A = vN(E > 0 ? v[g] + " " + b : st(b, /&\f/g, v[g]))) && (l[x++] = A);
  return $g(e, t, r, i === 0 ? Tg : a, l, u, f, d);
}
function sV(e, t, r, n) {
  return $g(e, t, r, mN, HS(X6()), Bl(e, 2, -2), 0, n);
}
function fk(e, t, r, n, i) {
  return $g(e, t, r, WS, Bl(e, 0, n), Bl(e, n + 1, -1), n, i);
}
function SN(e, t, r) {
  switch (G6(e, t)) {
    case 5103:
      return St + "print-" + e + e;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return St + e + e;
    case 4789:
      return Lc + e + e;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return St + e + Lc + e + Lt + e + e;
    case 5936:
      switch (mr(e, t + 11)) {
        case 114:
          return St + e + Lt + st(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        case 108:
          return St + e + Lt + st(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        case 45:
          return St + e + Lt + st(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
    case 6828:
    case 4268:
    case 2903:
      return St + e + Lt + e + e;
    case 6165:
      return St + e + Lt + "flex-" + e + e;
    case 5187:
      return St + e + st(e, /(\w+).+(:[^]+)/, St + "box-$1$2" + Lt + "flex-$1$2") + e;
    case 5443:
      return St + e + Lt + "flex-item-" + st(e, /flex-|-self/g, "") + (no(e, /flex-|baseline/) ? "" : Lt + "grid-row-" + st(e, /flex-|-self/g, "")) + e;
    case 4675:
      return St + e + Lt + "flex-line-pack" + st(e, /align-content|flex-|-self/g, "") + e;
    case 5548:
      return St + e + Lt + st(e, "shrink", "negative") + e;
    case 5292:
      return St + e + Lt + st(e, "basis", "preferred-size") + e;
    case 6060:
      return St + "box-" + st(e, "-grow", "") + St + e + Lt + st(e, "grow", "positive") + e;
    case 4554:
      return St + st(e, /([^-])(transform)/g, "$1" + St + "$2") + e;
    case 6187:
      return st(st(st(e, /(zoom-|grab)/, St + "$1"), /(image-set)/, St + "$1"), e, "") + e;
    case 5495:
    case 3959:
      return st(e, /(image-set\([^]*)/, St + "$1$`$1");
    case 4968:
      return st(st(e, /(.+:)(flex-)?(.*)/, St + "box-pack:$3" + Lt + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + St + e + e;
    case 4200:
      if (!no(e, /flex-|baseline/)) return Lt + "grid-column-align" + Bl(e, t) + e;
      break;
    case 2592:
    case 3360:
      return Lt + st(e, "template-", "") + e;
    case 4384:
    case 3616:
      return r && r.some(function(n, i) {
        return t = i, no(n.props, /grid-\w+-end/);
      }) ? ~Wh(e + (r = r[t].value), "span", 0) ? e : Lt + st(e, "-start", "") + e + Lt + "grid-row-span:" + (~Wh(r, "span", 0) ? no(r, /\d+/) : +no(r, /\d+/) - +no(e, /\d+/)) + ";" : Lt + st(e, "-start", "") + e;
    case 4896:
    case 4128:
      return r && r.some(function(n) {
        return no(n.props, /grid-\w+-start/);
      }) ? e : Lt + st(st(e, "-end", "-span"), "span ", "") + e;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return st(e, /(.+)-inline(.+)/, St + "$1$2") + e;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (_i(e) - 1 - t > 6)
        switch (mr(e, t + 1)) {
          case 109:
            if (mr(e, t + 4) !== 45)
              break;
          case 102:
            return st(e, /(.+:)(.+)-([^]+)/, "$1" + St + "$2-$3$1" + Lc + (mr(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
          case 115:
            return ~Wh(e, "stretch", 0) ? SN(st(e, "stretch", "fill-available"), t, r) + e : e;
        }
      break;
    case 5152:
    case 5920:
      return st(e, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(n, i, s, o, a, l, u) {
        return Lt + i + ":" + s + u + (o ? Lt + i + "-span:" + (a ? l : +l - +s) + u : "") + e;
      });
    case 4949:
      if (mr(e, t + 6) === 121)
        return st(e, ":", ":" + St) + e;
      break;
    case 6444:
      switch (mr(e, mr(e, 14) === 45 ? 18 : 11)) {
        case 120:
          return st(e, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + St + (mr(e, 14) === 45 ? "inline-" : "") + "box$3$1" + St + "$2$3$1" + Lt + "$2box$3") + e;
        case 100:
          return st(e, ":", ":" + Lt) + e;
      }
      break;
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return st(e, "scroll-", "scroll-snap-") + e;
  }
  return e;
}
function Tm(e, t) {
  for (var r = "", n = 0; n < e.length; n++)
    r += t(e[n], n, e, t) || "";
  return r;
}
function aV(e, t, r, n) {
  switch (e.type) {
    case Y6:
      if (e.children.length) break;
    case Q6:
    case WS:
      return e.return = e.return || e.value;
    case mN:
      return "";
    case gN:
      return e.return = e.value + "{" + Tm(e.children, n) + "}";
    case Tg:
      if (!_i(e.value = e.props.join(","))) return "";
  }
  return _i(r = Tm(e.children, n)) ? e.return = e.value + "{" + r + "}" : "";
}
function lV(e) {
  var t = bN(e);
  return function(r, n, i, s) {
    for (var o = "", a = 0; a < t; a++)
      o += e[a](r, n, i, s) || "";
    return o;
  };
}
function uV(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function cV(e, t, r, n) {
  if (e.length > -1 && !e.return)
    switch (e.type) {
      case WS:
        e.return = SN(e.value, e.length, r);
        return;
      case gN:
        return Tm([Fo(e, { value: st(e.value, "@", "@" + St) })], n);
      case Tg:
        if (e.length)
          return K6(r = e.props, function(i) {
            switch (no(i, n = /(::plac\w+|:read-\w+)/)) {
              case ":read-only":
              case ":read-write":
                Xa(Fo(e, { props: [st(i, /:(read-\w+)/, ":" + Lc + "$1")] })), Xa(Fo(e, { props: [i] })), rw(e, { props: ck(r, n) });
                break;
              case "::placeholder":
                Xa(Fo(e, { props: [st(i, /:(plac\w+)/, ":" + St + "input-$1")] })), Xa(Fo(e, { props: [st(i, /:(plac\w+)/, ":" + Lc + "$1")] })), Xa(Fo(e, { props: [st(i, /:(plac\w+)/, Lt + "input-$1")] })), Xa(Fo(e, { props: [i] })), rw(e, { props: ck(r, n) });
                break;
            }
            return "";
          });
    }
}
var pV = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, fs = typeof process < "u" && process.env !== void 0 && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled", xN = "active", Cm = "data-styled-version", da = "6.1.15", QS = `/*!sc*/
`, $m = typeof window < "u" && "HTMLElement" in window, fV = !!(typeof SC_DISABLE_SPEEDY == "boolean" ? SC_DISABLE_SPEEDY : typeof process < "u" && process.env !== void 0 && process.env.REACT_APP_SC_DISABLE_SPEEDY !== void 0 && process.env.REACT_APP_SC_DISABLE_SPEEDY !== "" ? process.env.REACT_APP_SC_DISABLE_SPEEDY !== "false" && process.env.REACT_APP_SC_DISABLE_SPEEDY : typeof process < "u" && process.env !== void 0 && process.env.SC_DISABLE_SPEEDY !== void 0 && process.env.SC_DISABLE_SPEEDY !== "" && process.env.SC_DISABLE_SPEEDY !== "false" && process.env.SC_DISABLE_SPEEDY), dV = {}, Ig = Object.freeze([]), Vl = Object.freeze({});
function YS(e, t, r) {
  return r === void 0 && (r = Vl), e.theme !== r.theme && e.theme || t || r.theme;
}
var EN = /* @__PURE__ */ new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "use", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]), hV = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g, mV = /(^-|-$)/g;
function dk(e) {
  return e.replace(hV, "-").replace(mV, "");
}
var gV = /(a)(d)/gi, hd = 52, hk = function(e) {
  return String.fromCharCode(e + (e > 25 ? 39 : 97));
};
function ow(e) {
  var t, r = "";
  for (t = Math.abs(e); t > hd; t = t / hd | 0) r = hk(t % hd) + r;
  return (hk(t % hd) + r).replace(gV, "$1-$2");
}
var Lv, _N = 5381, wl = function(e, t) {
  for (var r = t.length; r; ) e = 33 * e ^ t.charCodeAt(--r);
  return e;
}, ON = function(e) {
  return wl(_N, e);
};
function GS(e) {
  return ow(ON(e) >>> 0);
}
function kN(e) {
  return e.displayName || e.name || "Component";
}
function Mv(e) {
  return typeof e == "string" && !0;
}
var AN = typeof Symbol == "function" && Symbol.for, PN = AN ? Symbol.for("react.memo") : 60115, yV = AN ? Symbol.for("react.forward_ref") : 60112, vV = { childContextTypes: !0, contextType: !0, contextTypes: !0, defaultProps: !0, displayName: !0, getDefaultProps: !0, getDerivedStateFromError: !0, getDerivedStateFromProps: !0, mixins: !0, propTypes: !0, type: !0 }, bV = { name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0 }, TN = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 }, wV = ((Lv = {})[yV] = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 }, Lv[PN] = TN, Lv);
function mk(e) {
  return ("type" in (t = e) && t.type.$$typeof) === PN ? TN : "$$typeof" in e ? wV[e.$$typeof] : vV;
  var t;
}
var SV = Object.defineProperty, xV = Object.getOwnPropertyNames, gk = Object.getOwnPropertySymbols, EV = Object.getOwnPropertyDescriptor, _V = Object.getPrototypeOf, yk = Object.prototype;
function KS(e, t, r) {
  if (typeof t != "string") {
    if (yk) {
      var n = _V(t);
      n && n !== yk && KS(e, n, r);
    }
    var i = xV(t);
    gk && (i = i.concat(gk(t)));
    for (var s = mk(e), o = mk(t), a = 0; a < i.length; ++a) {
      var l = i[a];
      if (!(l in bV || r && r[l] || o && l in o || s && l in s)) {
        var u = EV(t, l);
        try {
          SV(e, l, u);
        } catch {
        }
      }
    }
  }
  return e;
}
function ha(e) {
  return typeof e == "function";
}
function Ng(e) {
  return typeof e == "object" && "styledComponentId" in e;
}
function ta(e, t) {
  return e && t ? "".concat(e, " ").concat(t) : e || t || "";
}
function pp(e, t) {
  if (e.length === 0) return "";
  for (var r = e[0], n = 1; n < e.length; n++) r += t ? t + e[n] : e[n];
  return r;
}
function fp(e) {
  return e !== null && typeof e == "object" && e.constructor.name === Object.name && !("props" in e && e.$$typeof);
}
function sw(e, t, r) {
  if (r === void 0 && (r = !1), !r && !fp(e) && !Array.isArray(e)) return t;
  if (Array.isArray(t)) for (var n = 0; n < t.length; n++) e[n] = sw(e[n], t[n]);
  else if (fp(t)) for (var n in t) e[n] = sw(e[n], t[n]);
  return e;
}
function XS(e, t) {
  Object.defineProperty(e, "toString", { value: t });
}
function Rn(e) {
  for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
  return new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(e, " for more information.").concat(t.length > 0 ? " Args: ".concat(t.join(", ")) : ""));
}
var OV = function() {
  function e(t) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = t;
  }
  return e.prototype.indexOfGroup = function(t) {
    for (var r = 0, n = 0; n < t; n++) r += this.groupSizes[n];
    return r;
  }, e.prototype.insertRules = function(t, r) {
    if (t >= this.groupSizes.length) {
      for (var n = this.groupSizes, i = n.length, s = i; t >= s; ) if ((s <<= 1) < 0) throw Rn(16, "".concat(t));
      this.groupSizes = new Uint32Array(s), this.groupSizes.set(n), this.length = s;
      for (var o = i; o < s; o++) this.groupSizes[o] = 0;
    }
    for (var a = this.indexOfGroup(t + 1), l = (o = 0, r.length); o < l; o++) this.tag.insertRule(a, r[o]) && (this.groupSizes[t]++, a++);
  }, e.prototype.clearGroup = function(t) {
    if (t < this.length) {
      var r = this.groupSizes[t], n = this.indexOfGroup(t), i = n + r;
      this.groupSizes[t] = 0;
      for (var s = n; s < i; s++) this.tag.deleteRule(n);
    }
  }, e.prototype.getGroup = function(t) {
    var r = "";
    if (t >= this.length || this.groupSizes[t] === 0) return r;
    for (var n = this.groupSizes[t], i = this.indexOfGroup(t), s = i + n, o = i; o < s; o++) r += "".concat(this.tag.getRule(o)).concat(QS);
    return r;
  }, e;
}(), Yh = /* @__PURE__ */ new Map(), Rm = /* @__PURE__ */ new Map(), Gh = 1, md = function(e) {
  if (Yh.has(e)) return Yh.get(e);
  for (; Rm.has(Gh); ) Gh++;
  var t = Gh++;
  return Yh.set(e, t), Rm.set(t, e), t;
}, kV = function(e, t) {
  Gh = t + 1, Yh.set(e, t), Rm.set(t, e);
}, AV = "style[".concat(fs, "][").concat(Cm, '="').concat(da, '"]'), PV = new RegExp("^".concat(fs, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')), TV = function(e, t, r) {
  for (var n, i = r.split(","), s = 0, o = i.length; s < o; s++) (n = i[s]) && e.registerName(t, n);
}, CV = function(e, t) {
  for (var r, n = ((r = t.textContent) !== null && r !== void 0 ? r : "").split(QS), i = [], s = 0, o = n.length; s < o; s++) {
    var a = n[s].trim();
    if (a) {
      var l = a.match(PV);
      if (l) {
        var u = 0 | parseInt(l[1], 10), f = l[2];
        u !== 0 && (kV(f, u), TV(e, f, l[3]), e.getTag().insertRules(u, i)), i.length = 0;
      } else i.push(a);
    }
  }
}, vk = function(e) {
  for (var t = document.querySelectorAll(AV), r = 0, n = t.length; r < n; r++) {
    var i = t[r];
    i && i.getAttribute(fs) !== xN && (CV(e, i), i.parentNode && i.parentNode.removeChild(i));
  }
};
function aw() {
  return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : null;
}
var CN = function(e) {
  var t = document.head, r = e || t, n = document.createElement("style"), i = function(a) {
    var l = Array.from(a.querySelectorAll("style[".concat(fs, "]")));
    return l[l.length - 1];
  }(r), s = i !== void 0 ? i.nextSibling : null;
  n.setAttribute(fs, xN), n.setAttribute(Cm, da);
  var o = aw();
  return o && n.setAttribute("nonce", o), r.insertBefore(n, s), n;
}, $V = function() {
  function e(t) {
    this.element = CN(t), this.element.appendChild(document.createTextNode("")), this.sheet = function(r) {
      if (r.sheet) return r.sheet;
      for (var n = document.styleSheets, i = 0, s = n.length; i < s; i++) {
        var o = n[i];
        if (o.ownerNode === r) return o;
      }
      throw Rn(17);
    }(this.element), this.length = 0;
  }
  return e.prototype.insertRule = function(t, r) {
    try {
      return this.sheet.insertRule(r, t), this.length++, !0;
    } catch {
      return !1;
    }
  }, e.prototype.deleteRule = function(t) {
    this.sheet.deleteRule(t), this.length--;
  }, e.prototype.getRule = function(t) {
    var r = this.sheet.cssRules[t];
    return r && r.cssText ? r.cssText : "";
  }, e;
}(), RV = function() {
  function e(t) {
    this.element = CN(t), this.nodes = this.element.childNodes, this.length = 0;
  }
  return e.prototype.insertRule = function(t, r) {
    if (t <= this.length && t >= 0) {
      var n = document.createTextNode(r);
      return this.element.insertBefore(n, this.nodes[t] || null), this.length++, !0;
    }
    return !1;
  }, e.prototype.deleteRule = function(t) {
    this.element.removeChild(this.nodes[t]), this.length--;
  }, e.prototype.getRule = function(t) {
    return t < this.length ? this.nodes[t].textContent : "";
  }, e;
}(), IV = function() {
  function e(t) {
    this.rules = [], this.length = 0;
  }
  return e.prototype.insertRule = function(t, r) {
    return t <= this.length && (this.rules.splice(t, 0, r), this.length++, !0);
  }, e.prototype.deleteRule = function(t) {
    this.rules.splice(t, 1), this.length--;
  }, e.prototype.getRule = function(t) {
    return t < this.length ? this.rules[t] : "";
  }, e;
}(), bk = $m, NV = { isServer: !$m, useCSSOMInjection: !fV }, Wl = function() {
  function e(t, r, n) {
    t === void 0 && (t = Vl), r === void 0 && (r = {});
    var i = this;
    this.options = ar(ar({}, NV), t), this.gs = r, this.names = new Map(n), this.server = !!t.isServer, !this.server && $m && bk && (bk = !1, vk(this)), XS(this, function() {
      return function(s) {
        for (var o = s.getTag(), a = o.length, l = "", u = function(d) {
          var m = function(x) {
            return Rm.get(x);
          }(d);
          if (m === void 0) return "continue";
          var v = s.names.get(m), S = o.getGroup(d);
          if (v === void 0 || !v.size || S.length === 0) return "continue";
          var y = "".concat(fs, ".g").concat(d, '[id="').concat(m, '"]'), E = "";
          v !== void 0 && v.forEach(function(x) {
            x.length > 0 && (E += "".concat(x, ","));
          }), l += "".concat(S).concat(y, '{content:"').concat(E, '"}').concat(QS);
        }, f = 0; f < a; f++) u(f);
        return l;
      }(i);
    });
  }
  return e.registerId = function(t) {
    return md(t);
  }, e.prototype.rehydrate = function() {
    !this.server && $m && vk(this);
  }, e.prototype.reconstructWithOptions = function(t, r) {
    return r === void 0 && (r = !0), new e(ar(ar({}, this.options), t), this.gs, r && this.names || void 0);
  }, e.prototype.allocateGSInstance = function(t) {
    return this.gs[t] = (this.gs[t] || 0) + 1;
  }, e.prototype.getTag = function() {
    return this.tag || (this.tag = (t = function(r) {
      var n = r.useCSSOMInjection, i = r.target;
      return r.isServer ? new IV(i) : n ? new $V(i) : new RV(i);
    }(this.options), new OV(t)));
    var t;
  }, e.prototype.hasNameForId = function(t, r) {
    return this.names.has(t) && this.names.get(t).has(r);
  }, e.prototype.registerName = function(t, r) {
    if (md(t), this.names.has(t)) this.names.get(t).add(r);
    else {
      var n = /* @__PURE__ */ new Set();
      n.add(r), this.names.set(t, n);
    }
  }, e.prototype.insertRules = function(t, r, n) {
    this.registerName(t, r), this.getTag().insertRules(md(t), n);
  }, e.prototype.clearNames = function(t) {
    this.names.has(t) && this.names.get(t).clear();
  }, e.prototype.clearRules = function(t) {
    this.getTag().clearGroup(md(t)), this.clearNames(t);
  }, e.prototype.clearTag = function() {
    this.tag = void 0;
  }, e;
}(), jV = /&/g, LV = /^\s*\/\/.*$/gm;
function $N(e, t) {
  return e.map(function(r) {
    return r.type === "rule" && (r.value = "".concat(t, " ").concat(r.value), r.value = r.value.replaceAll(",", ",".concat(t, " ")), r.props = r.props.map(function(n) {
      return "".concat(t, " ").concat(n);
    })), Array.isArray(r.children) && r.type !== "@keyframes" && (r.children = $N(r.children, t)), r;
  });
}
function RN(e) {
  var t, r, n, i = e === void 0 ? Vl : e, s = i.options, o = s === void 0 ? Vl : s, a = i.plugins, l = a === void 0 ? Ig : a, u = function(m, v, S) {
    return S.startsWith(r) && S.endsWith(r) && S.replaceAll(r, "").length > 0 ? ".".concat(t) : m;
  }, f = l.slice();
  f.push(function(m) {
    m.type === Tg && m.value.includes("&") && (m.props[0] = m.props[0].replace(jV, r).replace(n, u));
  }), o.prefix && f.push(cV), f.push(aV);
  var d = function(m, v, S, y) {
    v === void 0 && (v = ""), S === void 0 && (S = ""), y === void 0 && (y = "&"), t = y, r = v, n = new RegExp("\\".concat(r, "\\b"), "g");
    var E = m.replace(LV, ""), x = oV(S || v ? "".concat(S, " ").concat(v, " { ").concat(E, " }") : E);
    o.namespace && (x = $N(x, o.namespace));
    var g = [];
    return Tm(x, lV(f.concat(uV(function(b) {
      return g.push(b);
    })))), g;
  };
  return d.hash = l.length ? l.reduce(function(m, v) {
    return v.name || Rn(15), wl(m, v.name);
  }, _N).toString() : "", d;
}
var IN = new Wl(), lw = RN(), jg = at.createContext({ shouldForwardProp: void 0, styleSheet: IN, stylis: lw }), MV = jg.Consumer, DV = at.createContext(void 0);
function Im() {
  return et.useContext(jg);
}
function NN(e) {
  var t = et.useState(e.stylisPlugins), r = t[0], n = t[1], i = Im().styleSheet, s = et.useMemo(function() {
    var l = i;
    return e.sheet ? l = e.sheet : e.target && (l = l.reconstructWithOptions({ target: e.target }, !1)), e.disableCSSOMInjection && (l = l.reconstructWithOptions({ useCSSOMInjection: !1 })), l;
  }, [e.disableCSSOMInjection, e.sheet, e.target, i]), o = et.useMemo(function() {
    return RN({ options: { namespace: e.namespace, prefix: e.enableVendorPrefixes }, plugins: r });
  }, [e.enableVendorPrefixes, e.namespace, r]);
  et.useEffect(function() {
    H6(r, e.stylisPlugins) || n(e.stylisPlugins);
  }, [e.stylisPlugins]);
  var a = et.useMemo(function() {
    return { shouldForwardProp: e.shouldForwardProp, styleSheet: s, stylis: o };
  }, [e.shouldForwardProp, s, o]);
  return at.createElement(jg.Provider, { value: a }, at.createElement(DV.Provider, { value: o }, e.children));
}
var jN = function() {
  function e(t, r) {
    var n = this;
    this.inject = function(i, s) {
      s === void 0 && (s = lw);
      var o = n.name + s.hash;
      i.hasNameForId(n.id, o) || i.insertRules(n.id, o, s(n.rules, o, "@keyframes"));
    }, this.name = t, this.id = "sc-keyframes-".concat(t), this.rules = r, XS(this, function() {
      throw Rn(12, String(n.name));
    });
  }
  return e.prototype.getName = function(t) {
    return t === void 0 && (t = lw), this.name + t.hash;
  }, e;
}(), FV = function(e) {
  return e >= "A" && e <= "Z";
};
function wk(e) {
  for (var t = "", r = 0; r < e.length; r++) {
    var n = e[r];
    if (r === 1 && n === "-" && e[0] === "-") return e;
    FV(n) ? t += "-" + n.toLowerCase() : t += n;
  }
  return t.startsWith("ms-") ? "-" + t : t;
}
var LN = function(e) {
  return e == null || e === !1 || e === "";
}, MN = function(e) {
  var t, r, n = [];
  for (var i in e) {
    var s = e[i];
    e.hasOwnProperty(i) && !LN(s) && (Array.isArray(s) && s.isCss || ha(s) ? n.push("".concat(wk(i), ":"), s, ";") : fp(s) ? n.push.apply(n, ql(ql(["".concat(i, " {")], MN(s), !1), ["}"], !1)) : n.push("".concat(wk(i), ": ").concat((t = i, (r = s) == null || typeof r == "boolean" || r === "" ? "" : typeof r != "number" || r === 0 || t in pV || t.startsWith("--") ? String(r).trim() : "".concat(r, "px")), ";")));
  }
  return n;
};
function ss(e, t, r, n) {
  if (LN(e)) return [];
  if (Ng(e)) return [".".concat(e.styledComponentId)];
  if (ha(e)) {
    if (!ha(s = e) || s.prototype && s.prototype.isReactComponent || !t) return [e];
    var i = e(t);
    return ss(i, t, r, n);
  }
  var s;
  return e instanceof jN ? r ? (e.inject(r, n), [e.getName(n)]) : [e] : fp(e) ? MN(e) : Array.isArray(e) ? Array.prototype.concat.apply(Ig, e.map(function(o) {
    return ss(o, t, r, n);
  })) : [e.toString()];
}
function DN(e) {
  for (var t = 0; t < e.length; t += 1) {
    var r = e[t];
    if (ha(r) && !Ng(r)) return !1;
  }
  return !0;
}
var zV = ON(da), qV = function() {
  function e(t, r, n) {
    this.rules = t, this.staticRulesId = "", this.isStatic = (n === void 0 || n.isStatic) && DN(t), this.componentId = r, this.baseHash = wl(zV, r), this.baseStyle = n, Wl.registerId(r);
  }
  return e.prototype.generateAndInjectStyles = function(t, r, n) {
    var i = this.baseStyle ? this.baseStyle.generateAndInjectStyles(t, r, n) : "";
    if (this.isStatic && !n.hash) if (this.staticRulesId && r.hasNameForId(this.componentId, this.staticRulesId)) i = ta(i, this.staticRulesId);
    else {
      var s = pp(ss(this.rules, t, r, n)), o = ow(wl(this.baseHash, s) >>> 0);
      if (!r.hasNameForId(this.componentId, o)) {
        var a = n(s, ".".concat(o), void 0, this.componentId);
        r.insertRules(this.componentId, o, a);
      }
      i = ta(i, o), this.staticRulesId = o;
    }
    else {
      for (var l = wl(this.baseHash, n.hash), u = "", f = 0; f < this.rules.length; f++) {
        var d = this.rules[f];
        if (typeof d == "string") u += d;
        else if (d) {
          var m = pp(ss(d, t, r, n));
          l = wl(l, m + f), u += m;
        }
      }
      if (u) {
        var v = ow(l >>> 0);
        r.hasNameForId(this.componentId, v) || r.insertRules(this.componentId, v, n(u, ".".concat(v), void 0, this.componentId)), i = ta(i, v);
      }
    }
    return i;
  }, e;
}(), ds = at.createContext(void 0), BV = ds.Consumer;
function UV() {
  var e = et.useContext(ds);
  if (!e) throw Rn(18);
  return e;
}
function VV(e) {
  var t = at.useContext(ds), r = et.useMemo(function() {
    return function(n, i) {
      if (!n) throw Rn(14);
      if (ha(n)) {
        var s = n(i);
        return s;
      }
      if (Array.isArray(n) || typeof n != "object") throw Rn(8);
      return i ? ar(ar({}, i), n) : n;
    }(e.theme, t);
  }, [e.theme, t]);
  return e.children ? at.createElement(ds.Provider, { value: r }, e.children) : null;
}
var Dv = {};
function WV(e, t, r) {
  var n = Ng(e), i = e, s = !Mv(e), o = t.attrs, a = o === void 0 ? Ig : o, l = t.componentId, u = l === void 0 ? function(A, P) {
    var k = typeof A != "string" ? "sc" : dk(A);
    Dv[k] = (Dv[k] || 0) + 1;
    var $ = "".concat(k, "-").concat(GS(da + k + Dv[k]));
    return P ? "".concat(P, "-").concat($) : $;
  }(t.displayName, t.parentComponentId) : l, f = t.displayName, d = f === void 0 ? function(A) {
    return Mv(A) ? "styled.".concat(A) : "Styled(".concat(kN(A), ")");
  }(e) : f, m = t.displayName && t.componentId ? "".concat(dk(t.displayName), "-").concat(t.componentId) : t.componentId || u, v = n && i.attrs ? i.attrs.concat(a).filter(Boolean) : a, S = t.shouldForwardProp;
  if (n && i.shouldForwardProp) {
    var y = i.shouldForwardProp;
    if (t.shouldForwardProp) {
      var E = t.shouldForwardProp;
      S = function(A, P) {
        return y(A, P) && E(A, P);
      };
    } else S = y;
  }
  var x = new qV(r, m, n ? i.componentStyle : void 0);
  function g(A, P) {
    return function(k, $, I) {
      var F = k.attrs, L = k.componentStyle, Q = k.defaultProps, Y = k.foldedComponentIds, ae = k.styledComponentId, le = k.target, ue = at.useContext(ds), ce = Im(), be = k.shouldForwardProp || ce.shouldForwardProp, G = YS($, ue, Q) || Vl, ee = function(H, B, pe) {
        for (var he, Ae = ar(ar({}, B), { className: void 0, theme: pe }), C = 0; C < H.length; C += 1) {
          var N = ha(he = H[C]) ? he(Ae) : he;
          for (var J in N) Ae[J] = J === "className" ? ta(Ae[J], N[J]) : J === "style" ? ar(ar({}, Ae[J]), N[J]) : N[J];
        }
        return B.className && (Ae.className = ta(Ae.className, B.className)), Ae;
      }(F, $, G), K = ee.as || le, z = {};
      for (var te in ee) ee[te] === void 0 || te[0] === "$" || te === "as" || te === "theme" && ee.theme === G || (te === "forwardedAs" ? z.as = ee.forwardedAs : be && !be(te, K) || (z[te] = ee[te]));
      var q = function(H, B) {
        var pe = Im(), he = H.generateAndInjectStyles(B, pe.styleSheet, pe.stylis);
        return he;
      }(L, ee), j = ta(Y, ae);
      return q && (j += " " + q), ee.className && (j += " " + ee.className), z[Mv(K) && !EN.has(K) ? "class" : "className"] = j, I && (z.ref = I), et.createElement(K, z);
    }(b, A, P);
  }
  g.displayName = d;
  var b = at.forwardRef(g);
  return b.attrs = v, b.componentStyle = x, b.displayName = d, b.shouldForwardProp = S, b.foldedComponentIds = n ? ta(i.foldedComponentIds, i.styledComponentId) : "", b.styledComponentId = m, b.target = n ? i.target : e, Object.defineProperty(b, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(A) {
    this._foldedDefaultProps = n ? function(P) {
      for (var k = [], $ = 1; $ < arguments.length; $++) k[$ - 1] = arguments[$];
      for (var I = 0, F = k; I < F.length; I++) sw(P, F[I], !0);
      return P;
    }({}, i.defaultProps, A) : A;
  } }), XS(b, function() {
    return ".".concat(b.styledComponentId);
  }), s && KS(b, e, { attrs: !0, componentStyle: !0, displayName: !0, foldedComponentIds: !0, shouldForwardProp: !0, styledComponentId: !0, target: !0 }), b;
}
function Sk(e, t) {
  for (var r = [e[0]], n = 0, i = t.length; n < i; n += 1) r.push(t[n], e[n + 1]);
  return r;
}
var xk = function(e) {
  return Object.assign(e, { isCss: !0 });
};
function Lg(e) {
  for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
  if (ha(e) || fp(e)) return xk(ss(Sk(Ig, ql([e], t, !0))));
  var n = e;
  return t.length === 0 && n.length === 1 && typeof n[0] == "string" ? ss(n) : xk(ss(Sk(n, t)));
}
function uw(e, t, r) {
  if (r === void 0 && (r = Vl), !t) throw Rn(1, t);
  var n = function(i) {
    for (var s = [], o = 1; o < arguments.length; o++) s[o - 1] = arguments[o];
    return e(t, r, Lg.apply(void 0, ql([i], s, !1)));
  };
  return n.attrs = function(i) {
    return uw(e, t, ar(ar({}, r), { attrs: Array.prototype.concat(r.attrs, i).filter(Boolean) }));
  }, n.withConfig = function(i) {
    return uw(e, t, ar(ar({}, r), i));
  }, n;
}
var FN = function(e) {
  return uw(WV, e);
}, cw = FN;
EN.forEach(function(e) {
  cw[e] = FN(e);
});
var HV = function() {
  function e(t, r) {
    this.rules = t, this.componentId = r, this.isStatic = DN(t), Wl.registerId(this.componentId + 1);
  }
  return e.prototype.createStyles = function(t, r, n, i) {
    var s = i(pp(ss(this.rules, r, n, i)), ""), o = this.componentId + t;
    n.insertRules(o, o, s);
  }, e.prototype.removeStyles = function(t, r) {
    r.clearRules(this.componentId + t);
  }, e.prototype.renderStyles = function(t, r, n, i) {
    t > 2 && Wl.registerId(this.componentId + t), this.removeStyles(t, n), this.createStyles(t, r, n, i);
  }, e;
}();
function QV(e) {
  for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
  var n = Lg.apply(void 0, ql([e], t, !1)), i = "sc-global-".concat(GS(JSON.stringify(n))), s = new HV(n, i), o = function(l) {
    var u = Im(), f = at.useContext(ds), d = at.useRef(u.styleSheet.allocateGSInstance(i)).current;
    return u.styleSheet.server && a(d, l, u.styleSheet, f, u.stylis), at.useLayoutEffect(function() {
      if (!u.styleSheet.server) return a(d, l, u.styleSheet, f, u.stylis), function() {
        return s.removeStyles(d, u.styleSheet);
      };
    }, [d, l, u.styleSheet, f, u.stylis]), null;
  };
  function a(l, u, f, d, m) {
    if (s.isStatic) s.renderStyles(l, dV, f, m);
    else {
      var v = ar(ar({}, u), { theme: YS(u, d, o.defaultProps) });
      s.renderStyles(l, v, f, m);
    }
  }
  return at.memo(o);
}
function YV(e) {
  for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
  var n = pp(Lg.apply(void 0, ql([e], t, !1))), i = GS(n);
  return new jN(i, n);
}
function GV(e) {
  var t = at.forwardRef(function(r, n) {
    var i = YS(r, at.useContext(ds), e.defaultProps);
    return at.createElement(e, ar({}, r, { theme: i, ref: n }));
  });
  return t.displayName = "WithTheme(".concat(kN(e), ")"), KS(t, e);
}
var KV = function() {
  function e() {
    var t = this;
    this._emitSheetCSS = function() {
      var r = t.instance.toString();
      if (!r) return "";
      var n = aw(), i = pp([n && 'nonce="'.concat(n, '"'), "".concat(fs, '="true"'), "".concat(Cm, '="').concat(da, '"')].filter(Boolean), " ");
      return "<style ".concat(i, ">").concat(r, "</style>");
    }, this.getStyleTags = function() {
      if (t.sealed) throw Rn(2);
      return t._emitSheetCSS();
    }, this.getStyleElement = function() {
      var r;
      if (t.sealed) throw Rn(2);
      var n = t.instance.toString();
      if (!n) return [];
      var i = ((r = {})[fs] = "", r[Cm] = da, r.dangerouslySetInnerHTML = { __html: n }, r), s = aw();
      return s && (i.nonce = s), [at.createElement("style", ar({}, i, { key: "sc-0-0" }))];
    }, this.seal = function() {
      t.sealed = !0;
    }, this.instance = new Wl({ isServer: !0 }), this.sealed = !1;
  }
  return e.prototype.collectStyles = function(t) {
    if (this.sealed) throw Rn(2);
    return at.createElement(NN, { sheet: this.instance }, t);
  }, e.prototype.interleaveWithNodeStream = function(t) {
    throw Rn(3);
  }, e;
}(), XV = { StyleSheet: Wl, mainSheet: IN };
const JV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ServerStyleSheet: KV,
  StyleSheetConsumer: MV,
  StyleSheetContext: jg,
  StyleSheetManager: NN,
  ThemeConsumer: BV,
  ThemeContext: ds,
  ThemeProvider: VV,
  __PRIVATE__: XV,
  createGlobalStyle: QV,
  css: Lg,
  default: cw,
  isStyledComponent: Ng,
  keyframes: YV,
  styled: cw,
  useTheme: UV,
  version: da,
  withTheme: GV
}, Symbol.toStringTag, { value: "Module" })), ZV = /* @__PURE__ */ Di(JV);
var Fv = { exports: {} }, zv, Ek;
function e8() {
  if (Ek) return zv;
  Ek = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return zv = e, zv;
}
var qv, _k;
function t8() {
  if (_k) return qv;
  _k = 1;
  var e = e8();
  function t() {
  }
  function r() {
  }
  return r.resetWarningCache = t, qv = function() {
    function n(o, a, l, u, f, d) {
      if (d !== e) {
        var m = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw m.name = "Invariant Violation", m;
      }
    }
    n.isRequired = n;
    function i() {
      return n;
    }
    var s = {
      array: n,
      bigint: n,
      bool: n,
      func: n,
      number: n,
      object: n,
      string: n,
      symbol: n,
      any: n,
      arrayOf: i,
      element: n,
      elementType: n,
      instanceOf: i,
      node: n,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: r,
      resetWarningCache: t
    };
    return s.PropTypes = s, s;
  }, qv;
}
var Ok;
function zN() {
  return Ok || (Ok = 1, Fv.exports = t8()()), Fv.exports;
}
function tt(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    r[n - 1] = arguments[n];
  throw new Error(typeof e == "number" ? "[MobX] minified error nr: " + e + (r.length ? " " + r.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + e);
}
var r8 = {};
function Mg() {
  return typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : r8;
}
var qN = Object.assign, Nm = Object.getOwnPropertyDescriptor, Ni = Object.defineProperty, kp = Object.prototype, pw = [];
Object.freeze(pw);
var JS = {};
Object.freeze(JS);
var n8 = typeof Proxy < "u", i8 = /* @__PURE__ */ Object.toString();
function BN() {
  n8 || tt("Proxy not available");
}
function UN(e) {
  var t = !1;
  return function() {
    if (!t)
      return t = !0, e.apply(this, arguments);
  };
}
var Sl = function() {
};
function yn(e) {
  return typeof e == "function";
}
function ma(e) {
  var t = typeof e;
  switch (t) {
    case "string":
    case "symbol":
    case "number":
      return !0;
  }
  return !1;
}
function Dg(e) {
  return e !== null && typeof e == "object";
}
function So(e) {
  if (!Dg(e))
    return !1;
  var t = Object.getPrototypeOf(e);
  if (t == null)
    return !0;
  var r = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return typeof r == "function" && r.toString() === i8;
}
function VN(e) {
  var t = e == null ? void 0 : e.constructor;
  return t ? t.name === "GeneratorFunction" || t.displayName === "GeneratorFunction" : !1;
}
function Ap(e, t, r) {
  Ni(e, t, {
    enumerable: !1,
    writable: !0,
    configurable: !0,
    value: r
  });
}
function WN(e, t, r) {
  Ni(e, t, {
    enumerable: !1,
    writable: !1,
    configurable: !0,
    value: r
  });
}
function ws(e, t) {
  var r = "isMobX" + e;
  return t.prototype[r] = !0, function(n) {
    return Dg(n) && n[r] === !0;
  };
}
function ou(e) {
  return e != null && Object.prototype.toString.call(e) === "[object Map]";
}
function o8(e) {
  var t = Object.getPrototypeOf(e), r = Object.getPrototypeOf(t), n = Object.getPrototypeOf(r);
  return n === null;
}
function oo(e) {
  return e != null && Object.prototype.toString.call(e) === "[object Set]";
}
var HN = typeof Object.getOwnPropertySymbols < "u";
function s8(e) {
  var t = Object.keys(e);
  if (!HN)
    return t;
  var r = Object.getOwnPropertySymbols(e);
  return r.length ? [].concat(t, r.filter(function(n) {
    return kp.propertyIsEnumerable.call(e, n);
  })) : t;
}
var Hl = typeof Reflect < "u" && Reflect.ownKeys ? Reflect.ownKeys : HN ? function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : (
  /* istanbul ignore next */
  Object.getOwnPropertyNames
);
function QN(e) {
  return e === null ? null : typeof e == "object" ? "" + e : e;
}
function po(e, t) {
  return kp.hasOwnProperty.call(e, t);
}
var a8 = Object.getOwnPropertyDescriptors || function(t) {
  var r = {};
  return Hl(t).forEach(function(n) {
    r[n] = Nm(t, n);
  }), r;
};
function pn(e, t) {
  return !!(e & t);
}
function fn(e, t, r) {
  return r ? e |= t : e &= ~t, e;
}
function kk(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function l8(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, c8(n.key), n);
  }
}
function su(e, t, r) {
  return t && l8(e.prototype, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function xl(e, t) {
  var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r) return (r = r.call(e)).next.bind(r);
  if (Array.isArray(e) || (r = p8(e)) || t) {
    r && (e = r);
    var n = 0;
    return function() {
      return n >= e.length ? {
        done: !0
      } : {
        done: !1,
        value: e[n++]
      };
    };
  }
  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function hs() {
  return hs = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r) ({}).hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, hs.apply(null, arguments);
}
function YN(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, fw(e, t);
}
function fw(e, t) {
  return fw = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, n) {
    return r.__proto__ = n, r;
  }, fw(e, t);
}
function u8(e, t) {
  if (typeof e != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
function c8(e) {
  var t = u8(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function p8(e, t) {
  if (e) {
    if (typeof e == "string") return kk(e, t);
    var r = {}.toString.call(e).slice(8, -1);
    return r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set" ? Array.from(e) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? kk(e, t) : void 0;
  }
}
var Pi = /* @__PURE__ */ Symbol("mobx-stored-annotations");
function ii(e) {
  function t(r, n) {
    if (Tp(n))
      return e.decorate_20223_(r, n);
    Pp(r, n, e);
  }
  return Object.assign(t, e);
}
function Pp(e, t, r) {
  po(e, Pi) || Ap(e, Pi, hs({}, e[Pi])), w8(r) || (e[Pi][t] = r);
}
function f8(e) {
  return po(e, Pi) || Ap(e, Pi, hs({}, e[Pi])), e[Pi];
}
function Tp(e) {
  return typeof e == "object" && typeof e.kind == "string";
}
var Ye = /* @__PURE__ */ Symbol("mobx administration"), Ss = /* @__PURE__ */ function() {
  function e(r) {
    r === void 0 && (r = "Atom"), this.name_ = void 0, this.flags_ = 0, this.observers_ = /* @__PURE__ */ new Set(), this.lastAccessedBy_ = 0, this.lowestObserverState_ = gt.NOT_TRACKING_, this.onBOL = void 0, this.onBUOL = void 0, this.name_ = r;
  }
  var t = e.prototype;
  return t.onBO = function() {
    this.onBOL && this.onBOL.forEach(function(n) {
      return n();
    });
  }, t.onBUO = function() {
    this.onBUOL && this.onBUOL.forEach(function(n) {
      return n();
    });
  }, t.reportObserved = function() {
    return fj(this);
  }, t.reportChanged = function() {
    en(), dj(this), tn();
  }, t.toString = function() {
    return this.name_;
  }, su(e, [{
    key: "isBeingObserved",
    get: function() {
      return pn(this.flags_, e.isBeingObservedMask_);
    },
    set: function(n) {
      this.flags_ = fn(this.flags_, e.isBeingObservedMask_, n);
    }
  }, {
    key: "isPendingUnobservation",
    get: function() {
      return pn(this.flags_, e.isPendingUnobservationMask_);
    },
    set: function(n) {
      this.flags_ = fn(this.flags_, e.isPendingUnobservationMask_, n);
    }
  }, {
    key: "diffValue",
    get: function() {
      return pn(this.flags_, e.diffValueMask_) ? 1 : 0;
    },
    set: function(n) {
      this.flags_ = fn(this.flags_, e.diffValueMask_, n === 1);
    }
  }]);
}();
Ss.isBeingObservedMask_ = 1;
Ss.isPendingUnobservationMask_ = 2;
Ss.diffValueMask_ = 4;
var ZS = /* @__PURE__ */ ws("Atom", Ss);
function e1(e, t, r) {
  t === void 0 && (t = Sl), r === void 0 && (r = Sl);
  var n = new Ss(e);
  return t !== Sl && Sj(n, t), r !== Sl && i1(n, r), n;
}
function d8(e, t) {
  return e === t;
}
function h8(e, t) {
  return c1(e, t);
}
function m8(e, t) {
  return c1(e, t, 1);
}
function g8(e, t) {
  return Object.is ? Object.is(e, t) : e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
var ga = {
  identity: d8,
  structural: h8,
  default: g8,
  shallow: m8
};
function ya(e, t, r) {
  return Hg(e) ? e : Array.isArray(e) ? Xt.array(e, {
    name: r
  }) : So(e) ? Xt.object(e, void 0, {
    name: r
  }) : ou(e) ? Xt.map(e, {
    name: r
  }) : oo(e) ? Xt.set(e, {
    name: r
  }) : typeof e == "function" && !Yl(e) && !Gl(e) ? VN(e) ? ba(e) : Ql(r, e) : e;
}
function y8(e, t, r) {
  if (e == null || yr(e) || Wr(e) || vr(e) || cr(e))
    return e;
  if (Array.isArray(e))
    return Xt.array(e, {
      name: r,
      deep: !1
    });
  if (So(e))
    return Xt.object(e, void 0, {
      name: r,
      deep: !1
    });
  if (ou(e))
    return Xt.map(e, {
      name: r,
      deep: !1
    });
  if (oo(e))
    return Xt.set(e, {
      name: r,
      deep: !1
    });
}
function Fg(e) {
  return e;
}
function v8(e, t) {
  return c1(e, t) ? t : e;
}
var GN = "override", b8 = /* @__PURE__ */ ii({
  annotationType_: GN,
  make_: S8,
  extend_: x8,
  decorate_20223_: E8
});
function w8(e) {
  return e.annotationType_ === GN;
}
function S8(e, t) {
  return 0;
}
function x8(e, t, r, n) {
  tt("'" + this.annotationType_ + "' can only be used with 'makeObservable'");
}
function E8(e, t) {
  console.warn("'" + this.annotationType_ + "' cannot be used with decorators - this is a no-op");
}
function Cp(e, t) {
  return {
    annotationType_: e,
    options_: t,
    make_: _8,
    extend_: O8,
    decorate_20223_: k8
  };
}
function _8(e, t, r, n) {
  var i;
  if ((i = this.options_) != null && i.bound)
    return this.extend_(e, t, r, !1) === null ? 0 : 1;
  if (n === e.target_)
    return this.extend_(e, t, r, !1) === null ? 0 : 2;
  if (Yl(r.value))
    return 1;
  var s = KN(e, this, t, r, !1);
  return Ni(n, t, s), 2;
}
function O8(e, t, r, n) {
  var i = KN(e, this, t, r);
  return e.defineProperty_(t, i, n);
}
function k8(e, t) {
  var r = t.kind, n = t.name, i = t.addInitializer, s = this, o = function(u) {
    var f, d, m, v;
    return ms((f = (d = s.options_) == null ? void 0 : d.name) != null ? f : n.toString(), u, (m = (v = s.options_) == null ? void 0 : v.autoAction) != null ? m : !1);
  };
  if (r == "field")
    return function(l) {
      var u, f = l;
      return Yl(f) || (f = o(f)), (u = s.options_) != null && u.bound && (f = f.bind(this), f.isMobxAction = !0), f;
    };
  if (r == "method") {
    var a;
    return Yl(e) || (e = o(e)), (a = this.options_) != null && a.bound && i(function() {
      var l = this, u = l[n].bind(l);
      u.isMobxAction = !0, l[n] = u;
    }), e;
  }
  tt("Cannot apply '" + s.annotationType_ + "' to '" + String(n) + "' (kind: " + r + "):" + (`
'` + s.annotationType_ + "' can only be used on properties with a function value."));
}
function A8(e, t, r, n) {
  t.annotationType_, n.value;
}
function KN(e, t, r, n, i) {
  var s, o, a, l, u, f, d;
  i === void 0 && (i = Le.safeDescriptors), A8(e, t, r, n);
  var m = n.value;
  if ((s = t.options_) != null && s.bound) {
    var v;
    m = m.bind((v = e.proxy_) != null ? v : e.target_);
  }
  return {
    value: ms(
      (o = (a = t.options_) == null ? void 0 : a.name) != null ? o : r.toString(),
      m,
      (l = (u = t.options_) == null ? void 0 : u.autoAction) != null ? l : !1,
      // https://github.com/mobxjs/mobx/discussions/3140
      (f = t.options_) != null && f.bound ? (d = e.proxy_) != null ? d : e.target_ : void 0
    ),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: i ? e.isPlainObject_ : !0,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: !1,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: !i
  };
}
function XN(e, t) {
  return {
    annotationType_: e,
    options_: t,
    make_: P8,
    extend_: T8,
    decorate_20223_: C8
  };
}
function P8(e, t, r, n) {
  var i;
  if (n === e.target_)
    return this.extend_(e, t, r, !1) === null ? 0 : 2;
  if ((i = this.options_) != null && i.bound && (!po(e.target_, t) || !Gl(e.target_[t])) && this.extend_(e, t, r, !1) === null)
    return 0;
  if (Gl(r.value))
    return 1;
  var s = JN(e, this, t, r, !1, !1);
  return Ni(n, t, s), 2;
}
function T8(e, t, r, n) {
  var i, s = JN(e, this, t, r, (i = this.options_) == null ? void 0 : i.bound);
  return e.defineProperty_(t, s, n);
}
function C8(e, t) {
  var r, n = t.name, i = t.addInitializer;
  return Gl(e) || (e = ba(e)), (r = this.options_) != null && r.bound && i(function() {
    var s = this, o = s[n].bind(s);
    o.isMobXFlow = !0, s[n] = o;
  }), e;
}
function $8(e, t, r, n) {
  t.annotationType_, n.value;
}
function JN(e, t, r, n, i, s) {
  s === void 0 && (s = Le.safeDescriptors), $8(e, t, r, n);
  var o = n.value;
  if (Gl(o) || (o = ba(o)), i) {
    var a;
    o = o.bind((a = e.proxy_) != null ? a : e.target_), o.isMobXFlow = !0;
  }
  return {
    value: o,
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: s ? e.isPlainObject_ : !0,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: !1,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: !s
  };
}
function t1(e, t) {
  return {
    annotationType_: e,
    options_: t,
    make_: R8,
    extend_: I8,
    decorate_20223_: N8
  };
}
function R8(e, t, r) {
  return this.extend_(e, t, r, !1) === null ? 0 : 1;
}
function I8(e, t, r, n) {
  return j8(e, this, t, r), e.defineComputedProperty_(t, hs({}, this.options_, {
    get: r.get,
    set: r.set
  }), n);
}
function N8(e, t) {
  var r = this, n = t.name, i = t.addInitializer;
  return i(function() {
    var s = Ea(this)[Ye], o = hs({}, r.options_, {
      get: e,
      context: this
    });
    o.name || (o.name = "ObservableObject." + n.toString()), s.values_.set(n, new li(o));
  }), function() {
    return this[Ye].getObservablePropValue_(n);
  };
}
function j8(e, t, r, n) {
  t.annotationType_, n.get;
}
function zg(e, t) {
  return {
    annotationType_: e,
    options_: t,
    make_: L8,
    extend_: M8,
    decorate_20223_: D8
  };
}
function L8(e, t, r) {
  return this.extend_(e, t, r, !1) === null ? 0 : 1;
}
function M8(e, t, r, n) {
  var i, s;
  return F8(e, this), e.defineObservableProperty_(t, r.value, (i = (s = this.options_) == null ? void 0 : s.enhancer) != null ? i : ya, n);
}
function D8(e, t) {
  var r = this, n = t.kind, i = t.name, s = /* @__PURE__ */ new WeakSet();
  function o(a, l) {
    var u, f, d = Ea(a)[Ye], m = new as(l, (u = (f = r.options_) == null ? void 0 : f.enhancer) != null ? u : ya, "ObservableObject." + i.toString(), !1);
    d.values_.set(i, m), s.add(a);
  }
  if (n == "accessor")
    return {
      get: function() {
        return s.has(this) || o(this, e.get.call(this)), this[Ye].getObservablePropValue_(i);
      },
      set: function(l) {
        return s.has(this) || o(this, l), this[Ye].setObservablePropValue_(i, l);
      },
      init: function(l) {
        return s.has(this) || o(this, l), l;
      }
    };
}
function F8(e, t, r, n) {
  t.annotationType_;
}
var z8 = "true", q8 = /* @__PURE__ */ ZN();
function ZN(e) {
  return {
    annotationType_: z8,
    options_: e,
    make_: B8,
    extend_: U8,
    decorate_20223_: V8
  };
}
function B8(e, t, r, n) {
  var i, s;
  if (r.get)
    return $p.make_(e, t, r, n);
  if (r.set) {
    var o = ms(t.toString(), r.set);
    return n === e.target_ ? e.defineProperty_(t, {
      configurable: Le.safeDescriptors ? e.isPlainObject_ : !0,
      set: o
    }) === null ? 0 : 2 : (Ni(n, t, {
      configurable: !0,
      set: o
    }), 2);
  }
  if (n !== e.target_ && typeof r.value == "function") {
    var a;
    if (VN(r.value)) {
      var l, u = (l = this.options_) != null && l.autoBind ? ba.bound : ba;
      return u.make_(e, t, r, n);
    }
    var f = (a = this.options_) != null && a.autoBind ? Ql.bound : Ql;
    return f.make_(e, t, r, n);
  }
  var d = ((i = this.options_) == null ? void 0 : i.deep) === !1 ? Xt.ref : Xt;
  if (typeof r.value == "function" && (s = this.options_) != null && s.autoBind) {
    var m;
    r.value = r.value.bind((m = e.proxy_) != null ? m : e.target_);
  }
  return d.make_(e, t, r, n);
}
function U8(e, t, r, n) {
  var i, s;
  if (r.get)
    return $p.extend_(e, t, r, n);
  if (r.set)
    return e.defineProperty_(t, {
      configurable: Le.safeDescriptors ? e.isPlainObject_ : !0,
      set: ms(t.toString(), r.set)
    }, n);
  if (typeof r.value == "function" && (i = this.options_) != null && i.autoBind) {
    var o;
    r.value = r.value.bind((o = e.proxy_) != null ? o : e.target_);
  }
  var a = ((s = this.options_) == null ? void 0 : s.deep) === !1 ? Xt.ref : Xt;
  return a.extend_(e, t, r, n);
}
function V8(e, t) {
  tt("'" + this.annotationType_ + "' cannot be used as a decorator");
}
var W8 = "observable", H8 = "observable.ref", Q8 = "observable.shallow", Y8 = "observable.struct", ej = {
  deep: !0,
  name: void 0,
  defaultDecorator: void 0,
  proxy: !0
};
Object.freeze(ej);
function gd(e) {
  return e || ej;
}
var dw = /* @__PURE__ */ zg(W8), G8 = /* @__PURE__ */ zg(H8, {
  enhancer: Fg
}), K8 = /* @__PURE__ */ zg(Q8, {
  enhancer: y8
}), X8 = /* @__PURE__ */ zg(Y8, {
  enhancer: v8
}), tj = /* @__PURE__ */ ii(dw);
function yd(e) {
  return e.deep === !0 ? ya : e.deep === !1 ? Fg : Z8(e.defaultDecorator);
}
function J8(e) {
  var t;
  return e ? (t = e.defaultDecorator) != null ? t : ZN(e) : void 0;
}
function Z8(e) {
  var t, r;
  return e && (t = (r = e.options_) == null ? void 0 : r.enhancer) != null ? t : ya;
}
function rj(e, t, r) {
  if (Tp(t))
    return dw.decorate_20223_(e, t);
  if (ma(t)) {
    Pp(e, t, dw);
    return;
  }
  return Hg(e) ? e : So(e) ? Xt.object(e, t, r) : Array.isArray(e) ? Xt.array(e, t) : ou(e) ? Xt.map(e, t) : oo(e) ? Xt.set(e, t) : typeof e == "object" && e !== null ? e : Xt.box(e, t);
}
qN(rj, tj);
var eW = {
  box: function(t, r) {
    var n = gd(r);
    return new as(t, yd(n), n.name, !0, n.equals);
  },
  array: function(t, r) {
    var n = gd(r);
    return (Le.useProxies === !1 || n.proxy === !1 ? y9 : a9)(t, yd(n), n.name);
  },
  map: function(t, r) {
    var n = gd(r);
    return new a1(t, yd(n), n.name);
  },
  set: function(t, r) {
    var n = gd(r);
    return new l1(t, yd(n), n.name);
  },
  object: function(t, r, n) {
    return xs(function() {
      return o1(Le.useProxies === !1 || (n == null ? void 0 : n.proxy) === !1 ? Ea({}, n) : n9({}, n), t, r);
    });
  },
  ref: /* @__PURE__ */ ii(G8),
  shallow: /* @__PURE__ */ ii(K8),
  deep: tj,
  struct: /* @__PURE__ */ ii(X8)
}, Xt = /* @__PURE__ */ qN(rj, eW), nj = "computed", tW = "computed.struct", hw = /* @__PURE__ */ t1(nj), rW = /* @__PURE__ */ t1(tW, {
  equals: ga.structural
}), $p = function(t, r) {
  if (Tp(r))
    return hw.decorate_20223_(t, r);
  if (ma(r))
    return Pp(t, r, hw);
  if (So(t))
    return ii(t1(nj, t));
  var n = So(r) ? r : {};
  return n.get = t, n.name || (n.name = t.name || ""), new li(n);
};
Object.assign($p, hw);
$p.struct = /* @__PURE__ */ ii(rW);
var Ak, Pk, jm = 0, nW = 1, iW = (Ak = (Pk = /* @__PURE__ */ Nm(function() {
}, "name")) == null ? void 0 : Pk.configurable) != null ? Ak : !1, Tk = {
  value: "action",
  configurable: !0,
  writable: !1,
  enumerable: !1
};
function ms(e, t, r, n) {
  r === void 0 && (r = !1);
  function i() {
    return ij(e, r, t, n || this, arguments);
  }
  return i.isMobxAction = !0, i.toString = function() {
    return t.toString();
  }, iW && (Tk.value = e, Ni(i, "name", Tk)), i;
}
function ij(e, t, r, n, i) {
  var s = oj(e, t);
  try {
    return r.apply(n, i);
  } catch (o) {
    throw s.error_ = o, o;
  } finally {
    sj(s);
  }
}
function oj(e, t, r, n) {
  var i = !1, s = 0, o = Le.trackingDerivation, a = !t || !o;
  en();
  var l = Le.allowStateChanges;
  a && (xa(), l = Bg(!0));
  var u = Vg(!0), f = {
    runAsAction_: a,
    prevDerivation_: o,
    prevAllowStateChanges_: l,
    prevAllowStateReads_: u,
    notifySpy_: i,
    startTime_: s,
    actionId_: nW++,
    parentActionId_: jm
  };
  return jm = f.actionId_, f;
}
function sj(e) {
  jm !== e.actionId_ && tt(30), jm = e.parentActionId_, e.error_ !== void 0 && (Le.suppressReactionErrors = !0), Ug(e.prevAllowStateChanges_), $l(e.prevAllowStateReads_), tn(), e.runAsAction_ && fo(e.prevDerivation_), Le.suppressReactionErrors = !1;
}
function qg(e, t) {
  var r = Bg(e);
  try {
    return t();
  } finally {
    Ug(r);
  }
}
function Bg(e) {
  var t = Le.allowStateChanges;
  return Le.allowStateChanges = e, t;
}
function Ug(e) {
  Le.allowStateChanges = e;
}
var as = /* @__PURE__ */ function(e) {
  function t(n, i, s, o, a) {
    var l;
    return s === void 0 && (s = "ObservableValue"), a === void 0 && (a = ga.default), l = e.call(this, s) || this, l.enhancer = void 0, l.name_ = void 0, l.equals = void 0, l.hasUnreportedChange_ = !1, l.interceptors_ = void 0, l.changeListeners_ = void 0, l.value_ = void 0, l.dehancer = void 0, l.enhancer = i, l.name_ = s, l.equals = a, l.value_ = i(n, void 0, s), l;
  }
  YN(t, e);
  var r = t.prototype;
  return r.dehanceValue = function(i) {
    return this.dehancer !== void 0 ? this.dehancer(i) : i;
  }, r.set = function(i) {
    this.value_, i = this.prepareNewValue_(i), i !== Le.UNCHANGED && this.setNewValue_(i);
  }, r.prepareNewValue_ = function(i) {
    if (Tn(this)) {
      var s = Cn(this, {
        object: this,
        type: ji,
        newValue: i
      });
      if (!s)
        return Le.UNCHANGED;
      i = s.newValue;
    }
    return i = this.enhancer(i, this.value_, this.name_), this.equals(this.value_, i) ? Le.UNCHANGED : i;
  }, r.setNewValue_ = function(i) {
    var s = this.value_;
    this.value_ = i, this.reportChanged(), oi(this) && si(this, {
      type: ji,
      object: this,
      newValue: i,
      oldValue: s
    });
  }, r.get = function() {
    return this.reportObserved(), this.dehanceValue(this.value_);
  }, r.intercept_ = function(i) {
    return Rp(this, i);
  }, r.observe_ = function(i, s) {
    return s && i({
      observableKind: "value",
      debugObjectName: this.name_,
      object: this,
      type: ji,
      newValue: this.value_,
      oldValue: void 0
    }), Ip(this, i);
  }, r.raw = function() {
    return this.value_;
  }, r.toJSON = function() {
    return this.get();
  }, r.toString = function() {
    return this.name_ + "[" + this.value_ + "]";
  }, r.valueOf = function() {
    return QN(this.get());
  }, r[Symbol.toPrimitive] = function() {
    return this.valueOf();
  }, t;
}(Ss), r1 = /* @__PURE__ */ ws("ObservableValue", as), li = /* @__PURE__ */ function() {
  function e(r) {
    this.dependenciesState_ = gt.NOT_TRACKING_, this.observing_ = [], this.newObserving_ = null, this.observers_ = /* @__PURE__ */ new Set(), this.runId_ = 0, this.lastAccessedBy_ = 0, this.lowestObserverState_ = gt.UP_TO_DATE_, this.unboundDepsCount_ = 0, this.value_ = new Mm(null), this.name_ = void 0, this.triggeredBy_ = void 0, this.flags_ = 0, this.derivation = void 0, this.setter_ = void 0, this.isTracing_ = Lm.NONE, this.scope_ = void 0, this.equals_ = void 0, this.requiresReaction_ = void 0, this.keepAlive_ = void 0, this.onBOL = void 0, this.onBUOL = void 0, r.get || tt(31), this.derivation = r.get, this.name_ = r.name || "ComputedValue", r.set && (this.setter_ = ms("ComputedValue-setter", r.set)), this.equals_ = r.equals || (r.compareStructural || r.struct ? ga.structural : ga.default), this.scope_ = r.context, this.requiresReaction_ = r.requiresReaction, this.keepAlive_ = !!r.keepAlive;
  }
  var t = e.prototype;
  return t.onBecomeStale_ = function() {
    mW(this);
  }, t.onBO = function() {
    this.onBOL && this.onBOL.forEach(function(n) {
      return n();
    });
  }, t.onBUO = function() {
    this.onBUOL && this.onBUOL.forEach(function(n) {
      return n();
    });
  }, t.get = function() {
    if (this.isComputing && tt(32, this.name_, this.derivation), Le.inBatch === 0 && // !globalState.trackingDerivatpion &&
    this.observers_.size === 0 && !this.keepAlive_)
      mw(this) && (this.warnAboutUntrackedRead_(), en(), this.value_ = this.computeValue_(!1), tn());
    else if (fj(this), mw(this)) {
      var n = Le.trackingContext;
      this.keepAlive_ && !n && (Le.trackingContext = this), this.trackAndCompute() && hW(this), Le.trackingContext = n;
    }
    var i = this.value_;
    if (Kh(i))
      throw i.cause;
    return i;
  }, t.set = function(n) {
    if (this.setter_) {
      this.isRunningSetter && tt(33, this.name_), this.isRunningSetter = !0;
      try {
        this.setter_.call(this.scope_, n);
      } finally {
        this.isRunningSetter = !1;
      }
    } else
      tt(34, this.name_);
  }, t.trackAndCompute = function() {
    var n = this.value_, i = (
      /* see #1208 */
      this.dependenciesState_ === gt.NOT_TRACKING_
    ), s = this.computeValue_(!0), o = i || Kh(n) || Kh(s) || !this.equals_(n, s);
    return o && (this.value_ = s), o;
  }, t.computeValue_ = function(n) {
    this.isComputing = !0;
    var i = Bg(!1), s;
    if (n)
      s = aj(this, this.derivation, this.scope_);
    else if (Le.disableErrorBoundaries === !0)
      s = this.derivation.call(this.scope_);
    else
      try {
        s = this.derivation.call(this.scope_);
      } catch (o) {
        s = new Mm(o);
      }
    return Ug(i), this.isComputing = !1, s;
  }, t.suspend_ = function() {
    this.keepAlive_ || (gw(this), this.value_ = void 0);
  }, t.observe_ = function(n, i) {
    var s = this, o = !0, a = void 0;
    return n1(function() {
      var l = s.get();
      if (!o || i) {
        var u = xa();
        n({
          observableKind: "computed",
          debugObjectName: s.name_,
          type: ji,
          object: s,
          newValue: l,
          oldValue: a
        }), fo(u);
      }
      o = !1, a = l;
    });
  }, t.warnAboutUntrackedRead_ = function() {
  }, t.toString = function() {
    return this.name_ + "[" + this.derivation.toString() + "]";
  }, t.valueOf = function() {
    return QN(this.get());
  }, t[Symbol.toPrimitive] = function() {
    return this.valueOf();
  }, su(e, [{
    key: "isComputing",
    get: function() {
      return pn(this.flags_, e.isComputingMask_);
    },
    set: function(n) {
      this.flags_ = fn(this.flags_, e.isComputingMask_, n);
    }
  }, {
    key: "isRunningSetter",
    get: function() {
      return pn(this.flags_, e.isRunningSetterMask_);
    },
    set: function(n) {
      this.flags_ = fn(this.flags_, e.isRunningSetterMask_, n);
    }
  }, {
    key: "isBeingObserved",
    get: function() {
      return pn(this.flags_, e.isBeingObservedMask_);
    },
    set: function(n) {
      this.flags_ = fn(this.flags_, e.isBeingObservedMask_, n);
    }
  }, {
    key: "isPendingUnobservation",
    get: function() {
      return pn(this.flags_, e.isPendingUnobservationMask_);
    },
    set: function(n) {
      this.flags_ = fn(this.flags_, e.isPendingUnobservationMask_, n);
    }
  }, {
    key: "diffValue",
    get: function() {
      return pn(this.flags_, e.diffValueMask_) ? 1 : 0;
    },
    set: function(n) {
      this.flags_ = fn(this.flags_, e.diffValueMask_, n === 1);
    }
  }]);
}();
li.isComputingMask_ = 1;
li.isRunningSetterMask_ = 2;
li.isBeingObservedMask_ = 4;
li.isPendingUnobservationMask_ = 8;
li.diffValueMask_ = 16;
var va = /* @__PURE__ */ ws("ComputedValue", li), gt;
(function(e) {
  e[e.NOT_TRACKING_ = -1] = "NOT_TRACKING_", e[e.UP_TO_DATE_ = 0] = "UP_TO_DATE_", e[e.POSSIBLY_STALE_ = 1] = "POSSIBLY_STALE_", e[e.STALE_ = 2] = "STALE_";
})(gt || (gt = {}));
var Lm;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.LOG = 1] = "LOG", e[e.BREAK = 2] = "BREAK";
})(Lm || (Lm = {}));
var Mm = function(t) {
  this.cause = void 0, this.cause = t;
};
function Kh(e) {
  return e instanceof Mm;
}
function mw(e) {
  switch (e.dependenciesState_) {
    case gt.UP_TO_DATE_:
      return !1;
    case gt.NOT_TRACKING_:
    case gt.STALE_:
      return !0;
    case gt.POSSIBLY_STALE_: {
      for (var t = Vg(!0), r = xa(), n = e.observing_, i = n.length, s = 0; s < i; s++) {
        var o = n[s];
        if (va(o)) {
          if (Le.disableErrorBoundaries)
            o.get();
          else
            try {
              o.get();
            } catch {
              return fo(r), $l(t), !0;
            }
          if (e.dependenciesState_ === gt.STALE_)
            return fo(r), $l(t), !0;
        }
      }
      return lj(e), fo(r), $l(t), !1;
    }
  }
}
function oW() {
  return Le.trackingDerivation !== null;
}
function aj(e, t, r) {
  var n = Vg(!0);
  lj(e), e.newObserving_ = new Array(
    // Reserve constant space for initial dependencies, dynamic space otherwise.
    // See https://github.com/mobxjs/mobx/pull/3833
    e.runId_ === 0 ? 100 : e.observing_.length
  ), e.unboundDepsCount_ = 0, e.runId_ = ++Le.runId;
  var i = Le.trackingDerivation;
  Le.trackingDerivation = e, Le.inBatch++;
  var s;
  if (Le.disableErrorBoundaries === !0)
    s = t.call(r);
  else
    try {
      s = t.call(r);
    } catch (o) {
      s = new Mm(o);
    }
  return Le.inBatch--, Le.trackingDerivation = i, sW(e), $l(n), s;
}
function sW(e) {
  for (var t = e.observing_, r = e.observing_ = e.newObserving_, n = gt.UP_TO_DATE_, i = 0, s = e.unboundDepsCount_, o = 0; o < s; o++) {
    var a = r[o];
    a.diffValue === 0 && (a.diffValue = 1, i !== o && (r[i] = a), i++), a.dependenciesState_ > n && (n = a.dependenciesState_);
  }
  for (r.length = i, e.newObserving_ = null, s = t.length; s--; ) {
    var l = t[s];
    l.diffValue === 0 && cj(l, e), l.diffValue = 0;
  }
  for (; i--; ) {
    var u = r[i];
    u.diffValue === 1 && (u.diffValue = 0, dW(u, e));
  }
  n !== gt.UP_TO_DATE_ && (e.dependenciesState_ = n, e.onBecomeStale_());
}
function gw(e) {
  var t = e.observing_;
  e.observing_ = [];
  for (var r = t.length; r--; )
    cj(t[r], e);
  e.dependenciesState_ = gt.NOT_TRACKING_;
}
function au(e) {
  var t = xa();
  try {
    return e();
  } finally {
    fo(t);
  }
}
function xa() {
  var e = Le.trackingDerivation;
  return Le.trackingDerivation = null, e;
}
function fo(e) {
  Le.trackingDerivation = e;
}
function Vg(e) {
  var t = Le.allowStateReads;
  return Le.allowStateReads = e, t;
}
function $l(e) {
  Le.allowStateReads = e;
}
function lj(e) {
  if (e.dependenciesState_ !== gt.UP_TO_DATE_) {
    e.dependenciesState_ = gt.UP_TO_DATE_;
    for (var t = e.observing_, r = t.length; r--; )
      t[r].lowestObserverState_ = gt.UP_TO_DATE_;
  }
}
var aW = ["mobxGuid", "spyListeners", "enforceActions", "computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "allowStateReads", "disableErrorBoundaries", "runId", "UNCHANGED", "useProxies"], Mc = function() {
  this.version = 6, this.UNCHANGED = {}, this.trackingDerivation = null, this.trackingContext = null, this.runId = 0, this.mobxGuid = 0, this.inBatch = 0, this.pendingUnobservations = [], this.pendingReactions = [], this.isRunningReactions = !1, this.allowStateChanges = !1, this.allowStateReads = !0, this.enforceActions = !0, this.spyListeners = [], this.globalReactionErrorHandlers = [], this.computedRequiresReaction = !1, this.reactionRequiresObservable = !1, this.observableRequiresReaction = !1, this.disableErrorBoundaries = !1, this.suppressReactionErrors = !1, this.useProxies = !0, this.verifyProxies = !1, this.safeDescriptors = !0;
}, Xh = !0, uj = !1, Le = /* @__PURE__ */ function() {
  var e = /* @__PURE__ */ Mg();
  return e.__mobxInstanceCount > 0 && !e.__mobxGlobals && (Xh = !1), e.__mobxGlobals && e.__mobxGlobals.version !== new Mc().version && (Xh = !1), Xh ? e.__mobxGlobals ? (e.__mobxInstanceCount += 1, e.__mobxGlobals.UNCHANGED || (e.__mobxGlobals.UNCHANGED = {}), e.__mobxGlobals) : (e.__mobxInstanceCount = 1, e.__mobxGlobals = /* @__PURE__ */ new Mc()) : (setTimeout(function() {
    uj || tt(35);
  }, 1), new Mc());
}();
function lW() {
  if ((Le.pendingReactions.length || Le.inBatch || Le.isRunningReactions) && tt(36), uj = !0, Xh) {
    var e = Mg();
    --e.__mobxInstanceCount === 0 && (e.__mobxGlobals = void 0), Le = new Mc();
  }
}
function uW() {
  return Le;
}
function cW() {
  var e = new Mc();
  for (var t in e)
    aW.indexOf(t) === -1 && (Le[t] = e[t]);
  Le.allowStateChanges = !Le.enforceActions;
}
function pW(e) {
  return e.observers_ && e.observers_.size > 0;
}
function fW(e) {
  return e.observers_;
}
function dW(e, t) {
  e.observers_.add(t), e.lowestObserverState_ > t.dependenciesState_ && (e.lowestObserverState_ = t.dependenciesState_);
}
function cj(e, t) {
  e.observers_.delete(t), e.observers_.size === 0 && pj(e);
}
function pj(e) {
  e.isPendingUnobservation === !1 && (e.isPendingUnobservation = !0, Le.pendingUnobservations.push(e));
}
function en() {
  Le.inBatch++;
}
function tn() {
  if (--Le.inBatch === 0) {
    hj();
    for (var e = Le.pendingUnobservations, t = 0; t < e.length; t++) {
      var r = e[t];
      r.isPendingUnobservation = !1, r.observers_.size === 0 && (r.isBeingObserved && (r.isBeingObserved = !1, r.onBUO()), r instanceof li && r.suspend_());
    }
    Le.pendingUnobservations = [];
  }
}
function fj(e) {
  var t = Le.trackingDerivation;
  return t !== null ? (t.runId_ !== e.lastAccessedBy_ && (e.lastAccessedBy_ = t.runId_, t.newObserving_[t.unboundDepsCount_++] = e, !e.isBeingObserved && Le.trackingContext && (e.isBeingObserved = !0, e.onBO())), e.isBeingObserved) : (e.observers_.size === 0 && Le.inBatch > 0 && pj(e), !1);
}
function dj(e) {
  e.lowestObserverState_ !== gt.STALE_ && (e.lowestObserverState_ = gt.STALE_, e.observers_.forEach(function(t) {
    t.dependenciesState_ === gt.UP_TO_DATE_ && t.onBecomeStale_(), t.dependenciesState_ = gt.STALE_;
  }));
}
function hW(e) {
  e.lowestObserverState_ !== gt.STALE_ && (e.lowestObserverState_ = gt.STALE_, e.observers_.forEach(function(t) {
    t.dependenciesState_ === gt.POSSIBLY_STALE_ ? t.dependenciesState_ = gt.STALE_ : t.dependenciesState_ === gt.UP_TO_DATE_ && (e.lowestObserverState_ = gt.UP_TO_DATE_);
  }));
}
function mW(e) {
  e.lowestObserverState_ === gt.UP_TO_DATE_ && (e.lowestObserverState_ = gt.POSSIBLY_STALE_, e.observers_.forEach(function(t) {
    t.dependenciesState_ === gt.UP_TO_DATE_ && (t.dependenciesState_ = gt.POSSIBLY_STALE_, t.onBecomeStale_());
  }));
}
var Mn = /* @__PURE__ */ function() {
  function e(r, n, i, s) {
    r === void 0 && (r = "Reaction"), this.name_ = void 0, this.onInvalidate_ = void 0, this.errorHandler_ = void 0, this.requiresObservable_ = void 0, this.observing_ = [], this.newObserving_ = [], this.dependenciesState_ = gt.NOT_TRACKING_, this.runId_ = 0, this.unboundDepsCount_ = 0, this.flags_ = 0, this.isTracing_ = Lm.NONE, this.name_ = r, this.onInvalidate_ = n, this.errorHandler_ = i, this.requiresObservable_ = s;
  }
  var t = e.prototype;
  return t.onBecomeStale_ = function() {
    this.schedule_();
  }, t.schedule_ = function() {
    this.isScheduled || (this.isScheduled = !0, Le.pendingReactions.push(this), hj());
  }, t.runReaction_ = function() {
    if (!this.isDisposed) {
      en(), this.isScheduled = !1;
      var n = Le.trackingContext;
      if (Le.trackingContext = this, mw(this)) {
        this.isTrackPending = !0;
        try {
          this.onInvalidate_();
        } catch (i) {
          this.reportExceptionInDerivation_(i);
        }
      }
      Le.trackingContext = n, tn();
    }
  }, t.track = function(n) {
    if (!this.isDisposed) {
      en(), this.isRunning = !0;
      var i = Le.trackingContext;
      Le.trackingContext = this;
      var s = aj(this, n, void 0);
      Le.trackingContext = i, this.isRunning = !1, this.isTrackPending = !1, this.isDisposed && gw(this), Kh(s) && this.reportExceptionInDerivation_(s.cause), tn();
    }
  }, t.reportExceptionInDerivation_ = function(n) {
    var i = this;
    if (this.errorHandler_) {
      this.errorHandler_(n, this);
      return;
    }
    if (Le.disableErrorBoundaries)
      throw n;
    var s = "[mobx] uncaught error in '" + this + "'";
    Le.suppressReactionErrors || console.error(s, n), Le.globalReactionErrorHandlers.forEach(function(o) {
      return o(n, i);
    });
  }, t.dispose = function() {
    this.isDisposed || (this.isDisposed = !0, this.isRunning || (en(), gw(this), tn()));
  }, t.getDisposer_ = function(n) {
    var i = this, s = function o() {
      i.dispose(), n == null || n.removeEventListener == null || n.removeEventListener("abort", o);
    };
    return n == null || n.addEventListener == null || n.addEventListener("abort", s), s[Ye] = this, s;
  }, t.toString = function() {
    return "Reaction[" + this.name_ + "]";
  }, t.trace = function(n) {
  }, su(e, [{
    key: "isDisposed",
    get: function() {
      return pn(this.flags_, e.isDisposedMask_);
    },
    set: function(n) {
      this.flags_ = fn(this.flags_, e.isDisposedMask_, n);
    }
  }, {
    key: "isScheduled",
    get: function() {
      return pn(this.flags_, e.isScheduledMask_);
    },
    set: function(n) {
      this.flags_ = fn(this.flags_, e.isScheduledMask_, n);
    }
  }, {
    key: "isTrackPending",
    get: function() {
      return pn(this.flags_, e.isTrackPendingMask_);
    },
    set: function(n) {
      this.flags_ = fn(this.flags_, e.isTrackPendingMask_, n);
    }
  }, {
    key: "isRunning",
    get: function() {
      return pn(this.flags_, e.isRunningMask_);
    },
    set: function(n) {
      this.flags_ = fn(this.flags_, e.isRunningMask_, n);
    }
  }, {
    key: "diffValue",
    get: function() {
      return pn(this.flags_, e.diffValueMask_) ? 1 : 0;
    },
    set: function(n) {
      this.flags_ = fn(this.flags_, e.diffValueMask_, n === 1);
    }
  }]);
}();
Mn.isDisposedMask_ = 1;
Mn.isScheduledMask_ = 2;
Mn.isTrackPendingMask_ = 4;
Mn.isRunningMask_ = 8;
Mn.diffValueMask_ = 16;
function gW(e) {
  return Le.globalReactionErrorHandlers.push(e), function() {
    var t = Le.globalReactionErrorHandlers.indexOf(e);
    t >= 0 && Le.globalReactionErrorHandlers.splice(t, 1);
  };
}
var yW = 100, yw = function(t) {
  return t();
};
function hj() {
  Le.inBatch > 0 || Le.isRunningReactions || yw(vW);
}
function vW() {
  Le.isRunningReactions = !0;
  for (var e = Le.pendingReactions, t = 0; e.length > 0; ) {
    ++t === yW && (console.error("[mobx] cycle in reaction: " + e[0]), e.splice(0));
    for (var r = e.splice(0), n = 0, i = r.length; n < i; n++)
      r[n].runReaction_();
  }
  Le.isRunningReactions = !1;
}
var Dm = /* @__PURE__ */ ws("Reaction", Mn);
function bW(e) {
  var t = yw;
  yw = function(n) {
    return e(function() {
      return t(n);
    });
  };
}
function Dc() {
  return !1;
}
function mj(e) {
  return console.warn("[mobx.spy] Is a no-op in production builds"), function() {
  };
}
var gj = "action", wW = "action.bound", yj = "autoAction", SW = "autoAction.bound", vj = "<unnamed action>", vw = /* @__PURE__ */ Cp(gj), xW = /* @__PURE__ */ Cp(wW, {
  bound: !0
}), bw = /* @__PURE__ */ Cp(yj, {
  autoAction: !0
}), EW = /* @__PURE__ */ Cp(SW, {
  autoAction: !0,
  bound: !0
});
function bj(e) {
  var t = function(n, i) {
    if (yn(n))
      return ms(n.name || vj, n, e);
    if (yn(i))
      return ms(n, i, e);
    if (Tp(i))
      return (e ? bw : vw).decorate_20223_(n, i);
    if (ma(i))
      return Pp(n, i, e ? bw : vw);
    if (ma(n))
      return ii(Cp(e ? yj : gj, {
        name: n,
        autoAction: e
      }));
  };
  return t;
}
var Yo = /* @__PURE__ */ bj(!1);
Object.assign(Yo, vw);
var Ql = /* @__PURE__ */ bj(!0);
Object.assign(Ql, bw);
Yo.bound = /* @__PURE__ */ ii(xW);
Ql.bound = /* @__PURE__ */ ii(EW);
function ww(e) {
  return ij(e.name || vj, !1, e, this, void 0);
}
function Yl(e) {
  return yn(e) && e.isMobxAction === !0;
}
function n1(e, t) {
  var r, n, i, s;
  t === void 0 && (t = JS);
  var o = (r = (n = t) == null ? void 0 : n.name) != null ? r : "Autorun", a = !t.scheduler && !t.delay, l;
  if (a)
    l = new Mn(o, function() {
      this.track(d);
    }, t.onError, t.requiresObservable);
  else {
    var u = wj(t), f = !1;
    l = new Mn(o, function() {
      f || (f = !0, u(function() {
        f = !1, l.isDisposed || l.track(d);
      }));
    }, t.onError, t.requiresObservable);
  }
  function d() {
    e(l);
  }
  return (i = t) != null && (i = i.signal) != null && i.aborted || l.schedule_(), l.getDisposer_((s = t) == null ? void 0 : s.signal);
}
var _W = function(t) {
  return t();
};
function wj(e) {
  return e.scheduler ? e.scheduler : e.delay ? function(t) {
    return setTimeout(t, e.delay);
  } : _W;
}
function OW(e, t, r) {
  var n, i, s;
  r === void 0 && (r = JS);
  var o = (n = r.name) != null ? n : "Reaction", a = Yo(o, r.onError ? kW(r.onError, t) : t), l = !r.scheduler && !r.delay, u = wj(r), f = !0, d = !1, m, v = r.compareStructural ? ga.structural : r.equals || ga.default, S = new Mn(o, function() {
    f || l ? y() : d || (d = !0, u(y));
  }, r.onError, r.requiresObservable);
  function y() {
    if (d = !1, !S.isDisposed) {
      var E = !1, x = m;
      S.track(function() {
        var g = qg(!1, function() {
          return e(S);
        });
        E = f || !v(m, g), m = g;
      }), (f && r.fireImmediately || !f && E) && a(m, x, S), f = !1;
    }
  }
  return (i = r) != null && (i = i.signal) != null && i.aborted || S.schedule_(), S.getDisposer_((s = r) == null ? void 0 : s.signal);
}
function kW(e, t) {
  return function() {
    try {
      return t.apply(this, arguments);
    } catch (r) {
      e.call(this, r);
    }
  };
}
var AW = "onBO", PW = "onBUO";
function Sj(e, t, r) {
  return xj(AW, e, t, r);
}
function i1(e, t, r) {
  return xj(PW, e, t, r);
}
function xj(e, t, r, n) {
  var i = typeof n == "function" ? xo(t, r) : xo(t), s = yn(n) ? n : r, o = e + "L";
  return i[o] ? i[o].add(s) : i[o] = /* @__PURE__ */ new Set([s]), function() {
    var a = i[o];
    a && (a.delete(s), a.size === 0 && delete i[o]);
  };
}
var TW = "never", vd = "always", CW = "observed";
function Ej(e) {
  e.isolateGlobalState === !0 && lW();
  var t = e.useProxies, r = e.enforceActions;
  if (t !== void 0 && (Le.useProxies = t === vd ? !0 : t === TW ? !1 : typeof Proxy < "u"), t === "ifavailable" && (Le.verifyProxies = !0), r !== void 0) {
    var n = r === vd ? vd : r === CW;
    Le.enforceActions = n, Le.allowStateChanges = !(n === !0 || n === vd);
  }
  ["computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "disableErrorBoundaries", "safeDescriptors"].forEach(function(i) {
    i in e && (Le[i] = !!e[i]);
  }), Le.allowStateReads = !Le.observableRequiresReaction, e.reactionScheduler && bW(e.reactionScheduler);
}
function o1(e, t, r, n) {
  var i = a8(t);
  return xs(function() {
    var s = Ea(e, n)[Ye];
    Hl(i).forEach(function(o) {
      s.extend_(
        o,
        i[o],
        // must pass "undefined" for { key: undefined }
        r && o in r ? r[o] : !0
      );
    });
  }), e;
}
function _j(e, t) {
  return Oj(xo(e, t));
}
function Oj(e) {
  var t = {
    name: e.name_
  };
  return e.observing_ && e.observing_.length > 0 && (t.dependencies = RW(e.observing_).map(Oj)), t;
}
function $W(e, t) {
  return kj(xo(e, t));
}
function kj(e) {
  var t = {
    name: e.name_
  };
  return pW(e) && (t.observers = Array.from(fW(e)).map(kj)), t;
}
function RW(e) {
  return Array.from(new Set(e));
}
var IW = 0;
function Wg() {
  this.message = "FLOW_CANCELLED";
}
Wg.prototype = /* @__PURE__ */ Object.create(Error.prototype);
function NW(e) {
  return e instanceof Wg;
}
var Bv = /* @__PURE__ */ XN("flow"), jW = /* @__PURE__ */ XN("flow.bound", {
  bound: !0
}), ba = /* @__PURE__ */ Object.assign(function(t, r) {
  if (Tp(r))
    return Bv.decorate_20223_(t, r);
  if (ma(r))
    return Pp(t, r, Bv);
  var n = t, i = n.name || "<unnamed flow>", s = function() {
    var a = this, l = arguments, u = ++IW, f = Yo(i + " - runid: " + u + " - init", n).apply(a, l), d, m = void 0, v = new Promise(function(S, y) {
      var E = 0;
      d = y;
      function x(A) {
        m = void 0;
        var P;
        try {
          P = Yo(i + " - runid: " + u + " - yield " + E++, f.next).call(f, A);
        } catch (k) {
          return y(k);
        }
        b(P);
      }
      function g(A) {
        m = void 0;
        var P;
        try {
          P = Yo(i + " - runid: " + u + " - yield " + E++, f.throw).call(f, A);
        } catch (k) {
          return y(k);
        }
        b(P);
      }
      function b(A) {
        if (yn(A == null ? void 0 : A.then)) {
          A.then(b, y);
          return;
        }
        return A.done ? S(A.value) : (m = Promise.resolve(A.value), m.then(x, g));
      }
      x(void 0);
    });
    return v.cancel = Yo(i + " - runid: " + u + " - cancel", function() {
      try {
        m && Ck(m);
        var S = f.return(void 0), y = Promise.resolve(S.value);
        y.then(Sl, Sl), Ck(y), d(new Wg());
      } catch (E) {
        d(E);
      }
    }), v;
  };
  return s.isMobXFlow = !0, s;
}, Bv);
ba.bound = /* @__PURE__ */ ii(jW);
function Ck(e) {
  yn(e.cancel) && e.cancel();
}
function LW(e) {
  return e;
}
function Gl(e) {
  return (e == null ? void 0 : e.isMobXFlow) === !0;
}
function MW(e, t, r) {
  var n;
  return vr(e) || Wr(e) || r1(e) ? n = Eo(e) : yr(e) && (n = Eo(e, t)), n.dehancer = typeof t == "function" ? t : r, function() {
    n.dehancer = void 0;
  };
}
function DW(e, t, r) {
  return yn(r) ? zW(e, t, r) : FW(e, t);
}
function FW(e, t) {
  return Eo(e).intercept_(t);
}
function zW(e, t, r) {
  return Eo(e, t).intercept_(r);
}
function Aj(e, t) {
  if (t === void 0)
    return va(e);
  if (yr(e) === !1 || !e[Ye].values_.has(t))
    return !1;
  var r = xo(e, t);
  return va(r);
}
function qW(e) {
  return Aj(e);
}
function BW(e, t) {
  return Aj(e, t);
}
function Pj(e, t) {
  return e ? t !== void 0 ? yr(e) ? e[Ye].values_.has(t) : !1 : yr(e) || !!e[Ye] || ZS(e) || Dm(e) || va(e) : !1;
}
function Hg(e) {
  return Pj(e);
}
function UW(e, t) {
  return Pj(e, t);
}
function dp(e) {
  if (yr(e))
    return e[Ye].keys_();
  if (vr(e) || cr(e))
    return Array.from(e.keys());
  if (Wr(e))
    return e.map(function(t, r) {
      return r;
    });
  tt(5);
}
function VW(e) {
  if (yr(e))
    return dp(e).map(function(t) {
      return e[t];
    });
  if (vr(e))
    return dp(e).map(function(t) {
      return e.get(t);
    });
  if (cr(e))
    return Array.from(e.values());
  if (Wr(e))
    return e.slice();
  tt(6);
}
function WW(e) {
  if (yr(e))
    return dp(e).map(function(t) {
      return [t, e[t]];
    });
  if (vr(e))
    return dp(e).map(function(t) {
      return [t, e.get(t)];
    });
  if (cr(e))
    return Array.from(e.entries());
  if (Wr(e))
    return e.map(function(t, r) {
      return [r, t];
    });
  tt(7);
}
function Tj(e, t, r) {
  if (arguments.length === 2 && !cr(e)) {
    en();
    var n = t;
    try {
      for (var i in n)
        Tj(e, i, n[i]);
    } finally {
      tn();
    }
    return;
  }
  yr(e) ? e[Ye].set_(t, r) : vr(e) ? e.set(t, r) : cr(e) ? e.add(t) : Wr(e) ? (typeof t != "number" && (t = parseInt(t, 10)), t < 0 && tt("Invalid index: '" + t + "'"), en(), t >= e.length && (e.length = t + 1), e[t] = r, tn()) : tt(8);
}
function HW(e, t) {
  yr(e) ? e[Ye].delete_(t) : vr(e) || cr(e) ? e.delete(t) : Wr(e) ? (typeof t != "number" && (t = parseInt(t, 10)), e.splice(t, 1)) : tt(9);
}
function Cj(e, t) {
  if (yr(e))
    return e[Ye].has_(t);
  if (vr(e))
    return e.has(t);
  if (cr(e))
    return e.has(t);
  if (Wr(e))
    return t >= 0 && t < e.length;
  tt(10);
}
function QW(e, t) {
  if (Cj(e, t)) {
    if (yr(e))
      return e[Ye].get_(t);
    if (vr(e))
      return e.get(t);
    if (Wr(e))
      return e[t];
    tt(11);
  }
}
function YW(e, t, r) {
  if (yr(e))
    return e[Ye].defineProperty_(t, r);
  tt(39);
}
function $j(e) {
  if (yr(e))
    return e[Ye].ownKeys_();
  tt(38);
}
function GW(e, t, r, n) {
  return yn(r) ? XW(e, t, r, n) : KW(e, t, r);
}
function KW(e, t, r) {
  return Eo(e).observe_(t, r);
}
function XW(e, t, r, n) {
  return Eo(e, t).observe_(r, n);
}
function bd(e, t, r) {
  return e.set(t, r), r;
}
function ol(e, t) {
  if (e == null || typeof e != "object" || e instanceof Date || !Hg(e))
    return e;
  if (r1(e) || va(e))
    return ol(e.get(), t);
  if (t.has(e))
    return t.get(e);
  if (Wr(e)) {
    var r = bd(t, e, new Array(e.length));
    return e.forEach(function(o, a) {
      r[a] = ol(o, t);
    }), r;
  }
  if (cr(e)) {
    var n = bd(t, e, /* @__PURE__ */ new Set());
    return e.forEach(function(o) {
      n.add(ol(o, t));
    }), n;
  }
  if (vr(e)) {
    var i = bd(t, e, /* @__PURE__ */ new Map());
    return e.forEach(function(o, a) {
      i.set(a, ol(o, t));
    }), i;
  } else {
    var s = bd(t, e, {});
    return $j(e).forEach(function(o) {
      kp.propertyIsEnumerable.call(e, o) && (s[o] = ol(e[o], t));
    }), s;
  }
}
function JW(e, t) {
  return ol(e, /* @__PURE__ */ new Map());
}
function ZW() {
}
function ki(e, t) {
  t === void 0 && (t = void 0), en();
  try {
    return e.apply(t);
  } finally {
    tn();
  }
}
function e9(e, t, r) {
  return arguments.length === 1 || t && typeof t == "object" ? t9(e, t) : Rj(e, t, r || {});
}
function Rj(e, t, r) {
  var n;
  if (typeof r.timeout == "number") {
    var i = new Error("WHEN_TIMEOUT");
    n = setTimeout(function() {
      if (!o[Ye].isDisposed)
        if (o(), r.onError)
          r.onError(i);
        else
          throw i;
    }, r.timeout);
  }
  r.name = "When";
  var s = ms("When-effect", t), o = n1(function(a) {
    var l = qg(!1, e);
    l && (a.dispose(), n && clearTimeout(n), s());
  }, r);
  return o;
}
function t9(e, t) {
  var r;
  if (t != null && (r = t.signal) != null && r.aborted)
    return Object.assign(Promise.reject(new Error("WHEN_ABORTED")), {
      cancel: function() {
        return null;
      }
    });
  var n, i, s = new Promise(function(o, a) {
    var l, u = Rj(e, o, hs({}, t, {
      onError: a
    }));
    n = function() {
      u(), a(new Error("WHEN_CANCELLED"));
    }, i = function() {
      u(), a(new Error("WHEN_ABORTED"));
    }, t == null || (l = t.signal) == null || l.addEventListener == null || l.addEventListener("abort", i);
  }).finally(function() {
    var o;
    return t == null || (o = t.signal) == null || o.removeEventListener == null ? void 0 : o.removeEventListener("abort", i);
  });
  return s.cancel = n, s;
}
function Ja(e) {
  return e[Ye];
}
var r9 = {
  has: function(t, r) {
    return Ja(t).has_(r);
  },
  get: function(t, r) {
    return Ja(t).get_(r);
  },
  set: function(t, r, n) {
    var i;
    return ma(r) ? (i = Ja(t).set_(r, n, !0)) != null ? i : !0 : !1;
  },
  deleteProperty: function(t, r) {
    var n;
    return ma(r) ? (n = Ja(t).delete_(r, !0)) != null ? n : !0 : !1;
  },
  defineProperty: function(t, r, n) {
    var i;
    return (i = Ja(t).defineProperty_(r, n)) != null ? i : !0;
  },
  ownKeys: function(t) {
    return Ja(t).ownKeys_();
  },
  preventExtensions: function(t) {
    tt(13);
  }
};
function n9(e, t) {
  var r, n;
  return BN(), e = Ea(e, t), (n = (r = e[Ye]).proxy_) != null ? n : r.proxy_ = new Proxy(e, r9);
}
function Tn(e) {
  return e.interceptors_ !== void 0 && e.interceptors_.length > 0;
}
function Rp(e, t) {
  var r = e.interceptors_ || (e.interceptors_ = []);
  return r.push(t), UN(function() {
    var n = r.indexOf(t);
    n !== -1 && r.splice(n, 1);
  });
}
function Cn(e, t) {
  var r = xa();
  try {
    for (var n = [].concat(e.interceptors_ || []), i = 0, s = n.length; i < s && (t = n[i](t), t && !t.type && tt(14), !!t); i++)
      ;
    return t;
  } finally {
    fo(r);
  }
}
function oi(e) {
  return e.changeListeners_ !== void 0 && e.changeListeners_.length > 0;
}
function Ip(e, t) {
  var r = e.changeListeners_ || (e.changeListeners_ = []);
  return r.push(t), UN(function() {
    var n = r.indexOf(t);
    n !== -1 && r.splice(n, 1);
  });
}
function si(e, t) {
  var r = xa(), n = e.changeListeners_;
  if (n) {
    n = n.slice();
    for (var i = 0, s = n.length; i < s; i++)
      n[i](t);
    fo(r);
  }
}
function Ij(e, t, r) {
  return xs(function() {
    var n, i = Ea(e, r)[Ye];
    (n = t) != null || (t = f8(e)), Hl(t).forEach(function(s) {
      return i.make_(s, t[s]);
    });
  }), e;
}
var Uv = /* @__PURE__ */ Symbol("mobx-keys");
function i9(e, t, r) {
  return So(e) ? o1(e, e, t, r) : (xs(function() {
    var n = Ea(e, r)[Ye];
    if (!e[Uv]) {
      var i = Object.getPrototypeOf(e), s = new Set([].concat(Hl(e), Hl(i)));
      s.delete("constructor"), s.delete(Ye), Ap(i, Uv, s);
    }
    e[Uv].forEach(function(o) {
      return n.make_(
        o,
        // must pass "undefined" for { key: undefined }
        t && o in t ? t[o] : !0
      );
    });
  }), e);
}
var $k = "splice", ji = "update", o9 = 1e4, s9 = {
  get: function(t, r) {
    var n = t[Ye];
    return r === Ye ? n : r === "length" ? n.getArrayLength_() : typeof r == "string" && !isNaN(r) ? n.get_(parseInt(r)) : po(Fm, r) ? Fm[r] : t[r];
  },
  set: function(t, r, n) {
    var i = t[Ye];
    return r === "length" && i.setArrayLength_(n), typeof r == "symbol" || isNaN(r) ? t[r] = n : i.set_(parseInt(r), n), !0;
  },
  preventExtensions: function() {
    tt(15);
  }
}, s1 = /* @__PURE__ */ function() {
  function e(r, n, i, s) {
    r === void 0 && (r = "ObservableArray"), this.owned_ = void 0, this.legacyMode_ = void 0, this.atom_ = void 0, this.values_ = [], this.interceptors_ = void 0, this.changeListeners_ = void 0, this.enhancer_ = void 0, this.dehancer = void 0, this.proxy_ = void 0, this.lastKnownLength_ = 0, this.owned_ = i, this.legacyMode_ = s, this.atom_ = new Ss(r), this.enhancer_ = function(o, a) {
      return n(o, a, "ObservableArray[..]");
    };
  }
  var t = e.prototype;
  return t.dehanceValue_ = function(n) {
    return this.dehancer !== void 0 ? this.dehancer(n) : n;
  }, t.dehanceValues_ = function(n) {
    return this.dehancer !== void 0 && n.length > 0 ? n.map(this.dehancer) : n;
  }, t.intercept_ = function(n) {
    return Rp(this, n);
  }, t.observe_ = function(n, i) {
    return i === void 0 && (i = !1), i && n({
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: "splice",
      index: 0,
      added: this.values_.slice(),
      addedCount: this.values_.length,
      removed: [],
      removedCount: 0
    }), Ip(this, n);
  }, t.getArrayLength_ = function() {
    return this.atom_.reportObserved(), this.values_.length;
  }, t.setArrayLength_ = function(n) {
    (typeof n != "number" || isNaN(n) || n < 0) && tt("Out of range: " + n);
    var i = this.values_.length;
    if (n !== i)
      if (n > i) {
        for (var s = new Array(n - i), o = 0; o < n - i; o++)
          s[o] = void 0;
        this.spliceWithArray_(i, 0, s);
      } else
        this.spliceWithArray_(n, i - n);
  }, t.updateArrayLength_ = function(n, i) {
    n !== this.lastKnownLength_ && tt(16), this.lastKnownLength_ += i, this.legacyMode_ && i > 0 && Dj(n + i + 1);
  }, t.spliceWithArray_ = function(n, i, s) {
    var o = this;
    this.atom_;
    var a = this.values_.length;
    if (n === void 0 ? n = 0 : n > a ? n = a : n < 0 && (n = Math.max(0, a + n)), arguments.length === 1 ? i = a - n : i == null ? i = 0 : i = Math.max(0, Math.min(i, a - n)), s === void 0 && (s = pw), Tn(this)) {
      var l = Cn(this, {
        object: this.proxy_,
        type: $k,
        index: n,
        removedCount: i,
        added: s
      });
      if (!l)
        return pw;
      i = l.removedCount, s = l.added;
    }
    if (s = s.length === 0 ? s : s.map(function(d) {
      return o.enhancer_(d, void 0);
    }), this.legacyMode_) {
      var u = s.length - i;
      this.updateArrayLength_(a, u);
    }
    var f = this.spliceItemsIntoValues_(n, i, s);
    return (i !== 0 || s.length !== 0) && this.notifyArraySplice_(n, s, f), this.dehanceValues_(f);
  }, t.spliceItemsIntoValues_ = function(n, i, s) {
    if (s.length < o9) {
      var o;
      return (o = this.values_).splice.apply(o, [n, i].concat(s));
    } else {
      var a = this.values_.slice(n, n + i), l = this.values_.slice(n + i);
      this.values_.length += s.length - i;
      for (var u = 0; u < s.length; u++)
        this.values_[n + u] = s[u];
      for (var f = 0; f < l.length; f++)
        this.values_[n + s.length + f] = l[f];
      return a;
    }
  }, t.notifyArrayChildUpdate_ = function(n, i, s) {
    var o = !this.owned_ && Dc(), a = oi(this), l = a || o ? {
      observableKind: "array",
      object: this.proxy_,
      type: ji,
      debugObjectName: this.atom_.name_,
      index: n,
      newValue: i,
      oldValue: s
    } : null;
    this.atom_.reportChanged(), a && si(this, l);
  }, t.notifyArraySplice_ = function(n, i, s) {
    var o = !this.owned_ && Dc(), a = oi(this), l = a || o ? {
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: $k,
      index: n,
      removed: s,
      added: i,
      removedCount: s.length,
      addedCount: i.length
    } : null;
    this.atom_.reportChanged(), a && si(this, l);
  }, t.get_ = function(n) {
    if (this.legacyMode_ && n >= this.values_.length) {
      console.warn("[mobx] Out of bounds read: " + n);
      return;
    }
    return this.atom_.reportObserved(), this.dehanceValue_(this.values_[n]);
  }, t.set_ = function(n, i) {
    var s = this.values_;
    if (this.legacyMode_ && n > s.length && tt(17, n, s.length), n < s.length) {
      this.atom_;
      var o = s[n];
      if (Tn(this)) {
        var a = Cn(this, {
          type: ji,
          object: this.proxy_,
          // since "this" is the real array we need to pass its proxy
          index: n,
          newValue: i
        });
        if (!a)
          return;
        i = a.newValue;
      }
      i = this.enhancer_(i, o);
      var l = i !== o;
      l && (s[n] = i, this.notifyArrayChildUpdate_(n, i, o));
    } else {
      for (var u = new Array(n + 1 - s.length), f = 0; f < u.length - 1; f++)
        u[f] = void 0;
      u[u.length - 1] = i, this.spliceWithArray_(s.length, 0, u);
    }
  }, e;
}();
function a9(e, t, r, n) {
  return r === void 0 && (r = "ObservableArray"), n === void 0 && (n = !1), BN(), xs(function() {
    var i = new s1(r, t, n, !1);
    WN(i.values_, Ye, i);
    var s = new Proxy(i.values_, s9);
    return i.proxy_ = s, e && e.length && i.spliceWithArray_(0, 0, e), s;
  });
}
var Fm = {
  clear: function() {
    return this.splice(0);
  },
  replace: function(t) {
    var r = this[Ye];
    return r.spliceWithArray_(0, r.values_.length, t);
  },
  // Used by JSON.stringify
  toJSON: function() {
    return this.slice();
  },
  /*
   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
   * since these functions alter the inner structure of the array, the have side effects.
   * Because the have side effects, they should not be used in computed function,
   * and for that reason the do not call dependencyState.notifyObserved
   */
  splice: function(t, r) {
    for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), s = 2; s < n; s++)
      i[s - 2] = arguments[s];
    var o = this[Ye];
    switch (arguments.length) {
      case 0:
        return [];
      case 1:
        return o.spliceWithArray_(t);
      case 2:
        return o.spliceWithArray_(t, r);
    }
    return o.spliceWithArray_(t, r, i);
  },
  spliceWithArray: function(t, r, n) {
    return this[Ye].spliceWithArray_(t, r, n);
  },
  push: function() {
    for (var t = this[Ye], r = arguments.length, n = new Array(r), i = 0; i < r; i++)
      n[i] = arguments[i];
    return t.spliceWithArray_(t.values_.length, 0, n), t.values_.length;
  },
  pop: function() {
    return this.splice(Math.max(this[Ye].values_.length - 1, 0), 1)[0];
  },
  shift: function() {
    return this.splice(0, 1)[0];
  },
  unshift: function() {
    for (var t = this[Ye], r = arguments.length, n = new Array(r), i = 0; i < r; i++)
      n[i] = arguments[i];
    return t.spliceWithArray_(0, 0, n), t.values_.length;
  },
  reverse: function() {
    return Le.trackingDerivation && tt(37, "reverse"), this.replace(this.slice().reverse()), this;
  },
  sort: function() {
    Le.trackingDerivation && tt(37, "sort");
    var t = this.slice();
    return t.sort.apply(t, arguments), this.replace(t), this;
  },
  remove: function(t) {
    var r = this[Ye], n = r.dehanceValues_(r.values_).indexOf(t);
    return n > -1 ? (this.splice(n, 1), !0) : !1;
  }
};
Nt("at", Sn);
Nt("concat", Sn);
Nt("flat", Sn);
Nt("includes", Sn);
Nt("indexOf", Sn);
Nt("join", Sn);
Nt("lastIndexOf", Sn);
Nt("slice", Sn);
Nt("toString", Sn);
Nt("toLocaleString", Sn);
Nt("toSorted", Sn);
Nt("toSpliced", Sn);
Nt("with", Sn);
Nt("every", ci);
Nt("filter", ci);
Nt("find", ci);
Nt("findIndex", ci);
Nt("findLast", ci);
Nt("findLastIndex", ci);
Nt("flatMap", ci);
Nt("forEach", ci);
Nt("map", ci);
Nt("some", ci);
Nt("toReversed", ci);
Nt("reduce", Nj);
Nt("reduceRight", Nj);
function Nt(e, t) {
  typeof Array.prototype[e] == "function" && (Fm[e] = t(e));
}
function Sn(e) {
  return function() {
    var t = this[Ye];
    t.atom_.reportObserved();
    var r = t.dehanceValues_(t.values_);
    return r[e].apply(r, arguments);
  };
}
function ci(e) {
  return function(t, r) {
    var n = this, i = this[Ye];
    i.atom_.reportObserved();
    var s = i.dehanceValues_(i.values_);
    return s[e](function(o, a) {
      return t.call(r, o, a, n);
    });
  };
}
function Nj(e) {
  return function() {
    var t = this, r = this[Ye];
    r.atom_.reportObserved();
    var n = r.dehanceValues_(r.values_), i = arguments[0];
    return arguments[0] = function(s, o, a) {
      return i(s, o, a, t);
    }, n[e].apply(n, arguments);
  };
}
var l9 = /* @__PURE__ */ ws("ObservableArrayAdministration", s1);
function Wr(e) {
  return Dg(e) && l9(e[Ye]);
}
var u9 = {}, Go = "add", zm = "delete", a1 = /* @__PURE__ */ function() {
  function e(r, n, i) {
    var s = this;
    n === void 0 && (n = ya), i === void 0 && (i = "ObservableMap"), this.enhancer_ = void 0, this.name_ = void 0, this[Ye] = u9, this.data_ = void 0, this.hasMap_ = void 0, this.keysAtom_ = void 0, this.interceptors_ = void 0, this.changeListeners_ = void 0, this.dehancer = void 0, this.enhancer_ = n, this.name_ = i, yn(Map) || tt(18), xs(function() {
      s.keysAtom_ = e1("ObservableMap.keys()"), s.data_ = /* @__PURE__ */ new Map(), s.hasMap_ = /* @__PURE__ */ new Map(), r && s.merge(r);
    });
  }
  var t = e.prototype;
  return t.has_ = function(n) {
    return this.data_.has(n);
  }, t.has = function(n) {
    var i = this;
    if (!Le.trackingDerivation)
      return this.has_(n);
    var s = this.hasMap_.get(n);
    if (!s) {
      var o = s = new as(this.has_(n), Fg, "ObservableMap.key?", !1);
      this.hasMap_.set(n, o), i1(o, function() {
        return i.hasMap_.delete(n);
      });
    }
    return s.get();
  }, t.set = function(n, i) {
    var s = this.has_(n);
    if (Tn(this)) {
      var o = Cn(this, {
        type: s ? ji : Go,
        object: this,
        newValue: i,
        name: n
      });
      if (!o)
        return this;
      i = o.newValue;
    }
    return s ? this.updateValue_(n, i) : this.addValue_(n, i), this;
  }, t.delete = function(n) {
    var i = this;
    if (this.keysAtom_, Tn(this)) {
      var s = Cn(this, {
        type: zm,
        object: this,
        name: n
      });
      if (!s)
        return !1;
    }
    if (this.has_(n)) {
      var o = Dc(), a = oi(this), l = a || o ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: zm,
        object: this,
        oldValue: this.data_.get(n).value_,
        name: n
      } : null;
      return ki(function() {
        var u;
        i.keysAtom_.reportChanged(), (u = i.hasMap_.get(n)) == null || u.setNewValue_(!1);
        var f = i.data_.get(n);
        f.setNewValue_(void 0), i.data_.delete(n);
      }), a && si(this, l), !0;
    }
    return !1;
  }, t.updateValue_ = function(n, i) {
    var s = this.data_.get(n);
    if (i = s.prepareNewValue_(i), i !== Le.UNCHANGED) {
      var o = Dc(), a = oi(this), l = a || o ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: ji,
        object: this,
        oldValue: s.value_,
        name: n,
        newValue: i
      } : null;
      s.setNewValue_(i), a && si(this, l);
    }
  }, t.addValue_ = function(n, i) {
    var s = this;
    this.keysAtom_, ki(function() {
      var u, f = new as(i, s.enhancer_, "ObservableMap.key", !1);
      s.data_.set(n, f), i = f.value_, (u = s.hasMap_.get(n)) == null || u.setNewValue_(!0), s.keysAtom_.reportChanged();
    });
    var o = Dc(), a = oi(this), l = a || o ? {
      observableKind: "map",
      debugObjectName: this.name_,
      type: Go,
      object: this,
      name: n,
      newValue: i
    } : null;
    a && si(this, l);
  }, t.get = function(n) {
    return this.has(n) ? this.dehanceValue_(this.data_.get(n).get()) : this.dehanceValue_(void 0);
  }, t.dehanceValue_ = function(n) {
    return this.dehancer !== void 0 ? this.dehancer(n) : n;
  }, t.keys = function() {
    return this.keysAtom_.reportObserved(), this.data_.keys();
  }, t.values = function() {
    var n = this, i = this.keys();
    return Rk({
      next: function() {
        var o = i.next(), a = o.done, l = o.value;
        return {
          done: a,
          value: a ? void 0 : n.get(l)
        };
      }
    });
  }, t.entries = function() {
    var n = this, i = this.keys();
    return Rk({
      next: function() {
        var o = i.next(), a = o.done, l = o.value;
        return {
          done: a,
          value: a ? void 0 : [l, n.get(l)]
        };
      }
    });
  }, t[Symbol.iterator] = function() {
    return this.entries();
  }, t.forEach = function(n, i) {
    for (var s = xl(this), o; !(o = s()).done; ) {
      var a = o.value, l = a[0], u = a[1];
      n.call(i, u, l, this);
    }
  }, t.merge = function(n) {
    var i = this;
    return vr(n) && (n = new Map(n)), ki(function() {
      So(n) ? s8(n).forEach(function(s) {
        return i.set(s, n[s]);
      }) : Array.isArray(n) ? n.forEach(function(s) {
        var o = s[0], a = s[1];
        return i.set(o, a);
      }) : ou(n) ? (o8(n) || tt(19, n), n.forEach(function(s, o) {
        return i.set(o, s);
      })) : n != null && tt(20, n);
    }), this;
  }, t.clear = function() {
    var n = this;
    ki(function() {
      au(function() {
        for (var i = xl(n.keys()), s; !(s = i()).done; ) {
          var o = s.value;
          n.delete(o);
        }
      });
    });
  }, t.replace = function(n) {
    var i = this;
    return ki(function() {
      for (var s = c9(n), o = /* @__PURE__ */ new Map(), a = !1, l = xl(i.data_.keys()), u; !(u = l()).done; ) {
        var f = u.value;
        if (!s.has(f)) {
          var d = i.delete(f);
          if (d)
            a = !0;
          else {
            var m = i.data_.get(f);
            o.set(f, m);
          }
        }
      }
      for (var v = xl(s.entries()), S; !(S = v()).done; ) {
        var y = S.value, E = y[0], x = y[1], g = i.data_.has(E);
        if (i.set(E, x), i.data_.has(E)) {
          var b = i.data_.get(E);
          o.set(E, b), g || (a = !0);
        }
      }
      if (!a)
        if (i.data_.size !== o.size)
          i.keysAtom_.reportChanged();
        else
          for (var A = i.data_.keys(), P = o.keys(), k = A.next(), $ = P.next(); !k.done; ) {
            if (k.value !== $.value) {
              i.keysAtom_.reportChanged();
              break;
            }
            k = A.next(), $ = P.next();
          }
      i.data_ = o;
    }), this;
  }, t.toString = function() {
    return "[object ObservableMap]";
  }, t.toJSON = function() {
    return Array.from(this);
  }, t.observe_ = function(n, i) {
    return Ip(this, n);
  }, t.intercept_ = function(n) {
    return Rp(this, n);
  }, su(e, [{
    key: "size",
    get: function() {
      return this.keysAtom_.reportObserved(), this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function() {
      return "Map";
    }
  }]);
}(), vr = /* @__PURE__ */ ws("ObservableMap", a1);
function Rk(e) {
  return e[Symbol.toStringTag] = "MapIterator", p1(e);
}
function c9(e) {
  if (ou(e) || vr(e))
    return e;
  if (Array.isArray(e))
    return new Map(e);
  if (So(e)) {
    var t = /* @__PURE__ */ new Map();
    for (var r in e)
      t.set(r, e[r]);
    return t;
  } else
    return tt(21, e);
}
var p9 = {}, l1 = /* @__PURE__ */ function() {
  function e(r, n, i) {
    var s = this;
    n === void 0 && (n = ya), i === void 0 && (i = "ObservableSet"), this.name_ = void 0, this[Ye] = p9, this.data_ = /* @__PURE__ */ new Set(), this.atom_ = void 0, this.changeListeners_ = void 0, this.interceptors_ = void 0, this.dehancer = void 0, this.enhancer_ = void 0, this.name_ = i, yn(Set) || tt(22), this.enhancer_ = function(o, a) {
      return n(o, a, i);
    }, xs(function() {
      s.atom_ = e1(s.name_), r && s.replace(r);
    });
  }
  var t = e.prototype;
  return t.dehanceValue_ = function(n) {
    return this.dehancer !== void 0 ? this.dehancer(n) : n;
  }, t.clear = function() {
    var n = this;
    ki(function() {
      au(function() {
        for (var i = xl(n.data_.values()), s; !(s = i()).done; ) {
          var o = s.value;
          n.delete(o);
        }
      });
    });
  }, t.forEach = function(n, i) {
    for (var s = xl(this), o; !(o = s()).done; ) {
      var a = o.value;
      n.call(i, a, a, this);
    }
  }, t.add = function(n) {
    var i = this;
    if (this.atom_, Tn(this)) {
      var s = Cn(this, {
        type: Go,
        object: this,
        newValue: n
      });
      if (!s)
        return this;
    }
    if (!this.has(n)) {
      ki(function() {
        i.data_.add(i.enhancer_(n, void 0)), i.atom_.reportChanged();
      });
      var o = !1, a = oi(this), l = a || o ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: Go,
        object: this,
        newValue: n
      } : null;
      a && si(this, l);
    }
    return this;
  }, t.delete = function(n) {
    var i = this;
    if (Tn(this)) {
      var s = Cn(this, {
        type: zm,
        object: this,
        oldValue: n
      });
      if (!s)
        return !1;
    }
    if (this.has(n)) {
      var o = !1, a = oi(this), l = a || o ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: zm,
        object: this,
        oldValue: n
      } : null;
      return ki(function() {
        i.atom_.reportChanged(), i.data_.delete(n);
      }), a && si(this, l), !0;
    }
    return !1;
  }, t.has = function(n) {
    return this.atom_.reportObserved(), this.data_.has(this.dehanceValue_(n));
  }, t.entries = function() {
    var n = this.values();
    return Ik({
      next: function() {
        var s = n.next(), o = s.value, a = s.done;
        return a ? {
          value: void 0,
          done: a
        } : {
          value: [o, o],
          done: a
        };
      }
    });
  }, t.keys = function() {
    return this.values();
  }, t.values = function() {
    this.atom_.reportObserved();
    var n = this, i = this.data_.values();
    return Ik({
      next: function() {
        var o = i.next(), a = o.value, l = o.done;
        return l ? {
          value: void 0,
          done: l
        } : {
          value: n.dehanceValue_(a),
          done: l
        };
      }
    });
  }, t.intersection = function(n) {
    if (oo(n) && !cr(n))
      return n.intersection(this);
    var i = new Set(this);
    return i.intersection(n);
  }, t.union = function(n) {
    if (oo(n) && !cr(n))
      return n.union(this);
    var i = new Set(this);
    return i.union(n);
  }, t.difference = function(n) {
    return new Set(this).difference(n);
  }, t.symmetricDifference = function(n) {
    if (oo(n) && !cr(n))
      return n.symmetricDifference(this);
    var i = new Set(this);
    return i.symmetricDifference(n);
  }, t.isSubsetOf = function(n) {
    return new Set(this).isSubsetOf(n);
  }, t.isSupersetOf = function(n) {
    return new Set(this).isSupersetOf(n);
  }, t.isDisjointFrom = function(n) {
    if (oo(n) && !cr(n))
      return n.isDisjointFrom(this);
    var i = new Set(this);
    return i.isDisjointFrom(n);
  }, t.replace = function(n) {
    var i = this;
    return cr(n) && (n = new Set(n)), ki(function() {
      Array.isArray(n) ? (i.clear(), n.forEach(function(s) {
        return i.add(s);
      })) : oo(n) ? (i.clear(), n.forEach(function(s) {
        return i.add(s);
      })) : n != null && tt("Cannot initialize set from " + n);
    }), this;
  }, t.observe_ = function(n, i) {
    return Ip(this, n);
  }, t.intercept_ = function(n) {
    return Rp(this, n);
  }, t.toJSON = function() {
    return Array.from(this);
  }, t.toString = function() {
    return "[object ObservableSet]";
  }, t[Symbol.iterator] = function() {
    return this.values();
  }, su(e, [{
    key: "size",
    get: function() {
      return this.atom_.reportObserved(), this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function() {
      return "Set";
    }
  }]);
}(), cr = /* @__PURE__ */ ws("ObservableSet", l1);
function Ik(e) {
  return e[Symbol.toStringTag] = "SetIterator", p1(e);
}
var Nk = /* @__PURE__ */ Object.create(null), jk = "remove", jj = /* @__PURE__ */ function() {
  function e(r, n, i, s) {
    n === void 0 && (n = /* @__PURE__ */ new Map()), s === void 0 && (s = q8), this.target_ = void 0, this.values_ = void 0, this.name_ = void 0, this.defaultAnnotation_ = void 0, this.keysAtom_ = void 0, this.changeListeners_ = void 0, this.interceptors_ = void 0, this.proxy_ = void 0, this.isPlainObject_ = void 0, this.appliedAnnotations_ = void 0, this.pendingKeys_ = void 0, this.target_ = r, this.values_ = n, this.name_ = i, this.defaultAnnotation_ = s, this.keysAtom_ = new Ss("ObservableObject.keys"), this.isPlainObject_ = So(this.target_);
  }
  var t = e.prototype;
  return t.getObservablePropValue_ = function(n) {
    return this.values_.get(n).get();
  }, t.setObservablePropValue_ = function(n, i) {
    var s = this.values_.get(n);
    if (s instanceof li)
      return s.set(i), !0;
    if (Tn(this)) {
      var o = Cn(this, {
        type: ji,
        object: this.proxy_ || this.target_,
        name: n,
        newValue: i
      });
      if (!o)
        return null;
      i = o.newValue;
    }
    if (i = s.prepareNewValue_(i), i !== Le.UNCHANGED) {
      var a = oi(this), l = !1, u = a || l ? {
        type: ji,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        oldValue: s.value_,
        name: n,
        newValue: i
      } : null;
      s.setNewValue_(i), a && si(this, u);
    }
    return !0;
  }, t.get_ = function(n) {
    return Le.trackingDerivation && !po(this.target_, n) && this.has_(n), this.target_[n];
  }, t.set_ = function(n, i, s) {
    return s === void 0 && (s = !1), po(this.target_, n) ? this.values_.has(n) ? this.setObservablePropValue_(n, i) : s ? Reflect.set(this.target_, n, i) : (this.target_[n] = i, !0) : this.extend_(n, {
      value: i,
      enumerable: !0,
      writable: !0,
      configurable: !0
    }, this.defaultAnnotation_, s);
  }, t.has_ = function(n) {
    if (!Le.trackingDerivation)
      return n in this.target_;
    this.pendingKeys_ || (this.pendingKeys_ = /* @__PURE__ */ new Map());
    var i = this.pendingKeys_.get(n);
    return i || (i = new as(n in this.target_, Fg, "ObservableObject.key?", !1), this.pendingKeys_.set(n, i)), i.get();
  }, t.make_ = function(n, i) {
    if (i === !0 && (i = this.defaultAnnotation_), i !== !1) {
      if (!(n in this.target_)) {
        var s;
        if ((s = this.target_[Pi]) != null && s[n])
          return;
        tt(1, i.annotationType_, this.name_ + "." + n.toString());
      }
      for (var o = this.target_; o && o !== kp; ) {
        var a = Nm(o, n);
        if (a) {
          var l = i.make_(this, n, a, o);
          if (l === 0)
            return;
          if (l === 1)
            break;
        }
        o = Object.getPrototypeOf(o);
      }
      Mk(this, i, n);
    }
  }, t.extend_ = function(n, i, s, o) {
    if (o === void 0 && (o = !1), s === !0 && (s = this.defaultAnnotation_), s === !1)
      return this.defineProperty_(n, i, o);
    var a = s.extend_(this, n, i, o);
    return a && Mk(this, s, n), a;
  }, t.defineProperty_ = function(n, i, s) {
    s === void 0 && (s = !1), this.keysAtom_;
    try {
      en();
      var o = this.delete_(n);
      if (!o)
        return o;
      if (Tn(this)) {
        var a = Cn(this, {
          object: this.proxy_ || this.target_,
          name: n,
          type: Go,
          newValue: i.value
        });
        if (!a)
          return null;
        var l = a.newValue;
        i.value !== l && (i = hs({}, i, {
          value: l
        }));
      }
      if (s) {
        if (!Reflect.defineProperty(this.target_, n, i))
          return !1;
      } else
        Ni(this.target_, n, i);
      this.notifyPropertyAddition_(n, i.value);
    } finally {
      tn();
    }
    return !0;
  }, t.defineObservableProperty_ = function(n, i, s, o) {
    o === void 0 && (o = !1), this.keysAtom_;
    try {
      en();
      var a = this.delete_(n);
      if (!a)
        return a;
      if (Tn(this)) {
        var l = Cn(this, {
          object: this.proxy_ || this.target_,
          name: n,
          type: Go,
          newValue: i
        });
        if (!l)
          return null;
        i = l.newValue;
      }
      var u = Lk(n), f = {
        configurable: Le.safeDescriptors ? this.isPlainObject_ : !0,
        enumerable: !0,
        get: u.get,
        set: u.set
      };
      if (o) {
        if (!Reflect.defineProperty(this.target_, n, f))
          return !1;
      } else
        Ni(this.target_, n, f);
      var d = new as(i, s, "ObservableObject.key", !1);
      this.values_.set(n, d), this.notifyPropertyAddition_(n, d.value_);
    } finally {
      tn();
    }
    return !0;
  }, t.defineComputedProperty_ = function(n, i, s) {
    s === void 0 && (s = !1), this.keysAtom_;
    try {
      en();
      var o = this.delete_(n);
      if (!o)
        return o;
      if (Tn(this)) {
        var a = Cn(this, {
          object: this.proxy_ || this.target_,
          name: n,
          type: Go,
          newValue: void 0
        });
        if (!a)
          return null;
      }
      i.name || (i.name = "ObservableObject.key"), i.context = this.proxy_ || this.target_;
      var l = Lk(n), u = {
        configurable: Le.safeDescriptors ? this.isPlainObject_ : !0,
        enumerable: !1,
        get: l.get,
        set: l.set
      };
      if (s) {
        if (!Reflect.defineProperty(this.target_, n, u))
          return !1;
      } else
        Ni(this.target_, n, u);
      this.values_.set(n, new li(i)), this.notifyPropertyAddition_(n, void 0);
    } finally {
      tn();
    }
    return !0;
  }, t.delete_ = function(n, i) {
    if (i === void 0 && (i = !1), this.keysAtom_, !po(this.target_, n))
      return !0;
    if (Tn(this)) {
      var s = Cn(this, {
        object: this.proxy_ || this.target_,
        name: n,
        type: jk
      });
      if (!s)
        return null;
    }
    try {
      var o;
      en();
      var a = oi(this), l = !1, u = this.values_.get(n), f = void 0;
      if (!u && (a || l)) {
        var d;
        f = (d = Nm(this.target_, n)) == null ? void 0 : d.value;
      }
      if (i) {
        if (!Reflect.deleteProperty(this.target_, n))
          return !1;
      } else
        delete this.target_[n];
      if (u && (this.values_.delete(n), u instanceof as && (f = u.value_), dj(u)), this.keysAtom_.reportChanged(), (o = this.pendingKeys_) == null || (o = o.get(n)) == null || o.set(n in this.target_), a || l) {
        var m = {
          type: jk,
          observableKind: "object",
          object: this.proxy_ || this.target_,
          debugObjectName: this.name_,
          oldValue: f,
          name: n
        };
        a && si(this, m);
      }
    } finally {
      tn();
    }
    return !0;
  }, t.observe_ = function(n, i) {
    return Ip(this, n);
  }, t.intercept_ = function(n) {
    return Rp(this, n);
  }, t.notifyPropertyAddition_ = function(n, i) {
    var s, o = oi(this), a = !1;
    if (o || a) {
      var l = o || a ? {
        type: Go,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        name: n,
        newValue: i
      } : null;
      o && si(this, l);
    }
    (s = this.pendingKeys_) == null || (s = s.get(n)) == null || s.set(!0), this.keysAtom_.reportChanged();
  }, t.ownKeys_ = function() {
    return this.keysAtom_.reportObserved(), Hl(this.target_);
  }, t.keys_ = function() {
    return this.keysAtom_.reportObserved(), Object.keys(this.target_);
  }, e;
}();
function Ea(e, t) {
  var r;
  if (po(e, Ye))
    return e;
  var n = (r = t == null ? void 0 : t.name) != null ? r : "ObservableObject", i = new jj(e, /* @__PURE__ */ new Map(), String(n), J8(t));
  return Ap(e, Ye, i), e;
}
var f9 = /* @__PURE__ */ ws("ObservableObjectAdministration", jj);
function Lk(e) {
  return Nk[e] || (Nk[e] = {
    get: function() {
      return this[Ye].getObservablePropValue_(e);
    },
    set: function(r) {
      return this[Ye].setObservablePropValue_(e, r);
    }
  });
}
function yr(e) {
  return Dg(e) ? f9(e[Ye]) : !1;
}
function Mk(e, t, r) {
  var n;
  (n = e.target_[Pi]) == null || delete n[r];
}
var d9 = /* @__PURE__ */ Mj(0), h9 = /* @__PURE__ */ function() {
  var e = !1, t = {};
  return Object.defineProperty(t, "0", {
    set: function() {
      e = !0;
    }
  }), Object.create(t)[0] = 1, e === !1;
}(), Vv = 0, Lj = function() {
};
function m9(e, t) {
  Object.setPrototypeOf ? Object.setPrototypeOf(e.prototype, t) : e.prototype.__proto__ !== void 0 ? e.prototype.__proto__ = t : e.prototype = t;
}
m9(Lj, Array.prototype);
var u1 = /* @__PURE__ */ function(e) {
  function t(n, i, s, o) {
    var a;
    return s === void 0 && (s = "ObservableArray"), o === void 0 && (o = !1), a = e.call(this) || this, xs(function() {
      var l = new s1(s, i, o, !0);
      l.proxy_ = a, WN(a, Ye, l), n && n.length && a.spliceWithArray(0, 0, n), h9 && Object.defineProperty(a, "0", d9);
    }), a;
  }
  YN(t, e);
  var r = t.prototype;
  return r.concat = function() {
    this[Ye].atom_.reportObserved();
    for (var i = arguments.length, s = new Array(i), o = 0; o < i; o++)
      s[o] = arguments[o];
    return Array.prototype.concat.apply(
      this.slice(),
      //@ts-ignore
      s.map(function(a) {
        return Wr(a) ? a.slice() : a;
      })
    );
  }, r[Symbol.iterator] = function() {
    var n = this, i = 0;
    return p1({
      next: function() {
        return i < n.length ? {
          value: n[i++],
          done: !1
        } : {
          done: !0,
          value: void 0
        };
      }
    });
  }, su(t, [{
    key: "length",
    get: function() {
      return this[Ye].getArrayLength_();
    },
    set: function(i) {
      this[Ye].setArrayLength_(i);
    }
  }, {
    key: Symbol.toStringTag,
    get: function() {
      return "Array";
    }
  }]);
}(Lj);
Object.entries(Fm).forEach(function(e) {
  var t = e[0], r = e[1];
  t !== "concat" && Ap(u1.prototype, t, r);
});
function Mj(e) {
  return {
    enumerable: !1,
    configurable: !0,
    get: function() {
      return this[Ye].get_(e);
    },
    set: function(r) {
      this[Ye].set_(e, r);
    }
  };
}
function g9(e) {
  Ni(u1.prototype, "" + e, Mj(e));
}
function Dj(e) {
  if (e > Vv) {
    for (var t = Vv; t < e + 100; t++)
      g9(t);
    Vv = e;
  }
}
Dj(1e3);
function y9(e, t, r) {
  return new u1(e, t, r);
}
function xo(e, t) {
  if (typeof e == "object" && e !== null) {
    if (Wr(e))
      return t !== void 0 && tt(23), e[Ye].atom_;
    if (cr(e))
      return e.atom_;
    if (vr(e)) {
      if (t === void 0)
        return e.keysAtom_;
      var r = e.data_.get(t) || e.hasMap_.get(t);
      return r || tt(25, t, qm(e)), r;
    }
    if (yr(e)) {
      if (!t)
        return tt(26);
      var n = e[Ye].values_.get(t);
      return n || tt(27, t, qm(e)), n;
    }
    if (ZS(e) || va(e) || Dm(e))
      return e;
  } else if (yn(e) && Dm(e[Ye]))
    return e[Ye];
  tt(28);
}
function Eo(e, t) {
  if (e || tt(29), t !== void 0)
    return Eo(xo(e, t));
  if (ZS(e) || va(e) || Dm(e) || vr(e) || cr(e))
    return e;
  if (e[Ye])
    return e[Ye];
  tt(24, e);
}
function qm(e, t) {
  var r;
  if (t !== void 0)
    r = xo(e, t);
  else {
    if (Yl(e))
      return e.name;
    yr(e) || vr(e) || cr(e) ? r = Eo(e) : r = xo(e);
  }
  return r.name_;
}
function xs(e) {
  var t = xa(), r = Bg(!0);
  en();
  try {
    return e();
  } finally {
    tn(), Ug(r), fo(t);
  }
}
var Dk = kp.toString;
function c1(e, t, r) {
  return r === void 0 && (r = -1), Sw(e, t, r);
}
function Sw(e, t, r, n, i) {
  if (e === t)
    return e !== 0 || 1 / e === 1 / t;
  if (e == null || t == null)
    return !1;
  if (e !== e)
    return t !== t;
  var s = typeof e;
  if (s !== "function" && s !== "object" && typeof t != "object")
    return !1;
  var o = Dk.call(e);
  if (o !== Dk.call(t))
    return !1;
  switch (o) {
    case "[object RegExp]":
    case "[object String]":
      return "" + e == "" + t;
    case "[object Number]":
      return +e != +e ? +t != +t : +e == 0 ? 1 / +e === 1 / t : +e == +t;
    case "[object Date]":
    case "[object Boolean]":
      return +e == +t;
    case "[object Symbol]":
      return typeof Symbol < "u" && Symbol.valueOf.call(e) === Symbol.valueOf.call(t);
    case "[object Map]":
    case "[object Set]":
      r >= 0 && r++;
      break;
  }
  e = Fk(e), t = Fk(t);
  var a = o === "[object Array]";
  if (!a) {
    if (typeof e != "object" || typeof t != "object")
      return !1;
    var l = e.constructor, u = t.constructor;
    if (l !== u && !(yn(l) && l instanceof l && yn(u) && u instanceof u) && "constructor" in e && "constructor" in t)
      return !1;
  }
  if (r === 0)
    return !1;
  r < 0 && (r = -1), n = n || [], i = i || [];
  for (var f = n.length; f--; )
    if (n[f] === e)
      return i[f] === t;
  if (n.push(e), i.push(t), a) {
    if (f = e.length, f !== t.length)
      return !1;
    for (; f--; )
      if (!Sw(e[f], t[f], r - 1, n, i))
        return !1;
  } else {
    var d = Object.keys(e), m;
    if (f = d.length, Object.keys(t).length !== f)
      return !1;
    for (; f--; )
      if (m = d[f], !(po(t, m) && Sw(e[m], t[m], r - 1, n, i)))
        return !1;
  }
  return n.pop(), i.pop(), !0;
}
function Fk(e) {
  return Wr(e) ? e.slice() : ou(e) || vr(e) || oo(e) || cr(e) ? Array.from(e.entries()) : e;
}
var zk, v9 = ((zk = Mg().Iterator) == null ? void 0 : zk.prototype) || {};
function p1(e) {
  return e[Symbol.iterator] = b9, Object.assign(Object.create(v9), e);
}
function b9() {
  return this;
}
["Symbol", "Map", "Set"].forEach(function(e) {
  var t = Mg();
  typeof t[e] > "u" && tt("MobX requires global '" + e + "' to be available or polyfilled");
});
typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ == "object" && __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
  spy: mj,
  extras: {
    getDebugName: qm
  },
  $mobx: Ye
});
const w9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  $mobx: Ye,
  FlowCancellationError: Wg,
  ObservableMap: a1,
  ObservableSet: l1,
  Reaction: Mn,
  _allowStateChanges: qg,
  _allowStateChangesInsideComputed: ww,
  _allowStateReadsEnd: $l,
  _allowStateReadsStart: Vg,
  _autoAction: Ql,
  _endAction: sj,
  _getAdministration: Eo,
  _getGlobalState: uW,
  _interceptReads: MW,
  _isComputingDerivation: oW,
  _resetGlobalState: cW,
  _startAction: oj,
  action: Yo,
  autorun: n1,
  comparer: ga,
  computed: $p,
  configure: Ej,
  createAtom: e1,
  defineProperty: YW,
  entries: WW,
  extendObservable: o1,
  flow: ba,
  flowResult: LW,
  get: QW,
  getAtom: xo,
  getDebugName: qm,
  getDependencyTree: _j,
  getObserverTree: $W,
  has: Cj,
  intercept: DW,
  isAction: Yl,
  isBoxedObservable: r1,
  isComputed: qW,
  isComputedProp: BW,
  isFlow: Gl,
  isFlowCancellationError: NW,
  isObservable: Hg,
  isObservableArray: Wr,
  isObservableMap: vr,
  isObservableObject: yr,
  isObservableProp: UW,
  isObservableSet: cr,
  keys: dp,
  makeAutoObservable: i9,
  makeObservable: Ij,
  observable: Xt,
  observe: GW,
  onBecomeObserved: Sj,
  onBecomeUnobserved: i1,
  onReactionError: gW,
  override: b8,
  ownKeys: $j,
  reaction: OW,
  remove: HW,
  runInAction: ww,
  set: Tj,
  spy: mj,
  toJS: JW,
  trace: ZW,
  transaction: ki,
  untracked: au,
  values: VW,
  when: e9
}, Symbol.toStringTag, { value: "Module" })), S9 = /* @__PURE__ */ Di(w9);
var Si = {}, Yr = {};
const x9 = {}, E9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: x9
}, Symbol.toStringTag, { value: "Module" })), hp = /* @__PURE__ */ Di(E9);
var Wv, qk;
function f1() {
  if (qk) return Wv;
  qk = 1;
  function e(i) {
    if (typeof i != "string")
      throw new TypeError("Path must be a string. Received " + JSON.stringify(i));
  }
  function t(i, s) {
    for (var o = "", a = 0, l = -1, u = 0, f, d = 0; d <= i.length; ++d) {
      if (d < i.length)
        f = i.charCodeAt(d);
      else {
        if (f === 47)
          break;
        f = 47;
      }
      if (f === 47) {
        if (!(l === d - 1 || u === 1)) if (l !== d - 1 && u === 2) {
          if (o.length < 2 || a !== 2 || o.charCodeAt(o.length - 1) !== 46 || o.charCodeAt(o.length - 2) !== 46) {
            if (o.length > 2) {
              var m = o.lastIndexOf("/");
              if (m !== o.length - 1) {
                m === -1 ? (o = "", a = 0) : (o = o.slice(0, m), a = o.length - 1 - o.lastIndexOf("/")), l = d, u = 0;
                continue;
              }
            } else if (o.length === 2 || o.length === 1) {
              o = "", a = 0, l = d, u = 0;
              continue;
            }
          }
          s && (o.length > 0 ? o += "/.." : o = "..", a = 2);
        } else
          o.length > 0 ? o += "/" + i.slice(l + 1, d) : o = i.slice(l + 1, d), a = d - l - 1;
        l = d, u = 0;
      } else f === 46 && u !== -1 ? ++u : u = -1;
    }
    return o;
  }
  function r(i, s) {
    var o = s.dir || s.root, a = s.base || (s.name || "") + (s.ext || "");
    return o ? o === s.root ? o + a : o + i + a : a;
  }
  var n = {
    // path.resolve([from ...], to)
    resolve: function() {
      for (var s = "", o = !1, a, l = arguments.length - 1; l >= -1 && !o; l--) {
        var u;
        l >= 0 ? u = arguments[l] : (a === void 0 && (a = process.cwd()), u = a), e(u), u.length !== 0 && (s = u + "/" + s, o = u.charCodeAt(0) === 47);
      }
      return s = t(s, !o), o ? s.length > 0 ? "/" + s : "/" : s.length > 0 ? s : ".";
    },
    normalize: function(s) {
      if (e(s), s.length === 0) return ".";
      var o = s.charCodeAt(0) === 47, a = s.charCodeAt(s.length - 1) === 47;
      return s = t(s, !o), s.length === 0 && !o && (s = "."), s.length > 0 && a && (s += "/"), o ? "/" + s : s;
    },
    isAbsolute: function(s) {
      return e(s), s.length > 0 && s.charCodeAt(0) === 47;
    },
    join: function() {
      if (arguments.length === 0)
        return ".";
      for (var s, o = 0; o < arguments.length; ++o) {
        var a = arguments[o];
        e(a), a.length > 0 && (s === void 0 ? s = a : s += "/" + a);
      }
      return s === void 0 ? "." : n.normalize(s);
    },
    relative: function(s, o) {
      if (e(s), e(o), s === o || (s = n.resolve(s), o = n.resolve(o), s === o)) return "";
      for (var a = 1; a < s.length && s.charCodeAt(a) === 47; ++a)
        ;
      for (var l = s.length, u = l - a, f = 1; f < o.length && o.charCodeAt(f) === 47; ++f)
        ;
      for (var d = o.length, m = d - f, v = u < m ? u : m, S = -1, y = 0; y <= v; ++y) {
        if (y === v) {
          if (m > v) {
            if (o.charCodeAt(f + y) === 47)
              return o.slice(f + y + 1);
            if (y === 0)
              return o.slice(f + y);
          } else u > v && (s.charCodeAt(a + y) === 47 ? S = y : y === 0 && (S = 0));
          break;
        }
        var E = s.charCodeAt(a + y), x = o.charCodeAt(f + y);
        if (E !== x)
          break;
        E === 47 && (S = y);
      }
      var g = "";
      for (y = a + S + 1; y <= l; ++y)
        (y === l || s.charCodeAt(y) === 47) && (g.length === 0 ? g += ".." : g += "/..");
      return g.length > 0 ? g + o.slice(f + S) : (f += S, o.charCodeAt(f) === 47 && ++f, o.slice(f));
    },
    _makeLong: function(s) {
      return s;
    },
    dirname: function(s) {
      if (e(s), s.length === 0) return ".";
      for (var o = s.charCodeAt(0), a = o === 47, l = -1, u = !0, f = s.length - 1; f >= 1; --f)
        if (o = s.charCodeAt(f), o === 47) {
          if (!u) {
            l = f;
            break;
          }
        } else
          u = !1;
      return l === -1 ? a ? "/" : "." : a && l === 1 ? "//" : s.slice(0, l);
    },
    basename: function(s, o) {
      if (o !== void 0 && typeof o != "string") throw new TypeError('"ext" argument must be a string');
      e(s);
      var a = 0, l = -1, u = !0, f;
      if (o !== void 0 && o.length > 0 && o.length <= s.length) {
        if (o.length === s.length && o === s) return "";
        var d = o.length - 1, m = -1;
        for (f = s.length - 1; f >= 0; --f) {
          var v = s.charCodeAt(f);
          if (v === 47) {
            if (!u) {
              a = f + 1;
              break;
            }
          } else
            m === -1 && (u = !1, m = f + 1), d >= 0 && (v === o.charCodeAt(d) ? --d === -1 && (l = f) : (d = -1, l = m));
        }
        return a === l ? l = m : l === -1 && (l = s.length), s.slice(a, l);
      } else {
        for (f = s.length - 1; f >= 0; --f)
          if (s.charCodeAt(f) === 47) {
            if (!u) {
              a = f + 1;
              break;
            }
          } else l === -1 && (u = !1, l = f + 1);
        return l === -1 ? "" : s.slice(a, l);
      }
    },
    extname: function(s) {
      e(s);
      for (var o = -1, a = 0, l = -1, u = !0, f = 0, d = s.length - 1; d >= 0; --d) {
        var m = s.charCodeAt(d);
        if (m === 47) {
          if (!u) {
            a = d + 1;
            break;
          }
          continue;
        }
        l === -1 && (u = !1, l = d + 1), m === 46 ? o === -1 ? o = d : f !== 1 && (f = 1) : o !== -1 && (f = -1);
      }
      return o === -1 || l === -1 || // We saw a non-dot character immediately before the dot
      f === 0 || // The (right-most) trimmed path component is exactly '..'
      f === 1 && o === l - 1 && o === a + 1 ? "" : s.slice(o, l);
    },
    format: function(s) {
      if (s === null || typeof s != "object")
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof s);
      return r("/", s);
    },
    parse: function(s) {
      e(s);
      var o = { root: "", dir: "", base: "", ext: "", name: "" };
      if (s.length === 0) return o;
      var a = s.charCodeAt(0), l = a === 47, u;
      l ? (o.root = "/", u = 1) : u = 0;
      for (var f = -1, d = 0, m = -1, v = !0, S = s.length - 1, y = 0; S >= u; --S) {
        if (a = s.charCodeAt(S), a === 47) {
          if (!v) {
            d = S + 1;
            break;
          }
          continue;
        }
        m === -1 && (v = !1, m = S + 1), a === 46 ? f === -1 ? f = S : y !== 1 && (y = 1) : f !== -1 && (y = -1);
      }
      return f === -1 || m === -1 || // We saw a non-dot character immediately before the dot
      y === 0 || // The (right-most) trimmed path component is exactly '..'
      y === 1 && f === m - 1 && f === d + 1 ? m !== -1 && (d === 0 && l ? o.base = o.name = s.slice(1, m) : o.base = o.name = s.slice(d, m)) : (d === 0 && l ? (o.name = s.slice(1, f), o.base = s.slice(1, m)) : (o.name = s.slice(d, f), o.base = s.slice(d, m)), o.ext = s.slice(f, m)), d > 0 ? o.dir = s.slice(0, d - 1) : l && (o.dir = "/"), o;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  return n.posix = n, Wv = n, Wv;
}
var wr = {}, Hv = {}, Qv, Bk;
function _9() {
  return Bk || (Bk = 1, Qv = typeof process == "object" && process && process.platform === "win32" ? { sep: "\\" } : { sep: "/" }), Qv;
}
var Yv, Uk;
function O9() {
  if (Uk) return Yv;
  Uk = 1, Yv = e;
  function e(n, i, s) {
    n instanceof RegExp && (n = t(n, s)), i instanceof RegExp && (i = t(i, s));
    var o = r(n, i, s);
    return o && {
      start: o[0],
      end: o[1],
      pre: s.slice(0, o[0]),
      body: s.slice(o[0] + n.length, o[1]),
      post: s.slice(o[1] + i.length)
    };
  }
  function t(n, i) {
    var s = i.match(n);
    return s ? s[0] : null;
  }
  e.range = r;
  function r(n, i, s) {
    var o, a, l, u, f, d = s.indexOf(n), m = s.indexOf(i, d + 1), v = d;
    if (d >= 0 && m > 0) {
      if (n === i)
        return [d, m];
      for (o = [], l = s.length; v >= 0 && !f; )
        v == d ? (o.push(v), d = s.indexOf(n, v + 1)) : o.length == 1 ? f = [o.pop(), m] : (a = o.pop(), a < l && (l = a, u = m), m = s.indexOf(i, v + 1)), v = d < m && d >= 0 ? d : m;
      o.length && (f = [l, u]);
    }
    return f;
  }
  return Yv;
}
var Gv, Vk;
function k9() {
  if (Vk) return Gv;
  Vk = 1;
  var e = O9();
  Gv = f;
  var t = "\0SLASH" + Math.random() + "\0", r = "\0OPEN" + Math.random() + "\0", n = "\0CLOSE" + Math.random() + "\0", i = "\0COMMA" + Math.random() + "\0", s = "\0PERIOD" + Math.random() + "\0";
  function o(E) {
    return parseInt(E, 10) == E ? parseInt(E, 10) : E.charCodeAt(0);
  }
  function a(E) {
    return E.split("\\\\").join(t).split("\\{").join(r).split("\\}").join(n).split("\\,").join(i).split("\\.").join(s);
  }
  function l(E) {
    return E.split(t).join("\\").split(r).join("{").split(n).join("}").split(i).join(",").split(s).join(".");
  }
  function u(E) {
    if (!E)
      return [""];
    var x = [], g = e("{", "}", E);
    if (!g)
      return E.split(",");
    var b = g.pre, A = g.body, P = g.post, k = b.split(",");
    k[k.length - 1] += "{" + A + "}";
    var $ = u(P);
    return P.length && (k[k.length - 1] += $.shift(), k.push.apply(k, $)), x.push.apply(x, k), x;
  }
  function f(E) {
    return E ? (E.substr(0, 2) === "{}" && (E = "\\{\\}" + E.substr(2)), y(a(E), !0).map(l)) : [];
  }
  function d(E) {
    return "{" + E + "}";
  }
  function m(E) {
    return /^-?0\d/.test(E);
  }
  function v(E, x) {
    return E <= x;
  }
  function S(E, x) {
    return E >= x;
  }
  function y(E, x) {
    var g = [], b = e("{", "}", E);
    if (!b) return [E];
    var A = b.pre, P = b.post.length ? y(b.post, !1) : [""];
    if (/\$$/.test(b.pre))
      for (var k = 0; k < P.length; k++) {
        var $ = A + "{" + b.body + "}" + P[k];
        g.push($);
      }
    else {
      var I = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(b.body), F = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(b.body), L = I || F, Q = b.body.indexOf(",") >= 0;
      if (!L && !Q)
        return b.post.match(/,.*\}/) ? (E = b.pre + "{" + b.body + n + b.post, y(E)) : [E];
      var Y;
      if (L)
        Y = b.body.split(/\.\./);
      else if (Y = u(b.body), Y.length === 1 && (Y = y(Y[0], !1).map(d), Y.length === 1))
        return P.map(function(B) {
          return b.pre + Y[0] + B;
        });
      var ae;
      if (L) {
        var le = o(Y[0]), ue = o(Y[1]), ce = Math.max(Y[0].length, Y[1].length), be = Y.length == 3 ? Math.abs(o(Y[2])) : 1, G = v, ee = ue < le;
        ee && (be *= -1, G = S);
        var K = Y.some(m);
        ae = [];
        for (var z = le; G(z, ue); z += be) {
          var te;
          if (F)
            te = String.fromCharCode(z), te === "\\" && (te = "");
          else if (te = String(z), K) {
            var q = ce - te.length;
            if (q > 0) {
              var j = new Array(q + 1).join("0");
              z < 0 ? te = "-" + j + te.slice(1) : te = j + te;
            }
          }
          ae.push(te);
        }
      } else {
        ae = [];
        for (var H = 0; H < Y.length; H++)
          ae.push.apply(ae, y(Y[H], !1));
      }
      for (var H = 0; H < ae.length; H++)
        for (var k = 0; k < P.length; k++) {
          var $ = A + ae[H] + P[k];
          (!x || L || $) && g.push($);
        }
    }
    return g;
  }
  return Gv;
}
var wd, Wk;
function A9() {
  if (Wk) return wd;
  Wk = 1;
  const e = wd = ($, I, F = {}) => (E(I), !F.nocomment && I.charAt(0) === "#" ? !1 : new k(I, F).match($));
  wd = e;
  const t = _9();
  e.sep = t.sep;
  const r = Symbol("globstar **");
  e.GLOBSTAR = r;
  const n = k9(), i = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  }, s = "[^/]", o = s + "*?", a = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", l = "(?:(?!(?:\\/|^)\\.).)*?", u = ($) => $.split("").reduce((I, F) => (I[F] = !0, I), {}), f = u("().*{}+?[]^$\\!"), d = u("[.("), m = /\/+/;
  e.filter = ($, I = {}) => (F, L, Q) => e(F, $, I);
  const v = ($, I = {}) => {
    const F = {};
    return Object.keys($).forEach((L) => F[L] = $[L]), Object.keys(I).forEach((L) => F[L] = I[L]), F;
  };
  e.defaults = ($) => {
    if (!$ || typeof $ != "object" || !Object.keys($).length)
      return e;
    const I = e, F = (L, Q, Y) => I(L, Q, v($, Y));
    return F.Minimatch = class extends I.Minimatch {
      constructor(Q, Y) {
        super(Q, v($, Y));
      }
    }, F.Minimatch.defaults = (L) => I.defaults(v($, L)).Minimatch, F.filter = (L, Q) => I.filter(L, v($, Q)), F.defaults = (L) => I.defaults(v($, L)), F.makeRe = (L, Q) => I.makeRe(L, v($, Q)), F.braceExpand = (L, Q) => I.braceExpand(L, v($, Q)), F.match = (L, Q, Y) => I.match(L, Q, v($, Y)), F;
  }, e.braceExpand = ($, I) => S($, I);
  const S = ($, I = {}) => (E($), I.nobrace || !/\{(?:(?!\{).)*\}/.test($) ? [$] : n($)), y = 1024 * 64, E = ($) => {
    if (typeof $ != "string")
      throw new TypeError("invalid pattern");
    if ($.length > y)
      throw new TypeError("pattern is too long");
  }, x = Symbol("subparse");
  e.makeRe = ($, I) => new k($, I || {}).makeRe(), e.match = ($, I, F = {}) => {
    const L = new k(I, F);
    return $ = $.filter((Q) => L.match(Q)), L.options.nonull && !$.length && $.push(I), $;
  };
  const g = ($) => $.replace(/\\(.)/g, "$1"), b = ($) => $.replace(/\\([^-\]])/g, "$1"), A = ($) => $.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), P = ($) => $.replace(/[[\]\\]/g, "\\$&");
  class k {
    constructor(I, F) {
      E(I), F || (F = {}), this.options = F, this.set = [], this.pattern = I, this.windowsPathsNoEscape = !!F.windowsPathsNoEscape || F.allowWindowsEscape === !1, this.windowsPathsNoEscape && (this.pattern = this.pattern.replace(/\\/g, "/")), this.regexp = null, this.negate = !1, this.comment = !1, this.empty = !1, this.partial = !!F.partial, this.make();
    }
    debug() {
    }
    make() {
      const I = this.pattern, F = this.options;
      if (!F.nocomment && I.charAt(0) === "#") {
        this.comment = !0;
        return;
      }
      if (!I) {
        this.empty = !0;
        return;
      }
      this.parseNegate();
      let L = this.globSet = this.braceExpand();
      F.debug && (this.debug = (...Q) => console.error(...Q)), this.debug(this.pattern, L), L = this.globParts = L.map((Q) => Q.split(m)), this.debug(this.pattern, L), L = L.map((Q, Y, ae) => Q.map(this.parse, this)), this.debug(this.pattern, L), L = L.filter((Q) => Q.indexOf(!1) === -1), this.debug(this.pattern, L), this.set = L;
    }
    parseNegate() {
      if (this.options.nonegate) return;
      const I = this.pattern;
      let F = !1, L = 0;
      for (let Q = 0; Q < I.length && I.charAt(Q) === "!"; Q++)
        F = !F, L++;
      L && (this.pattern = I.slice(L)), this.negate = F;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(I, F, L) {
      var Q = this.options;
      this.debug(
        "matchOne",
        { this: this, file: I, pattern: F }
      ), this.debug("matchOne", I.length, F.length);
      for (var Y = 0, ae = 0, le = I.length, ue = F.length; Y < le && ae < ue; Y++, ae++) {
        this.debug("matchOne loop");
        var ce = F[ae], be = I[Y];
        if (this.debug(F, ce, be), ce === !1) return !1;
        if (ce === r) {
          this.debug("GLOBSTAR", [F, ce, be]);
          var G = Y, ee = ae + 1;
          if (ee === ue) {
            for (this.debug("** at the end"); Y < le; Y++)
              if (I[Y] === "." || I[Y] === ".." || !Q.dot && I[Y].charAt(0) === ".") return !1;
            return !0;
          }
          for (; G < le; ) {
            var K = I[G];
            if (this.debug(`
globstar while`, I, G, F, ee, K), this.matchOne(I.slice(G), F.slice(ee), L))
              return this.debug("globstar found match!", G, le, K), !0;
            if (K === "." || K === ".." || !Q.dot && K.charAt(0) === ".") {
              this.debug("dot detected!", I, G, F, ee);
              break;
            }
            this.debug("globstar swallow a segment, and continue"), G++;
          }
          return !!(L && (this.debug(`
>>> no match, partial?`, I, G, F, ee), G === le));
        }
        var z;
        if (typeof ce == "string" ? (z = be === ce, this.debug("string match", ce, be, z)) : (z = be.match(ce), this.debug("pattern match", ce, be, z)), !z) return !1;
      }
      if (Y === le && ae === ue)
        return !0;
      if (Y === le)
        return L;
      if (ae === ue)
        return Y === le - 1 && I[Y] === "";
      throw new Error("wtf?");
    }
    braceExpand() {
      return S(this.pattern, this.options);
    }
    parse(I, F) {
      E(I);
      const L = this.options;
      if (I === "**")
        if (L.noglobstar)
          I = "*";
        else
          return r;
      if (I === "") return "";
      let Q = "", Y = !1, ae = !1;
      const le = [], ue = [];
      let ce, be = !1, G = -1, ee = -1, K, z, te, q = I.charAt(0) === ".", j = L.dot || q;
      const H = () => q ? "" : j ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", B = (C) => C.charAt(0) === "." ? "" : L.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", pe = () => {
        if (ce) {
          switch (ce) {
            case "*":
              Q += o, Y = !0;
              break;
            case "?":
              Q += s, Y = !0;
              break;
            default:
              Q += "\\" + ce;
              break;
          }
          this.debug("clearStateChar %j %j", ce, Q), ce = !1;
        }
      };
      for (let C = 0, N; C < I.length && (N = I.charAt(C)); C++) {
        if (this.debug("%s	%s %s %j", I, C, Q, N), ae) {
          if (N === "/")
            return !1;
          f[N] && (Q += "\\"), Q += N, ae = !1;
          continue;
        }
        switch (N) {
          case "/":
            return !1;
          case "\\":
            if (be && I.charAt(C + 1) === "-") {
              Q += N;
              continue;
            }
            pe(), ae = !0;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            if (this.debug("%s	%s %s %j <-- stateChar", I, C, Q, N), be) {
              this.debug("  in class"), N === "!" && C === ee + 1 && (N = "^"), Q += N;
              continue;
            }
            this.debug("call clearStateChar %j", ce), pe(), ce = N, L.noext && pe();
            continue;
          case "(": {
            if (be) {
              Q += "(";
              continue;
            }
            if (!ce) {
              Q += "\\(";
              continue;
            }
            const J = {
              type: ce,
              start: C - 1,
              reStart: Q.length,
              open: i[ce].open,
              close: i[ce].close
            };
            this.debug(this.pattern, "	", J), le.push(J), Q += J.open, J.start === 0 && J.type !== "!" && (q = !0, Q += B(I.slice(C + 1))), this.debug("plType %j %j", ce, Q), ce = !1;
            continue;
          }
          case ")": {
            const J = le[le.length - 1];
            if (be || !J) {
              Q += "\\)";
              continue;
            }
            le.pop(), pe(), Y = !0, z = J, Q += z.close, z.type === "!" && ue.push(Object.assign(z, { reEnd: Q.length }));
            continue;
          }
          case "|": {
            const J = le[le.length - 1];
            if (be || !J) {
              Q += "\\|";
              continue;
            }
            pe(), Q += "|", J.start === 0 && J.type !== "!" && (q = !0, Q += B(I.slice(C + 1)));
            continue;
          }
          case "[":
            if (pe(), be) {
              Q += "\\" + N;
              continue;
            }
            be = !0, ee = C, G = Q.length, Q += N;
            continue;
          case "]":
            if (C === ee + 1 || !be) {
              Q += "\\" + N;
              continue;
            }
            K = I.substring(ee + 1, C);
            try {
              RegExp("[" + P(b(K)) + "]"), Q += N;
            } catch {
              Q = Q.substring(0, G) + "(?:$.)";
            }
            Y = !0, be = !1;
            continue;
          default:
            pe(), f[N] && !(N === "^" && be) && (Q += "\\"), Q += N;
            break;
        }
      }
      for (be && (K = I.slice(ee + 1), te = this.parse(K, x), Q = Q.substring(0, G) + "\\[" + te[0], Y = Y || te[1]), z = le.pop(); z; z = le.pop()) {
        let C;
        C = Q.slice(z.reStart + z.open.length), this.debug("setting tail", Q, z), C = C.replace(/((?:\\{2}){0,64})(\\?)\|/g, (J, X, oe) => (oe || (oe = "\\"), X + X + oe + "|")), this.debug(`tail=%j
   %s`, C, C, z, Q);
        const N = z.type === "*" ? o : z.type === "?" ? s : "\\" + z.type;
        Y = !0, Q = Q.slice(0, z.reStart) + N + "\\(" + C;
      }
      pe(), ae && (Q += "\\\\");
      const he = d[Q.charAt(0)];
      for (let C = ue.length - 1; C > -1; C--) {
        const N = ue[C], J = Q.slice(0, N.reStart), X = Q.slice(N.reStart, N.reEnd - 8);
        let oe = Q.slice(N.reEnd);
        const U = Q.slice(N.reEnd - 8, N.reEnd) + oe, V = J.split(")").length, ye = J.split("(").length - V;
        let de = oe;
        for (let Se = 0; Se < ye; Se++)
          de = de.replace(/\)[+*?]?/, "");
        oe = de;
        const Ce = oe === "" && F !== x ? "(?:$|\\/)" : "";
        Q = J + X + oe + Ce + U;
      }
      if (Q !== "" && Y && (Q = "(?=.)" + Q), he && (Q = H() + Q), F === x)
        return [Q, Y];
      if (L.nocase && !Y && (Y = I.toUpperCase() !== I.toLowerCase()), !Y)
        return g(I);
      const Ae = L.nocase ? "i" : "";
      try {
        return Object.assign(new RegExp("^" + Q + "$", Ae), {
          _glob: I,
          _src: Q
        });
      } catch {
        return new RegExp("$.");
      }
    }
    makeRe() {
      if (this.regexp || this.regexp === !1) return this.regexp;
      const I = this.set;
      if (!I.length)
        return this.regexp = !1, this.regexp;
      const F = this.options, L = F.noglobstar ? o : F.dot ? a : l, Q = F.nocase ? "i" : "";
      let Y = I.map((ae) => (ae = ae.map(
        (le) => typeof le == "string" ? A(le) : le === r ? r : le._src
      ).reduce((le, ue) => (le[le.length - 1] === r && ue === r || le.push(ue), le), []), ae.forEach((le, ue) => {
        le !== r || ae[ue - 1] === r || (ue === 0 ? ae.length > 1 ? ae[ue + 1] = "(?:\\/|" + L + "\\/)?" + ae[ue + 1] : ae[ue] = L : ue === ae.length - 1 ? ae[ue - 1] += "(?:\\/|" + L + ")?" : (ae[ue - 1] += "(?:\\/|\\/" + L + "\\/)" + ae[ue + 1], ae[ue + 1] = r));
      }), ae.filter((le) => le !== r).join("/"))).join("|");
      Y = "^(?:" + Y + ")$", this.negate && (Y = "^(?!" + Y + ").*$");
      try {
        this.regexp = new RegExp(Y, Q);
      } catch {
        this.regexp = !1;
      }
      return this.regexp;
    }
    match(I, F = this.partial) {
      if (this.debug("match", I, this.pattern), this.comment) return !1;
      if (this.empty) return I === "";
      if (I === "/" && F) return !0;
      const L = this.options;
      t.sep !== "/" && (I = I.split(t.sep).join("/")), I = I.split(m), this.debug(this.pattern, "split", I);
      const Q = this.set;
      this.debug(this.pattern, "set", Q);
      let Y;
      for (let ae = I.length - 1; ae >= 0 && (Y = I[ae], !Y); ae--)
        ;
      for (let ae = 0; ae < Q.length; ae++) {
        const le = Q[ae];
        let ue = I;
        if (L.matchBase && le.length === 1 && (ue = [Y]), this.matchOne(ue, le, F))
          return L.flipNegate ? !0 : !this.negate;
      }
      return L.flipNegate ? !1 : this.negate;
    }
    static defaults(I) {
      return e.defaults(I).Minimatch;
    }
  }
  return e.Minimatch = k, wd;
}
var Fs = {}, $r = {}, Sd = {}, Mo = {}, Hk;
function Np() {
  if (Hk) return Mo;
  Hk = 1;
  function e(o) {
    return typeof o > "u" || o === null;
  }
  function t(o) {
    return typeof o == "object" && o !== null;
  }
  function r(o) {
    return Array.isArray(o) ? o : e(o) ? [] : [o];
  }
  function n(o, a) {
    var l, u, f, d;
    if (a)
      for (d = Object.keys(a), l = 0, u = d.length; l < u; l += 1)
        f = d[l], o[f] = a[f];
    return o;
  }
  function i(o, a) {
    var l = "", u;
    for (u = 0; u < a; u += 1)
      l += o;
    return l;
  }
  function s(o) {
    return o === 0 && Number.NEGATIVE_INFINITY === 1 / o;
  }
  return Mo.isNothing = e, Mo.isObject = t, Mo.toArray = r, Mo.repeat = i, Mo.isNegativeZero = s, Mo.extend = n, Mo;
}
var Kv, Qk;
function jp() {
  if (Qk) return Kv;
  Qk = 1;
  function e(r, n) {
    var i = "", s = r.reason || "(unknown reason)";
    return r.mark ? (r.mark.name && (i += 'in "' + r.mark.name + '" '), i += "(" + (r.mark.line + 1) + ":" + (r.mark.column + 1) + ")", !n && r.mark.snippet && (i += `

` + r.mark.snippet), s + " " + i) : s;
  }
  function t(r, n) {
    Error.call(this), this.name = "YAMLException", this.reason = r, this.mark = n, this.message = e(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
  }
  return t.prototype = Object.create(Error.prototype), t.prototype.constructor = t, t.prototype.toString = function(n) {
    return this.name + ": " + e(this, n);
  }, Kv = t, Kv;
}
var Xv, Yk;
function P9() {
  if (Yk) return Xv;
  Yk = 1;
  var e = Np();
  function t(i, s, o, a, l) {
    var u = "", f = "", d = Math.floor(l / 2) - 1;
    return a - s > d && (u = " ... ", s = a - d + u.length), o - a > d && (f = " ...", o = a + d - f.length), {
      str: u + i.slice(s, o).replace(/\t/g, "") + f,
      pos: a - s + u.length
      // relative position
    };
  }
  function r(i, s) {
    return e.repeat(" ", s - i.length) + i;
  }
  function n(i, s) {
    if (s = Object.create(s || null), !i.buffer) return null;
    s.maxLength || (s.maxLength = 79), typeof s.indent != "number" && (s.indent = 1), typeof s.linesBefore != "number" && (s.linesBefore = 3), typeof s.linesAfter != "number" && (s.linesAfter = 2);
    for (var o = /\r?\n|\r|\0/g, a = [0], l = [], u, f = -1; u = o.exec(i.buffer); )
      l.push(u.index), a.push(u.index + u[0].length), i.position <= u.index && f < 0 && (f = a.length - 2);
    f < 0 && (f = a.length - 1);
    var d = "", m, v, S = Math.min(i.line + s.linesAfter, l.length).toString().length, y = s.maxLength - (s.indent + S + 3);
    for (m = 1; m <= s.linesBefore && !(f - m < 0); m++)
      v = t(
        i.buffer,
        a[f - m],
        l[f - m],
        i.position - (a[f] - a[f - m]),
        y
      ), d = e.repeat(" ", s.indent) + r((i.line - m + 1).toString(), S) + " | " + v.str + `
` + d;
    for (v = t(i.buffer, a[f], l[f], i.position, y), d += e.repeat(" ", s.indent) + r((i.line + 1).toString(), S) + " | " + v.str + `
`, d += e.repeat("-", s.indent + S + 3 + v.pos) + `^
`, m = 1; m <= s.linesAfter && !(f + m >= l.length); m++)
      v = t(
        i.buffer,
        a[f + m],
        l[f + m],
        i.position - (a[f] - a[f + m]),
        y
      ), d += e.repeat(" ", s.indent) + r((i.line + m + 1).toString(), S) + " | " + v.str + `
`;
    return d.replace(/\n$/, "");
  }
  return Xv = n, Xv;
}
var Jv, Gk;
function Hr() {
  if (Gk) return Jv;
  Gk = 1;
  var e = jp(), t = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases"
  ], r = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function n(s) {
    var o = {};
    return s !== null && Object.keys(s).forEach(function(a) {
      s[a].forEach(function(l) {
        o[String(l)] = a;
      });
    }), o;
  }
  function i(s, o) {
    if (o = o || {}, Object.keys(o).forEach(function(a) {
      if (t.indexOf(a) === -1)
        throw new e('Unknown option "' + a + '" is met in definition of "' + s + '" YAML type.');
    }), this.options = o, this.tag = s, this.kind = o.kind || null, this.resolve = o.resolve || function() {
      return !0;
    }, this.construct = o.construct || function(a) {
      return a;
    }, this.instanceOf = o.instanceOf || null, this.predicate = o.predicate || null, this.represent = o.represent || null, this.representName = o.representName || null, this.defaultStyle = o.defaultStyle || null, this.multi = o.multi || !1, this.styleAliases = n(o.styleAliases || null), r.indexOf(this.kind) === -1)
      throw new e('Unknown kind "' + this.kind + '" is specified for "' + s + '" YAML type.');
  }
  return Jv = i, Jv;
}
var Zv, Kk;
function Fj() {
  if (Kk) return Zv;
  Kk = 1;
  var e = jp(), t = Hr();
  function r(s, o) {
    var a = [];
    return s[o].forEach(function(l) {
      var u = a.length;
      a.forEach(function(f, d) {
        f.tag === l.tag && f.kind === l.kind && f.multi === l.multi && (u = d);
      }), a[u] = l;
    }), a;
  }
  function n() {
    var s = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: {
        scalar: [],
        sequence: [],
        mapping: [],
        fallback: []
      }
    }, o, a;
    function l(u) {
      u.multi ? (s.multi[u.kind].push(u), s.multi.fallback.push(u)) : s[u.kind][u.tag] = s.fallback[u.tag] = u;
    }
    for (o = 0, a = arguments.length; o < a; o += 1)
      arguments[o].forEach(l);
    return s;
  }
  function i(s) {
    return this.extend(s);
  }
  return i.prototype.extend = function(o) {
    var a = [], l = [];
    if (o instanceof t)
      l.push(o);
    else if (Array.isArray(o))
      l = l.concat(o);
    else if (o && (Array.isArray(o.implicit) || Array.isArray(o.explicit)))
      o.implicit && (a = a.concat(o.implicit)), o.explicit && (l = l.concat(o.explicit));
    else
      throw new e("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
    a.forEach(function(f) {
      if (!(f instanceof t))
        throw new e("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      if (f.loadKind && f.loadKind !== "scalar")
        throw new e("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      if (f.multi)
        throw new e("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }), l.forEach(function(f) {
      if (!(f instanceof t))
        throw new e("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    });
    var u = Object.create(i.prototype);
    return u.implicit = (this.implicit || []).concat(a), u.explicit = (this.explicit || []).concat(l), u.compiledImplicit = r(u, "implicit"), u.compiledExplicit = r(u, "explicit"), u.compiledTypeMap = n(u.compiledImplicit, u.compiledExplicit), u;
  }, Zv = i, Zv;
}
var eb, Xk;
function zj() {
  if (Xk) return eb;
  Xk = 1;
  var e = Hr();
  return eb = new e("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(t) {
      return t !== null ? t : "";
    }
  }), eb;
}
var tb, Jk;
function qj() {
  if (Jk) return tb;
  Jk = 1;
  var e = Hr();
  return tb = new e("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(t) {
      return t !== null ? t : [];
    }
  }), tb;
}
var rb, Zk;
function Bj() {
  if (Zk) return rb;
  Zk = 1;
  var e = Hr();
  return rb = new e("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(t) {
      return t !== null ? t : {};
    }
  }), rb;
}
var nb, eA;
function Uj() {
  if (eA) return nb;
  eA = 1;
  var e = Fj();
  return nb = new e({
    explicit: [
      zj(),
      qj(),
      Bj()
    ]
  }), nb;
}
var ib, tA;
function Vj() {
  if (tA) return ib;
  tA = 1;
  var e = Hr();
  function t(i) {
    if (i === null) return !0;
    var s = i.length;
    return s === 1 && i === "~" || s === 4 && (i === "null" || i === "Null" || i === "NULL");
  }
  function r() {
    return null;
  }
  function n(i) {
    return i === null;
  }
  return ib = new e("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: t,
    construct: r,
    predicate: n,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      },
      empty: function() {
        return "";
      }
    },
    defaultStyle: "lowercase"
  }), ib;
}
var ob, rA;
function Wj() {
  if (rA) return ob;
  rA = 1;
  var e = Hr();
  function t(i) {
    if (i === null) return !1;
    var s = i.length;
    return s === 4 && (i === "true" || i === "True" || i === "TRUE") || s === 5 && (i === "false" || i === "False" || i === "FALSE");
  }
  function r(i) {
    return i === "true" || i === "True" || i === "TRUE";
  }
  function n(i) {
    return Object.prototype.toString.call(i) === "[object Boolean]";
  }
  return ob = new e("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: t,
    construct: r,
    predicate: n,
    represent: {
      lowercase: function(i) {
        return i ? "true" : "false";
      },
      uppercase: function(i) {
        return i ? "TRUE" : "FALSE";
      },
      camelcase: function(i) {
        return i ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  }), ob;
}
var sb, nA;
function Hj() {
  if (nA) return sb;
  nA = 1;
  var e = Np(), t = Hr();
  function r(l) {
    return 48 <= l && l <= 57 || 65 <= l && l <= 70 || 97 <= l && l <= 102;
  }
  function n(l) {
    return 48 <= l && l <= 55;
  }
  function i(l) {
    return 48 <= l && l <= 57;
  }
  function s(l) {
    if (l === null) return !1;
    var u = l.length, f = 0, d = !1, m;
    if (!u) return !1;
    if (m = l[f], (m === "-" || m === "+") && (m = l[++f]), m === "0") {
      if (f + 1 === u) return !0;
      if (m = l[++f], m === "b") {
        for (f++; f < u; f++)
          if (m = l[f], m !== "_") {
            if (m !== "0" && m !== "1") return !1;
            d = !0;
          }
        return d && m !== "_";
      }
      if (m === "x") {
        for (f++; f < u; f++)
          if (m = l[f], m !== "_") {
            if (!r(l.charCodeAt(f))) return !1;
            d = !0;
          }
        return d && m !== "_";
      }
      if (m === "o") {
        for (f++; f < u; f++)
          if (m = l[f], m !== "_") {
            if (!n(l.charCodeAt(f))) return !1;
            d = !0;
          }
        return d && m !== "_";
      }
    }
    if (m === "_") return !1;
    for (; f < u; f++)
      if (m = l[f], m !== "_") {
        if (!i(l.charCodeAt(f)))
          return !1;
        d = !0;
      }
    return !(!d || m === "_");
  }
  function o(l) {
    var u = l, f = 1, d;
    if (u.indexOf("_") !== -1 && (u = u.replace(/_/g, "")), d = u[0], (d === "-" || d === "+") && (d === "-" && (f = -1), u = u.slice(1), d = u[0]), u === "0") return 0;
    if (d === "0") {
      if (u[1] === "b") return f * parseInt(u.slice(2), 2);
      if (u[1] === "x") return f * parseInt(u.slice(2), 16);
      if (u[1] === "o") return f * parseInt(u.slice(2), 8);
    }
    return f * parseInt(u, 10);
  }
  function a(l) {
    return Object.prototype.toString.call(l) === "[object Number]" && l % 1 === 0 && !e.isNegativeZero(l);
  }
  return sb = new t("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: s,
    construct: o,
    predicate: a,
    represent: {
      binary: function(l) {
        return l >= 0 ? "0b" + l.toString(2) : "-0b" + l.toString(2).slice(1);
      },
      octal: function(l) {
        return l >= 0 ? "0o" + l.toString(8) : "-0o" + l.toString(8).slice(1);
      },
      decimal: function(l) {
        return l.toString(10);
      },
      /* eslint-disable max-len */
      hexadecimal: function(l) {
        return l >= 0 ? "0x" + l.toString(16).toUpperCase() : "-0x" + l.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  }), sb;
}
var ab, iA;
function Qj() {
  if (iA) return ab;
  iA = 1;
  var e = Np(), t = Hr(), r = new RegExp(
    // 2.5e4, 2.5 and integers
    "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
  );
  function n(l) {
    return !(l === null || !r.test(l) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    l[l.length - 1] === "_");
  }
  function i(l) {
    var u, f;
    return u = l.replace(/_/g, "").toLowerCase(), f = u[0] === "-" ? -1 : 1, "+-".indexOf(u[0]) >= 0 && (u = u.slice(1)), u === ".inf" ? f === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : u === ".nan" ? NaN : f * parseFloat(u, 10);
  }
  var s = /^[-+]?[0-9]+e/;
  function o(l, u) {
    var f;
    if (isNaN(l))
      switch (u) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    else if (Number.POSITIVE_INFINITY === l)
      switch (u) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    else if (Number.NEGATIVE_INFINITY === l)
      switch (u) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    else if (e.isNegativeZero(l))
      return "-0.0";
    return f = l.toString(10), s.test(f) ? f.replace("e", ".e") : f;
  }
  function a(l) {
    return Object.prototype.toString.call(l) === "[object Number]" && (l % 1 !== 0 || e.isNegativeZero(l));
  }
  return ab = new t("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: n,
    construct: i,
    predicate: a,
    represent: o,
    defaultStyle: "lowercase"
  }), ab;
}
var lb, oA;
function Yj() {
  return oA || (oA = 1, lb = Uj().extend({
    implicit: [
      Vj(),
      Wj(),
      Hj(),
      Qj()
    ]
  })), lb;
}
var ub, sA;
function Gj() {
  return sA || (sA = 1, ub = Yj()), ub;
}
var cb, aA;
function Kj() {
  if (aA) return cb;
  aA = 1;
  var e = Hr(), t = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
  ), r = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
  );
  function n(o) {
    return o === null ? !1 : t.exec(o) !== null || r.exec(o) !== null;
  }
  function i(o) {
    var a, l, u, f, d, m, v, S = 0, y = null, E, x, g;
    if (a = t.exec(o), a === null && (a = r.exec(o)), a === null) throw new Error("Date resolve error");
    if (l = +a[1], u = +a[2] - 1, f = +a[3], !a[4])
      return new Date(Date.UTC(l, u, f));
    if (d = +a[4], m = +a[5], v = +a[6], a[7]) {
      for (S = a[7].slice(0, 3); S.length < 3; )
        S += "0";
      S = +S;
    }
    return a[9] && (E = +a[10], x = +(a[11] || 0), y = (E * 60 + x) * 6e4, a[9] === "-" && (y = -y)), g = new Date(Date.UTC(l, u, f, d, m, v, S)), y && g.setTime(g.getTime() - y), g;
  }
  function s(o) {
    return o.toISOString();
  }
  return cb = new e("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: n,
    construct: i,
    instanceOf: Date,
    represent: s
  }), cb;
}
var pb, lA;
function Xj() {
  if (lA) return pb;
  lA = 1;
  var e = Hr();
  function t(r) {
    return r === "<<" || r === null;
  }
  return pb = new e("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: t
  }), pb;
}
var fb, uA;
function Jj() {
  if (uA) return fb;
  uA = 1;
  var e = Hr(), t = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
  function r(o) {
    if (o === null) return !1;
    var a, l, u = 0, f = o.length, d = t;
    for (l = 0; l < f; l++)
      if (a = d.indexOf(o.charAt(l)), !(a > 64)) {
        if (a < 0) return !1;
        u += 6;
      }
    return u % 8 === 0;
  }
  function n(o) {
    var a, l, u = o.replace(/[\r\n=]/g, ""), f = u.length, d = t, m = 0, v = [];
    for (a = 0; a < f; a++)
      a % 4 === 0 && a && (v.push(m >> 16 & 255), v.push(m >> 8 & 255), v.push(m & 255)), m = m << 6 | d.indexOf(u.charAt(a));
    return l = f % 4 * 6, l === 0 ? (v.push(m >> 16 & 255), v.push(m >> 8 & 255), v.push(m & 255)) : l === 18 ? (v.push(m >> 10 & 255), v.push(m >> 2 & 255)) : l === 12 && v.push(m >> 4 & 255), new Uint8Array(v);
  }
  function i(o) {
    var a = "", l = 0, u, f, d = o.length, m = t;
    for (u = 0; u < d; u++)
      u % 3 === 0 && u && (a += m[l >> 18 & 63], a += m[l >> 12 & 63], a += m[l >> 6 & 63], a += m[l & 63]), l = (l << 8) + o[u];
    return f = d % 3, f === 0 ? (a += m[l >> 18 & 63], a += m[l >> 12 & 63], a += m[l >> 6 & 63], a += m[l & 63]) : f === 2 ? (a += m[l >> 10 & 63], a += m[l >> 4 & 63], a += m[l << 2 & 63], a += m[64]) : f === 1 && (a += m[l >> 2 & 63], a += m[l << 4 & 63], a += m[64], a += m[64]), a;
  }
  function s(o) {
    return Object.prototype.toString.call(o) === "[object Uint8Array]";
  }
  return fb = new e("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: r,
    construct: n,
    predicate: s,
    represent: i
  }), fb;
}
var db, cA;
function Zj() {
  if (cA) return db;
  cA = 1;
  var e = Hr(), t = Object.prototype.hasOwnProperty, r = Object.prototype.toString;
  function n(s) {
    if (s === null) return !0;
    var o = [], a, l, u, f, d, m = s;
    for (a = 0, l = m.length; a < l; a += 1) {
      if (u = m[a], d = !1, r.call(u) !== "[object Object]") return !1;
      for (f in u)
        if (t.call(u, f))
          if (!d) d = !0;
          else return !1;
      if (!d) return !1;
      if (o.indexOf(f) === -1) o.push(f);
      else return !1;
    }
    return !0;
  }
  function i(s) {
    return s !== null ? s : [];
  }
  return db = new e("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: n,
    construct: i
  }), db;
}
var hb, pA;
function eL() {
  if (pA) return hb;
  pA = 1;
  var e = Hr(), t = Object.prototype.toString;
  function r(i) {
    if (i === null) return !0;
    var s, o, a, l, u, f = i;
    for (u = new Array(f.length), s = 0, o = f.length; s < o; s += 1) {
      if (a = f[s], t.call(a) !== "[object Object]" || (l = Object.keys(a), l.length !== 1)) return !1;
      u[s] = [l[0], a[l[0]]];
    }
    return !0;
  }
  function n(i) {
    if (i === null) return [];
    var s, o, a, l, u, f = i;
    for (u = new Array(f.length), s = 0, o = f.length; s < o; s += 1)
      a = f[s], l = Object.keys(a), u[s] = [l[0], a[l[0]]];
    return u;
  }
  return hb = new e("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: r,
    construct: n
  }), hb;
}
var mb, fA;
function tL() {
  if (fA) return mb;
  fA = 1;
  var e = Hr(), t = Object.prototype.hasOwnProperty;
  function r(i) {
    if (i === null) return !0;
    var s, o = i;
    for (s in o)
      if (t.call(o, s) && o[s] !== null)
        return !1;
    return !0;
  }
  function n(i) {
    return i !== null ? i : {};
  }
  return mb = new e("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: r,
    construct: n
  }), mb;
}
var gb, dA;
function d1() {
  return dA || (dA = 1, gb = Gj().extend({
    implicit: [
      Kj(),
      Xj()
    ],
    explicit: [
      Jj(),
      Zj(),
      eL(),
      tL()
    ]
  })), gb;
}
var hA;
function T9() {
  if (hA) return Sd;
  hA = 1;
  var e = Np(), t = jp(), r = P9(), n = d1(), i = Object.prototype.hasOwnProperty, s = 1, o = 2, a = 3, l = 4, u = 1, f = 2, d = 3, m = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, v = /[\x85\u2028\u2029]/, S = /[,\[\]\{\}]/, y = /^(?:!|!!|![a-z\-]+!)$/i, E = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function x(O) {
    return Object.prototype.toString.call(O);
  }
  function g(O) {
    return O === 10 || O === 13;
  }
  function b(O) {
    return O === 9 || O === 32;
  }
  function A(O) {
    return O === 9 || O === 32 || O === 10 || O === 13;
  }
  function P(O) {
    return O === 44 || O === 91 || O === 93 || O === 123 || O === 125;
  }
  function k(O) {
    var M;
    return 48 <= O && O <= 57 ? O - 48 : (M = O | 32, 97 <= M && M <= 102 ? M - 97 + 10 : -1);
  }
  function $(O) {
    return O === 120 ? 2 : O === 117 ? 4 : O === 85 ? 8 : 0;
  }
  function I(O) {
    return 48 <= O && O <= 57 ? O - 48 : -1;
  }
  function F(O) {
    return O === 48 ? "\0" : O === 97 ? "\x07" : O === 98 ? "\b" : O === 116 || O === 9 ? "	" : O === 110 ? `
` : O === 118 ? "\v" : O === 102 ? "\f" : O === 114 ? "\r" : O === 101 ? "\x1B" : O === 32 ? " " : O === 34 ? '"' : O === 47 ? "/" : O === 92 ? "\\" : O === 78 ? "" : O === 95 ? "" : O === 76 ? "\u2028" : O === 80 ? "\u2029" : "";
  }
  function L(O) {
    return O <= 65535 ? String.fromCharCode(O) : String.fromCharCode(
      (O - 65536 >> 10) + 55296,
      (O - 65536 & 1023) + 56320
    );
  }
  for (var Q = new Array(256), Y = new Array(256), ae = 0; ae < 256; ae++)
    Q[ae] = F(ae) ? 1 : 0, Y[ae] = F(ae);
  function le(O, M) {
    this.input = O, this.filename = M.filename || null, this.schema = M.schema || n, this.onWarning = M.onWarning || null, this.legacy = M.legacy || !1, this.json = M.json || !1, this.listener = M.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = O.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
  }
  function ue(O, M) {
    var se = {
      name: O.filename,
      buffer: O.input.slice(0, -1),
      // omit trailing \0
      position: O.position,
      line: O.line,
      column: O.position - O.lineStart
    };
    return se.snippet = r(se), new t(M, se);
  }
  function ce(O, M) {
    throw ue(O, M);
  }
  function be(O, M) {
    O.onWarning && O.onWarning.call(null, ue(O, M));
  }
  var G = {
    YAML: function(M, se, ve) {
      var ge, Oe, ke;
      M.version !== null && ce(M, "duplication of %YAML directive"), ve.length !== 1 && ce(M, "YAML directive accepts exactly one argument"), ge = /^([0-9]+)\.([0-9]+)$/.exec(ve[0]), ge === null && ce(M, "ill-formed argument of the YAML directive"), Oe = parseInt(ge[1], 10), ke = parseInt(ge[2], 10), Oe !== 1 && ce(M, "unacceptable YAML version of the document"), M.version = ve[0], M.checkLineBreaks = ke < 2, ke !== 1 && ke !== 2 && be(M, "unsupported YAML version of the document");
    },
    TAG: function(M, se, ve) {
      var ge, Oe;
      ve.length !== 2 && ce(M, "TAG directive accepts exactly two arguments"), ge = ve[0], Oe = ve[1], y.test(ge) || ce(M, "ill-formed tag handle (first argument) of the TAG directive"), i.call(M.tagMap, ge) && ce(M, 'there is a previously declared suffix for "' + ge + '" tag handle'), E.test(Oe) || ce(M, "ill-formed tag prefix (second argument) of the TAG directive");
      try {
        Oe = decodeURIComponent(Oe);
      } catch {
        ce(M, "tag prefix is malformed: " + Oe);
      }
      M.tagMap[ge] = Oe;
    }
  };
  function ee(O, M, se, ve) {
    var ge, Oe, ke, Me;
    if (M < se) {
      if (Me = O.input.slice(M, se), ve)
        for (ge = 0, Oe = Me.length; ge < Oe; ge += 1)
          ke = Me.charCodeAt(ge), ke === 9 || 32 <= ke && ke <= 1114111 || ce(O, "expected valid JSON character");
      else m.test(Me) && ce(O, "the stream contains non-printable characters");
      O.result += Me;
    }
  }
  function K(O, M, se, ve) {
    var ge, Oe, ke, Me;
    for (e.isObject(se) || ce(O, "cannot merge mappings; the provided source object is unacceptable"), ge = Object.keys(se), ke = 0, Me = ge.length; ke < Me; ke += 1)
      Oe = ge[ke], i.call(M, Oe) || (M[Oe] = se[Oe], ve[Oe] = !0);
  }
  function z(O, M, se, ve, ge, Oe, ke, Me, Ve) {
    var Je, He;
    if (Array.isArray(ge))
      for (ge = Array.prototype.slice.call(ge), Je = 0, He = ge.length; Je < He; Je += 1)
        Array.isArray(ge[Je]) && ce(O, "nested arrays are not supported inside keys"), typeof ge == "object" && x(ge[Je]) === "[object Object]" && (ge[Je] = "[object Object]");
    if (typeof ge == "object" && x(ge) === "[object Object]" && (ge = "[object Object]"), ge = String(ge), M === null && (M = {}), ve === "tag:yaml.org,2002:merge")
      if (Array.isArray(Oe))
        for (Je = 0, He = Oe.length; Je < He; Je += 1)
          K(O, M, Oe[Je], se);
      else
        K(O, M, Oe, se);
    else
      !O.json && !i.call(se, ge) && i.call(M, ge) && (O.line = ke || O.line, O.lineStart = Me || O.lineStart, O.position = Ve || O.position, ce(O, "duplicated mapping key")), ge === "__proto__" ? Object.defineProperty(M, ge, {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        value: Oe
      }) : M[ge] = Oe, delete se[ge];
    return M;
  }
  function te(O) {
    var M;
    M = O.input.charCodeAt(O.position), M === 10 ? O.position++ : M === 13 ? (O.position++, O.input.charCodeAt(O.position) === 10 && O.position++) : ce(O, "a line break is expected"), O.line += 1, O.lineStart = O.position, O.firstTabInLine = -1;
  }
  function q(O, M, se) {
    for (var ve = 0, ge = O.input.charCodeAt(O.position); ge !== 0; ) {
      for (; b(ge); )
        ge === 9 && O.firstTabInLine === -1 && (O.firstTabInLine = O.position), ge = O.input.charCodeAt(++O.position);
      if (M && ge === 35)
        do
          ge = O.input.charCodeAt(++O.position);
        while (ge !== 10 && ge !== 13 && ge !== 0);
      if (g(ge))
        for (te(O), ge = O.input.charCodeAt(O.position), ve++, O.lineIndent = 0; ge === 32; )
          O.lineIndent++, ge = O.input.charCodeAt(++O.position);
      else
        break;
    }
    return se !== -1 && ve !== 0 && O.lineIndent < se && be(O, "deficient indentation"), ve;
  }
  function j(O) {
    var M = O.position, se;
    return se = O.input.charCodeAt(M), !!((se === 45 || se === 46) && se === O.input.charCodeAt(M + 1) && se === O.input.charCodeAt(M + 2) && (M += 3, se = O.input.charCodeAt(M), se === 0 || A(se)));
  }
  function H(O, M) {
    M === 1 ? O.result += " " : M > 1 && (O.result += e.repeat(`
`, M - 1));
  }
  function B(O, M, se) {
    var ve, ge, Oe, ke, Me, Ve, Je, He, Ue = O.kind, Ot = O.result, D;
    if (D = O.input.charCodeAt(O.position), A(D) || P(D) || D === 35 || D === 38 || D === 42 || D === 33 || D === 124 || D === 62 || D === 39 || D === 34 || D === 37 || D === 64 || D === 96 || (D === 63 || D === 45) && (ge = O.input.charCodeAt(O.position + 1), A(ge) || se && P(ge)))
      return !1;
    for (O.kind = "scalar", O.result = "", Oe = ke = O.position, Me = !1; D !== 0; ) {
      if (D === 58) {
        if (ge = O.input.charCodeAt(O.position + 1), A(ge) || se && P(ge))
          break;
      } else if (D === 35) {
        if (ve = O.input.charCodeAt(O.position - 1), A(ve))
          break;
      } else {
        if (O.position === O.lineStart && j(O) || se && P(D))
          break;
        if (g(D))
          if (Ve = O.line, Je = O.lineStart, He = O.lineIndent, q(O, !1, -1), O.lineIndent >= M) {
            Me = !0, D = O.input.charCodeAt(O.position);
            continue;
          } else {
            O.position = ke, O.line = Ve, O.lineStart = Je, O.lineIndent = He;
            break;
          }
      }
      Me && (ee(O, Oe, ke, !1), H(O, O.line - Ve), Oe = ke = O.position, Me = !1), b(D) || (ke = O.position + 1), D = O.input.charCodeAt(++O.position);
    }
    return ee(O, Oe, ke, !1), O.result ? !0 : (O.kind = Ue, O.result = Ot, !1);
  }
  function pe(O, M) {
    var se, ve, ge;
    if (se = O.input.charCodeAt(O.position), se !== 39)
      return !1;
    for (O.kind = "scalar", O.result = "", O.position++, ve = ge = O.position; (se = O.input.charCodeAt(O.position)) !== 0; )
      if (se === 39)
        if (ee(O, ve, O.position, !0), se = O.input.charCodeAt(++O.position), se === 39)
          ve = O.position, O.position++, ge = O.position;
        else
          return !0;
      else g(se) ? (ee(O, ve, ge, !0), H(O, q(O, !1, M)), ve = ge = O.position) : O.position === O.lineStart && j(O) ? ce(O, "unexpected end of the document within a single quoted scalar") : (O.position++, ge = O.position);
    ce(O, "unexpected end of the stream within a single quoted scalar");
  }
  function he(O, M) {
    var se, ve, ge, Oe, ke, Me;
    if (Me = O.input.charCodeAt(O.position), Me !== 34)
      return !1;
    for (O.kind = "scalar", O.result = "", O.position++, se = ve = O.position; (Me = O.input.charCodeAt(O.position)) !== 0; ) {
      if (Me === 34)
        return ee(O, se, O.position, !0), O.position++, !0;
      if (Me === 92) {
        if (ee(O, se, O.position, !0), Me = O.input.charCodeAt(++O.position), g(Me))
          q(O, !1, M);
        else if (Me < 256 && Q[Me])
          O.result += Y[Me], O.position++;
        else if ((ke = $(Me)) > 0) {
          for (ge = ke, Oe = 0; ge > 0; ge--)
            Me = O.input.charCodeAt(++O.position), (ke = k(Me)) >= 0 ? Oe = (Oe << 4) + ke : ce(O, "expected hexadecimal character");
          O.result += L(Oe), O.position++;
        } else
          ce(O, "unknown escape sequence");
        se = ve = O.position;
      } else g(Me) ? (ee(O, se, ve, !0), H(O, q(O, !1, M)), se = ve = O.position) : O.position === O.lineStart && j(O) ? ce(O, "unexpected end of the document within a double quoted scalar") : (O.position++, ve = O.position);
    }
    ce(O, "unexpected end of the stream within a double quoted scalar");
  }
  function Ae(O, M) {
    var se = !0, ve, ge, Oe, ke = O.tag, Me, Ve = O.anchor, Je, He, Ue, Ot, D, we = /* @__PURE__ */ Object.create(null), Ee, _e, Te, $e;
    if ($e = O.input.charCodeAt(O.position), $e === 91)
      He = 93, D = !1, Me = [];
    else if ($e === 123)
      He = 125, D = !0, Me = {};
    else
      return !1;
    for (O.anchor !== null && (O.anchorMap[O.anchor] = Me), $e = O.input.charCodeAt(++O.position); $e !== 0; ) {
      if (q(O, !0, M), $e = O.input.charCodeAt(O.position), $e === He)
        return O.position++, O.tag = ke, O.anchor = Ve, O.kind = D ? "mapping" : "sequence", O.result = Me, !0;
      se ? $e === 44 && ce(O, "expected the node content, but found ','") : ce(O, "missed comma between flow collection entries"), _e = Ee = Te = null, Ue = Ot = !1, $e === 63 && (Je = O.input.charCodeAt(O.position + 1), A(Je) && (Ue = Ot = !0, O.position++, q(O, !0, M))), ve = O.line, ge = O.lineStart, Oe = O.position, V(O, M, s, !1, !0), _e = O.tag, Ee = O.result, q(O, !0, M), $e = O.input.charCodeAt(O.position), (Ot || O.line === ve) && $e === 58 && (Ue = !0, $e = O.input.charCodeAt(++O.position), q(O, !0, M), V(O, M, s, !1, !0), Te = O.result), D ? z(O, Me, we, _e, Ee, Te, ve, ge, Oe) : Ue ? Me.push(z(O, null, we, _e, Ee, Te, ve, ge, Oe)) : Me.push(Ee), q(O, !0, M), $e = O.input.charCodeAt(O.position), $e === 44 ? (se = !0, $e = O.input.charCodeAt(++O.position)) : se = !1;
    }
    ce(O, "unexpected end of the stream within a flow collection");
  }
  function C(O, M) {
    var se, ve, ge = u, Oe = !1, ke = !1, Me = M, Ve = 0, Je = !1, He, Ue;
    if (Ue = O.input.charCodeAt(O.position), Ue === 124)
      ve = !1;
    else if (Ue === 62)
      ve = !0;
    else
      return !1;
    for (O.kind = "scalar", O.result = ""; Ue !== 0; )
      if (Ue = O.input.charCodeAt(++O.position), Ue === 43 || Ue === 45)
        u === ge ? ge = Ue === 43 ? d : f : ce(O, "repeat of a chomping mode identifier");
      else if ((He = I(Ue)) >= 0)
        He === 0 ? ce(O, "bad explicit indentation width of a block scalar; it cannot be less than one") : ke ? ce(O, "repeat of an indentation width identifier") : (Me = M + He - 1, ke = !0);
      else
        break;
    if (b(Ue)) {
      do
        Ue = O.input.charCodeAt(++O.position);
      while (b(Ue));
      if (Ue === 35)
        do
          Ue = O.input.charCodeAt(++O.position);
        while (!g(Ue) && Ue !== 0);
    }
    for (; Ue !== 0; ) {
      for (te(O), O.lineIndent = 0, Ue = O.input.charCodeAt(O.position); (!ke || O.lineIndent < Me) && Ue === 32; )
        O.lineIndent++, Ue = O.input.charCodeAt(++O.position);
      if (!ke && O.lineIndent > Me && (Me = O.lineIndent), g(Ue)) {
        Ve++;
        continue;
      }
      if (O.lineIndent < Me) {
        ge === d ? O.result += e.repeat(`
`, Oe ? 1 + Ve : Ve) : ge === u && Oe && (O.result += `
`);
        break;
      }
      for (ve ? b(Ue) ? (Je = !0, O.result += e.repeat(`
`, Oe ? 1 + Ve : Ve)) : Je ? (Je = !1, O.result += e.repeat(`
`, Ve + 1)) : Ve === 0 ? Oe && (O.result += " ") : O.result += e.repeat(`
`, Ve) : O.result += e.repeat(`
`, Oe ? 1 + Ve : Ve), Oe = !0, ke = !0, Ve = 0, se = O.position; !g(Ue) && Ue !== 0; )
        Ue = O.input.charCodeAt(++O.position);
      ee(O, se, O.position, !1);
    }
    return !0;
  }
  function N(O, M) {
    var se, ve = O.tag, ge = O.anchor, Oe = [], ke, Me = !1, Ve;
    if (O.firstTabInLine !== -1) return !1;
    for (O.anchor !== null && (O.anchorMap[O.anchor] = Oe), Ve = O.input.charCodeAt(O.position); Ve !== 0 && (O.firstTabInLine !== -1 && (O.position = O.firstTabInLine, ce(O, "tab characters must not be used in indentation")), !(Ve !== 45 || (ke = O.input.charCodeAt(O.position + 1), !A(ke)))); ) {
      if (Me = !0, O.position++, q(O, !0, -1) && O.lineIndent <= M) {
        Oe.push(null), Ve = O.input.charCodeAt(O.position);
        continue;
      }
      if (se = O.line, V(O, M, a, !1, !0), Oe.push(O.result), q(O, !0, -1), Ve = O.input.charCodeAt(O.position), (O.line === se || O.lineIndent > M) && Ve !== 0)
        ce(O, "bad indentation of a sequence entry");
      else if (O.lineIndent < M)
        break;
    }
    return Me ? (O.tag = ve, O.anchor = ge, O.kind = "sequence", O.result = Oe, !0) : !1;
  }
  function J(O, M, se) {
    var ve, ge, Oe, ke, Me, Ve, Je = O.tag, He = O.anchor, Ue = {}, Ot = /* @__PURE__ */ Object.create(null), D = null, we = null, Ee = null, _e = !1, Te = !1, $e;
    if (O.firstTabInLine !== -1) return !1;
    for (O.anchor !== null && (O.anchorMap[O.anchor] = Ue), $e = O.input.charCodeAt(O.position); $e !== 0; ) {
      if (!_e && O.firstTabInLine !== -1 && (O.position = O.firstTabInLine, ce(O, "tab characters must not be used in indentation")), ve = O.input.charCodeAt(O.position + 1), Oe = O.line, ($e === 63 || $e === 58) && A(ve))
        $e === 63 ? (_e && (z(O, Ue, Ot, D, we, null, ke, Me, Ve), D = we = Ee = null), Te = !0, _e = !0, ge = !0) : _e ? (_e = !1, ge = !0) : ce(O, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), O.position += 1, $e = ve;
      else {
        if (ke = O.line, Me = O.lineStart, Ve = O.position, !V(O, se, o, !1, !0))
          break;
        if (O.line === Oe) {
          for ($e = O.input.charCodeAt(O.position); b($e); )
            $e = O.input.charCodeAt(++O.position);
          if ($e === 58)
            $e = O.input.charCodeAt(++O.position), A($e) || ce(O, "a whitespace character is expected after the key-value separator within a block mapping"), _e && (z(O, Ue, Ot, D, we, null, ke, Me, Ve), D = we = Ee = null), Te = !0, _e = !1, ge = !1, D = O.tag, we = O.result;
          else if (Te)
            ce(O, "can not read an implicit mapping pair; a colon is missed");
          else
            return O.tag = Je, O.anchor = He, !0;
        } else if (Te)
          ce(O, "can not read a block mapping entry; a multiline key may not be an implicit key");
        else
          return O.tag = Je, O.anchor = He, !0;
      }
      if ((O.line === Oe || O.lineIndent > M) && (_e && (ke = O.line, Me = O.lineStart, Ve = O.position), V(O, M, l, !0, ge) && (_e ? we = O.result : Ee = O.result), _e || (z(O, Ue, Ot, D, we, Ee, ke, Me, Ve), D = we = Ee = null), q(O, !0, -1), $e = O.input.charCodeAt(O.position)), (O.line === Oe || O.lineIndent > M) && $e !== 0)
        ce(O, "bad indentation of a mapping entry");
      else if (O.lineIndent < M)
        break;
    }
    return _e && z(O, Ue, Ot, D, we, null, ke, Me, Ve), Te && (O.tag = Je, O.anchor = He, O.kind = "mapping", O.result = Ue), Te;
  }
  function X(O) {
    var M, se = !1, ve = !1, ge, Oe, ke;
    if (ke = O.input.charCodeAt(O.position), ke !== 33) return !1;
    if (O.tag !== null && ce(O, "duplication of a tag property"), ke = O.input.charCodeAt(++O.position), ke === 60 ? (se = !0, ke = O.input.charCodeAt(++O.position)) : ke === 33 ? (ve = !0, ge = "!!", ke = O.input.charCodeAt(++O.position)) : ge = "!", M = O.position, se) {
      do
        ke = O.input.charCodeAt(++O.position);
      while (ke !== 0 && ke !== 62);
      O.position < O.length ? (Oe = O.input.slice(M, O.position), ke = O.input.charCodeAt(++O.position)) : ce(O, "unexpected end of the stream within a verbatim tag");
    } else {
      for (; ke !== 0 && !A(ke); )
        ke === 33 && (ve ? ce(O, "tag suffix cannot contain exclamation marks") : (ge = O.input.slice(M - 1, O.position + 1), y.test(ge) || ce(O, "named tag handle cannot contain such characters"), ve = !0, M = O.position + 1)), ke = O.input.charCodeAt(++O.position);
      Oe = O.input.slice(M, O.position), S.test(Oe) && ce(O, "tag suffix cannot contain flow indicator characters");
    }
    Oe && !E.test(Oe) && ce(O, "tag name cannot contain such characters: " + Oe);
    try {
      Oe = decodeURIComponent(Oe);
    } catch {
      ce(O, "tag name is malformed: " + Oe);
    }
    return se ? O.tag = Oe : i.call(O.tagMap, ge) ? O.tag = O.tagMap[ge] + Oe : ge === "!" ? O.tag = "!" + Oe : ge === "!!" ? O.tag = "tag:yaml.org,2002:" + Oe : ce(O, 'undeclared tag handle "' + ge + '"'), !0;
  }
  function oe(O) {
    var M, se;
    if (se = O.input.charCodeAt(O.position), se !== 38) return !1;
    for (O.anchor !== null && ce(O, "duplication of an anchor property"), se = O.input.charCodeAt(++O.position), M = O.position; se !== 0 && !A(se) && !P(se); )
      se = O.input.charCodeAt(++O.position);
    return O.position === M && ce(O, "name of an anchor node must contain at least one character"), O.anchor = O.input.slice(M, O.position), !0;
  }
  function U(O) {
    var M, se, ve;
    if (ve = O.input.charCodeAt(O.position), ve !== 42) return !1;
    for (ve = O.input.charCodeAt(++O.position), M = O.position; ve !== 0 && !A(ve) && !P(ve); )
      ve = O.input.charCodeAt(++O.position);
    return O.position === M && ce(O, "name of an alias node must contain at least one character"), se = O.input.slice(M, O.position), i.call(O.anchorMap, se) || ce(O, 'unidentified alias "' + se + '"'), O.result = O.anchorMap[se], q(O, !0, -1), !0;
  }
  function V(O, M, se, ve, ge) {
    var Oe, ke, Me, Ve = 1, Je = !1, He = !1, Ue, Ot, D, we, Ee, _e;
    if (O.listener !== null && O.listener("open", O), O.tag = null, O.anchor = null, O.kind = null, O.result = null, Oe = ke = Me = l === se || a === se, ve && q(O, !0, -1) && (Je = !0, O.lineIndent > M ? Ve = 1 : O.lineIndent === M ? Ve = 0 : O.lineIndent < M && (Ve = -1)), Ve === 1)
      for (; X(O) || oe(O); )
        q(O, !0, -1) ? (Je = !0, Me = Oe, O.lineIndent > M ? Ve = 1 : O.lineIndent === M ? Ve = 0 : O.lineIndent < M && (Ve = -1)) : Me = !1;
    if (Me && (Me = Je || ge), (Ve === 1 || l === se) && (s === se || o === se ? Ee = M : Ee = M + 1, _e = O.position - O.lineStart, Ve === 1 ? Me && (N(O, _e) || J(O, _e, Ee)) || Ae(O, Ee) ? He = !0 : (ke && C(O, Ee) || pe(O, Ee) || he(O, Ee) ? He = !0 : U(O) ? (He = !0, (O.tag !== null || O.anchor !== null) && ce(O, "alias node should not have any properties")) : B(O, Ee, s === se) && (He = !0, O.tag === null && (O.tag = "?")), O.anchor !== null && (O.anchorMap[O.anchor] = O.result)) : Ve === 0 && (He = Me && N(O, _e))), O.tag === null)
      O.anchor !== null && (O.anchorMap[O.anchor] = O.result);
    else if (O.tag === "?") {
      for (O.result !== null && O.kind !== "scalar" && ce(O, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + O.kind + '"'), Ue = 0, Ot = O.implicitTypes.length; Ue < Ot; Ue += 1)
        if (we = O.implicitTypes[Ue], we.resolve(O.result)) {
          O.result = we.construct(O.result), O.tag = we.tag, O.anchor !== null && (O.anchorMap[O.anchor] = O.result);
          break;
        }
    } else if (O.tag !== "!") {
      if (i.call(O.typeMap[O.kind || "fallback"], O.tag))
        we = O.typeMap[O.kind || "fallback"][O.tag];
      else
        for (we = null, D = O.typeMap.multi[O.kind || "fallback"], Ue = 0, Ot = D.length; Ue < Ot; Ue += 1)
          if (O.tag.slice(0, D[Ue].tag.length) === D[Ue].tag) {
            we = D[Ue];
            break;
          }
      we || ce(O, "unknown tag !<" + O.tag + ">"), O.result !== null && we.kind !== O.kind && ce(O, "unacceptable node kind for !<" + O.tag + '> tag; it should be "' + we.kind + '", not "' + O.kind + '"'), we.resolve(O.result, O.tag) ? (O.result = we.construct(O.result, O.tag), O.anchor !== null && (O.anchorMap[O.anchor] = O.result)) : ce(O, "cannot resolve a node with !<" + O.tag + "> explicit tag");
    }
    return O.listener !== null && O.listener("close", O), O.tag !== null || O.anchor !== null || He;
  }
  function ye(O) {
    var M = O.position, se, ve, ge, Oe = !1, ke;
    for (O.version = null, O.checkLineBreaks = O.legacy, O.tagMap = /* @__PURE__ */ Object.create(null), O.anchorMap = /* @__PURE__ */ Object.create(null); (ke = O.input.charCodeAt(O.position)) !== 0 && (q(O, !0, -1), ke = O.input.charCodeAt(O.position), !(O.lineIndent > 0 || ke !== 37)); ) {
      for (Oe = !0, ke = O.input.charCodeAt(++O.position), se = O.position; ke !== 0 && !A(ke); )
        ke = O.input.charCodeAt(++O.position);
      for (ve = O.input.slice(se, O.position), ge = [], ve.length < 1 && ce(O, "directive name must not be less than one character in length"); ke !== 0; ) {
        for (; b(ke); )
          ke = O.input.charCodeAt(++O.position);
        if (ke === 35) {
          do
            ke = O.input.charCodeAt(++O.position);
          while (ke !== 0 && !g(ke));
          break;
        }
        if (g(ke)) break;
        for (se = O.position; ke !== 0 && !A(ke); )
          ke = O.input.charCodeAt(++O.position);
        ge.push(O.input.slice(se, O.position));
      }
      ke !== 0 && te(O), i.call(G, ve) ? G[ve](O, ve, ge) : be(O, 'unknown document directive "' + ve + '"');
    }
    if (q(O, !0, -1), O.lineIndent === 0 && O.input.charCodeAt(O.position) === 45 && O.input.charCodeAt(O.position + 1) === 45 && O.input.charCodeAt(O.position + 2) === 45 ? (O.position += 3, q(O, !0, -1)) : Oe && ce(O, "directives end mark is expected"), V(O, O.lineIndent - 1, l, !1, !0), q(O, !0, -1), O.checkLineBreaks && v.test(O.input.slice(M, O.position)) && be(O, "non-ASCII line breaks are interpreted as content"), O.documents.push(O.result), O.position === O.lineStart && j(O)) {
      O.input.charCodeAt(O.position) === 46 && (O.position += 3, q(O, !0, -1));
      return;
    }
    if (O.position < O.length - 1)
      ce(O, "end of the stream or a document separator is expected");
    else
      return;
  }
  function de(O, M) {
    O = String(O), M = M || {}, O.length !== 0 && (O.charCodeAt(O.length - 1) !== 10 && O.charCodeAt(O.length - 1) !== 13 && (O += `
`), O.charCodeAt(0) === 65279 && (O = O.slice(1)));
    var se = new le(O, M), ve = O.indexOf("\0");
    for (ve !== -1 && (se.position = ve, ce(se, "null byte is not allowed in input")), se.input += "\0"; se.input.charCodeAt(se.position) === 32; )
      se.lineIndent += 1, se.position += 1;
    for (; se.position < se.length - 1; )
      ye(se);
    return se.documents;
  }
  function Ce(O, M, se) {
    M !== null && typeof M == "object" && typeof se > "u" && (se = M, M = null);
    var ve = de(O, se);
    if (typeof M != "function")
      return ve;
    for (var ge = 0, Oe = ve.length; ge < Oe; ge += 1)
      M(ve[ge]);
  }
  function Se(O, M) {
    var se = de(O, M);
    if (se.length !== 0) {
      if (se.length === 1)
        return se[0];
      throw new t("expected a single document in the stream, but found more");
    }
  }
  return Sd.loadAll = Ce, Sd.load = Se, Sd;
}
var yb = {}, mA;
function C9() {
  if (mA) return yb;
  mA = 1;
  var e = Np(), t = jp(), r = d1(), n = Object.prototype.toString, i = Object.prototype.hasOwnProperty, s = 65279, o = 9, a = 10, l = 13, u = 32, f = 33, d = 34, m = 35, v = 37, S = 38, y = 39, E = 42, x = 44, g = 45, b = 58, A = 61, P = 62, k = 63, $ = 64, I = 91, F = 93, L = 96, Q = 123, Y = 124, ae = 125, le = {};
  le[0] = "\\0", le[7] = "\\a", le[8] = "\\b", le[9] = "\\t", le[10] = "\\n", le[11] = "\\v", le[12] = "\\f", le[13] = "\\r", le[27] = "\\e", le[34] = '\\"', le[92] = "\\\\", le[133] = "\\N", le[160] = "\\_", le[8232] = "\\L", le[8233] = "\\P";
  var ue = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ], ce = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
  function be(D, we) {
    var Ee, _e, Te, $e, Be, Pe, Re;
    if (we === null) return {};
    for (Ee = {}, _e = Object.keys(we), Te = 0, $e = _e.length; Te < $e; Te += 1)
      Be = _e[Te], Pe = String(we[Be]), Be.slice(0, 2) === "!!" && (Be = "tag:yaml.org,2002:" + Be.slice(2)), Re = D.compiledTypeMap.fallback[Be], Re && i.call(Re.styleAliases, Pe) && (Pe = Re.styleAliases[Pe]), Ee[Be] = Pe;
    return Ee;
  }
  function G(D) {
    var we, Ee, _e;
    if (we = D.toString(16).toUpperCase(), D <= 255)
      Ee = "x", _e = 2;
    else if (D <= 65535)
      Ee = "u", _e = 4;
    else if (D <= 4294967295)
      Ee = "U", _e = 8;
    else
      throw new t("code point within a string may not be greater than 0xFFFFFFFF");
    return "\\" + Ee + e.repeat("0", _e - we.length) + we;
  }
  var ee = 1, K = 2;
  function z(D) {
    this.schema = D.schema || r, this.indent = Math.max(1, D.indent || 2), this.noArrayIndent = D.noArrayIndent || !1, this.skipInvalid = D.skipInvalid || !1, this.flowLevel = e.isNothing(D.flowLevel) ? -1 : D.flowLevel, this.styleMap = be(this.schema, D.styles || null), this.sortKeys = D.sortKeys || !1, this.lineWidth = D.lineWidth || 80, this.noRefs = D.noRefs || !1, this.noCompatMode = D.noCompatMode || !1, this.condenseFlow = D.condenseFlow || !1, this.quotingType = D.quotingType === '"' ? K : ee, this.forceQuotes = D.forceQuotes || !1, this.replacer = typeof D.replacer == "function" ? D.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
  }
  function te(D, we) {
    for (var Ee = e.repeat(" ", we), _e = 0, Te = -1, $e = "", Be, Pe = D.length; _e < Pe; )
      Te = D.indexOf(`
`, _e), Te === -1 ? (Be = D.slice(_e), _e = Pe) : (Be = D.slice(_e, Te + 1), _e = Te + 1), Be.length && Be !== `
` && ($e += Ee), $e += Be;
    return $e;
  }
  function q(D, we) {
    return `
` + e.repeat(" ", D.indent * we);
  }
  function j(D, we) {
    var Ee, _e, Te;
    for (Ee = 0, _e = D.implicitTypes.length; Ee < _e; Ee += 1)
      if (Te = D.implicitTypes[Ee], Te.resolve(we))
        return !0;
    return !1;
  }
  function H(D) {
    return D === u || D === o;
  }
  function B(D) {
    return 32 <= D && D <= 126 || 161 <= D && D <= 55295 && D !== 8232 && D !== 8233 || 57344 <= D && D <= 65533 && D !== s || 65536 <= D && D <= 1114111;
  }
  function pe(D) {
    return B(D) && D !== s && D !== l && D !== a;
  }
  function he(D, we, Ee) {
    var _e = pe(D), Te = _e && !H(D);
    return (
      // ns-plain-safe
      (Ee ? (
        // c = flow-in
        _e
      ) : _e && D !== x && D !== I && D !== F && D !== Q && D !== ae) && D !== m && !(we === b && !Te) || pe(we) && !H(we) && D === m || we === b && Te
    );
  }
  function Ae(D) {
    return B(D) && D !== s && !H(D) && D !== g && D !== k && D !== b && D !== x && D !== I && D !== F && D !== Q && D !== ae && D !== m && D !== S && D !== E && D !== f && D !== Y && D !== A && D !== P && D !== y && D !== d && D !== v && D !== $ && D !== L;
  }
  function C(D) {
    return !H(D) && D !== b;
  }
  function N(D, we) {
    var Ee = D.charCodeAt(we), _e;
    return Ee >= 55296 && Ee <= 56319 && we + 1 < D.length && (_e = D.charCodeAt(we + 1), _e >= 56320 && _e <= 57343) ? (Ee - 55296) * 1024 + _e - 56320 + 65536 : Ee;
  }
  function J(D) {
    var we = /^\n* /;
    return we.test(D);
  }
  var X = 1, oe = 2, U = 3, V = 4, ye = 5;
  function de(D, we, Ee, _e, Te, $e, Be, Pe) {
    var Re, Qe = 0, ht = null, rt = !1, ut = !1, yt = _e !== -1, zn = -1, qt = Ae(N(D, 0)) && C(N(D, D.length - 1));
    if (we || Be)
      for (Re = 0; Re < D.length; Qe >= 65536 ? Re += 2 : Re++) {
        if (Qe = N(D, Re), !B(Qe))
          return ye;
        qt = qt && he(Qe, ht, Pe), ht = Qe;
      }
    else {
      for (Re = 0; Re < D.length; Qe >= 65536 ? Re += 2 : Re++) {
        if (Qe = N(D, Re), Qe === a)
          rt = !0, yt && (ut = ut || // Foldable line = too long, and not more-indented.
          Re - zn - 1 > _e && D[zn + 1] !== " ", zn = Re);
        else if (!B(Qe))
          return ye;
        qt = qt && he(Qe, ht, Pe), ht = Qe;
      }
      ut = ut || yt && Re - zn - 1 > _e && D[zn + 1] !== " ";
    }
    return !rt && !ut ? qt && !Be && !Te(D) ? X : $e === K ? ye : oe : Ee > 9 && J(D) ? ye : Be ? $e === K ? ye : oe : ut ? V : U;
  }
  function Ce(D, we, Ee, _e, Te) {
    D.dump = function() {
      if (we.length === 0)
        return D.quotingType === K ? '""' : "''";
      if (!D.noCompatMode && (ue.indexOf(we) !== -1 || ce.test(we)))
        return D.quotingType === K ? '"' + we + '"' : "'" + we + "'";
      var $e = D.indent * Math.max(1, Ee), Be = D.lineWidth === -1 ? -1 : Math.max(Math.min(D.lineWidth, 40), D.lineWidth - $e), Pe = _e || D.flowLevel > -1 && Ee >= D.flowLevel;
      function Re(Qe) {
        return j(D, Qe);
      }
      switch (de(
        we,
        Pe,
        D.indent,
        Be,
        Re,
        D.quotingType,
        D.forceQuotes && !_e,
        Te
      )) {
        case X:
          return we;
        case oe:
          return "'" + we.replace(/'/g, "''") + "'";
        case U:
          return "|" + Se(we, D.indent) + O(te(we, $e));
        case V:
          return ">" + Se(we, D.indent) + O(te(M(we, Be), $e));
        case ye:
          return '"' + ve(we) + '"';
        default:
          throw new t("impossible error: invalid scalar style");
      }
    }();
  }
  function Se(D, we) {
    var Ee = J(D) ? String(we) : "", _e = D[D.length - 1] === `
`, Te = _e && (D[D.length - 2] === `
` || D === `
`), $e = Te ? "+" : _e ? "" : "-";
    return Ee + $e + `
`;
  }
  function O(D) {
    return D[D.length - 1] === `
` ? D.slice(0, -1) : D;
  }
  function M(D, we) {
    for (var Ee = /(\n+)([^\n]*)/g, _e = function() {
      var Qe = D.indexOf(`
`);
      return Qe = Qe !== -1 ? Qe : D.length, Ee.lastIndex = Qe, se(D.slice(0, Qe), we);
    }(), Te = D[0] === `
` || D[0] === " ", $e, Be; Be = Ee.exec(D); ) {
      var Pe = Be[1], Re = Be[2];
      $e = Re[0] === " ", _e += Pe + (!Te && !$e && Re !== "" ? `
` : "") + se(Re, we), Te = $e;
    }
    return _e;
  }
  function se(D, we) {
    if (D === "" || D[0] === " ") return D;
    for (var Ee = / [^ ]/g, _e, Te = 0, $e, Be = 0, Pe = 0, Re = ""; _e = Ee.exec(D); )
      Pe = _e.index, Pe - Te > we && ($e = Be > Te ? Be : Pe, Re += `
` + D.slice(Te, $e), Te = $e + 1), Be = Pe;
    return Re += `
`, D.length - Te > we && Be > Te ? Re += D.slice(Te, Be) + `
` + D.slice(Be + 1) : Re += D.slice(Te), Re.slice(1);
  }
  function ve(D) {
    for (var we = "", Ee = 0, _e, Te = 0; Te < D.length; Ee >= 65536 ? Te += 2 : Te++)
      Ee = N(D, Te), _e = le[Ee], !_e && B(Ee) ? (we += D[Te], Ee >= 65536 && (we += D[Te + 1])) : we += _e || G(Ee);
    return we;
  }
  function ge(D, we, Ee) {
    var _e = "", Te = D.tag, $e, Be, Pe;
    for ($e = 0, Be = Ee.length; $e < Be; $e += 1)
      Pe = Ee[$e], D.replacer && (Pe = D.replacer.call(Ee, String($e), Pe)), (Je(D, we, Pe, !1, !1) || typeof Pe > "u" && Je(D, we, null, !1, !1)) && (_e !== "" && (_e += "," + (D.condenseFlow ? "" : " ")), _e += D.dump);
    D.tag = Te, D.dump = "[" + _e + "]";
  }
  function Oe(D, we, Ee, _e) {
    var Te = "", $e = D.tag, Be, Pe, Re;
    for (Be = 0, Pe = Ee.length; Be < Pe; Be += 1)
      Re = Ee[Be], D.replacer && (Re = D.replacer.call(Ee, String(Be), Re)), (Je(D, we + 1, Re, !0, !0, !1, !0) || typeof Re > "u" && Je(D, we + 1, null, !0, !0, !1, !0)) && ((!_e || Te !== "") && (Te += q(D, we)), D.dump && a === D.dump.charCodeAt(0) ? Te += "-" : Te += "- ", Te += D.dump);
    D.tag = $e, D.dump = Te || "[]";
  }
  function ke(D, we, Ee) {
    var _e = "", Te = D.tag, $e = Object.keys(Ee), Be, Pe, Re, Qe, ht;
    for (Be = 0, Pe = $e.length; Be < Pe; Be += 1)
      ht = "", _e !== "" && (ht += ", "), D.condenseFlow && (ht += '"'), Re = $e[Be], Qe = Ee[Re], D.replacer && (Qe = D.replacer.call(Ee, Re, Qe)), Je(D, we, Re, !1, !1) && (D.dump.length > 1024 && (ht += "? "), ht += D.dump + (D.condenseFlow ? '"' : "") + ":" + (D.condenseFlow ? "" : " "), Je(D, we, Qe, !1, !1) && (ht += D.dump, _e += ht));
    D.tag = Te, D.dump = "{" + _e + "}";
  }
  function Me(D, we, Ee, _e) {
    var Te = "", $e = D.tag, Be = Object.keys(Ee), Pe, Re, Qe, ht, rt, ut;
    if (D.sortKeys === !0)
      Be.sort();
    else if (typeof D.sortKeys == "function")
      Be.sort(D.sortKeys);
    else if (D.sortKeys)
      throw new t("sortKeys must be a boolean or a function");
    for (Pe = 0, Re = Be.length; Pe < Re; Pe += 1)
      ut = "", (!_e || Te !== "") && (ut += q(D, we)), Qe = Be[Pe], ht = Ee[Qe], D.replacer && (ht = D.replacer.call(Ee, Qe, ht)), Je(D, we + 1, Qe, !0, !0, !0) && (rt = D.tag !== null && D.tag !== "?" || D.dump && D.dump.length > 1024, rt && (D.dump && a === D.dump.charCodeAt(0) ? ut += "?" : ut += "? "), ut += D.dump, rt && (ut += q(D, we)), Je(D, we + 1, ht, !0, rt) && (D.dump && a === D.dump.charCodeAt(0) ? ut += ":" : ut += ": ", ut += D.dump, Te += ut));
    D.tag = $e, D.dump = Te || "{}";
  }
  function Ve(D, we, Ee) {
    var _e, Te, $e, Be, Pe, Re;
    for (Te = Ee ? D.explicitTypes : D.implicitTypes, $e = 0, Be = Te.length; $e < Be; $e += 1)
      if (Pe = Te[$e], (Pe.instanceOf || Pe.predicate) && (!Pe.instanceOf || typeof we == "object" && we instanceof Pe.instanceOf) && (!Pe.predicate || Pe.predicate(we))) {
        if (Ee ? Pe.multi && Pe.representName ? D.tag = Pe.representName(we) : D.tag = Pe.tag : D.tag = "?", Pe.represent) {
          if (Re = D.styleMap[Pe.tag] || Pe.defaultStyle, n.call(Pe.represent) === "[object Function]")
            _e = Pe.represent(we, Re);
          else if (i.call(Pe.represent, Re))
            _e = Pe.represent[Re](we, Re);
          else
            throw new t("!<" + Pe.tag + '> tag resolver accepts not "' + Re + '" style');
          D.dump = _e;
        }
        return !0;
      }
    return !1;
  }
  function Je(D, we, Ee, _e, Te, $e, Be) {
    D.tag = null, D.dump = Ee, Ve(D, Ee, !1) || Ve(D, Ee, !0);
    var Pe = n.call(D.dump), Re = _e, Qe;
    _e && (_e = D.flowLevel < 0 || D.flowLevel > we);
    var ht = Pe === "[object Object]" || Pe === "[object Array]", rt, ut;
    if (ht && (rt = D.duplicates.indexOf(Ee), ut = rt !== -1), (D.tag !== null && D.tag !== "?" || ut || D.indent !== 2 && we > 0) && (Te = !1), ut && D.usedDuplicates[rt])
      D.dump = "*ref_" + rt;
    else {
      if (ht && ut && !D.usedDuplicates[rt] && (D.usedDuplicates[rt] = !0), Pe === "[object Object]")
        _e && Object.keys(D.dump).length !== 0 ? (Me(D, we, D.dump, Te), ut && (D.dump = "&ref_" + rt + D.dump)) : (ke(D, we, D.dump), ut && (D.dump = "&ref_" + rt + " " + D.dump));
      else if (Pe === "[object Array]")
        _e && D.dump.length !== 0 ? (D.noArrayIndent && !Be && we > 0 ? Oe(D, we - 1, D.dump, Te) : Oe(D, we, D.dump, Te), ut && (D.dump = "&ref_" + rt + D.dump)) : (ge(D, we, D.dump), ut && (D.dump = "&ref_" + rt + " " + D.dump));
      else if (Pe === "[object String]")
        D.tag !== "?" && Ce(D, D.dump, we, $e, Re);
      else {
        if (Pe === "[object Undefined]")
          return !1;
        if (D.skipInvalid) return !1;
        throw new t("unacceptable kind of an object to dump " + Pe);
      }
      D.tag !== null && D.tag !== "?" && (Qe = encodeURI(
        D.tag[0] === "!" ? D.tag.slice(1) : D.tag
      ).replace(/!/g, "%21"), D.tag[0] === "!" ? Qe = "!" + Qe : Qe.slice(0, 18) === "tag:yaml.org,2002:" ? Qe = "!!" + Qe.slice(18) : Qe = "!<" + Qe + ">", D.dump = Qe + " " + D.dump);
    }
    return !0;
  }
  function He(D, we) {
    var Ee = [], _e = [], Te, $e;
    for (Ue(D, Ee, _e), Te = 0, $e = _e.length; Te < $e; Te += 1)
      we.duplicates.push(Ee[_e[Te]]);
    we.usedDuplicates = new Array($e);
  }
  function Ue(D, we, Ee) {
    var _e, Te, $e;
    if (D !== null && typeof D == "object")
      if (Te = we.indexOf(D), Te !== -1)
        Ee.indexOf(Te) === -1 && Ee.push(Te);
      else if (we.push(D), Array.isArray(D))
        for (Te = 0, $e = D.length; Te < $e; Te += 1)
          Ue(D[Te], we, Ee);
      else
        for (_e = Object.keys(D), Te = 0, $e = _e.length; Te < $e; Te += 1)
          Ue(D[_e[Te]], we, Ee);
  }
  function Ot(D, we) {
    we = we || {};
    var Ee = new z(we);
    Ee.noRefs || He(D, Ee);
    var _e = D;
    return Ee.replacer && (_e = Ee.replacer.call({ "": _e }, "", _e)), Je(Ee, 0, _e, !0, !0) ? Ee.dump + `
` : "";
  }
  return yb.dump = Ot, yb;
}
var gA;
function $9() {
  if (gA) return $r;
  gA = 1;
  var e = T9(), t = C9();
  function r(n, i) {
    return function() {
      throw new Error("Function yaml." + n + " is removed in js-yaml 4. Use yaml." + i + " instead, which is now safe by default.");
    };
  }
  return $r.Type = Hr(), $r.Schema = Fj(), $r.FAILSAFE_SCHEMA = Uj(), $r.JSON_SCHEMA = Yj(), $r.CORE_SCHEMA = Gj(), $r.DEFAULT_SCHEMA = d1(), $r.load = e.load, $r.loadAll = e.loadAll, $r.dump = t.dump, $r.YAMLException = jp(), $r.types = {
    binary: Jj(),
    float: Qj(),
    map: Bj(),
    null: Vj(),
    pairs: eL(),
    set: tL(),
    timestamp: Kj(),
    bool: Wj(),
    int: Hj(),
    merge: Xj(),
    omap: Zj(),
    seq: qj(),
    str: zj()
  }, $r.safeLoad = r("safeLoad", "load"), $r.safeLoadAll = r("safeLoadAll", "loadAll"), $r.safeDump = r("safeDump", "dump"), $r;
}
var yA;
function xw() {
  if (yA) return Fs;
  yA = 1, Object.defineProperty(Fs, "__esModule", { value: !0 }), Fs.stringifyYaml = Fs.parseYaml = void 0;
  const e = $9(), t = e.JSON_SCHEMA.extend({
    implicit: [e.types.merge],
    explicit: [e.types.binary, e.types.omap, e.types.pairs, e.types.set]
  }), r = (i, s) => (0, e.load)(i, { schema: t, ...s });
  Fs.parseYaml = r;
  const n = (i, s) => (0, e.dump)(i, s);
  return Fs.stringifyYaml = n, Fs;
}
var vb = {}, vA;
function h1() {
  return vA || (vA = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.env = e.isBrowser = void 0, e.isBrowser = typeof window < "u" || typeof process > "u" || (process == null ? void 0 : process.platform) === "browser", e.env = e.isBrowser ? {} : process.env || {};
  }(vb)), vb;
}
var bb = {}, bA;
function rL() {
  return bA || (bA = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.logger = e.colorize = e.colorOptions = void 0;
    const t = hp, r = h1(), n = xn();
    e.colorOptions = t.options, e.colorize = new Proxy(t, {
      get(s, o) {
        return r.isBrowser ? n.identity : s[o];
      }
    });
    class i {
      stderr(o) {
        return process.stderr.write(o);
      }
      info(o) {
        return r.isBrowser ? console.log(o) : this.stderr(o);
      }
      warn(o) {
        return r.isBrowser ? console.warn(o) : this.stderr(e.colorize.yellow(o));
      }
      error(o) {
        return r.isBrowser ? console.error(o) : this.stderr(e.colorize.red(o));
      }
    }
    e.logger = new i();
  }(bb)), bb;
}
function R9(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var wb = { exports: {} }, wA;
function I9() {
  return wA || (wA = 1, function(e, t) {
    (function(r, n) {
      typeof R9 == "function" ? e.exports = n() : r.pluralize = n();
    })(ft, function() {
      var r = [], n = [], i = {}, s = {}, o = {};
      function a(y) {
        return typeof y == "string" ? new RegExp("^" + y + "$", "i") : y;
      }
      function l(y, E) {
        return y === E ? E : y === y.toLowerCase() ? E.toLowerCase() : y === y.toUpperCase() ? E.toUpperCase() : y[0] === y[0].toUpperCase() ? E.charAt(0).toUpperCase() + E.substr(1).toLowerCase() : E.toLowerCase();
      }
      function u(y, E) {
        return y.replace(/\$(\d{1,2})/g, function(x, g) {
          return E[g] || "";
        });
      }
      function f(y, E) {
        return y.replace(E[0], function(x, g) {
          var b = u(E[1], arguments);
          return l(x === "" ? y[g - 1] : x, b);
        });
      }
      function d(y, E, x) {
        if (!y.length || i.hasOwnProperty(y))
          return E;
        for (var g = x.length; g--; ) {
          var b = x[g];
          if (b[0].test(E)) return f(E, b);
        }
        return E;
      }
      function m(y, E, x) {
        return function(g) {
          var b = g.toLowerCase();
          return E.hasOwnProperty(b) ? l(g, b) : y.hasOwnProperty(b) ? l(g, y[b]) : d(b, g, x);
        };
      }
      function v(y, E, x, g) {
        return function(b) {
          var A = b.toLowerCase();
          return E.hasOwnProperty(A) ? !0 : y.hasOwnProperty(A) ? !1 : d(A, A, x) === A;
        };
      }
      function S(y, E, x) {
        var g = E === 1 ? S.singular(y) : S.plural(y);
        return (x ? E + " " : "") + g;
      }
      return S.plural = m(
        o,
        s,
        r
      ), S.isPlural = v(
        o,
        s,
        r
      ), S.singular = m(
        s,
        o,
        n
      ), S.isSingular = v(
        s,
        o,
        n
      ), S.addPluralRule = function(y, E) {
        r.push([a(y), E]);
      }, S.addSingularRule = function(y, E) {
        n.push([a(y), E]);
      }, S.addUncountableRule = function(y) {
        if (typeof y == "string") {
          i[y.toLowerCase()] = !0;
          return;
        }
        S.addPluralRule(y, "$0"), S.addSingularRule(y, "$0");
      }, S.addIrregularRule = function(y, E) {
        E = E.toLowerCase(), y = y.toLowerCase(), o[y] = E, s[E] = y;
      }, [
        // Pronouns.
        ["I", "we"],
        ["me", "us"],
        ["he", "they"],
        ["she", "they"],
        ["them", "them"],
        ["myself", "ourselves"],
        ["yourself", "yourselves"],
        ["itself", "themselves"],
        ["herself", "themselves"],
        ["himself", "themselves"],
        ["themself", "themselves"],
        ["is", "are"],
        ["was", "were"],
        ["has", "have"],
        ["this", "these"],
        ["that", "those"],
        // Words ending in with a consonant and `o`.
        ["echo", "echoes"],
        ["dingo", "dingoes"],
        ["volcano", "volcanoes"],
        ["tornado", "tornadoes"],
        ["torpedo", "torpedoes"],
        // Ends with `us`.
        ["genus", "genera"],
        ["viscus", "viscera"],
        // Ends with `ma`.
        ["stigma", "stigmata"],
        ["stoma", "stomata"],
        ["dogma", "dogmata"],
        ["lemma", "lemmata"],
        ["schema", "schemata"],
        ["anathema", "anathemata"],
        // Other irregular rules.
        ["ox", "oxen"],
        ["axe", "axes"],
        ["die", "dice"],
        ["yes", "yeses"],
        ["foot", "feet"],
        ["eave", "eaves"],
        ["goose", "geese"],
        ["tooth", "teeth"],
        ["quiz", "quizzes"],
        ["human", "humans"],
        ["proof", "proofs"],
        ["carve", "carves"],
        ["valve", "valves"],
        ["looey", "looies"],
        ["thief", "thieves"],
        ["groove", "grooves"],
        ["pickaxe", "pickaxes"],
        ["passerby", "passersby"]
      ].forEach(function(y) {
        return S.addIrregularRule(y[0], y[1]);
      }), [
        [/s?$/i, "s"],
        [/[^\u0000-\u007F]$/i, "$0"],
        [/([^aeiou]ese)$/i, "$1"],
        [/(ax|test)is$/i, "$1es"],
        [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"],
        [/(e[mn]u)s?$/i, "$1s"],
        [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"],
        [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
        [/(seraph|cherub)(?:im)?$/i, "$1im"],
        [/(her|at|gr)o$/i, "$1oes"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"],
        [/sis$/i, "ses"],
        [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
        [/([^aeiouy]|qu)y$/i, "$1ies"],
        [/([^ch][ieo][ln])ey$/i, "$1ies"],
        [/(x|ch|ss|sh|zz)$/i, "$1es"],
        [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
        [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"],
        [/(pe)(?:rson|ople)$/i, "$1ople"],
        [/(child)(?:ren)?$/i, "$1ren"],
        [/eaux$/i, "$0"],
        [/m[ae]n$/i, "men"],
        ["thou", "you"]
      ].forEach(function(y) {
        return S.addPluralRule(y[0], y[1]);
      }), [
        [/s$/i, ""],
        [/(ss)$/i, "$1"],
        [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"],
        [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
        [/ies$/i, "y"],
        [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"],
        [/\b(mon|smil)ies$/i, "$1ey"],
        [/\b((?:tit)?m|l)ice$/i, "$1ouse"],
        [/(seraph|cherub)im$/i, "$1"],
        [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, "$1"],
        [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, "$1sis"],
        [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"],
        [/(test)(?:is|es)$/i, "$1is"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"],
        [/(alumn|alg|vertebr)ae$/i, "$1a"],
        [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
        [/(matr|append)ices$/i, "$1ix"],
        [/(pe)(rson|ople)$/i, "$1rson"],
        [/(child)ren$/i, "$1"],
        [/(eau)x?$/i, "$1"],
        [/men$/i, "man"]
      ].forEach(function(y) {
        return S.addSingularRule(y[0], y[1]);
      }), [
        // Singular words with no plurals.
        "adulthood",
        "advice",
        "agenda",
        "aid",
        "aircraft",
        "alcohol",
        "ammo",
        "analytics",
        "anime",
        "athletics",
        "audio",
        "bison",
        "blood",
        "bream",
        "buffalo",
        "butter",
        "carp",
        "cash",
        "chassis",
        "chess",
        "clothing",
        "cod",
        "commerce",
        "cooperation",
        "corps",
        "debris",
        "diabetes",
        "digestion",
        "elk",
        "energy",
        "equipment",
        "excretion",
        "expertise",
        "firmware",
        "flounder",
        "fun",
        "gallows",
        "garbage",
        "graffiti",
        "hardware",
        "headquarters",
        "health",
        "herpes",
        "highjinks",
        "homework",
        "housework",
        "information",
        "jeans",
        "justice",
        "kudos",
        "labour",
        "literature",
        "machinery",
        "mackerel",
        "mail",
        "media",
        "mews",
        "moose",
        "music",
        "mud",
        "manga",
        "news",
        "only",
        "personnel",
        "pike",
        "plankton",
        "pliers",
        "police",
        "pollution",
        "premises",
        "rain",
        "research",
        "rice",
        "salmon",
        "scissors",
        "series",
        "sewage",
        "shambles",
        "shrimp",
        "software",
        "species",
        "staff",
        "swine",
        "tennis",
        "traffic",
        "transportation",
        "trout",
        "tuna",
        "wealth",
        "welfare",
        "whiting",
        "wildebeest",
        "wildlife",
        "you",
        /pok[e]mon$/i,
        // Regexes.
        /[^aeiou]ese$/i,
        // "chinese", "japanese"
        /deer$/i,
        // "deer", "reindeer"
        /fish$/i,
        // "fish", "blowfish", "angelfish"
        /measles$/i,
        /o[iu]s$/i,
        // "carnivorous"
        /pox$/i,
        // "chickpox", "smallpox"
        /sheep$/i
      ].forEach(S.addUncountableRule), S;
    });
  }(wb)), wb.exports;
}
var SA;
function xn() {
  return SA || (SA = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.assignConfig = e.stringifyYaml = e.parseYaml = void 0, e.pushStack = f, e.pluralize = d, e.popStack = m, e.loadYaml = v, e.isDefined = S, e.isPlainObject = y, e.isEmptyObject = E, e.isNotEmptyObject = x, e.isEmptyArray = g, e.isNotEmptyArray = b, e.readFileFromUrl = A, e.pickObjectProps = k, e.omitObjectProps = $, e.splitCamelCaseIntoWords = I, e.validateMimeType = F, e.validateMimeTypeOAS3 = L, e.readFileAsStringSync = Q, e.yamlAndJsonSyncReader = Y, e.isPathParameter = ae, e.slash = le, e.isString = ue, e.isNotString = ce, e.assignOnlyExistingConfig = G, e.getMatchingStatusCodeRange = ee, e.isCustomRuleId = K, e.doesYamlFileExist = z, e.showWarningForDeprecatedField = te, e.showErrorForDeprecatedField = q, e.isTruthy = j, e.identity = H, e.keysOf = B, e.pickDefined = pe, e.nextTick = he, e.pause = Ae, e.getProxyAgent = N, e.dequal = J;
    const t = hp, r = f1(), n = A9(), i = xw(), s = h1(), o = rL(), a = hp, l = I9();
    var u = xw();
    Object.defineProperty(e, "parseYaml", { enumerable: !0, get: function() {
      return u.parseYaml;
    } }), Object.defineProperty(e, "stringifyYaml", { enumerable: !0, get: function() {
      return u.stringifyYaml;
    } });
    function f(X, oe) {
      return { prev: X, value: oe };
    }
    function d(X, oe, U) {
      return X.split(" ").map((V) => l(V, oe, U)).join(" ");
    }
    function m(X) {
      return (X == null ? void 0 : X.prev) ?? null;
    }
    async function v(X) {
      const oe = await t.promises.readFile(X, "utf-8");
      return (0, i.parseYaml)(oe);
    }
    function S(X) {
      return X !== void 0;
    }
    function y(X) {
      return X !== null && typeof X == "object" && !Array.isArray(X);
    }
    function E(X) {
      return y(X) && Object.keys(X).length === 0;
    }
    function x(X) {
      return y(X) && !E(X);
    }
    function g(X) {
      return Array.isArray(X) && X.length === 0;
    }
    function b(X) {
      return !!X && Array.isArray(X) && !!X.length;
    }
    async function A(X, oe) {
      const U = {};
      for (const ye of oe.headers)
        P(X, ye.matches) && (U[ye.name] = ye.envVariable !== void 0 ? s.env[ye.envVariable] || "" : ye.value);
      const V = await (oe.customFetch || fetch)(X, {
        headers: U
      });
      if (!V.ok)
        throw new Error(`Failed to load ${X}: ${V.status} ${V.statusText}`);
      return { body: await V.text(), mimeType: V.headers.get("content-type") };
    }
    function P(X, oe) {
      return oe.match(/^https?:\/\//) || (X = X.replace(/^https?:\/\//, "")), n(X, oe);
    }
    function k(X, oe) {
      return Object.fromEntries(oe.filter((U) => U in X).map((U) => [U, X[U]]));
    }
    function $(X, oe) {
      return Object.fromEntries(Object.entries(X).filter(([U]) => !oe.includes(U)));
    }
    function I(X) {
      const oe = X.split(/(?:[-._])|([A-Z][a-z]+)/).filter(j).map((V) => V.toLocaleLowerCase()), U = X.split(/([A-Z]{2,})/).filter((V) => V && V === V.toUpperCase()).map((V) => V.toLocaleLowerCase());
      return /* @__PURE__ */ new Set([...oe, ...U]);
    }
    function F({ type: X, value: oe }, { report: U, location: V }, ye) {
      const de = X === "consumes" ? "request" : "response";
      if (!ye)
        throw new Error(`Parameter "allowedValues" is not provided for "${de}-mime-type" rule`);
      if (oe[X])
        for (const Ce of oe[X])
          ye.includes(Ce) || U({
            message: `Mime type "${Ce}" is not allowed`,
            location: V.child(oe[X].indexOf(Ce)).key()
          });
    }
    function L({ type: X, value: oe }, { report: U, location: V }, ye) {
      const de = X === "consumes" ? "request" : "response";
      if (!ye)
        throw new Error(`Parameter "allowedValues" is not provided for "${de}-mime-type" rule`);
      if (oe.content)
        for (const Ce of Object.keys(oe.content))
          ye.includes(Ce) || U({
            message: `Mime type "${Ce}" is not allowed`,
            location: V.child("content").child(Ce).key()
          });
    }
    function Q(X) {
      return t.readFileSync(X, "utf-8");
    }
    function Y(X) {
      const oe = t.readFileSync(X, "utf-8");
      return (0, i.parseYaml)(oe);
    }
    function ae(X) {
      return X.startsWith("{") && X.endsWith("}");
    }
    function le(X) {
      return /^\\\\\?\\/.test(X) ? X : X.replace(/\\/g, "/");
    }
    function ue(X) {
      return typeof X == "string";
    }
    function ce(X) {
      return !ue(X);
    }
    const be = (X, oe) => {
      if (oe)
        for (const U of Object.keys(oe))
          y(X[U]) && typeof oe[U] == "string" ? X[U].severity = oe[U] : X[U] = oe[U];
    };
    e.assignConfig = be;
    function G(X, oe) {
      if (oe)
        for (const U of Object.keys(oe))
          X.hasOwnProperty(U) && (y(X[U]) && typeof oe[U] == "string" ? X[U].severity = oe[U] : X[U] = oe[U]);
    }
    function ee(X) {
      return `${X}`.replace(/^(\d)\d\d$/, (oe, U) => `${U}XX`);
    }
    function K(X) {
      return X.includes("/");
    }
    function z(X) {
      var oe;
      return ((0, r.extname)(X) === ".yaml" || (0, r.extname)(X) === ".yml") && ((oe = t == null ? void 0 : t.hasOwnProperty) == null ? void 0 : oe.call(t, "existsSync")) && t.existsSync(X);
    }
    function te(X, oe, U, V) {
      const ye = V ? `Read more about this change: ${V}` : "";
      o.logger.warn(`The '${o.colorize.red(X)}' field is deprecated. ${oe ? `Use ${o.colorize.green(C(oe, U))} instead. ` : ""}${ye}
`);
    }
    function q(X, oe, U) {
      throw new Error(`Do not use '${X}' field. ${oe ? `Use '${C(oe, U)}' instead. ` : ""}
`);
    }
    function j(X) {
      return !!X;
    }
    function H(X) {
      return X;
    }
    function B(X) {
      return X ? Object.keys(X) : [];
    }
    function pe(X) {
      if (!X)
        return;
      const oe = {};
      for (const U in X)
        X[U] !== void 0 && (oe[U] = X[U]);
      return oe;
    }
    function he() {
      return new Promise((X) => {
        setTimeout(X);
      });
    }
    async function Ae(X) {
      return new Promise((oe) => setTimeout(oe, X));
    }
    function C(X, oe) {
      return `${typeof oe < "u" ? `${oe}.` : ""}${X}`;
    }
    function N() {
      const X = process.env.HTTPS_PROXY || process.env.HTTP_PROXY;
      return X ? new a.HttpsProxyAgent(X) : void 0;
    }
    function J(X, oe) {
      let U, V;
      if (X === oe)
        return !0;
      if (X && oe && (U = X.constructor) === oe.constructor) {
        if (U === Date)
          return X.getTime() === oe.getTime();
        if (U === RegExp)
          return X.toString() === oe.toString();
        if (U === Array) {
          if ((V = X.length) === oe.length)
            for (; V-- && J(X[V], oe[V]); )
              ;
          return V === -1;
        }
        if (!U || typeof X == "object") {
          V = 0;
          for (U in X)
            if (Object.prototype.hasOwnProperty.call(X, U) && ++V && !Object.prototype.hasOwnProperty.call(oe, U) || !(U in oe) || !J(X[U], oe[U]))
              return !1;
          return Object.keys(oe).length === V;
        }
      }
      return X !== X && oe !== oe;
    }
  }(Hv)), Hv;
}
var xA;
function lu() {
  if (xA) return wr;
  xA = 1, Object.defineProperty(wr, "__esModule", { value: !0 }), wr.Location = void 0, wr.joinPointer = t, wr.isRef = r, wr.isExternalValue = n, wr.unescapePointer = s, wr.escapePointer = o, wr.parseRef = a, wr.parsePointer = l, wr.pointerBaseName = u, wr.refBaseName = f, wr.isAbsoluteUrl = d, wr.isMappingRef = m, wr.isAnchor = v;
  const e = xn();
  function t(S, y) {
    return S === "" && (S = "#/"), S[S.length - 1] === "/" ? S + y : S + "/" + y;
  }
  function r(S) {
    return (0, e.isPlainObject)(S) && typeof S.$ref == "string";
  }
  function n(S) {
    return (0, e.isPlainObject)(S) && typeof S.externalValue == "string";
  }
  class i {
    constructor(y, E) {
      this.source = y, this.pointer = E;
    }
    child(y) {
      return new i(this.source, t(this.pointer, (Array.isArray(y) ? y : [y]).map(o).join("/")));
    }
    key() {
      return { ...this, reportOnKey: !0 };
    }
    get absolutePointer() {
      return this.source.absoluteRef + (this.pointer === "#/" ? "" : this.pointer);
    }
  }
  wr.Location = i;
  function s(S) {
    return decodeURIComponent(S.replace(/~1/g, "/").replace(/~0/g, "~"));
  }
  function o(S) {
    return typeof S == "number" ? S : S.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function a(S) {
    const [y, E = ""] = S.split("#/");
    return {
      uri: (y.endsWith("#") ? y.slice(0, -1) : y) || null,
      pointer: l(E)
    };
  }
  function l(S) {
    return S.split("/").map(s).filter(e.isTruthy);
  }
  function u(S) {
    const y = S.split("/");
    return y[y.length - 1];
  }
  function f(S) {
    const y = S.split(/[\/\\]/);
    return y[y.length - 1].replace(/\.[^.]+$/, "");
  }
  function d(S) {
    return S.startsWith("http://") || S.startsWith("https://");
  }
  function m(S) {
    return S.startsWith("#") || S.startsWith("https://") || S.startsWith("http://") || S.startsWith("./") || S.startsWith("../") || S.indexOf("/") > -1;
  }
  function v(S) {
    return /^#[A-Za-z][A-Za-z0-9\-_:.]*$/.test(S);
  }
  return wr;
}
var Sb = {}, EA;
function Fn() {
  return EA || (EA = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SpecExtension = void 0, e.listOf = t, e.mapOf = r, e.normalizeTypes = n, e.isNamedType = i;
    function t(s) {
      return {
        name: `${s}List`,
        properties: {},
        items: s
      };
    }
    function r(s) {
      return {
        name: `${s}Map`,
        properties: {},
        additionalProperties: () => s
      };
    }
    e.SpecExtension = {
      name: "SpecExtension",
      properties: {},
      // skip validation of additional properties for unknown extensions
      additionalProperties: { resolvable: !0 }
    };
    function n(s, o = {}) {
      const a = {};
      for (const f of Object.keys(s))
        a[f] = {
          ...s[f],
          name: f
        };
      for (const f of Object.values(a))
        l(f);
      return a.SpecExtension = e.SpecExtension, a;
      function l(f) {
        if (f.additionalProperties && (f.additionalProperties = u(f.additionalProperties)), f.items && (f.items = u(f.items)), f.properties) {
          const d = {};
          for (const [m, v] of Object.entries(f.properties))
            d[m] = u(v), o.doNotResolveExamples && v && v.isExample && (d[m] = {
              ...v,
              resolvable: !1
            });
          f.properties = d;
        }
      }
      function u(f) {
        if (typeof f == "string") {
          if (!a[f])
            throw new Error(`Unknown type name found: ${f}`);
          return a[f];
        } else return typeof f == "function" ? (d, m) => u(f(d, m)) : f && f.name ? (f = { ...f }, l(f), f) : f && f.directResolveAs ? {
          ...f,
          directResolveAs: u(f.directResolveAs)
        } : f;
      }
    }
    function i(s) {
      return typeof (s == null ? void 0 : s.name) == "string";
    }
  }(Sb)), Sb;
}
var _A;
function m1() {
  if (_A) return Yr;
  _A = 1, Object.defineProperty(Yr, "__esModule", { value: !0 }), Yr.BaseResolver = Yr.YamlParseError = Yr.ResolveError = Yr.Source = void 0, Yr.makeRefId = u, Yr.makeDocumentFromString = f, Yr.resolveDocument = E;
  const e = hp, t = f1(), r = lu(), n = Fn(), i = xn();
  class s {
    constructor(g, b, A) {
      this.absoluteRef = g, this.body = b, this.mimeType = A;
    }
    // pass safeLoad as argument to separate it from browser bundle
    getAst(g) {
      return this._ast === void 0 && (this._ast = g(this.body, { filename: this.absoluteRef }) ?? void 0, this._ast && this._ast.kind === 0 && // KIND.scalar = 0
      this._ast.value === "" && this._ast.startPosition !== 1 && (this._ast.startPosition = 1, this._ast.endPosition = 1)), this._ast;
    }
    getLines() {
      return this._lines === void 0 && (this._lines = this.body.split(/\r\n|[\n\r]/g)), this._lines;
    }
  }
  Yr.Source = s;
  class o extends Error {
    constructor(g) {
      super(g.message), this.originalError = g, Object.setPrototypeOf(this, o.prototype);
    }
  }
  Yr.ResolveError = o;
  const a = /\((\d+):(\d+)\)$/;
  class l extends Error {
    constructor(g, b) {
      super(g.message.split(`
`)[0]), this.originalError = g, this.source = b, Object.setPrototypeOf(this, l.prototype);
      const [, A, P] = this.message.match(a) || [];
      this.line = parseInt(A, 10), this.col = parseInt(P, 10);
    }
  }
  Yr.YamlParseError = l;
  function u(x, g) {
    return x + "::" + g;
  }
  function f(x, g) {
    const b = new s(g, x);
    try {
      return {
        source: b,
        parsed: (0, i.parseYaml)(x, { filename: g })
      };
    } catch (A) {
      throw new l(A, b);
    }
  }
  class d {
    constructor(g = { http: { headers: [] } }) {
      this.config = g, this.cache = /* @__PURE__ */ new Map();
    }
    getFiles() {
      return new Set(Array.from(this.cache.keys()));
    }
    resolveExternalRef(g, b) {
      return (0, r.isAbsoluteUrl)(b) ? b : g && (0, r.isAbsoluteUrl)(g) ? new URL(b, g).href : t.resolve(g ? t.dirname(g) : process.cwd(), b);
    }
    async loadExternalRef(g) {
      try {
        if ((0, r.isAbsoluteUrl)(g)) {
          const { body: b, mimeType: A } = await (0, i.readFileFromUrl)(g, this.config.http);
          return new s(g, b, A);
        } else {
          if (e.lstatSync(g).isDirectory())
            throw new Error(`Expected a file but received a folder at ${g}.`);
          const b = await e.promises.readFile(g, "utf-8");
          return new s(g, b.replace(/\r\n/g, `
`));
        }
      } catch (b) {
        throw b.message = b.message.replace(", lstat", ""), new o(b);
      }
    }
    parseDocument(g, b = !1) {
      var P;
      const A = g.absoluteRef.substr(g.absoluteRef.lastIndexOf("."));
      if (![".json", ".json", ".yml", ".yaml"].includes(A) && !((P = g.mimeType) != null && P.match(/(json|yaml|openapi)/)) && !b)
        return { source: g, parsed: g.body };
      try {
        return {
          source: g,
          parsed: (0, i.parseYaml)(g.body, { filename: g.absoluteRef })
        };
      } catch (k) {
        throw new l(k, g);
      }
    }
    async resolveDocument(g, b, A = !1) {
      const P = this.resolveExternalRef(g, b), k = this.cache.get(P);
      if (k)
        return k;
      const $ = this.loadExternalRef(P).then((I) => this.parseDocument(I, A));
      return this.cache.set(P, $), $;
    }
  }
  Yr.BaseResolver = d;
  function m(x, g) {
    return {
      prev: x,
      node: g
    };
  }
  function v(x, g) {
    for (; x; ) {
      if (x.node === g)
        return !0;
      x = x.prev;
    }
    return !1;
  }
  const S = { name: "unknown", properties: {} }, y = { name: "scalar", properties: {} };
  async function E(x) {
    const { rootDocument: g, externalRefResolver: b, rootType: A } = x, P = /* @__PURE__ */ new Map(), k = /* @__PURE__ */ new Set(), $ = [];
    F(g.parsed, g, "#/", A);
    let I;
    do
      I = await Promise.all($);
    while ($.length !== I.length);
    return P;
    function F(L, Q, Y, ae) {
      const le = Q.source.absoluteRef, ue = /* @__PURE__ */ new Map();
      ce(L, ae, le + Y);
      function ce(G, ee, K) {
        if (typeof G != "object" || G === null)
          return;
        const z = `${ee.name}::${K}`;
        if (k.has(z))
          return;
        k.add(z);
        const [te, q] = Object.entries(G).find(([j]) => j === "$anchor") || [];
        if (q && ue.set(`#${q}`, G), Array.isArray(G)) {
          const j = ee.items;
          if (j === void 0 && ee !== S && ee !== n.SpecExtension)
            return;
          const H = typeof j == "function";
          for (let B = 0; B < G.length; B++) {
            const pe = H ? j(G[B], (0, r.joinPointer)(K, B)) : j;
            pe === void 0 && ee !== S && ee !== n.SpecExtension || ce(G[B], (0, n.isNamedType)(pe) ? pe : S, (0, r.joinPointer)(K, B));
          }
          return;
        }
        for (const j of Object.keys(G)) {
          let H = G[j], B = ee.properties[j];
          B === void 0 && (B = ee.additionalProperties), typeof B == "function" && (B = B(H, j)), B === void 0 && (B = S), ee.extensionsPrefix && j.startsWith(ee.extensionsPrefix) && B === S && (B = n.SpecExtension), !(0, n.isNamedType)(B) && (B != null && B.directResolveAs) && (B = B.directResolveAs, H = { $ref: H }), B && B.name === void 0 && B.resolvable !== !1 && (B = y), !(!(0, n.isNamedType)(B) || typeof H != "object") && ce(H, B, (0, r.joinPointer)(K, (0, r.escapePointer)(j)));
        }
        if ((0, r.isRef)(G)) {
          const j = be(Q, G, {
            prev: null,
            node: G
          }).then((H) => {
            H.resolved && F(H.node, H.document, H.nodePointer, ee);
          });
          $.push(j);
        }
        if ((0, r.isExternalValue)(G)) {
          const j = be(Q, { $ref: G.externalValue }, {
            prev: null,
            node: G
          }).then((H) => {
            H.resolved && F(H.node, H.document, H.nodePointer, ee);
          });
          $.push(j);
        }
      }
      async function be(G, ee, K) {
        if (v(K.prev, ee))
          throw new Error("Self-referencing circular pointer");
        if ((0, r.isAnchor)(ee.$ref)) {
          await (0, i.nextTick)();
          const Ae = {
            resolved: !0,
            isRemote: !1,
            node: ue.get(ee.$ref),
            document: G,
            nodePointer: ee.$ref
          }, C = u(G.source.absoluteRef, ee.$ref);
          return P.set(C, Ae), Ae;
        }
        const { uri: z, pointer: te } = (0, r.parseRef)(ee.$ref), q = z !== null;
        let j;
        try {
          j = q ? await b.resolveDocument(G.source.absoluteRef, z) : G;
        } catch (Ae) {
          const C = {
            resolved: !1,
            isRemote: q,
            document: void 0,
            error: Ae
          }, N = u(G.source.absoluteRef, ee.$ref);
          return P.set(N, C), C;
        }
        let H = {
          resolved: !0,
          document: j,
          isRemote: q,
          node: G.parsed,
          nodePointer: "#/"
        }, B = j.parsed;
        const pe = te;
        for (const Ae of pe)
          if (typeof B != "object") {
            B = void 0;
            break;
          } else if (B[Ae] !== void 0)
            B = B[Ae], H.nodePointer = (0, r.joinPointer)(H.nodePointer, (0, r.escapePointer)(Ae));
          else if ((0, r.isRef)(B)) {
            if (H = await be(j, B, m(K, B)), j = H.document || j, typeof H.node != "object") {
              B = void 0;
              break;
            }
            B = H.node[Ae], H.nodePointer = (0, r.joinPointer)(H.nodePointer, (0, r.escapePointer)(Ae));
          } else {
            B = void 0;
            break;
          }
        H.node = B, H.document = j;
        const he = u(G.source.absoluteRef, ee.$ref);
        return H.document && (0, r.isRef)(B) && (H = await be(H.document, B, m(K, B))), P.set(he, H), { ...H };
      }
    }
  }
  return Yr;
}
var xd = {}, OA;
function N9() {
  if (OA) return xd;
  OA = 1, Object.defineProperty(xd, "__esModule", { value: !0 }), xd.normalizeVisitors = r;
  const e = Fn(), t = {
    Root: "DefinitionRoot",
    ServerVariablesMap: "ServerVariableMap",
    Paths: ["PathMap", "PathsMap"],
    CallbacksMap: "CallbackMap",
    MediaTypesMap: "MediaTypeMap",
    ExamplesMap: "ExampleMap",
    EncodingMap: "EncodingsMap",
    HeadersMap: "HeaderMap",
    LinksMap: "LinkMap",
    OAuth2Flows: "SecuritySchemeFlows",
    Responses: "ResponsesMap"
  };
  function r(n, i) {
    const s = {};
    s.any = {
      enter: [],
      leave: []
    };
    for (const u of Object.keys(i))
      s[u] = {
        enter: [],
        leave: []
      };
    s.ref = {
      enter: [],
      leave: []
    };
    for (const { ruleId: u, severity: f, message: d, visitor: m } of n)
      l({ ruleId: u, severity: f, message: d }, m, null);
    for (const u of Object.keys(s))
      s[u].enter.sort((f, d) => d.depth - f.depth), s[u].leave.sort((f, d) => f.depth - d.depth);
    return s;
    function o(u, f, d, m, v = []) {
      if (v.includes(f))
        return;
      v = [...v, f];
      const S = /* @__PURE__ */ new Set();
      for (const E of Object.values(f.properties)) {
        if (E === d) {
          y(u, v);
          continue;
        }
        typeof E == "object" && E !== null && E.name && S.add(E);
      }
      f.additionalProperties && typeof f.additionalProperties != "function" && (f.additionalProperties === d ? y(u, v) : f.additionalProperties.name !== void 0 && S.add(f.additionalProperties)), f.items && typeof f.items != "function" && (f.items === d ? y(u, v) : f.items.name !== void 0 && S.add(f.items)), f.extensionsPrefix && S.add(e.SpecExtension);
      for (const E of Array.from(S.values()))
        o(u, E, d, m, v);
      function y(E, x) {
        for (const g of x.slice(1))
          s[g.name] = s[g.name] || {
            enter: [],
            leave: []
          }, s[g.name].enter.push({
            ...E,
            visit: () => {
            },
            depth: 0,
            context: {
              isSkippedLevel: !0,
              seen: /* @__PURE__ */ new Set(),
              parent: m
            }
          });
      }
    }
    function a(u, f) {
      if (Array.isArray(f)) {
        const d = f.find((m) => u[m]) || void 0;
        return d && u[d];
      }
      return u[f];
    }
    function l(u, f, d, m = 0) {
      const v = Object.keys(i);
      if (m === 0)
        v.push("any"), v.push("ref");
      else {
        if (f.any)
          throw new Error("any() is allowed only on top level");
        if (f.ref)
          throw new Error("ref() is allowed only on top level");
      }
      for (const S of v) {
        const y = f[S] || a(f, t[S]), E = s[S];
        if (!y)
          continue;
        let x, g, b;
        const A = typeof y == "object";
        if (S === "ref" && A && y.skip)
          throw new Error("ref() visitor does not support skip");
        typeof y == "function" ? x = y : A && (x = y.enter, g = y.leave, b = y.skip);
        const P = {
          activatedOn: null,
          type: i[S],
          parent: d,
          isSkippedLevel: !1
        };
        if (typeof y == "object" && l(u, y, P, m + 1), d && o(u, d.type, i[S], d), x || A) {
          if (x && typeof x != "function")
            throw new Error("DEV: should be function");
          E.enter.push({
            ...u,
            visit: x || (() => {
            }),
            skip: b,
            depth: m,
            context: P
          });
        }
        if (g) {
          if (typeof g != "function")
            throw new Error("DEV: should be function");
          E.leave.push({
            ...u,
            visit: g,
            depth: m,
            context: P
          });
        }
      }
    }
  }
  return xd;
}
var Ed = {}, kA;
function j9() {
  if (kA) return Ed;
  kA = 1, Object.defineProperty(Ed, "__esModule", { value: !0 }), Ed.walkDocument = o;
  const e = lu(), t = xn(), r = m1(), n = Fn();
  function i(a) {
    var u;
    const l = {};
    for (; a.parent; )
      l[a.parent.type.name] = (u = a.parent.activatedOn) == null ? void 0 : u.value.node, a = a.parent;
    return l;
  }
  function s(a) {
    var u, f;
    const l = {};
    for (; a.parent; )
      (u = a.parent.activatedOn) != null && u.value.location && (l[a.parent.type.name] = (f = a.parent.activatedOn) == null ? void 0 : f.value.location), a = a.parent;
    return l;
  }
  function o(a) {
    const { document: l, rootType: u, normalizedVisitors: f, resolvedRefMap: d, ctx: m } = a, v = {}, S = /* @__PURE__ */ new Set();
    y(l.parsed, u, new e.Location(l.source, "#/"), void 0, "");
    function y(E, x, g, b, A) {
      var ue, ce, be, G, ee, K, z, te, q, j;
      const P = (H, B = $.source.absoluteRef) => {
        if (!(0, e.isRef)(H))
          return { location: g, node: H };
        const pe = (0, r.makeRefId)(B, H.$ref), he = d.get(pe);
        if (!he)
          return {
            location: void 0,
            node: void 0
          };
        const { resolved: Ae, node: C, document: N, nodePointer: J, error: X } = he;
        return { location: Ae ? new e.Location(N.source, J) : X instanceof r.YamlParseError ? new e.Location(X.source, "") : void 0, node: C, error: X };
      }, k = g;
      let $ = g;
      const { node: I, location: F, error: L } = P(E), Q = /* @__PURE__ */ new Set();
      if ((0, e.isRef)(E)) {
        const H = f.ref.enter;
        for (const { visit: B, ruleId: pe, severity: he, message: Ae, context: C } of H) {
          Q.add(C);
          const N = ae.bind(void 0, pe, he, Ae);
          B(E, {
            report: N,
            resolve: P,
            rawNode: E,
            rawLocation: k,
            location: g,
            type: x,
            parent: b,
            key: A,
            parentLocations: {},
            oasVersion: m.oasVersion,
            getVisitorData: le.bind(void 0, pe)
          }, { node: I, location: F, error: L }), F != null && F.source.absoluteRef && m.refTypes && m.refTypes.set(F == null ? void 0 : F.source.absoluteRef, x);
        }
      }
      if (I !== void 0 && F && x.name !== "scalar") {
        $ = F;
        const H = (ce = (ue = v[x.name]) == null ? void 0 : ue.has) == null ? void 0 : ce.call(ue, I);
        let B = !1;
        const he = f.any.enter.concat(((be = f[x.name]) == null ? void 0 : be.enter) || []), Ae = [];
        for (const { context: J, visit: X, skip: oe, ruleId: U, severity: V, message: ye } of he) {
          if (S.has(`${$.absolutePointer}${$.pointer}`))
            break;
          if (J.isSkippedLevel)
            J.parent.activatedOn && !J.parent.activatedOn.value.nextLevelTypeActivated && !J.seen.has(E) && (J.seen.add(E), B = !0, Ae.push(J));
          else if (J.parent && // if nested
          J.parent.activatedOn && ((G = J.activatedOn) == null ? void 0 : G.value.withParentNode) !== J.parent.activatedOn.value.node && // do not enter if visited by parent children (it works thanks because deeper visitors are sorted before)
          ((ee = J.parent.activatedOn.value.nextLevelTypeActivated) == null ? void 0 : ee.value) !== x || !J.parent && !H) {
            Ae.push(J);
            const de = {
              node: I,
              location: F,
              nextLevelTypeActivated: null,
              withParentNode: (z = (K = J.parent) == null ? void 0 : K.activatedOn) == null ? void 0 : z.value.node,
              skipped: (((q = (te = J.parent) == null ? void 0 : te.activatedOn) == null ? void 0 : q.value.skipped) || (oe == null ? void 0 : oe(I, A, {
                location: g,
                rawLocation: k,
                resolve: P,
                rawNode: E
              }))) ?? !1
            };
            J.activatedOn = (0, t.pushStack)(J.activatedOn, de);
            let Ce = J.parent;
            for (; Ce; )
              Ce.activatedOn.value.nextLevelTypeActivated = (0, t.pushStack)(Ce.activatedOn.value.nextLevelTypeActivated, x), Ce = Ce.parent;
            de.skipped || (B = !0, Q.add(J), Y(X, I, E, J, U, V, ye));
          }
        }
        if (B || !H) {
          if (v[x.name] = v[x.name] || /* @__PURE__ */ new Set(), v[x.name].add(I), Array.isArray(I)) {
            const J = x.items;
            if (J !== void 0) {
              const X = typeof J == "function";
              for (let oe = 0; oe < I.length; oe++) {
                const U = X ? J(I[oe], F.child([oe]).absolutePointer) : J;
                (0, n.isNamedType)(U) && y(I[oe], U, F.child([oe]), I, oe);
              }
            }
          } else if (typeof I == "object" && I !== null) {
            const J = Object.keys(x.properties);
            x.additionalProperties ? J.push(...Object.keys(I).filter((X) => !J.includes(X))) : x.extensionsPrefix && J.push(...Object.keys(I).filter((X) => X.startsWith(x.extensionsPrefix))), (0, e.isRef)(E) && J.push(...Object.keys(E).filter((X) => X !== "$ref" && !J.includes(X)));
            for (const X of J) {
              let oe = I[X], U = F;
              oe === void 0 && (oe = E[X], U = g);
              let V = x.properties[X];
              V === void 0 && (V = x.additionalProperties), typeof V == "function" && (V = V(oe, X)), V === void 0 && x.extensionsPrefix && X.startsWith(x.extensionsPrefix) && (V = n.SpecExtension), !(0, n.isNamedType)(V) && (V != null && V.directResolveAs) && (V = V.directResolveAs, oe = { $ref: oe }), V && V.name === void 0 && V.resolvable !== !1 && (V = { name: "scalar", properties: {} }), !(!(0, n.isNamedType)(V) || V.name === "scalar" && !(0, e.isRef)(oe)) && y(oe, V, U.child([X]), I, X);
            }
          }
        }
        const C = f.any.leave, N = (((j = f[x.name]) == null ? void 0 : j.leave) || []).concat(C);
        for (const J of Ae.reverse())
          if (J.isSkippedLevel)
            J.seen.delete(I);
          else if (J.activatedOn = (0, t.popStack)(J.activatedOn), J.parent) {
            let X = J.parent;
            for (; X; )
              X.activatedOn.value.nextLevelTypeActivated = (0, t.popStack)(X.activatedOn.value.nextLevelTypeActivated), X = X.parent;
          }
        for (const { context: J, visit: X, ruleId: oe, severity: U, message: V } of N)
          !J.isSkippedLevel && Q.has(J) && Y(X, I, E, J, oe, U, V);
      }
      if ($ = g, (0, e.isRef)(E)) {
        const H = f.ref.leave;
        for (const { visit: B, ruleId: pe, severity: he, context: Ae, message: C } of H)
          if (Q.has(Ae)) {
            const N = ae.bind(void 0, pe, he, C);
            B(E, {
              report: N,
              resolve: P,
              rawNode: E,
              rawLocation: k,
              location: g,
              type: x,
              parent: b,
              key: A,
              parentLocations: {},
              oasVersion: m.oasVersion,
              getVisitorData: le.bind(void 0, pe)
            }, { node: I, location: F, error: L });
          }
      }
      function Y(H, B, pe, he, Ae, C, N) {
        const J = ae.bind(void 0, Ae, C, N);
        H(B, {
          report: J,
          resolve: P,
          rawNode: pe,
          location: $,
          rawLocation: k,
          type: x,
          parent: b,
          key: A,
          parentLocations: s(he),
          oasVersion: m.oasVersion,
          ignoreNextVisitorsOnNode: () => {
            S.add(`${$.absolutePointer}${$.pointer}`);
          },
          getVisitorData: le.bind(void 0, Ae)
        }, i(he), he);
      }
      function ae(H, B, pe, he) {
        const C = (he.location ? Array.isArray(he.location) ? he.location : [he.location] : [{ ...$, reportOnKey: !1 }]).map((J) => ({
          ...$,
          reportOnKey: !1,
          ...J
        })), N = he.forceSeverity || B;
        N !== "off" && m.problems.push({
          ruleId: he.ruleId || H,
          severity: N,
          ...he,
          message: pe ? pe.replace("{{message}}", he.message) : he.message,
          suggest: he.suggest || [],
          location: C
        });
      }
      function le(H) {
        return m.visitorsData[H] = m.visitorsData[H] || {}, m.visitorsData[H];
      }
    }
  }
  return Ed;
}
var xi = {}, Ku = {}, AA;
function L9() {
  if (AA) return Ku;
  AA = 1, Object.defineProperty(Ku, "__esModule", { value: !0 }), Ku.Oas2Types = void 0;
  const e = Fn(), t = /^[0-9][0-9Xx]{2}$/, r = {
    properties: {
      swagger: { type: "string" },
      info: "Info",
      host: { type: "string" },
      basePath: { type: "string" },
      schemes: { type: "array", items: { type: "string" } },
      consumes: { type: "array", items: { type: "string" } },
      produces: { type: "array", items: { type: "string" } },
      paths: "Paths",
      definitions: "NamedSchemas",
      parameters: "NamedParameters",
      responses: "NamedResponses",
      securityDefinitions: "NamedSecuritySchemes",
      security: "SecurityRequirementList",
      tags: "TagList",
      externalDocs: "ExternalDocs",
      "x-servers": "XServerList",
      "x-tagGroups": "TagGroups",
      "x-ignoredHeaderParameters": { type: "array", items: { type: "string" } }
    },
    required: ["swagger", "paths", "info"],
    extensionsPrefix: "x-"
  }, n = {
    properties: {
      title: { type: "string" },
      description: { type: "string" },
      termsOfService: { type: "string" },
      contact: "Contact",
      license: "License",
      version: { type: "string" },
      "x-logo": "Logo"
    },
    required: ["title", "version"],
    extensionsPrefix: "x-"
  }, i = {
    properties: {
      url: { type: "string" },
      altText: { type: "string" },
      backgroundColor: { type: "string" },
      href: { type: "string" }
    },
    extensionsPrefix: "x-"
  }, s = {
    properties: {
      name: { type: "string" },
      url: { type: "string" },
      email: { type: "string" }
    },
    extensionsPrefix: "x-"
  }, o = {
    properties: {
      name: { type: "string" },
      url: { type: "string" }
    },
    required: ["name"],
    extensionsPrefix: "x-"
  }, a = {
    properties: {},
    additionalProperties: (Y, ae) => ae.startsWith("/") ? "PathItem" : void 0
  }, l = {
    properties: {
      $ref: { type: "string" },
      // TODO: verify special $ref handling for Path Item
      parameters: "ParameterList",
      get: "Operation",
      put: "Operation",
      post: "Operation",
      delete: "Operation",
      options: "Operation",
      head: "Operation",
      patch: "Operation"
    },
    extensionsPrefix: "x-"
  }, u = {
    properties: {
      tags: { type: "array", items: { type: "string" } },
      summary: { type: "string" },
      description: { type: "string" },
      externalDocs: "ExternalDocs",
      operationId: { type: "string" },
      consumes: { type: "array", items: { type: "string" } },
      produces: { type: "array", items: { type: "string" } },
      parameters: "ParameterList",
      responses: "Responses",
      schemes: { type: "array", items: { type: "string" } },
      deprecated: { type: "boolean" },
      security: "SecurityRequirementList",
      "x-codeSamples": "XCodeSampleList",
      "x-code-samples": "XCodeSampleList",
      // deprecated
      "x-hideTryItPanel": { type: "boolean" }
    },
    required: ["responses"],
    extensionsPrefix: "x-"
  }, f = {
    properties: {
      lang: { type: "string" },
      label: { type: "string" },
      source: { type: "string" }
    }
  }, d = {
    properties: {
      url: { type: "string" },
      description: { type: "string" }
    },
    required: ["url"]
  }, m = {
    properties: {
      description: { type: "string" },
      url: { type: "string" }
    },
    required: ["url"],
    extensionsPrefix: "x-"
  }, v = {
    properties: {
      name: { type: "string" },
      in: { type: "string", enum: ["query", "header", "path", "formData", "body"] },
      description: { type: "string" },
      required: { type: "boolean" },
      schema: "Schema",
      type: { type: "string", enum: ["string", "number", "integer", "boolean", "array", "file"] },
      format: { type: "string" },
      allowEmptyValue: { type: "boolean" },
      items: "ParameterItems",
      collectionFormat: { type: "string", enum: ["csv", "ssv", "tsv", "pipes", "multi"] },
      default: null,
      maximum: { type: "integer" },
      exclusiveMaximum: { type: "boolean" },
      minimum: { type: "integer" },
      exclusiveMinimum: { type: "boolean" },
      maxLength: { type: "integer" },
      minLength: { type: "integer" },
      pattern: { type: "string" },
      maxItems: { type: "integer" },
      minItems: { type: "integer" },
      uniqueItems: { type: "boolean" },
      enum: { type: "array" },
      multipleOf: { type: "number" },
      "x-example": {},
      // any
      "x-examples": "ExamplesMap"
    },
    required(Y) {
      return !Y || !Y.in ? ["name", "in"] : Y.in === "body" ? ["name", "in", "schema"] : Y.type === "array" ? ["name", "in", "type", "items"] : ["name", "in", "type"];
    },
    extensionsPrefix: "x-"
  }, S = {
    properties: {
      type: { type: "string", enum: ["string", "number", "integer", "boolean", "array"] },
      format: { type: "string" },
      items: "ParameterItems",
      collectionFormat: { type: "string", enum: ["csv", "ssv", "tsv", "pipes", "multi"] },
      default: null,
      maximum: { type: "integer" },
      exclusiveMaximum: { type: "boolean" },
      minimum: { type: "integer" },
      exclusiveMinimum: { type: "boolean" },
      maxLength: { type: "integer" },
      minLength: { type: "integer" },
      pattern: { type: "string" },
      maxItems: { type: "integer" },
      minItems: { type: "integer" },
      uniqueItems: { type: "boolean" },
      enum: { type: "array" },
      multipleOf: { type: "number" }
    },
    required(Y) {
      return Y && Y.type === "array" ? ["type", "items"] : ["type"];
    },
    extensionsPrefix: "x-"
  }, y = {
    properties: {
      default: "Response"
    },
    additionalProperties: (Y, ae) => t.test(ae) ? "Response" : void 0
  }, E = {
    properties: {
      description: { type: "string" },
      schema: "Schema",
      headers: (0, e.mapOf)("Header"),
      examples: "Examples",
      "x-summary": { type: "string" }
    },
    required: ["description"],
    extensionsPrefix: "x-"
  }, x = {
    properties: {},
    additionalProperties: { isExample: !0 }
  }, g = {
    properties: {
      description: { type: "string" },
      type: { type: "string", enum: ["string", "number", "integer", "boolean", "array"] },
      format: { type: "string" },
      items: "ParameterItems",
      collectionFormat: { type: "string", enum: ["csv", "ssv", "tsv", "pipes", "multi"] },
      default: null,
      maximum: { type: "integer" },
      exclusiveMaximum: { type: "boolean" },
      minimum: { type: "integer" },
      exclusiveMinimum: { type: "boolean" },
      maxLength: { type: "integer" },
      minLength: { type: "integer" },
      pattern: { type: "string" },
      maxItems: { type: "integer" },
      minItems: { type: "integer" },
      uniqueItems: { type: "boolean" },
      enum: { type: "array" },
      multipleOf: { type: "number" }
    },
    required(Y) {
      return Y && Y.type === "array" ? ["type", "items"] : ["type"];
    },
    extensionsPrefix: "x-"
  }, b = {
    properties: {
      name: { type: "string" },
      description: { type: "string" },
      externalDocs: "ExternalDocs",
      "x-traitTag": { type: "boolean" },
      "x-displayName": { type: "string" }
    },
    required: ["name"],
    extensionsPrefix: "x-"
  }, A = {
    properties: {
      name: { type: "string" },
      tags: { type: "array", items: { type: "string" } }
    }
  }, P = {
    properties: {
      format: { type: "string" },
      title: { type: "string" },
      description: { type: "string" },
      default: null,
      multipleOf: { type: "number" },
      maximum: { type: "number" },
      minimum: { type: "number" },
      exclusiveMaximum: { type: "boolean" },
      exclusiveMinimum: { type: "boolean" },
      maxLength: { type: "number" },
      minLength: { type: "number" },
      pattern: { type: "string" },
      maxItems: { type: "number" },
      minItems: { type: "number" },
      uniqueItems: { type: "boolean" },
      maxProperties: { type: "number" },
      minProperties: { type: "number" },
      required: { type: "array", items: { type: "string" } },
      enum: { type: "array" },
      type: {
        type: "string",
        enum: ["object", "array", "string", "number", "integer", "boolean", "null"]
      },
      items: (Y) => Array.isArray(Y) ? (0, e.listOf)("Schema") : "Schema",
      allOf: (0, e.listOf)("Schema"),
      properties: "SchemaProperties",
      additionalProperties: (Y) => typeof Y == "boolean" ? { type: "boolean" } : "Schema",
      discriminator: { type: "string" },
      readOnly: { type: "boolean" },
      xml: "Xml",
      externalDocs: "ExternalDocs",
      example: { isExample: !0 },
      "x-tags": { type: "array", items: { type: "string" } },
      "x-nullable": { type: "boolean" },
      "x-extendedDiscriminator": { type: "string" },
      "x-additionalPropertiesName": { type: "string" },
      "x-explicitMappingOnly": { type: "boolean" },
      "x-enumDescriptions": "EnumDescriptions"
    },
    extensionsPrefix: "x-"
  }, k = {
    properties: {},
    additionalProperties: { type: "string" }
  }, $ = {
    properties: {},
    additionalProperties: "Schema"
  }, I = {
    properties: {
      name: { type: "string" },
      namespace: { type: "string" },
      prefix: { type: "string" },
      attribute: { type: "boolean" },
      wrapped: { type: "boolean" }
    },
    extensionsPrefix: "x-"
  }, F = {
    properties: {
      type: { enum: ["basic", "apiKey", "oauth2"] },
      description: { type: "string" },
      name: { type: "string" },
      in: { type: "string", enum: ["query", "header"] },
      flow: { enum: ["implicit", "password", "application", "accessCode"] },
      authorizationUrl: { type: "string" },
      tokenUrl: { type: "string" },
      scopes: { type: "object", additionalProperties: { type: "string" } },
      "x-defaultClientId": { type: "string" }
    },
    required(Y) {
      switch (Y == null ? void 0 : Y.type) {
        case "apiKey":
          return ["type", "name", "in"];
        case "oauth2":
          switch (Y == null ? void 0 : Y.flow) {
            case "implicit":
              return ["type", "flow", "authorizationUrl", "scopes"];
            case "accessCode":
              return ["type", "flow", "authorizationUrl", "tokenUrl", "scopes"];
            case "application":
            case "password":
              return ["type", "flow", "tokenUrl", "scopes"];
            default:
              return ["type", "flow", "scopes"];
          }
        default:
          return ["type"];
      }
    },
    allowed(Y) {
      switch (Y == null ? void 0 : Y.type) {
        case "basic":
          return ["type", "description"];
        case "apiKey":
          return ["type", "name", "in", "description"];
        case "oauth2":
          switch (Y == null ? void 0 : Y.flow) {
            case "implicit":
              return ["type", "flow", "authorizationUrl", "description", "scopes"];
            case "accessCode":
              return ["type", "flow", "authorizationUrl", "tokenUrl", "description", "scopes"];
            case "application":
            case "password":
              return ["type", "flow", "tokenUrl", "description", "scopes"];
            default:
              return ["type", "flow", "tokenUrl", "authorizationUrl", "description", "scopes"];
          }
        default:
          return ["type", "description"];
      }
    },
    extensionsPrefix: "x-"
  }, L = {
    properties: {},
    additionalProperties: { type: "array", items: { type: "string" } }
  }, Q = {
    properties: {
      value: { isExample: !0 },
      summary: { type: "string" },
      description: { type: "string" },
      externalValue: { type: "string" }
    },
    extensionsPrefix: "x-"
  };
  return Ku.Oas2Types = {
    Root: r,
    Tag: b,
    TagList: (0, e.listOf)("Tag"),
    TagGroups: (0, e.listOf)("TagGroup"),
    TagGroup: A,
    ExternalDocs: m,
    Example: Q,
    ExamplesMap: (0, e.mapOf)("Example"),
    EnumDescriptions: k,
    SecurityRequirement: L,
    SecurityRequirementList: (0, e.listOf)("SecurityRequirement"),
    Info: n,
    Contact: s,
    License: o,
    Logo: i,
    Paths: a,
    PathItem: l,
    Parameter: v,
    ParameterItems: S,
    ParameterList: (0, e.listOf)("Parameter"),
    Operation: u,
    Examples: x,
    Header: g,
    Responses: y,
    Response: E,
    Schema: P,
    Xml: I,
    SchemaProperties: $,
    NamedSchemas: (0, e.mapOf)("Schema"),
    NamedResponses: (0, e.mapOf)("Response"),
    NamedParameters: (0, e.mapOf)("Parameter"),
    NamedSecuritySchemes: (0, e.mapOf)("SecurityScheme"),
    SecurityScheme: F,
    XCodeSample: f,
    XCodeSampleList: (0, e.listOf)("XCodeSample"),
    XServerList: (0, e.listOf)("XServer"),
    XServer: d
  }, Ku;
}
var xb = {}, PA;
function g1() {
  return PA || (PA = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Oas3Types = e.Discriminator = e.DiscriminatorMapping = e.Xml = e.ExternalDocs = void 0;
    const t = Fn(), r = lu(), n = /^[0-9][0-9Xx]{2}$/, i = {
      properties: {
        openapi: null,
        info: "Info",
        servers: "ServerList",
        security: "SecurityRequirementList",
        tags: "TagList",
        externalDocs: "ExternalDocs",
        paths: "Paths",
        components: "Components",
        "x-webhooks": "WebhooksMap",
        "x-tagGroups": "TagGroups",
        "x-ignoredHeaderParameters": { type: "array", items: { type: "string" } }
      },
      required: ["openapi", "paths", "info"],
      extensionsPrefix: "x-"
    }, s = {
      properties: {
        name: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs",
        "x-traitTag": { type: "boolean" },
        "x-displayName": { type: "string" }
      },
      required: ["name"],
      extensionsPrefix: "x-"
    }, o = {
      properties: {
        name: { type: "string" },
        tags: { type: "array", items: { type: "string" } }
      },
      extensionsPrefix: "x-"
    };
    e.ExternalDocs = {
      properties: {
        description: { type: "string" },
        url: { type: "string" }
      },
      required: ["url"],
      extensionsPrefix: "x-"
    };
    const a = {
      properties: {
        url: { type: "string" },
        description: { type: "string" },
        variables: "ServerVariablesMap"
      },
      required: ["url"],
      extensionsPrefix: "x-"
    }, l = {
      properties: {
        enum: {
          type: "array",
          items: { type: "string" }
        },
        default: { type: "string" },
        description: { type: "string" }
      },
      required: ["default"],
      extensionsPrefix: "x-"
    }, u = {
      properties: {},
      additionalProperties: { type: "array", items: { type: "string" } }
    }, f = {
      properties: {
        title: { type: "string" },
        version: { type: "string" },
        description: { type: "string" },
        termsOfService: { type: "string" },
        contact: "Contact",
        license: "License",
        "x-logo": "Logo"
      },
      required: ["title", "version"],
      extensionsPrefix: "x-"
    }, d = {
      properties: {
        url: { type: "string" },
        altText: { type: "string" },
        backgroundColor: { type: "string" },
        href: { type: "string" }
      }
    }, m = {
      properties: {
        name: { type: "string" },
        url: { type: "string" },
        email: { type: "string" }
      },
      extensionsPrefix: "x-"
    }, v = {
      properties: {
        name: { type: "string" },
        url: { type: "string" }
      },
      required: ["name"],
      extensionsPrefix: "x-"
    }, S = {
      properties: {},
      additionalProperties: (j, H) => H.startsWith("/") ? "PathItem" : void 0
    }, y = {
      properties: {},
      additionalProperties: () => "PathItem"
    }, E = {
      properties: {
        $ref: { type: "string" },
        // TODO: verify special $ref handling for Path Item
        servers: "ServerList",
        parameters: "ParameterList",
        summary: { type: "string" },
        description: { type: "string" },
        get: "Operation",
        put: "Operation",
        post: "Operation",
        delete: "Operation",
        options: "Operation",
        head: "Operation",
        patch: "Operation",
        trace: "Operation"
      },
      extensionsPrefix: "x-"
    }, x = {
      properties: {
        name: { type: "string" },
        in: { enum: ["query", "header", "path", "cookie"] },
        description: { type: "string" },
        required: { type: "boolean" },
        deprecated: { type: "boolean" },
        allowEmptyValue: { type: "boolean" },
        style: {
          enum: ["form", "simple", "label", "matrix", "spaceDelimited", "pipeDelimited", "deepObject"]
        },
        explode: { type: "boolean" },
        allowReserved: { type: "boolean" },
        schema: "Schema",
        example: { isExample: !0 },
        examples: "ExamplesMap",
        content: "MediaTypesMap"
      },
      required: ["name", "in"],
      requiredOneOf: ["schema", "content"],
      extensionsPrefix: "x-"
    }, g = {
      properties: {
        tags: {
          type: "array",
          items: { type: "string" }
        },
        summary: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs",
        operationId: { type: "string" },
        parameters: "ParameterList",
        security: "SecurityRequirementList",
        servers: "ServerList",
        requestBody: "RequestBody",
        responses: "Responses",
        deprecated: { type: "boolean" },
        callbacks: "CallbacksMap",
        "x-codeSamples": "XCodeSampleList",
        "x-code-samples": "XCodeSampleList",
        // deprecated
        "x-hideTryItPanel": { type: "boolean" }
      },
      required: ["responses"],
      extensionsPrefix: "x-"
    }, b = {
      properties: {
        lang: { type: "string" },
        label: { type: "string" },
        source: { type: "string" }
      }
    }, A = {
      properties: {
        description: { type: "string" },
        required: { type: "boolean" },
        content: "MediaTypesMap"
      },
      required: ["content"],
      extensionsPrefix: "x-"
    }, P = {
      properties: {},
      additionalProperties: "MediaType"
    }, k = {
      properties: {
        schema: "Schema",
        example: { isExample: !0 },
        examples: "ExamplesMap",
        encoding: "EncodingMap"
      },
      extensionsPrefix: "x-"
    }, $ = {
      properties: {
        value: { isExample: !0 },
        summary: { type: "string" },
        description: { type: "string" },
        externalValue: { type: "string" }
      },
      extensionsPrefix: "x-"
    }, I = {
      properties: {
        contentType: { type: "string" },
        headers: "HeadersMap",
        style: {
          enum: ["form", "simple", "label", "matrix", "spaceDelimited", "pipeDelimited", "deepObject"]
        },
        explode: { type: "boolean" },
        allowReserved: { type: "boolean" }
      },
      extensionsPrefix: "x-"
    }, F = {
      properties: {},
      additionalProperties: { type: "string" }
    }, L = {
      properties: {
        description: { type: "string" },
        required: { type: "boolean" },
        deprecated: { type: "boolean" },
        allowEmptyValue: { type: "boolean" },
        style: {
          enum: ["form", "simple", "label", "matrix", "spaceDelimited", "pipeDelimited", "deepObject"]
        },
        explode: { type: "boolean" },
        allowReserved: { type: "boolean" },
        schema: "Schema",
        example: { isExample: !0 },
        examples: "ExamplesMap",
        content: "MediaTypesMap"
      },
      requiredOneOf: ["schema", "content"],
      extensionsPrefix: "x-"
    }, Q = {
      properties: { default: "Response" },
      additionalProperties: (j, H) => n.test(H) ? "Response" : void 0
    }, Y = {
      properties: {
        description: { type: "string" },
        headers: "HeadersMap",
        content: "MediaTypesMap",
        links: "LinksMap",
        "x-summary": { type: "string" }
      },
      required: ["description"],
      extensionsPrefix: "x-"
    }, ae = {
      properties: {
        operationRef: { type: "string" },
        operationId: { type: "string" },
        parameters: null,
        // TODO: figure out how to describe/validate this
        requestBody: null,
        // TODO: figure out how to describe/validate this
        description: { type: "string" },
        server: "Server"
      },
      extensionsPrefix: "x-"
    }, le = {
      properties: {
        externalDocs: "ExternalDocs",
        discriminator: "Discriminator",
        title: { type: "string" },
        multipleOf: { type: "number", minimum: 0 },
        maximum: { type: "number" },
        minimum: { type: "number" },
        exclusiveMaximum: { type: "boolean" },
        exclusiveMinimum: { type: "boolean" },
        maxLength: { type: "integer", minimum: 0 },
        minLength: { type: "integer", minimum: 0 },
        pattern: { type: "string" },
        maxItems: { type: "integer", minimum: 0 },
        minItems: { type: "integer", minimum: 0 },
        uniqueItems: { type: "boolean" },
        maxProperties: { type: "integer", minimum: 0 },
        minProperties: { type: "integer", minimum: 0 },
        required: { type: "array", items: { type: "string" } },
        enum: { type: "array" },
        type: {
          enum: ["object", "array", "string", "number", "integer", "boolean"]
        },
        allOf: (0, t.listOf)("Schema"),
        anyOf: (0, t.listOf)("Schema"),
        oneOf: (0, t.listOf)("Schema"),
        not: "Schema",
        properties: "SchemaProperties",
        items: (j) => Array.isArray(j) ? (0, t.listOf)("Schema") : "Schema",
        additionalProperties: (j) => typeof j == "boolean" ? { type: "boolean" } : "Schema",
        description: { type: "string" },
        format: { type: "string" },
        default: null,
        nullable: { type: "boolean" },
        readOnly: { type: "boolean" },
        writeOnly: { type: "boolean" },
        xml: "Xml",
        example: { isExample: !0 },
        deprecated: { type: "boolean" },
        "x-tags": { type: "array", items: { type: "string" } },
        "x-additionalPropertiesName": { type: "string" },
        "x-explicitMappingOnly": { type: "boolean" }
      },
      extensionsPrefix: "x-"
    };
    e.Xml = {
      properties: {
        name: { type: "string" },
        namespace: { type: "string" },
        prefix: { type: "string" },
        attribute: { type: "boolean" },
        wrapped: { type: "boolean" }
      },
      extensionsPrefix: "x-"
    };
    const ue = {
      properties: {},
      additionalProperties: "Schema"
    };
    e.DiscriminatorMapping = {
      properties: {},
      additionalProperties: (j) => (0, r.isMappingRef)(j) ? { type: "string", directResolveAs: "Schema" } : { type: "string" }
    }, e.Discriminator = {
      properties: {
        propertyName: { type: "string" },
        mapping: "DiscriminatorMapping"
      },
      required: ["propertyName"],
      extensionsPrefix: "x-"
    };
    const ce = {
      properties: {
        parameters: "NamedParameters",
        schemas: "NamedSchemas",
        responses: "NamedResponses",
        examples: "NamedExamples",
        requestBodies: "NamedRequestBodies",
        headers: "NamedHeaders",
        securitySchemes: "NamedSecuritySchemes",
        links: "NamedLinks",
        callbacks: "NamedCallbacks"
      },
      extensionsPrefix: "x-"
    }, be = {
      properties: {
        refreshUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        authorizationUrl: { type: "string" }
      },
      required: ["authorizationUrl", "scopes"],
      extensionsPrefix: "x-"
    }, G = {
      properties: {
        refreshUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        tokenUrl: { type: "string" }
      },
      required: ["tokenUrl", "scopes"],
      extensionsPrefix: "x-"
    }, ee = {
      properties: {
        refreshUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        tokenUrl: { type: "string" }
      },
      required: ["tokenUrl", "scopes"],
      extensionsPrefix: "x-"
    }, K = {
      properties: {
        refreshUrl: { type: "string" },
        authorizationUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        tokenUrl: { type: "string" },
        "x-usePkce": (j) => typeof j == "boolean" ? { type: "boolean" } : "XUsePkce"
      },
      required: ["authorizationUrl", "tokenUrl", "scopes"],
      extensionsPrefix: "x-"
    }, z = {
      properties: {
        implicit: "ImplicitFlow",
        password: "PasswordFlow",
        clientCredentials: "ClientCredentials",
        authorizationCode: "AuthorizationCode"
      },
      extensionsPrefix: "x-"
    }, te = {
      properties: {
        type: { enum: ["apiKey", "http", "oauth2", "openIdConnect"] },
        description: { type: "string" },
        name: { type: "string" },
        in: { type: "string", enum: ["query", "header", "cookie"] },
        scheme: { type: "string" },
        bearerFormat: { type: "string" },
        flows: "OAuth2Flows",
        openIdConnectUrl: { type: "string" },
        "x-defaultClientId": { type: "string" }
      },
      required(j) {
        switch (j == null ? void 0 : j.type) {
          case "apiKey":
            return ["type", "name", "in"];
          case "http":
            return ["type", "scheme"];
          case "oauth2":
            return ["type", "flows"];
          case "openIdConnect":
            return ["type", "openIdConnectUrl"];
          default:
            return ["type"];
        }
      },
      allowed(j) {
        switch (j == null ? void 0 : j.type) {
          case "apiKey":
            return ["type", "name", "in", "description"];
          case "http":
            return ["type", "scheme", "bearerFormat", "description"];
          case "oauth2":
            return ["type", "flows", "description"];
          case "openIdConnect":
            return ["type", "openIdConnectUrl", "description"];
          default:
            return ["type", "description"];
        }
      },
      extensionsPrefix: "x-"
    }, q = {
      properties: {
        disableManualConfiguration: { type: "boolean" },
        hideClientSecretInput: { type: "boolean" }
      }
    };
    e.Oas3Types = {
      Root: i,
      Tag: s,
      TagList: (0, t.listOf)("Tag"),
      TagGroups: (0, t.listOf)("TagGroup"),
      TagGroup: o,
      ExternalDocs: e.ExternalDocs,
      Server: a,
      ServerList: (0, t.listOf)("Server"),
      ServerVariable: l,
      ServerVariablesMap: (0, t.mapOf)("ServerVariable"),
      SecurityRequirement: u,
      SecurityRequirementList: (0, t.listOf)("SecurityRequirement"),
      Info: f,
      Contact: m,
      License: v,
      Paths: S,
      PathItem: E,
      Parameter: x,
      ParameterList: (0, t.listOf)("Parameter"),
      Operation: g,
      Callback: (0, t.mapOf)("PathItem"),
      CallbacksMap: (0, t.mapOf)("Callback"),
      RequestBody: A,
      MediaTypesMap: P,
      MediaType: k,
      Example: $,
      ExamplesMap: (0, t.mapOf)("Example"),
      Encoding: I,
      EncodingMap: (0, t.mapOf)("Encoding"),
      EnumDescriptions: F,
      Header: L,
      HeadersMap: (0, t.mapOf)("Header"),
      Responses: Q,
      Response: Y,
      Link: ae,
      Logo: d,
      Schema: le,
      Xml: e.Xml,
      SchemaProperties: ue,
      DiscriminatorMapping: e.DiscriminatorMapping,
      Discriminator: e.Discriminator,
      Components: ce,
      LinksMap: (0, t.mapOf)("Link"),
      NamedSchemas: (0, t.mapOf)("Schema"),
      NamedResponses: (0, t.mapOf)("Response"),
      NamedParameters: (0, t.mapOf)("Parameter"),
      NamedExamples: (0, t.mapOf)("Example"),
      NamedRequestBodies: (0, t.mapOf)("RequestBody"),
      NamedHeaders: (0, t.mapOf)("Header"),
      NamedSecuritySchemes: (0, t.mapOf)("SecurityScheme"),
      NamedLinks: (0, t.mapOf)("Link"),
      NamedCallbacks: (0, t.mapOf)("Callback"),
      ImplicitFlow: be,
      PasswordFlow: G,
      ClientCredentials: ee,
      AuthorizationCode: K,
      OAuth2Flows: z,
      SecurityScheme: te,
      XCodeSample: b,
      XCodeSampleList: (0, t.listOf)("XCodeSample"),
      XUsePkce: q,
      WebhooksMap: y
    };
  }(xb)), xb;
}
var Eb = {}, TA;
function nL() {
  return TA || (TA = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Oas3_1Types = e.DependentRequired = e.SchemaProperties = e.Schema = void 0;
    const t = Fn(), r = g1(), n = {
      properties: {
        openapi: null,
        info: "Info",
        servers: "ServerList",
        security: "SecurityRequirementList",
        tags: "TagList",
        externalDocs: "ExternalDocs",
        paths: "Paths",
        webhooks: "WebhooksMap",
        components: "Components",
        jsonSchemaDialect: { type: "string" }
      },
      required: ["openapi", "info"],
      requiredOneOf: ["paths", "components", "webhooks"],
      extensionsPrefix: "x-"
    }, i = {
      properties: {
        name: { type: "string" },
        url: { type: "string" },
        identifier: { type: "string" }
      },
      required: ["name"],
      extensionsPrefix: "x-"
    }, s = {
      properties: {
        title: { type: "string" },
        version: { type: "string" },
        description: { type: "string" },
        termsOfService: { type: "string" },
        summary: { type: "string" },
        contact: "Contact",
        license: "License",
        "x-logo": "Logo"
      },
      required: ["title", "version"],
      extensionsPrefix: "x-"
    }, o = {
      properties: {
        parameters: "NamedParameters",
        schemas: "NamedSchemas",
        responses: "NamedResponses",
        examples: "NamedExamples",
        requestBodies: "NamedRequestBodies",
        headers: "NamedHeaders",
        securitySchemes: "NamedSecuritySchemes",
        links: "NamedLinks",
        callbacks: "NamedCallbacks",
        pathItems: "NamedPathItems"
      },
      extensionsPrefix: "x-"
    }, a = {
      properties: {
        tags: {
          type: "array",
          items: { type: "string" }
        },
        summary: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs",
        operationId: { type: "string" },
        parameters: "ParameterList",
        security: "SecurityRequirementList",
        servers: "ServerList",
        requestBody: "RequestBody",
        responses: "Responses",
        deprecated: { type: "boolean" },
        callbacks: "CallbacksMap",
        "x-codeSamples": "XCodeSampleList",
        "x-code-samples": "XCodeSampleList",
        // deprecated
        "x-hideTryItPanel": { type: "boolean" }
      },
      extensionsPrefix: "x-"
    };
    e.Schema = {
      properties: {
        $id: { type: "string" },
        $anchor: { type: "string" },
        id: { type: "string" },
        $schema: { type: "string" },
        definitions: "NamedSchemas",
        $defs: "NamedSchemas",
        $vocabulary: { type: "string" },
        externalDocs: "ExternalDocs",
        discriminator: "Discriminator",
        title: { type: "string" },
        multipleOf: { type: "number", minimum: 0 },
        maximum: { type: "number" },
        minimum: { type: "number" },
        exclusiveMaximum: { type: "number" },
        exclusiveMinimum: { type: "number" },
        maxLength: { type: "integer", minimum: 0 },
        minLength: { type: "integer", minimum: 0 },
        pattern: { type: "string" },
        maxItems: { type: "integer", minimum: 0 },
        minItems: { type: "integer", minimum: 0 },
        uniqueItems: { type: "boolean" },
        maxProperties: { type: "integer", minimum: 0 },
        minProperties: { type: "integer", minimum: 0 },
        required: { type: "array", items: { type: "string" } },
        enum: { type: "array" },
        type: (u) => Array.isArray(u) ? {
          type: "array",
          items: { enum: ["object", "array", "string", "number", "integer", "boolean", "null"] }
        } : {
          enum: ["object", "array", "string", "number", "integer", "boolean", "null"]
        },
        allOf: (0, t.listOf)("Schema"),
        anyOf: (0, t.listOf)("Schema"),
        oneOf: (0, t.listOf)("Schema"),
        not: "Schema",
        if: "Schema",
        then: "Schema",
        else: "Schema",
        dependentSchemas: (0, t.mapOf)("Schema"),
        dependentRequired: "DependentRequired",
        prefixItems: (0, t.listOf)("Schema"),
        contains: "Schema",
        minContains: { type: "integer", minimum: 0 },
        maxContains: { type: "integer", minimum: 0 },
        patternProperties: "PatternProperties",
        propertyNames: "Schema",
        unevaluatedItems: (u) => typeof u == "boolean" ? { type: "boolean" } : "Schema",
        unevaluatedProperties: (u) => typeof u == "boolean" ? { type: "boolean" } : "Schema",
        summary: { type: "string" },
        properties: "SchemaProperties",
        items: (u) => typeof u == "boolean" ? { type: "boolean" } : "Schema",
        additionalProperties: (u) => typeof u == "boolean" ? { type: "boolean" } : "Schema",
        description: { type: "string" },
        format: { type: "string" },
        contentEncoding: { type: "string" },
        contentMediaType: { type: "string" },
        contentSchema: "Schema",
        default: null,
        readOnly: { type: "boolean" },
        writeOnly: { type: "boolean" },
        xml: "Xml",
        examples: { type: "array" },
        example: { isExample: !0 },
        deprecated: { type: "boolean" },
        const: null,
        $comment: { type: "string" },
        "x-tags": { type: "array", items: { type: "string" } },
        $dynamicAnchor: { type: "string" },
        $dynamicRef: { type: "string" }
      },
      extensionsPrefix: "x-"
    }, e.SchemaProperties = {
      properties: {},
      additionalProperties: (u) => typeof u == "boolean" ? { type: "boolean" } : "Schema"
    };
    const l = {
      properties: {
        type: { enum: ["apiKey", "http", "oauth2", "openIdConnect", "mutualTLS"] },
        description: { type: "string" },
        name: { type: "string" },
        in: { type: "string", enum: ["query", "header", "cookie"] },
        scheme: { type: "string" },
        bearerFormat: { type: "string" },
        flows: "OAuth2Flows",
        openIdConnectUrl: { type: "string" }
      },
      required(u) {
        switch (u == null ? void 0 : u.type) {
          case "apiKey":
            return ["type", "name", "in"];
          case "http":
            return ["type", "scheme"];
          case "oauth2":
            return ["type", "flows"];
          case "openIdConnect":
            return ["type", "openIdConnectUrl"];
          default:
            return ["type"];
        }
      },
      allowed(u) {
        switch (u == null ? void 0 : u.type) {
          case "apiKey":
            return ["type", "name", "in", "description"];
          case "http":
            return ["type", "scheme", "bearerFormat", "description"];
          case "oauth2":
            switch (u == null ? void 0 : u.flows) {
              case "implicit":
                return ["type", "flows", "authorizationUrl", "refreshUrl", "description", "scopes"];
              case "password":
              case "clientCredentials":
                return ["type", "flows", "tokenUrl", "refreshUrl", "description", "scopes"];
              case "authorizationCode":
                return [
                  "type",
                  "flows",
                  "authorizationUrl",
                  "refreshUrl",
                  "tokenUrl",
                  "description",
                  "scopes"
                ];
              default:
                return [
                  "type",
                  "flows",
                  "authorizationUrl",
                  "refreshUrl",
                  "tokenUrl",
                  "description",
                  "scopes"
                ];
            }
          case "openIdConnect":
            return ["type", "openIdConnectUrl", "description"];
          case "mutualTLS":
            return ["type", "description"];
          default:
            return ["type", "description"];
        }
      },
      extensionsPrefix: "x-"
    };
    e.DependentRequired = {
      properties: {},
      additionalProperties: { type: "array", items: { type: "string" } }
    }, e.Oas3_1Types = {
      ...r.Oas3Types,
      Info: s,
      Root: n,
      Schema: e.Schema,
      SchemaProperties: e.SchemaProperties,
      PatternProperties: e.SchemaProperties,
      License: i,
      Components: o,
      NamedPathItems: (0, t.mapOf)("PathItem"),
      SecurityScheme: l,
      Operation: a,
      DependentRequired: e.DependentRequired
    };
  }(Eb)), Eb;
}
var _b = {}, CA;
function iL() {
  return CA || (CA = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.AsyncApi2Types = e.AsyncApi2Bindings = e.Dependencies = e.SecuritySchemeFlows = e.Discriminator = e.DiscriminatorMapping = e.SchemaProperties = e.Schema = e.MessageExample = e.CorrelationId = e.License = e.Contact = e.ServerVariable = e.ServerMap = e.ExternalDocs = e.Tag = void 0;
    const t = Fn(), r = lu(), n = {
      properties: {
        asyncapi: null,
        // TODO: validate semver format and supported version
        info: "Info",
        id: { type: "string" },
        servers: "ServerMap",
        channels: "ChannelMap",
        components: "Components",
        tags: "TagList",
        externalDocs: "ExternalDocs",
        defaultContentType: { type: "string" }
      },
      required: ["asyncapi", "channels", "info"]
    }, i = {
      properties: {
        description: { type: "string" },
        subscribe: "Operation",
        publish: "Operation",
        parameters: "ParametersMap",
        bindings: "ChannelBindings",
        servers: { type: "array", items: { type: "string" } }
      }
    }, s = {
      properties: {},
      additionalProperties: "Channel"
    }, o = {
      properties: {},
      allowed() {
        return [
          "http",
          "ws",
          "kafka",
          "anypointmq",
          "amqp",
          "amqp1",
          "mqtt",
          "mqtt5",
          "nats",
          "jms",
          "sns",
          "solace",
          "sqs",
          "stomp",
          "redis",
          "mercure",
          "ibmmq",
          "googlepubsub",
          "pulsar"
        ];
      },
      additionalProperties: { type: "object" }
    };
    e.Tag = {
      properties: {
        name: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs"
      },
      required: ["name"]
    }, e.ExternalDocs = {
      properties: {
        description: { type: "string" },
        url: { type: "string" }
      },
      required: ["url"]
    };
    const a = {
      properties: {},
      additionalProperties: { type: "array", items: { type: "string" } }
    }, l = {
      properties: {},
      allowed() {
        return [
          "http",
          "ws",
          "kafka",
          "anypointmq",
          "amqp",
          "amqp1",
          "mqtt",
          "mqtt5",
          "nats",
          "jms",
          "sns",
          "solace",
          "sqs",
          "stomp",
          "redis",
          "mercure",
          "ibmmq",
          "googlepubsub",
          "pulsar"
        ];
      },
      additionalProperties: { type: "object" }
    }, u = {
      properties: {
        url: { type: "string" },
        protocol: { type: "string" },
        protocolVersion: { type: "string" },
        description: { type: "string" },
        variables: "ServerVariablesMap",
        security: "SecurityRequirementList",
        bindings: "ServerBindings",
        tags: "TagList"
      },
      required: ["url", "protocol"]
    };
    e.ServerMap = {
      properties: {},
      additionalProperties: (yt, zn) => (
        // eslint-disable-next-line no-useless-escape
        zn.match(/^[A-Za-z0-9_\-]+$/) ? "Server" : void 0
      )
    }, e.ServerVariable = {
      properties: {
        enum: {
          type: "array",
          items: { type: "string" }
        },
        default: { type: "string" },
        description: { type: "string" },
        examples: {
          type: "array",
          items: { type: "string" }
        }
      },
      required: []
    };
    const f = {
      properties: {
        title: { type: "string" },
        version: { type: "string" },
        description: { type: "string" },
        termsOfService: { type: "string" },
        contact: "Contact",
        license: "License"
      },
      required: ["title", "version"]
    };
    e.Contact = {
      properties: {
        name: { type: "string" },
        url: { type: "string" },
        email: { type: "string" }
      }
    }, e.License = {
      properties: {
        name: { type: "string" },
        url: { type: "string" }
      },
      required: ["name"]
    };
    const d = {
      properties: {
        description: { type: "string" },
        schema: "Schema",
        location: { type: "string" }
      }
    };
    e.CorrelationId = {
      properties: {
        description: { type: "string" },
        location: { type: "string" }
      },
      required: ["location"]
    };
    const m = {
      properties: {
        messageId: { type: "string" },
        headers: "Schema",
        payload: "Schema",
        // TODO: strictly this does not cover all cases
        correlationId: "CorrelationId",
        schemaFormat: { type: "string" },
        // TODO: support official list of schema formats and custom values
        contentType: { type: "string" },
        name: { type: "string" },
        title: { type: "string" },
        summary: { type: "string" },
        description: { type: "string" },
        tags: "TagList",
        externalDocs: "ExternalDocs",
        bindings: "MessageBindings",
        examples: "MessageExampleList",
        traits: "MessageTraitList"
      },
      additionalProperties: {}
    }, v = {
      properties: {},
      allowed() {
        return [
          "http",
          "ws",
          "kafka",
          "anypointmq",
          "amqp",
          "amqp1",
          "mqtt",
          "mqtt5",
          "nats",
          "jms",
          "sns",
          "solace",
          "sqs",
          "stomp",
          "redis",
          "mercure",
          "ibmmq",
          "googlepubsub",
          "pulsar"
        ];
      },
      additionalProperties: { type: "object" }
    }, S = {
      properties: {},
      allowed() {
        return [
          "http",
          "ws",
          "kafka",
          "anypointmq",
          "amqp",
          "amqp1",
          "mqtt",
          "mqtt5",
          "nats",
          "jms",
          "sns",
          "solace",
          "sqs",
          "stomp",
          "redis",
          "mercure",
          "ibmmq",
          "googlepubsub",
          "pulsar"
        ];
      },
      additionalProperties: { type: "object" }
    }, y = {
      properties: {
        tags: "TagList",
        summary: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs",
        operationId: { type: "string" },
        security: "SecurityRequirementList",
        bindings: "OperationBindings"
      },
      required: []
    }, E = {
      properties: {
        messageId: { type: "string" },
        headers: "Schema",
        correlationId: "CorrelationId",
        schemaFormat: { type: "string" },
        contentType: { type: "string" },
        name: { type: "string" },
        title: { type: "string" },
        summary: { type: "string" },
        description: { type: "string" },
        tags: "TagList",
        externalDocs: "ExternalDocs",
        bindings: "MessageBindings",
        examples: "MessageExampleList"
      },
      additionalProperties: {}
    }, x = {
      properties: {
        tags: "TagList",
        summary: { type: "string" },
        description: { type: "string" },
        externalDocs: "ExternalDocs",
        operationId: { type: "string" },
        security: "SecurityRequirementList",
        bindings: "OperationBindings",
        traits: "OperationTraitList",
        message: "Message"
      },
      required: []
    };
    e.MessageExample = {
      properties: {
        payload: { isExample: !0 },
        summary: { type: "string" },
        name: { type: "string" },
        headers: { type: "object" }
      }
    }, e.Schema = {
      properties: {
        $id: { type: "string" },
        $schema: { type: "string" },
        definitions: "NamedSchemas",
        externalDocs: "ExternalDocs",
        discriminator: "Discriminator",
        myArbitraryKeyword: { type: "boolean" },
        title: { type: "string" },
        multipleOf: { type: "number", minimum: 0 },
        maximum: { type: "number" },
        minimum: { type: "number" },
        exclusiveMaximum: { type: "number" },
        exclusiveMinimum: { type: "number" },
        maxLength: { type: "integer", minimum: 0 },
        minLength: { type: "integer", minimum: 0 },
        pattern: { type: "string" },
        maxItems: { type: "integer", minimum: 0 },
        minItems: { type: "integer", minimum: 0 },
        uniqueItems: { type: "boolean" },
        maxProperties: { type: "integer", minimum: 0 },
        minProperties: { type: "integer", minimum: 0 },
        required: { type: "array", items: { type: "string" } },
        enum: { type: "array" },
        type: (yt) => Array.isArray(yt) ? {
          type: "array",
          items: { enum: ["object", "array", "string", "number", "integer", "boolean", "null"] }
        } : {
          enum: ["object", "array", "string", "number", "integer", "boolean", "null"]
        },
        allOf: (0, t.listOf)("Schema"),
        anyOf: (0, t.listOf)("Schema"),
        oneOf: (0, t.listOf)("Schema"),
        not: "Schema",
        if: "Schema",
        then: "Schema",
        else: "Schema",
        contains: "Schema",
        patternProperties: { type: "object" },
        propertyNames: "Schema",
        properties: "SchemaProperties",
        items: (yt) => Array.isArray(yt) ? (0, t.listOf)("Schema") : "Schema",
        additionalProperties: (yt) => typeof yt == "boolean" ? { type: "boolean" } : "Schema",
        description: { type: "string" },
        format: { type: "string" },
        contentEncoding: { type: "string" },
        contentMediaType: { type: "string" },
        default: null,
        readOnly: { type: "boolean" },
        writeOnly: { type: "boolean" },
        examples: { type: "array" },
        example: { isExample: !0 },
        deprecated: { type: "boolean" },
        const: null,
        $comment: { type: "string" },
        additionalItems: (yt) => typeof yt == "boolean" ? { type: "boolean" } : "Schema",
        dependencies: "Dependencies"
      }
    }, e.SchemaProperties = {
      properties: {},
      additionalProperties: (yt) => typeof yt == "boolean" ? { type: "boolean" } : "Schema"
    }, e.DiscriminatorMapping = {
      properties: {},
      additionalProperties: (yt) => (0, r.isMappingRef)(yt) ? { type: "string", directResolveAs: "Schema" } : { type: "string" }
    }, e.Discriminator = {
      properties: {
        propertyName: { type: "string" },
        mapping: "DiscriminatorMapping"
      },
      required: ["propertyName"]
    };
    const g = {
      properties: {
        messages: "NamedMessages",
        parameters: "NamedParameters",
        schemas: "NamedSchemas",
        correlationIds: "NamedCorrelationIds",
        messageTraits: "NamedMessageTraits",
        operationTraits: "NamedOperationTraits",
        securitySchemes: "NamedSecuritySchemes",
        servers: "ServerMap",
        serverVariables: "ServerVariablesMap",
        channels: "ChannelMap",
        serverBindings: "ServerBindings",
        channelBindings: "ChannelBindings",
        operationBindings: "OperationBindings",
        messageBindings: "MessageBindings"
      }
    }, b = {
      properties: {
        refreshUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        authorizationUrl: { type: "string" }
      },
      required: ["authorizationUrl", "scopes"]
    }, A = {
      properties: {
        refreshUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        tokenUrl: { type: "string" }
      },
      required: ["tokenUrl", "scopes"]
    }, P = {
      properties: {
        refreshUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        tokenUrl: { type: "string" }
      },
      required: ["tokenUrl", "scopes"]
    }, k = {
      properties: {
        refreshUrl: { type: "string" },
        authorizationUrl: { type: "string" },
        scopes: { type: "object", additionalProperties: { type: "string" } },
        // TODO: validate scopes
        tokenUrl: { type: "string" }
      },
      required: ["authorizationUrl", "tokenUrl", "scopes"]
    };
    e.SecuritySchemeFlows = {
      properties: {
        implicit: "ImplicitFlow",
        password: "PasswordFlow",
        clientCredentials: "ClientCredentials",
        authorizationCode: "AuthorizationCode"
      }
    };
    const $ = {
      properties: {
        type: {
          enum: [
            "userPassword",
            "apiKey",
            "X509",
            "symmetricEncryption",
            "asymmetricEncryption",
            "httpApiKey",
            "http",
            "oauth2",
            "openIdConnect",
            "plain",
            "scramSha256",
            "scramSha512",
            "gssapi"
          ]
        },
        description: { type: "string" },
        name: { type: "string" },
        in: { type: "string", enum: ["query", "header", "cookie", "user", "password"] },
        scheme: { type: "string" },
        bearerFormat: { type: "string" },
        flows: "SecuritySchemeFlows",
        openIdConnectUrl: { type: "string" }
      },
      required(yt) {
        switch (yt == null ? void 0 : yt.type) {
          case "apiKey":
            return ["type", "in"];
          case "httpApiKey":
            return ["type", "name", "in"];
          case "http":
            return ["type", "scheme"];
          case "oauth2":
            return ["type", "flows"];
          case "openIdConnect":
            return ["type", "openIdConnectUrl"];
          default:
            return ["type"];
        }
      },
      allowed(yt) {
        switch (yt == null ? void 0 : yt.type) {
          case "apiKey":
            return ["type", "in", "description"];
          case "httpApiKey":
            return ["type", "name", "in", "description"];
          case "http":
            return ["type", "scheme", "bearerFormat", "description"];
          case "oauth2":
            return ["type", "flows", "description"];
          case "openIdConnect":
            return ["type", "openIdConnectUrl", "description"];
          default:
            return ["type", "description"];
        }
      },
      extensionsPrefix: "x-"
    };
    e.Dependencies = {
      properties: {},
      additionalProperties: (yt) => Array.isArray(yt) ? { type: "array", items: { type: "string" } } : "Schema"
    };
    const I = {
      properties: {}
      // empty object
    };
    o.properties.http = I;
    const F = {
      properties: {}
      // empty object
    };
    l.properties.http = F;
    const L = {
      properties: {
        headers: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    v.properties.http = L;
    const Q = {
      properties: {
        type: { type: "string" },
        method: {
          type: "string",
          enum: ["GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS", "CONNECT", "TRACE"]
        },
        headers: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    S.properties.http = Q;
    const Y = {
      properties: {
        method: { type: "string" },
        query: "Schema",
        headers: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    o.properties.ws = Y;
    const ae = {
      properties: {}
      // empty object
    };
    l.properties.ws = ae;
    const le = {
      properties: {}
      // empty object
    };
    v.properties.ws = le;
    const ue = {
      properties: {}
      // empty object
    };
    S.properties.ws = ue;
    const ce = {
      properties: {
        "cleanup.policy": { type: "array", items: { enum: ["delete", "compact"] } },
        "retention.ms": { type: "integer" },
        "retention.bytes": { type: "integer" },
        "delete.retention.ms": { type: "integer" },
        "max.message.bytes": { type: "integer" }
      }
    }, be = {
      properties: {
        topic: { type: "string" },
        partitions: { type: "integer" },
        replicas: { type: "integer" },
        topicConfiguration: "KafkaTopicConfiguration",
        bindingVersion: { type: "string" }
      }
    };
    o.properties.kafka = be;
    const G = {
      properties: {}
      // empty object
    };
    l.properties.kafka = G;
    const ee = {
      properties: {
        key: "Schema",
        // TODO: add avro support
        schemaIdLocation: { type: "string" },
        schemaIdPayloadEncoding: { type: "string" },
        schemaLookupStrategy: { type: "string" },
        bindingVersion: { type: "string" }
      }
    };
    v.properties.kafka = ee;
    const K = {
      properties: {
        groupId: "Schema",
        clientId: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    S.properties.kafka = K;
    const z = {
      properties: {
        destination: { type: "string" },
        destinationType: { type: "string" },
        bindingVersion: { type: "string" }
      }
    };
    o.properties.anypointmq = z;
    const te = {
      properties: {}
      // empty object
    };
    l.properties.anypointmq = te;
    const q = {
      properties: {
        headers: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    v.properties.anypointmq = q;
    const j = {
      properties: {}
      // empty object
    };
    S.properties.anypointmq = j;
    const H = {
      properties: {}
      // empty object
    };
    o.properties.amqp = H;
    const B = {
      properties: {}
      // empty object
    };
    l.properties.amqp = B;
    const pe = {
      properties: {
        contentEncoding: { type: "string" },
        messageType: { type: "string" },
        bindingVersion: { type: "string" }
      }
    };
    v.properties.amqp = pe;
    const he = {
      // TODO: some fields are subscribe only
      properties: {
        expiration: { type: "integer" },
        userId: { type: "string" },
        cc: { type: "array", items: { type: "string" } },
        priority: { type: "integer" },
        deliveryMode: { type: "integer" },
        // TODO: enum: [1, 2]
        mandatory: { type: "boolean" },
        bcc: { type: "array", items: { type: "string" } },
        replyTo: { type: "string" },
        timestamp: { type: "boolean" },
        ack: { type: "boolean" },
        bindingVersion: { type: "string" }
      }
    };
    S.properties.amqp = he;
    const Ae = {
      properties: {}
      // empty object
    };
    o.properties.amqp1 = Ae;
    const C = {
      properties: {}
      // empty object
    };
    l.properties.amqp1 = C;
    const N = {
      properties: {}
      // empty object
    };
    v.properties.amqp1 = N;
    const J = {
      properties: {}
      // empty object
    };
    S.properties.amqp1 = J;
    const X = {
      properties: {
        qos: { type: "integer" },
        retain: { type: "boolean" },
        bindingVersion: { type: "string" }
      }
    };
    o.properties.mqtt = X;
    const oe = {
      properties: {
        topic: { type: "string" },
        qos: { type: "integer" },
        message: { type: "string" },
        retain: { type: "boolean" }
      }
    }, U = {
      properties: {
        clientId: { type: "string" },
        cleanSession: { type: "boolean" },
        lastWill: "MqttServerBindingLastWill",
        keepAlive: { type: "integer" },
        bindingVersion: { type: "string" }
      }
    };
    l.properties.mqtt = U;
    const V = {
      properties: {
        bindingVersion: { type: "string" }
      }
    };
    v.properties.mqtt = V;
    const ye = {
      properties: {
        qos: { type: "integer" },
        retain: { type: "boolean" },
        bindingVersion: { type: "string" }
      }
    };
    S.properties.mqtt = ye;
    const de = {
      properties: {}
      // empty object
    };
    o.properties.mqtt5 = de;
    const Ce = {
      properties: {}
      // empty object
    };
    l.properties.mqtt5 = Ce;
    const Se = {
      properties: {}
      // empty object
    };
    v.properties.mqtt5 = Se;
    const O = {
      properties: {}
      // empty object
    };
    S.properties.mqtt5 = O;
    const M = {
      properties: {}
      // empty object
    };
    o.properties.nats = M;
    const se = {
      properties: {}
      // empty object
    };
    l.properties.nats = se;
    const ve = {
      properties: {}
      // empty object
    };
    v.properties.nats = ve;
    const ge = {
      properties: {
        queue: { type: "string" },
        bindingVersion: { type: "string" }
      }
    };
    S.properties.nats = ge;
    const Oe = {
      properties: {
        destination: { type: "string" },
        destinationType: { type: "string" },
        bindingVersion: { type: "string" }
      }
    };
    o.properties.jms = Oe;
    const ke = {
      properties: {}
      // empty object
    };
    l.properties.jms = ke;
    const Me = {
      properties: {
        headers: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    v.properties.jms = Me;
    const Ve = {
      properties: {
        headers: "Schema",
        bindingVersion: { type: "string" }
      }
    };
    S.properties.jms = Ve;
    const Je = {
      properties: {}
      // empty object
    };
    o.properties.solace = Je;
    const He = {
      properties: {
        bindingVersion: { type: "string" },
        msgVpn: { type: "string" }
      }
    };
    l.properties.solace = He;
    const Ue = {
      properties: {}
      // empty object
    };
    v.properties.solace = Ue;
    const Ot = {
      properties: {
        destinationType: { type: "string", enum: ["queue", "topic"] },
        deliveryMode: { type: "string", enum: ["direct", "persistent"] },
        "queue.name": { type: "string" },
        "queue.topicSubscriptions": { type: "array", items: { type: "string" } },
        "queue.accessType": { type: "string", enum: ["exclusive", "nonexclusive"] },
        "queue.maxMsgSpoolSize": { type: "string" },
        "queue.maxTtl": { type: "string" },
        "topic.topicSubscriptions": { type: "array", items: { type: "string" } }
      }
    }, D = {
      properties: {
        bindingVersion: { type: "string" },
        destinations: (0, t.listOf)("SolaceDestination")
      }
    };
    S.properties.solace = D;
    const we = {
      properties: {}
      // empty object
    };
    o.properties.stomp = we;
    const Ee = {
      properties: {}
      // empty object
    };
    l.properties.stomp = Ee;
    const _e = {
      properties: {}
      // empty object
    };
    v.properties.stomp = _e;
    const Te = {
      properties: {}
      // empty object
    };
    S.properties.stomp = Te;
    const $e = {
      properties: {}
      // empty object
    };
    o.properties.redis = $e;
    const Be = {
      properties: {}
      // empty object
    };
    l.properties.redis = Be;
    const Pe = {
      properties: {}
      // empty object
    };
    v.properties.redis = Pe;
    const Re = {
      properties: {}
      // empty object
    };
    S.properties.redis = Re;
    const Qe = {
      properties: {}
      // empty object
    };
    o.properties.mercure = Qe;
    const ht = {
      properties: {}
      // empty object
    };
    l.properties.mercure = ht;
    const rt = {
      properties: {}
      // empty object
    };
    v.properties.mercure = rt;
    const ut = {
      properties: {}
      // empty object
    };
    S.properties.mercure = ut, e.AsyncApi2Bindings = {
      HttpServerBinding: F,
      HttpChannelBinding: I,
      HttpMessageBinding: L,
      HttpOperationBinding: Q,
      WsServerBinding: ae,
      WsChannelBinding: Y,
      WsMessageBinding: le,
      WsOperationBinding: ue,
      KafkaServerBinding: G,
      KafkaTopicConfiguration: ce,
      KafkaChannelBinding: be,
      KafkaMessageBinding: ee,
      KafkaOperationBinding: K,
      AnypointmqServerBinding: te,
      AnypointmqChannelBinding: z,
      AnypointmqMessageBinding: q,
      AnypointmqOperationBinding: j,
      AmqpServerBinding: B,
      AmqpChannelBinding: H,
      AmqpMessageBinding: pe,
      AmqpOperationBinding: he,
      Amqp1ServerBinding: C,
      Amqp1ChannelBinding: Ae,
      Amqp1MessageBinding: N,
      Amqp1OperationBinding: J,
      MqttServerBindingLastWill: oe,
      MqttServerBinding: U,
      MqttChannelBinding: X,
      MqttMessageBinding: V,
      MqttOperationBinding: ye,
      Mqtt5ServerBinding: Ce,
      Mqtt5ChannelBinding: de,
      Mqtt5MessageBinding: Se,
      Mqtt5OperationBinding: O,
      NatsServerBinding: se,
      NatsChannelBinding: M,
      NatsMessageBinding: ve,
      NatsOperationBinding: ge,
      JmsServerBinding: ke,
      JmsChannelBinding: Oe,
      JmsMessageBinding: Me,
      JmsOperationBinding: Ve,
      SolaceServerBinding: He,
      SolaceChannelBinding: Je,
      SolaceMessageBinding: Ue,
      SolaceDestination: Ot,
      SolaceOperationBinding: D,
      StompServerBinding: Ee,
      StompChannelBinding: we,
      StompMessageBinding: _e,
      StompOperationBinding: Te,
      RedisServerBinding: Be,
      RedisChannelBinding: $e,
      RedisMessageBinding: Pe,
      RedisOperationBinding: Re,
      MercureServerBinding: ht,
      MercureChannelBinding: Qe,
      MercureMessageBinding: rt,
      MercureOperationBinding: ut,
      ServerBindings: l,
      ChannelBindings: o,
      MessageBindings: v,
      OperationBindings: S
    }, e.AsyncApi2Types = {
      ...e.AsyncApi2Bindings,
      Root: n,
      Tag: e.Tag,
      TagList: (0, t.listOf)("Tag"),
      ServerMap: e.ServerMap,
      ExternalDocs: e.ExternalDocs,
      Server: u,
      ServerVariable: e.ServerVariable,
      ServerVariablesMap: (0, t.mapOf)("ServerVariable"),
      SecurityRequirement: a,
      SecurityRequirementList: (0, t.listOf)("SecurityRequirement"),
      Info: f,
      Contact: e.Contact,
      License: e.License,
      ChannelMap: s,
      Channel: i,
      Parameter: d,
      ParametersMap: (0, t.mapOf)("Parameter"),
      Operation: x,
      Schema: e.Schema,
      MessageExample: e.MessageExample,
      SchemaProperties: e.SchemaProperties,
      DiscriminatorMapping: e.DiscriminatorMapping,
      Discriminator: e.Discriminator,
      Components: g,
      NamedSchemas: (0, t.mapOf)("Schema"),
      NamedMessages: (0, t.mapOf)("Message"),
      NamedMessageTraits: (0, t.mapOf)("MessageTrait"),
      NamedOperationTraits: (0, t.mapOf)("OperationTrait"),
      NamedParameters: (0, t.mapOf)("Parameter"),
      NamedSecuritySchemes: (0, t.mapOf)("SecurityScheme"),
      NamedCorrelationIds: (0, t.mapOf)("CorrelationId"),
      ImplicitFlow: b,
      PasswordFlow: A,
      ClientCredentials: P,
      AuthorizationCode: k,
      SecuritySchemeFlows: e.SecuritySchemeFlows,
      SecurityScheme: $,
      Message: m,
      MessageBindings: v,
      OperationBindings: S,
      OperationTrait: y,
      OperationTraitList: (0, t.listOf)("OperationTrait"),
      MessageTrait: E,
      MessageTraitList: (0, t.listOf)("MessageTrait"),
      MessageExampleList: (0, t.listOf)("MessageExample"),
      CorrelationId: e.CorrelationId,
      Dependencies: e.Dependencies
    };
  }(_b)), _b;
}
var Xu = {}, $A;
function M9() {
  if ($A) return Xu;
  $A = 1, Object.defineProperty(Xu, "__esModule", { value: !0 }), Xu.AsyncApi3Types = void 0;
  const e = Fn(), t = iL(), r = {
    properties: {
      asyncapi: { type: "string", enum: ["3.0.0"] },
      info: "Info",
      id: { type: "string" },
      servers: "ServerMap",
      channels: "NamedChannels",
      components: "Components",
      operations: "NamedOperations",
      defaultContentType: { type: "string" }
    },
    required: ["asyncapi", "info"]
  }, n = {
    properties: {
      address: { type: "string" },
      messages: "NamedMessages",
      title: { type: "string" },
      summary: { type: "string" },
      description: { type: "string" },
      servers: "ServerList",
      parameters: "ParametersMap",
      bindings: "ChannelBindings",
      tags: "TagList",
      externalDocs: "ExternalDocs"
    }
  }, i = {
    properties: {
      host: { type: "string" },
      pathname: { type: "string" },
      protocol: { type: "string" },
      protocolVersion: { type: "string" },
      description: { type: "string" },
      variables: "ServerVariablesMap",
      security: "SecuritySchemeList",
      bindings: "ServerBindings",
      externalDocs: "ExternalDocs",
      tags: "TagList"
    },
    required: ["host", "protocol"]
  }, s = {
    properties: {
      title: { type: "string" },
      version: { type: "string" },
      description: { type: "string" },
      termsOfService: { type: "string" },
      contact: "Contact",
      license: "License",
      tags: "TagList",
      externalDocs: "ExternalDocs"
    },
    required: ["title", "version"]
  }, o = {
    properties: {
      description: { type: "string" },
      enum: { type: "array", items: { type: "string" } },
      default: { type: "string" },
      examples: { type: "array", items: { type: "string" } },
      location: { type: "string" }
    }
  }, a = {
    properties: {
      headers: "Schema",
      payload: (b) => b && (b != null && b.schemaFormat) ? {
        properties: {
          schema: "Schema",
          schemaFormat: { type: "string" }
        },
        required: ["schema", "schemaFormat"]
      } : "Schema",
      correlationId: "CorrelationId",
      contentType: { type: "string" },
      name: { type: "string" },
      title: { type: "string" },
      summary: { type: "string" },
      description: { type: "string" },
      tags: "TagList",
      externalDocs: "ExternalDocs",
      bindings: "MessageBindings",
      examples: "MessageExampleList",
      traits: "MessageTraitList"
    },
    additionalProperties: {}
  }, l = {
    properties: {
      tags: "TagList",
      title: { type: "string" },
      summary: { type: "string" },
      description: { type: "string" },
      externalDocs: "ExternalDocs",
      security: "SecuritySchemeList",
      bindings: "OperationBindings"
    },
    required: []
  }, u = {
    properties: {
      headers: (b) => typeof b == "function" || typeof b == "object" && b ? {
        properties: {
          schema: "Schema",
          schemaFormat: { type: "string" }
        }
      } : "Schema",
      correlationId: "CorrelationId",
      contentType: { type: "string" },
      name: { type: "string" },
      title: { type: "string" },
      summary: { type: "string" },
      description: { type: "string" },
      tags: "TagList",
      externalDocs: "ExternalDocs",
      bindings: "MessageBindings",
      examples: "MessageExampleList"
    },
    additionalProperties: {}
  }, f = {
    properties: {
      action: { type: "string", enum: ["send", "receive"] },
      channel: "Channel",
      title: { type: "string" },
      tags: "TagList",
      summary: { type: "string" },
      description: { type: "string" },
      externalDocs: "ExternalDocs",
      operationId: { type: "string" },
      security: "SecuritySchemeList",
      bindings: "OperationBindings",
      traits: "OperationTraitList",
      messages: "MessageList",
      reply: "OperationReply"
    },
    required: ["action", "channel"]
  }, d = {
    properties: {
      channel: "Channel",
      messages: "MessageList",
      address: "OperationReplyAddress"
    }
  }, m = {
    properties: {
      location: { type: "string" },
      description: { type: "string" }
    },
    required: ["location"]
  }, v = {
    properties: {
      messages: "NamedMessages",
      parameters: "NamedParameters",
      schemas: "NamedSchemas",
      replies: "NamedOperationReplies",
      replyAddresses: "NamedOperationRelyAddresses",
      correlationIds: "NamedCorrelationIds",
      messageTraits: "NamedMessageTraits",
      operationTraits: "NamedOperationTraits",
      tags: "NamedTags",
      externalDocs: "NamedExternalDocs",
      securitySchemes: "NamedSecuritySchemes",
      servers: "ServerMap",
      serverVariables: "ServerVariablesMap",
      channels: "NamedChannels",
      operations: "NamedOperations",
      serverBindings: "ServerBindings",
      channelBindings: "ChannelBindings",
      operationBindings: "OperationBindings",
      messageBindings: "MessageBindings"
    }
  }, S = {
    properties: {
      refreshUrl: { type: "string" },
      availableScopes: { type: "object", additionalProperties: { type: "string" } },
      authorizationUrl: { type: "string" }
    },
    required: ["authorizationUrl", "availableScopes"]
  }, y = {
    properties: {
      refreshUrl: { type: "string" },
      availableScopes: { type: "object", additionalProperties: { type: "string" } },
      tokenUrl: { type: "string" }
    },
    required: ["tokenUrl", "availableScopes"]
  }, E = {
    properties: {
      refreshUrl: { type: "string" },
      availableScopes: { type: "object", additionalProperties: { type: "string" } },
      tokenUrl: { type: "string" }
    },
    required: ["tokenUrl", "availableScopes"]
  }, x = {
    properties: {
      refreshUrl: { type: "string" },
      authorizationUrl: { type: "string" },
      availableScopes: { type: "object", additionalProperties: { type: "string" } },
      tokenUrl: { type: "string" }
    },
    required: ["authorizationUrl", "tokenUrl", "availableScopes"]
  }, g = {
    properties: {
      type: {
        enum: [
          "userPassword",
          "apiKey",
          "X509",
          "symmetricEncryption",
          "asymmetricEncryption",
          "httpApiKey",
          "http",
          "oauth2",
          "openIdConnect",
          "plain",
          "scramSha256",
          "scramSha512",
          "gssapi"
        ]
      },
      description: { type: "string" },
      name: { type: "string" },
      in: { type: "string", enum: ["query", "header", "cookie", "user", "password"] },
      scheme: { type: "string" },
      bearerFormat: { type: "string" },
      flows: "SecuritySchemeFlows",
      openIdConnectUrl: { type: "string" },
      scopes: { type: "array", items: { type: "string" } }
    },
    required(b) {
      switch (b == null ? void 0 : b.type) {
        case "apiKey":
          return ["type", "in"];
        case "httpApiKey":
          return ["type", "name", "in"];
        case "http":
          return ["type", "scheme"];
        case "oauth2":
          return ["type", "flows"];
        case "openIdConnect":
          return ["type", "openIdConnectUrl"];
        default:
          return ["type"];
      }
    },
    allowed(b) {
      switch (b == null ? void 0 : b.type) {
        case "apiKey":
          return ["type", "in", "description"];
        case "httpApiKey":
          return ["type", "name", "in", "description"];
        case "http":
          return ["type", "scheme", "bearerFormat", "description"];
        case "oauth2":
          return ["type", "flows", "description", "scopes"];
        case "openIdConnect":
          return ["type", "openIdConnectUrl", "description", "scopes"];
        default:
          return ["type", "description"];
      }
    },
    extensionsPrefix: "x-"
  };
  return Xu.AsyncApi3Types = {
    // from asyncapi2
    ...t.AsyncApi2Bindings,
    CorrelationId: t.CorrelationId,
    SecuritySchemeFlows: t.SecuritySchemeFlows,
    ServerVariable: t.ServerVariable,
    Contact: t.Contact,
    License: t.License,
    MessageExample: t.MessageExample,
    Tag: t.Tag,
    Dependencies: t.Dependencies,
    Schema: t.Schema,
    Discriminator: t.Discriminator,
    DiscriminatorMapping: t.DiscriminatorMapping,
    SchemaProperties: t.SchemaProperties,
    ServerMap: t.ServerMap,
    ExternalDocs: t.ExternalDocs,
    Root: r,
    Channel: n,
    Parameter: o,
    Info: s,
    Server: i,
    MessageTrait: u,
    Operation: f,
    OperationReply: d,
    OperationReplyAddress: m,
    Components: v,
    ImplicitFlow: S,
    PasswordFlow: y,
    ClientCredentials: E,
    AuthorizationCode: x,
    SecurityScheme: g,
    Message: a,
    OperationTrait: l,
    ServerVariablesMap: (0, e.mapOf)("ServerVariable"),
    NamedTags: (0, e.mapOf)("Tag"),
    NamedExternalDocs: (0, e.mapOf)("ExternalDocs"),
    NamedChannels: (0, e.mapOf)("Channel"),
    ParametersMap: (0, e.mapOf)("Parameter"),
    NamedOperations: (0, e.mapOf)("Operation"),
    NamedOperationReplies: (0, e.mapOf)("OperationReply"),
    NamedOperationRelyAddresses: (0, e.mapOf)("OperationReplyAddress"),
    NamedSchemas: (0, e.mapOf)("Schema"),
    NamedMessages: (0, e.mapOf)("Message"),
    NamedMessageTraits: (0, e.mapOf)("MessageTrait"),
    NamedOperationTraits: (0, e.mapOf)("OperationTrait"),
    NamedParameters: (0, e.mapOf)("Parameter"),
    NamedSecuritySchemes: (0, e.mapOf)("SecurityScheme"),
    NamedCorrelationIds: (0, e.mapOf)("CorrelationId"),
    ServerList: (0, e.listOf)("Server"),
    SecuritySchemeList: (0, e.listOf)("SecurityScheme"),
    MessageList: (0, e.listOf)("Message"),
    OperationTraitList: (0, e.listOf)("OperationTrait"),
    MessageTraitList: (0, e.listOf)("MessageTrait"),
    MessageExampleList: (0, e.listOf)("MessageExample"),
    TagList: (0, e.listOf)("Tag")
  }, Xu;
}
var Ju = {}, RA;
function D9() {
  if (RA) return Ju;
  RA = 1, Object.defineProperty(Ju, "__esModule", { value: !0 }), Ju.Arazzo1Types = void 0;
  const e = Fn(), t = nL(), r = g1(), n = {
    properties: {
      arazzo: { type: "string" },
      info: "Info",
      sourceDescriptions: "SourceDescriptions",
      workflows: "Workflows",
      components: "Components"
    },
    required: ["arazzo", "info", "sourceDescriptions", "workflows"],
    extensionsPrefix: "x-"
  }, i = {
    properties: {},
    additionalProperties: "Parameter"
  }, s = {
    properties: {},
    additionalProperties: "SuccessActionObject"
  }, o = {
    properties: {},
    additionalProperties: "FailureActionObject"
  }, a = {
    properties: {
      inputs: "NamedInputs",
      parameters: "NamedParameters",
      successActions: "NamedSuccessActions",
      failureActions: "NamedFailureActions"
    },
    extensionsPrefix: "x-"
  }, l = (0, e.mapOf)("Schema"), u = {
    properties: {
      title: { type: "string" },
      description: { type: "string" },
      summary: { type: "string" },
      version: { type: "string" }
    },
    required: ["title", "version"],
    extensionsPrefix: "x-"
  }, f = {
    properties: {},
    items: (ue) => (ue == null ? void 0 : ue.type) === "openapi" ? "OpenAPISourceDescription" : "ArazzoSourceDescription"
  }, d = {
    properties: {
      name: { type: "string" },
      type: { type: "string", enum: ["openapi"] },
      url: { type: "string" },
      "x-serverUrl": { type: "string" }
    },
    required: ["name", "type", "url"],
    extensionsPrefix: "x-"
  }, m = {
    properties: {
      name: { type: "string" },
      type: { type: "string", enum: ["arazzo"] },
      url: { type: "string" }
    },
    required: ["name", "type", "url"],
    extensionsPrefix: "x-"
  }, v = {
    properties: {
      reference: { type: "string" },
      value: {}
      // any
    },
    required: ["reference"],
    extensionsPrefix: "x-"
  }, S = {
    properties: {
      in: { type: "string", enum: ["header", "query", "path", "cookie"] },
      name: { type: "string" },
      value: {}
      // any
    },
    required: ["name", "value"],
    extensionsPrefix: "x-"
  }, y = {
    properties: {},
    items: (ue) => ue != null && ue.reference ? "ReusableObject" : "Parameter"
  }, E = {
    properties: {
      workflowId: { type: "string" },
      summary: { type: "string" },
      description: { type: "string" },
      parameters: "Parameters",
      dependsOn: { type: "array", items: { type: "string" } },
      inputs: "Schema",
      outputs: "Outputs",
      steps: "Steps",
      successActions: "OnSuccessActionList",
      failureActions: "OnFailureActionList"
    },
    required: ["workflowId", "steps"],
    extensionsPrefix: "x-"
  }, x = (0, e.listOf)("Workflow"), g = (0, e.listOf)("Step"), b = {
    properties: {
      stepId: { type: "string" },
      description: { type: "string" },
      operationId: { type: "string" },
      operationPath: { type: "string" },
      workflowId: { type: "string" },
      parameters: "Parameters",
      successCriteria: (0, e.listOf)("CriterionObject"),
      onSuccess: "OnSuccessActionList",
      onFailure: "OnFailureActionList",
      outputs: "Outputs",
      "x-operation": "ExtendedOperation",
      requestBody: "RequestBody"
    },
    required: ["stepId"],
    requiredOneOf: ["x-operation", "operationId", "operationPath", "workflowId"],
    extensionsPrefix: "x-"
  }, A = {
    properties: {},
    additionalProperties: {
      type: "string"
    }
  }, P = {
    properties: {
      contentType: { type: "string" },
      payload: {},
      replacements: (0, e.listOf)("Replacement")
    },
    required: ["payload"],
    extensionsPrefix: "x-"
  }, k = {
    properties: {
      target: { type: "string" },
      value: {}
    },
    required: ["target", "value"],
    extensionsPrefix: "x-"
  }, $ = {
    properties: {
      url: { type: "string" },
      method: {
        enum: [
          "get",
          "post",
          "put",
          "delete",
          "patch",
          "head",
          "options",
          "trace",
          "connect",
          "query",
          "GET",
          "POST",
          "PUT",
          "DELETE",
          "PATCH",
          "OPTIONS",
          "HEAD",
          "TRACE",
          "CONNECT",
          "QUERY"
        ]
      }
    },
    required: ["url", "method"]
  }, I = {
    properties: {
      condition: { type: "string" },
      context: { type: "string" },
      type: (ue) => {
        if (ue)
          return typeof ue == "string" ? { enum: ["regex", "jsonpath", "simple", "xpath"] } : (ue == null ? void 0 : ue.type) === "jsonpath" ? "JSONPathCriterion" : "XPathCriterion";
      }
    },
    required: ["condition"]
  }, F = {
    properties: {
      type: { type: "string", enum: ["jsonpath"] },
      version: { type: "string", enum: ["draft-goessner-dispatch-jsonpath-00"] }
    }
  }, L = {
    properties: {
      type: { type: "string", enum: ["xpath"] },
      version: { type: "string", enum: ["xpath-30", "xpath-20", "xpath-10"] }
    }
  }, Q = {
    properties: {
      name: { type: "string" },
      type: { type: "string", enum: ["goto", "end"] },
      stepId: { type: "string" },
      workflowId: { type: "string" },
      criteria: (0, e.listOf)("CriterionObject")
    },
    required: ["type", "name"]
  }, Y = {
    properties: {},
    items: (ue) => ue != null && ue.type && (ue != null && ue.name) ? "SuccessActionObject" : "ReusableObject"
  }, ae = {
    properties: {
      name: { type: "string" },
      type: { type: "string", enum: ["goto", "retry", "end"] },
      workflowId: { type: "string" },
      stepId: { type: "string" },
      retryAfter: { type: "number" },
      retryLimit: { type: "number" },
      criteria: (0, e.listOf)("CriterionObject")
    },
    required: ["type", "name"]
  }, le = {
    properties: {},
    items: (ue) => ue != null && ue.type && (ue != null && ue.name) ? "FailureActionObject" : "ReusableObject"
  };
  return Ju.Arazzo1Types = {
    Root: n,
    Info: u,
    SourceDescriptions: f,
    OpenAPISourceDescription: d,
    ArazzoSourceDescription: m,
    Parameters: y,
    Parameter: S,
    ReusableObject: v,
    Workflows: x,
    Workflow: E,
    Steps: g,
    Step: b,
    RequestBody: P,
    Replacement: k,
    ExtendedOperation: $,
    Outputs: A,
    CriterionObject: I,
    XPathCriterion: L,
    JSONPathCriterion: F,
    SuccessActionObject: Q,
    OnSuccessActionList: Y,
    FailureActionObject: ae,
    OnFailureActionList: le,
    Schema: t.Schema,
    NamedSchemas: (0, e.mapOf)("Schema"),
    ExternalDocs: r.ExternalDocs,
    DiscriminatorMapping: r.DiscriminatorMapping,
    Discriminator: r.Discriminator,
    DependentRequired: t.DependentRequired,
    SchemaProperties: t.SchemaProperties,
    PatternProperties: t.SchemaProperties,
    Components: a,
    NamedInputs: l,
    NamedParameters: i,
    NamedSuccessActions: s,
    NamedFailureActions: o,
    Xml: r.Xml
  }, Ju;
}
var Zu = {}, IA;
function F9() {
  if (IA) return Zu;
  IA = 1, Object.defineProperty(Zu, "__esModule", { value: !0 }), Zu.Overlay1Types = void 0;
  const e = Fn(), t = {
    properties: {
      overlay: { type: "string" },
      info: "Info",
      extends: { type: "string" },
      actions: "Actions"
    },
    required: ["overlay", "info", "actions"],
    extensionsPrefix: "x-"
  }, r = {
    properties: {
      title: { type: "string" },
      version: { type: "string" }
    },
    required: ["title", "version"],
    extensionsPrefix: "x-"
  }, n = (0, e.listOf)("Action"), i = {
    properties: {
      target: { type: "string" },
      description: { type: "string" },
      update: {},
      // any
      remove: { type: "boolean" }
    },
    required: ["target"],
    extensionsPrefix: "x-"
  };
  return Zu.Overlay1Types = {
    Root: t,
    Info: r,
    Actions: n,
    Action: i
  }, Zu;
}
var zs = {}, NA;
function z9() {
  return NA || (NA = 1, Object.defineProperty(zs, "__esModule", { value: !0 }), zs.ARAZZO_VERSIONS_SUPPORTED_BY_RESPECT = zs.VERSION_PATTERN = void 0, zs.VERSION_PATTERN = /^1\.0\.\d+(-.+)?$/, zs.ARAZZO_VERSIONS_SUPPORTED_BY_RESPECT = ["1.0.1"]), zs;
}
var jA;
function y1() {
  if (jA) return xi;
  jA = 1, Object.defineProperty(xi, "__esModule", { value: !0 }), xi.SpecMajorVersion = xi.SpecVersion = void 0, xi.detectSpec = m, xi.getMajorSpecVersion = v, xi.getTypes = S;
  const e = L9(), t = g1(), r = nL(), n = iL(), i = M9(), s = D9(), o = F9(), a = xn(), l = z9();
  var u;
  (function(y) {
    y.OAS2 = "oas2", y.OAS3_0 = "oas3_0", y.OAS3_1 = "oas3_1", y.Async2 = "async2", y.Async3 = "async3", y.Arazzo1 = "arazzo1", y.Overlay1 = "overlay1";
  })(u || (xi.SpecVersion = u = {}));
  var f;
  (function(y) {
    y.OAS2 = "oas2", y.OAS3 = "oas3", y.Async2 = "async2", y.Async3 = "async3", y.Arazzo1 = "arazzo1", y.Overlay1 = "overlay1";
  })(f || (xi.SpecMajorVersion = f = {}));
  const d = {
    [u.OAS2]: e.Oas2Types,
    [u.OAS3_0]: t.Oas3Types,
    [u.OAS3_1]: r.Oas3_1Types,
    [u.Async2]: n.AsyncApi2Types,
    [u.Async3]: i.AsyncApi3Types,
    [u.Arazzo1]: s.Arazzo1Types,
    [u.Overlay1]: o.Overlay1Types
  };
  function m(y) {
    if (!(0, a.isPlainObject)(y))
      throw new Error(`Document must be JSON object, got ${typeof y}`);
    if (y.openapi && typeof y.openapi != "string")
      throw new Error(`Invalid OpenAPI version: should be a string but got "${typeof y.openapi}"`);
    if (typeof y.openapi == "string" && y.openapi.startsWith("3.0"))
      return u.OAS3_0;
    if (typeof y.openapi == "string" && y.openapi.startsWith("3.1"))
      return u.OAS3_1;
    if (y.swagger && y.swagger === "2.0")
      return u.OAS2;
    if (y.openapi || y.swagger)
      throw new Error(`Unsupported OpenAPI version: ${y.openapi || y.swagger}`);
    if (typeof y.asyncapi == "string" && y.asyncapi.startsWith("2."))
      return u.Async2;
    if (typeof y.asyncapi == "string" && y.asyncapi.startsWith("3."))
      return u.Async3;
    if (y.asyncapi)
      throw new Error(`Unsupported AsyncAPI version: ${y.asyncapi}`);
    if (typeof y.arazzo == "string" && l.VERSION_PATTERN.test(y.arazzo))
      return u.Arazzo1;
    if (typeof y.overlay == "string" && l.VERSION_PATTERN.test(y.overlay))
      return u.Overlay1;
    throw new Error("Unsupported specification");
  }
  function v(y) {
    return y === u.OAS2 ? f.OAS2 : y === u.Async2 ? f.Async2 : y === u.Async3 ? f.Async3 : y === u.Arazzo1 ? f.Arazzo1 : y === u.Overlay1 ? f.Overlay1 : f.OAS3;
  }
  function S(y) {
    return d[y];
  }
  return xi;
}
var _d = {}, LA;
function q9() {
  if (LA) return _d;
  LA = 1, Object.defineProperty(_d, "__esModule", { value: !0 }), _d.initRules = t;
  const e = xn();
  function t(r, n, i, s) {
    return r.flatMap((o) => Object.keys(o).map((a) => {
      const l = o[a], u = i === "rules" ? n.getRuleSettings(a, s) : i === "preprocessors" ? n.getPreprocessorSettings(a, s) : n.getDecoratorSettings(a, s);
      if (u.severity === "off")
        return;
      const f = u.severity, d = u.message, m = l(u);
      return Array.isArray(m) ? m.map((v) => ({
        severity: f,
        ruleId: a,
        message: d,
        visitor: v
      })) : {
        severity: f,
        message: d,
        ruleId: a,
        visitor: m
        // note: actually it is only one visitor object
      };
    })).flatMap((o) => o).filter(e.isDefined);
  }
  return _d;
}
var Za = {}, MA;
function B9() {
  if (MA) return Za;
  MA = 1, Object.defineProperty(Za, "__esModule", { value: !0 }), Za.NoUnresolvedRefs = void 0, Za.reportUnresolvedRef = r;
  const e = m1(), t = () => ({
    ref: {
      leave(n, { report: i, location: s }, o) {
        o.node === void 0 && r(o, i, s);
      }
    },
    DiscriminatorMapping(n, { report: i, resolve: s, location: o }) {
      for (const a of Object.keys(n)) {
        const l = s({ $ref: n[a] });
        if (l.node !== void 0)
          return;
        r(l, i, o.child(a));
      }
    }
  });
  Za.NoUnresolvedRefs = t;
  function r(n, i, s) {
    var l;
    const o = n.error;
    o instanceof e.YamlParseError && i({
      message: "Failed to parse: " + o.message,
      location: {
        source: o.source,
        pointer: void 0,
        start: {
          col: o.col,
          line: o.line
        }
      }
    });
    const a = (l = n.error) == null ? void 0 : l.message;
    i({
      location: s,
      message: `Can't resolve $ref${a ? ": " + a : ""}`
    });
  }
  return Za;
}
var Ob = {}, DA;
function U9() {
  return DA || (DA = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.AVAILABLE_REGIONS = e.DOMAINS = e.DEFAULT_REGION = void 0, e.getDomains = r, e.setRedoclyDomain = n, e.getRedoclyDomain = i, e.isRedoclyRegistryURL = s;
    let t = "redocly.com";
    e.DEFAULT_REGION = "us", e.DOMAINS = r(), e.AVAILABLE_REGIONS = Object.keys(e.DOMAINS);
    function r() {
      const o = {
        us: "redocly.com",
        eu: "eu.redocly.com"
      }, a = t;
      return a != null && a.endsWith(".redocly.host") && (o[a.split(".")[0]] = a), a === "redoc.online" && (o[a] = a), o;
    }
    function n(o) {
      t = o;
    }
    function i() {
      return t;
    }
    function s(o) {
      const a = i() || e.DOMAINS[e.DEFAULT_REGION], l = a === "redocly.com" ? "redoc.ly" : a;
      return !(!o.startsWith(`https://api.${a}/registry/`) && !o.startsWith(`https://api.${l}/registry/`));
    }
  }(Ob)), Ob;
}
var ec = {}, FA;
function V9() {
  if (FA) return ec;
  FA = 1, Object.defineProperty(ec, "__esModule", { value: !0 }), ec.RemoveUnusedComponents = void 0;
  const e = xn(), t = () => {
    const r = /* @__PURE__ */ new Map();
    function n(s, o, a) {
      var l;
      r.set(s.absolutePointer, {
        usedIn: ((l = r.get(s.absolutePointer)) == null ? void 0 : l.usedIn) ?? [],
        componentType: o,
        name: a
      });
    }
    function i(s, o) {
      const a = o.length;
      for (const [l, { usedIn: u, name: f, componentType: d }] of r)
        !u.some((v) => !o.some((S) => (
          // Check if the current location's absolute pointer starts with the 'removed' path
          // and either its length matches exactly with 'removed' or the character after the 'removed' path is a '/'
          v.absolutePointer.startsWith(S) && (v.absolutePointer.length === S.length || v.absolutePointer[S.length] === "/")
        ))) && d && (o.push(l), delete s[d][f], r.delete(l), (0, e.isEmptyObject)(s[d]) && delete s[d]);
      return o.length > a ? i(s, o) : o.length;
    }
    return {
      ref: {
        leave(s, { location: o, type: a, resolve: l, key: u }) {
          if (["Schema", "Parameter", "Response", "SecurityScheme"].includes(a.name)) {
            const f = l(s);
            if (!f.location)
              return;
            const [d, m] = f.location.absolutePointer.split("#", 2), v = m.split("/").slice(0, 3).join("/"), S = `${d}#${v}`, y = r.get(S);
            y ? y.usedIn.push(o) : r.set(S, {
              usedIn: [o],
              name: u.toString()
            });
          }
        }
      },
      Root: {
        leave(s, o) {
          const a = o.getVisitorData();
          a.removedCount = i(s, []);
        }
      },
      NamedSchemas: {
        Schema(s, { location: o, key: a }) {
          s.allOf || n(o, "definitions", a.toString());
        }
      },
      NamedParameters: {
        Parameter(s, { location: o, key: a }) {
          n(o, "parameters", a.toString());
        }
      },
      NamedResponses: {
        Response(s, { location: o, key: a }) {
          n(o, "responses", a.toString());
        }
      },
      NamedSecuritySchemes: {
        SecurityScheme(s, { location: o, key: a }) {
          n(o, "securityDefinitions", a.toString());
        }
      }
    };
  };
  return ec.RemoveUnusedComponents = t, ec;
}
var tc = {}, zA;
function W9() {
  if (zA) return tc;
  zA = 1, Object.defineProperty(tc, "__esModule", { value: !0 }), tc.RemoveUnusedComponents = void 0;
  const e = xn(), t = () => {
    const r = /* @__PURE__ */ new Map();
    function n(s, o, a) {
      var l;
      r.set(s.absolutePointer, {
        usedIn: ((l = r.get(s.absolutePointer)) == null ? void 0 : l.usedIn) ?? [],
        componentType: o,
        name: a
      });
    }
    function i(s, o) {
      const a = o.length;
      for (const [l, { usedIn: u, name: f, componentType: d }] of r)
        if (!u.some((v) => !o.some((S) => v.absolutePointer.startsWith(S) && (v.absolutePointer.length === S.length || v.absolutePointer[S.length] === "/"))) && d && s.components) {
          o.push(l);
          const v = s.components[d];
          delete v[f], r.delete(l), (0, e.isEmptyObject)(v) && delete s.components[d];
        }
      return o.length > a ? i(s, o) : o.length;
    }
    return {
      ref: {
        leave(s, { location: o, type: a, resolve: l, key: u }) {
          if (["Schema", "Header", "Parameter", "Response", "Example", "RequestBody"].includes(a.name)) {
            const f = l(s);
            if (!f.location)
              return;
            const [d, m] = f.location.absolutePointer.split("#", 2), v = m.split("/").slice(0, 4).join("/"), S = `${d}#${v}`, y = r.get(S);
            y ? y.usedIn.push(o) : r.set(S, {
              usedIn: [o],
              name: u.toString()
            });
          }
        }
      },
      Root: {
        leave(s, o) {
          const a = o.getVisitorData();
          a.removedCount = i(s, []), (0, e.isEmptyObject)(s.components) && delete s.components;
        }
      },
      NamedSchemas: {
        Schema(s, { location: o, key: a }) {
          s.allOf || n(o, "schemas", a.toString());
        }
      },
      NamedParameters: {
        Parameter(s, { location: o, key: a }) {
          n(o, "parameters", a.toString());
        }
      },
      NamedResponses: {
        Response(s, { location: o, key: a }) {
          n(o, "responses", a.toString());
        }
      },
      NamedExamples: {
        Example(s, { location: o, key: a }) {
          n(o, "examples", a.toString());
        }
      },
      NamedRequestBodies: {
        RequestBody(s, { location: o, key: a }) {
          n(o, "requestBodies", a.toString());
        }
      },
      NamedHeaders: {
        Header(s, { location: o, key: a }) {
          n(o, "headers", a.toString());
        }
      }
    };
  };
  return tc.RemoveUnusedComponents = t, tc;
}
var el = {};
const oL = {
  hide: {
    type: "boolean",
    default: !1
  },
  component: {
    type: "string",
    enum: ["radio", "checkbox"],
    default: "checkbox"
  },
  label: { type: "string" },
  items: { type: "array", items: { type: "string" } }
}, rc = {
  type: "object",
  properties: oL,
  additionalProperties: !1
}, H9 = {
  type: "object",
  properties: {
    hide: {
      type: "boolean",
      default: !1
    },
    label: { type: "string" },
    placeholder: { type: "string" }
  },
  additionalProperties: !1
}, Qg = {
  type: "object",
  properties: {
    hide: {
      type: "boolean",
      default: !1
    },
    type: {
      type: "string",
      enum: ["rating", "sentiment", "comment", "reasons", "mood", "scale"],
      default: "sentiment"
    },
    settings: {
      type: "object",
      properties: {
        label: { type: "string" },
        submitText: { type: "string" },
        buttonText: { type: "string" },
        component: {
          type: "string",
          enum: ["radio", "checkbox"],
          default: "checkbox"
        },
        items: { type: "array", items: { type: "string" }, minItems: 1 },
        leftScaleLabel: { type: "string" },
        rightScaleLabel: { type: "string" },
        reasons: {
          type: "object",
          properties: Object.assign(Object.assign({}, oL), { like: rc, dislike: rc, satisfied: rc, neutral: rc, dissatisfied: rc }),
          additionalProperties: !1
        },
        comment: {
          type: "object",
          properties: {
            hide: {
              type: "boolean",
              default: !1
            },
            label: { type: "string" },
            likeLabel: { type: "string" },
            dislikeLabel: { type: "string" },
            satisfiedLabel: { type: "string" },
            neutralLabel: { type: "string" },
            dissatisfiedLabel: { type: "string" }
          },
          additionalProperties: !1
        },
        optionalEmail: H9
      },
      additionalProperties: !1
    }
  },
  additionalProperties: !1
}, tl = {
  type: "object",
  properties: {
    includeByName: {
      type: "array",
      items: {
        type: "string"
      }
    },
    excludeByName: {
      type: "array",
      items: {
        type: "string"
      }
    }
  },
  additionalProperties: !1
}, Q9 = {
  type: "object",
  properties: {
    name: {
      type: "string"
    },
    items: tl,
    queries: tl,
    mutations: tl,
    subscriptions: tl,
    types: tl,
    directives: tl
  },
  required: ["name"],
  additionalProperties: !1
}, Y9 = {
  properties: {
    requireExactGroups: {
      type: "boolean"
    },
    groups: {
      type: "array",
      items: Q9
    },
    otherItemsGroupName: {
      type: "string"
    }
  }
}, Bm = {
  type: "object",
  properties: {
    hidePaginationButtons: {
      type: "boolean"
    },
    menu: {
      type: "object",
      properties: Object.assign({}, Y9.properties),
      additionalProperties: !1
    },
    sidebar: {
      type: "object",
      properties: {
        hide: {
          type: "boolean"
        }
      }
    },
    apiLogo: {
      type: "object",
      properties: {
        imageUrl: {
          type: "string"
        },
        href: {
          type: "string"
        },
        altText: {
          type: "string"
        },
        backgroundColor: {
          type: "string"
        }
      }
    },
    jsonSamplesDepth: {
      type: "number"
    },
    samplesMaxInlineArgs: {
      type: "number"
    },
    licenseKey: {
      type: "string"
    },
    fieldExpandLevel: {
      type: "number"
    },
    baseUrlPath: {
      type: "string"
    },
    feedback: Qg
  },
  additionalProperties: !1
}, G9 = {
  type: "object",
  properties: {
    languages: {
      type: "array",
      items: {
        type: "object",
        properties: {
          lang: {
            type: "string",
            enum: [
              "curl",
              "JavaScript",
              "Node.js",
              "Python",
              "Java8+Apache",
              "Java",
              "C#",
              "C#+Newtonsoft",
              "PHP",
              "Go",
              "Ruby",
              "R",
              "Payload"
            ]
          },
          label: { type: "string" },
          options: {
            type: "object",
            properties: {
              indent: { type: "string" },
              withImports: { type: "boolean" },
              withComments: { type: "boolean" },
              binary: { type: "boolean" },
              credentials: {
                type: "string",
                enum: ["omit", "same-origin", "include"]
              }
            },
            additionalProperties: !1
          }
        },
        required: ["lang"],
        additionalProperties: !1
      }
    },
    skipOptionalParameters: { type: "boolean" },
    withOAuth2Call: { type: "boolean" }
  },
  required: ["languages"],
  additionalProperties: !1
}, K9 = {
  type: "array",
  items: {
    type: "object",
    properties: {
      title: { type: "string" },
      url: { type: "string" }
    },
    required: ["url"],
    additionalProperties: !1
  }
}, Ew = {
  type: "object",
  properties: {
    licenseKey: { type: "string" },
    hideLoading: { type: "boolean" },
    disableRouter: { type: "boolean" },
    hideSidebar: { type: "boolean" },
    feedback: Qg,
    hideReplay: { type: "boolean" },
    oAuth2RedirectURI: { type: "string", nullable: !0 },
    corsProxyUrl: { type: "string" },
    sortRequiredPropsFirst: { type: "boolean" },
    sanitize: { type: "boolean" },
    hideDownloadButtons: { type: "boolean" },
    downloadUrls: K9,
    onlyRequiredInSamples: { type: "boolean" },
    generatedSamplesMaxDepth: { oneOf: [{ type: "number" }, { type: "string" }] },
    showExtensions: {
      oneOf: [
        { type: "boolean" },
        { type: "string" },
        { type: "array", items: { type: "string" } }
      ]
    },
    hideSchemaTitles: { type: "boolean" },
    jsonSamplesExpandLevel: { oneOf: [{ type: "number" }, { type: "string" }] },
    schemasExpansionLevel: { oneOf: [{ type: "number" }, { type: "string" }] },
    mockServer: {
      type: "object",
      properties: {
        url: { type: "string" },
        position: { type: "string", enum: ["first", "last", "replace", "off"] },
        description: { type: "string" }
      }
    },
    maxDisplayedEnumValues: { type: "number" },
    schemaDefinitionsTagName: { type: "string" },
    layout: { type: "string", enum: ["stacked", "three-panel"] },
    hideInfoMetadata: { type: "boolean" },
    events: { type: "object" },
    skipBundle: { type: "boolean" },
    routingBasePath: { type: "string" },
    codeSamples: G9,
    ignoreNamedSchemas: {
      oneOf: [{ type: "array", items: { type: "string" } }, { type: "string" }]
    },
    hidePropertiesPrefix: { type: "boolean" },
    excludeFromSearch: { type: "boolean" }
  },
  additionalProperties: !1
}, X9 = {
  type: "object",
  properties: {
    label: { type: "string" },
    lang: {
      enum: [
        "curl",
        "C#",
        "Go",
        "Java",
        "Java8+Apache",
        "JavaScript",
        "Node.js",
        "PHP",
        "Python",
        "R",
        "Ruby"
      ]
    }
  },
  required: ["lang"]
}, J9 = {
  type: "object",
  properties: {
    enum: { type: "string" },
    enumSingleValue: { type: "string" },
    enumArray: { type: "string" },
    default: { type: "string" },
    deprecated: { type: "string" },
    example: { type: "string" },
    examples: { type: "string" },
    nullable: { type: "string" },
    recursive: { type: "string" },
    arrayOf: { type: "string" },
    webhook: { type: "string" },
    authorizations: { type: "string" },
    tryItAuthBasicUsername: { type: "string" },
    tryItAuthBasicPassword: { type: "string" }
  }
}, qA = {
  type: "object",
  properties: {
    label: { type: "string" },
    link: { type: "string" },
    target: { type: "string" }
  },
  required: ["label", "link"]
}, Z9 = {
  type: "object",
  properties: {
    beforeInfo: { type: "array", items: qA },
    end: { type: "array", items: qA }
  }
}, Ks = {
  type: "object",
  properties: {
    main: { type: "string" },
    light: { type: "string" },
    dark: { type: "string" },
    contrastText: { type: "string" }
  }
}, Od = {
  type: "object",
  properties: {
    backgroundColor: { type: "string" },
    borderColor: { type: "string" },
    color: { type: "string" },
    tabTextColor: { type: "string" }
  }
}, eH = {
  type: "object",
  properties: Yg(Ks.properties, ["light", "dark"])
}, tH = {
  type: "object",
  properties: {
    basic: { type: "string" },
    delete: { type: "string" },
    get: { type: "string" },
    head: { type: "string" },
    link: { type: "string" },
    options: { type: "string" },
    patch: { type: "string" },
    post: { type: "string" },
    put: { type: "string" }
  }
}, rH = {
  type: "object",
  properties: {
    error: Od,
    info: Od,
    redirect: Od,
    success: Od
  }
}, nH = {
  type: "object",
  properties: uu(Ks.properties, ["dark"])
}, iH = {
  type: "object",
  properties: {
    primary: { type: "string" },
    secondary: { type: "string" },
    light: { type: "string" }
  }
}, oH = {
  type: "object",
  properties: {
    accent: Ks,
    border: eH,
    error: Ks,
    http: tH,
    primary: Ks,
    responses: rH,
    secondary: nH,
    success: Ks,
    text: iH,
    tonalOffset: { type: "number" },
    warning: Ks
  }
}, kd = {
  type: "object",
  properties: {
    fontSize: { type: "string" },
    padding: { type: "string" },
    minWidth: { type: "string" }
  }
}, sH = {
  type: "object",
  properties: {
    small: kd,
    medium: kd,
    large: kd,
    xlarge: kd
  }
}, Mi = {
  type: "object",
  properties: {
    fontFamily: { type: "string" },
    fontSize: { type: "string" },
    fontWeight: { type: "string" },
    lineHeight: { type: "string" }
  }
}, aH = {
  type: "object",
  properties: Object.assign(Object.assign({}, uu(Mi.properties, ["fontSize", "lineHeight"])), { borderRadius: { type: "string" }, hoverStyle: { type: "string" }, boxShadow: { type: "string" }, hoverBoxShadow: { type: "string" }, sizes: sH })
}, BA = {
  type: "object",
  properties: Yg(Mi.properties, ["fontSize", "lineHeight"])
}, lH = {
  type: "object",
  properties: {
    medium: BA,
    small: BA
  }
}, uH = {
  type: "object",
  properties: Object.assign(Object.assign({}, uu(Mi.properties, ["fontSize", "lineHeight"])), { borderRadius: { type: "string" }, color: { type: "string" }, sizes: lH })
}, cH = {
  type: "object",
  properties: {
    top: { type: "string" },
    width: { type: "string" },
    height: { type: "string" }
  }
}, pH = {
  type: "object",
  properties: {
    borderRadius: { type: "string" },
    backgroundColor: { type: "string" }
  }
}, UA = {
  type: "object",
  properties: {
    fullWidth: { type: "boolean" }
  }
}, fH = {
  type: "object",
  properties: {
    buttons: aH,
    httpBadges: uH,
    layoutControls: cH,
    panels: pH,
    tryItButton: UA,
    tryItSendButton: UA
  }
}, Um = {
  type: "object",
  properties: {
    small: { type: "string" },
    medium: { type: "string" },
    large: { type: "string" }
  }
}, dH = {
  type: "object",
  properties: {
    maxWidth: Um
  }
}, hH = {
  type: "object",
  properties: {
    maxWidth: Um,
    middlePanelMaxWidth: Um
  }
}, mH = {
  type: "object",
  properties: {
    showDarkRightPanel: { type: "boolean" },
    stacked: dH,
    "three-panel": hH
  }
}, VA = {
  type: "object",
  properties: {
    backgroundColor: { type: "string" },
    border: { type: "string" }
  }
}, gH = {
  type: "object",
  properties: {
    breakFieldNames: { type: "boolean" },
    caretColor: { type: "string" },
    caretSize: { type: "string" },
    constraints: VA,
    defaultDetailsWidth: { type: "string" },
    examples: VA,
    labelsTextSize: { type: "string" },
    linesColor: { type: "string" },
    nestedBackground: { type: "string" },
    nestingSpacing: { type: "string" },
    requireLabelColor: { type: "string" },
    typeNameColor: { type: "string" },
    typeTitleColor: { type: "string" }
  }
}, sL = {
  type: "object",
  properties: {
    subItemsColor: { type: "string" },
    textTransform: { type: "string" },
    fontWeight: { type: "string" }
  }
}, yH = {
  type: "object",
  properties: Yg(sL.properties, ["textTransform"])
}, vH = {
  type: "object",
  properties: {
    unit: { type: "number" },
    paddingHorizontal: { type: "string" },
    paddingVertical: { type: "string" },
    offsetTop: { type: "string" },
    offsetLeft: { type: "string" },
    offsetNesting: { type: "string" }
  }
}, bH = {
  type: "object",
  properties: Object.assign(Object.assign({}, uu(Mi.properties, ["fontWeight", "lineHeight"])), { activeBgColor: { type: "string" }, activeTextColor: { type: "string" }, backgroundColor: { type: "string" }, borderRadius: { type: "string" }, breakPath: { type: "boolean" }, caretColor: { type: "string" }, caretSize: { type: "string" }, groupItems: sL, level1items: yH, rightLineColor: { type: "string" }, separatorLabelColor: { type: "string" }, showAtBreakpoint: { type: "string" }, spacing: vH, textColor: { type: "string" }, width: { type: "string" } })
}, Ad = {
  type: "object",
  properties: Object.assign(Object.assign({}, Mi.properties), { color: { type: "string" }, transform: { type: "string" } })
}, wH = {
  type: "object",
  properties: Object.assign(Object.assign({}, Mi.properties), { backgroundColor: { type: "string" }, color: { type: "string" }, wordBreak: {
    type: "string",
    enum: [
      "break-all",
      "break-word",
      "keep-all",
      "normal",
      "revert",
      "unset",
      "inherit",
      "initial"
    ]
  }, wrap: { type: "boolean" } })
}, SH = {
  type: "object",
  properties: uu(Mi.properties, ["fontSize"])
}, xH = {
  type: "object",
  properties: {
    color: { type: "string" },
    hover: { type: "string" },
    textDecoration: { type: "string" },
    hoverTextDecoration: { type: "string" },
    visited: { type: "string" }
  }
}, EH = {
  type: "object",
  properties: Object.assign(Object.assign({ code: wH, fieldName: Mi }, Yg(Mi.properties, ["fontSize", "fontFamily"])), { fontWeightBold: { type: "string" }, fontWeightLight: { type: "string" }, fontWeightRegular: { type: "string" }, heading1: Ad, heading2: Ad, heading3: Ad, headings: SH, lineHeight: { type: "string" }, links: xH, optimizeSpeed: { type: "boolean" }, rightPanelHeading: Ad, smoothing: {
    type: "string",
    enum: ["auto", "none", "antialiased", "subpixel-antialiased", "grayscale"]
  } })
}, _H = {
  type: "object",
  properties: Object.assign({ color: { type: "string" } }, uu(Mi.properties, ["fontWeight"]))
}, OH = {
  type: "object",
  properties: {
    backgroundColor: { type: "string" },
    borderRadius: { type: "string" },
    tokens: _H
  }
}, kH = {
  type: "object",
  properties: {
    gutter: { type: "string" },
    maxHeight: { type: "string" },
    maxWidth: { type: "string" }
  }
}, AH = {
  type: "object",
  properties: {
    backgroundColor: { type: "string" },
    color: { type: "string" }
  }
}, WA = {
  type: "object",
  properties: {
    custom: { type: "string" }
  }
}, PH = {
  type: "object",
  properties: {
    DownloadButton: WA,
    NextSectionButton: WA
  }
}, TH = {
  type: "object",
  properties: {
    backgroundColor: { type: "string" },
    panelBackgroundColor: { type: "string" },
    panelControlsBackgroundColor: { type: "string" },
    showAtBreakpoint: { type: "string" },
    textColor: { type: "string" },
    width: { type: "string" }
  }
}, CH = {
  type: "object",
  properties: { borderRadius: { type: "string" } }
}, $H = {
  type: "object",
  properties: {
    sectionHorizontal: { type: "number" },
    sectionVertical: { type: "number" },
    unit: { type: "number" }
  }
}, RH = {
  type: "object",
  properties: {
    breakpoints: Um,
    codeBlock: OH,
    colors: oH,
    components: fH,
    layout: mH,
    logo: kH,
    fab: AH,
    overrides: PH,
    rightPanel: TH,
    schema: gH,
    shape: CH,
    sidebar: bH,
    spacing: $H,
    typography: EH,
    links: { properties: { color: { type: "string" } } },
    codeSample: { properties: { backgroundColor: { type: "string" } } }
  }
}, IH = {
  type: "object",
  properties: {
    skipOptionalParameters: { type: "boolean" },
    languages: { type: "array", items: X9 }
  },
  required: ["languages"]
}, NH = {
  properties: {
    theme: RH,
    ctrlFHijack: { type: "boolean" },
    defaultSampleLanguage: { type: "string" },
    disableDeepLinks: { type: "boolean" },
    disableSearch: { type: "boolean" },
    disableSidebar: { type: "boolean" },
    downloadDefinitionUrl: { type: "string" },
    expandDefaultServerVariables: { type: "boolean" },
    enumSkipQuotes: { type: "boolean" },
    expandDefaultRequest: { type: "boolean" },
    expandDefaultResponse: { type: "boolean" },
    expandResponses: { type: "string" },
    expandSingleSchemaField: { type: "boolean" },
    generateCodeSamples: IH,
    generatedPayloadSamplesMaxDepth: { type: "number" },
    hideDownloadButton: { type: "boolean" },
    hideHostname: { type: "boolean" },
    hideInfoSection: { type: "boolean" },
    hideLogo: { type: "boolean" },
    hideRequestPayloadSample: { type: "boolean" },
    hideRightPanel: { type: "boolean" },
    hideSchemaPattern: { type: "boolean" },
    hideSingleRequestSampleTab: { type: "boolean" },
    hideSecuritySection: { type: "boolean" },
    hideTryItPanel: { type: "boolean" },
    hideFab: { type: "boolean" },
    hideOneOfDescription: { type: "boolean" },
    htmlTemplate: { type: "string" },
    jsonSampleExpandLevel: {
      oneOf: [{ type: "number", minimum: 1 }, { type: "string" }]
    },
    labels: J9,
    menuToggle: { type: "boolean" },
    nativeScrollbars: { type: "boolean" },
    noAutoAuth: { type: "boolean" },
    onDeepLinkClick: { type: "object" },
    pagination: { enum: ["none", "section", "item"] },
    pathInMiddlePanel: { type: "boolean" },
    payloadSampleIdx: { type: "number", minimum: 0 },
    requestInterceptor: { type: "object" },
    requiredPropsFirst: { type: "boolean" },
    routingStrategy: { type: "string" },
    samplesTabsMaxCount: { type: "number" },
    schemaExpansionLevel: {
      oneOf: [{ type: "number", minimum: 0 }, { type: "string" }]
    },
    minCharacterLengthToInitSearch: { type: "number", minimum: 1 },
    maxResponseHeadersToShowInTryIt: { type: "number", minimum: 0 },
    scrollYOffset: {
      oneOf: [{ type: "number" }, { type: "string" }]
    },
    searchAutoExpand: { type: "boolean" },
    searchFieldLevelBoost: { type: "number", minimum: 0 },
    searchMaxDepth: { type: "number", minimum: 1 },
    searchMode: { type: "string", enum: ["default", "path-only"] },
    searchOperationTitleBoost: { type: "number" },
    searchTagTitleBoost: { type: "number" },
    sendXUserAgentInTryIt: { type: "boolean" },
    showChangeLayoutButton: { type: "boolean" },
    showConsole: { type: "boolean" },
    showNextButton: { type: "boolean" },
    showRightPanelToggle: { type: "boolean" },
    showSecuritySchemeType: { type: "boolean" },
    showWebhookVerb: { type: "boolean" },
    showObjectSchemaExamples: { type: "boolean" },
    disableTryItRequestUrlEncoding: { type: "boolean" },
    sidebarLinks: Z9,
    sideNavStyle: { type: "string", enum: ["summary-only", "path-first", "id-only", "path-only"] },
    simpleOneOfTypeLabel: { type: "boolean" },
    sortEnumValuesAlphabetically: { type: "boolean" },
    sortOperationsAlphabetically: { type: "boolean" },
    sortPropsAlphabetically: { type: "boolean" },
    sortTagsAlphabetically: { type: "boolean" },
    suppressWarnings: { type: "boolean" },
    unstable_externalDescription: { type: "boolean" },
    unstable_ignoreMimeParameters: { type: "boolean" },
    untrustedDefinition: { type: "boolean" },
    showAccessMode: { type: "boolean" },
    preserveOriginalExtensionsName: { type: "boolean" },
    markdownHeadingsAnchorLevel: { type: "number" }
  }
};
function Yg(e, t) {
  return Object.fromEntries(t.filter((r) => r in e).map((r) => [r, e[r]]));
}
function uu(e, t) {
  return Object.fromEntries(Object.entries(e).filter(([r]) => !t.includes(r)));
}
const _r = {
  type: "object",
  properties: {
    hide: { type: "boolean" }
  },
  additionalProperties: !1
}, HA = {
  type: "object",
  properties: {
    src: { type: "string" },
    async: { type: "boolean" },
    crossorigin: { type: "string" },
    defer: { type: "boolean" },
    fetchpriority: { type: "string" },
    integrity: { type: "string" },
    module: { type: "boolean" },
    nomodule: { type: "boolean" },
    nonce: { type: "string" },
    referrerpolicy: { type: "string" },
    type: { type: "string" }
  },
  required: ["src"],
  additionalProperties: !0
}, kb = {
  type: "object",
  properties: {
    page: { type: "string" },
    directory: { type: "string" },
    disconnect: { type: "boolean", default: !1 },
    group: { type: "string" },
    label: { type: "string" },
    href: { type: "string" },
    external: { type: "boolean" },
    labelTranslationKey: { type: "string" },
    groupTranslationKey: { type: "string" },
    icon: {
      oneOf: [
        { type: "string" },
        { type: "object", properties: { srcSet: { type: "string" } }, required: ["srcSet"] }
      ]
    },
    separator: { type: "string" },
    separatorLine: { type: "boolean" },
    linePosition: {
      type: "string",
      enum: ["top", "bottom"],
      default: "top"
    },
    version: { type: "string" },
    menuStyle: { type: "string", enum: ["drilldown"] },
    expanded: { type: "string", const: "always" },
    selectFirstItemOnExpand: { type: "boolean" },
    flatten: { type: "boolean" },
    linkedSidebars: {
      type: "array",
      items: { type: "string" }
    },
    // Allow users to eject the navbar and implement additional levels of nesting
    items: { type: "array", items: { type: "object", additionalProperties: !0 } }
  }
}, v1 = {
  type: "array",
  items: Object.assign(Object.assign({}, kb), { properties: Object.assign(Object.assign({}, kb.properties), { items: { type: "array", items: kb } }) })
}, jH = {
  type: "object",
  properties: {
    name: { type: "string" },
    icon: { type: "string" },
    folder: { type: "string" }
  },
  additionalProperties: !1,
  required: ["name", "folder"]
}, LH = {
  type: "object",
  properties: {
    hide: {
      type: "boolean",
      default: !1
    },
    suggestions: {
      default: [],
      type: "array",
      items: {
        type: "string"
      }
    },
    prompt: {
      type: "string"
    }
  },
  additionalProperties: !1
}, MH = {
  type: "array",
  items: {
    type: "object",
    required: ["name", "field", "type"],
    properties: {
      name: { type: "string" },
      field: { type: "string" },
      type: {
        type: "string",
        enum: ["multi-select", "select", "tags"]
      }
    },
    additionalProperties: !1
  }
}, DH = {
  type: "object",
  properties: Object.assign({ facets: MH }, _r.properties),
  additionalProperties: !1
}, FH = {
  type: "object",
  properties: {
    page: { type: "string" },
    label: { type: "string" },
    labelTranslationKey: { type: "string" }
  },
  required: ["page"]
}, aL = {
  type: "object",
  properties: {
    image: { type: "string" },
    srcSet: { type: "string" },
    altText: { type: "string" },
    link: { type: "string" },
    favicon: { type: "string" }
  },
  additionalProperties: !1
}, lL = {
  type: "object",
  properties: Object.assign({ items: v1 }, _r.properties),
  additionalProperties: !1
}, uL = {
  type: "object",
  additionalProperties: jH
}, cL = {
  type: "object",
  properties: Object.assign({ items: v1, copyrightText: { type: "string" }, logo: _r }, _r.properties),
  additionalProperties: !1
}, pL = {
  type: "object",
  properties: Object.assign({ separatorLine: { type: "boolean" }, linePosition: {
    type: "string",
    enum: ["top", "bottom"],
    default: "bottom"
  } }, _r.properties),
  additionalProperties: !1
}, fL = {
  type: "object",
  properties: {
    head: { type: "array", items: HA },
    body: { type: "array", items: HA }
  },
  additionalProperties: !1
}, dL = {
  type: "array",
  items: {
    type: "object",
    properties: {
      href: { type: "string" },
      as: { type: "string" },
      crossorigin: { type: "string" },
      fetchpriority: { type: "string" },
      hreflang: { type: "string" },
      imagesizes: { type: "string" },
      imagesrcset: { type: "string" },
      integrity: { type: "string" },
      media: { type: "string" },
      prefetch: { type: "string" },
      referrerpolicy: { type: "string" },
      rel: { type: "string" },
      sizes: { type: "string" },
      title: { type: "string" },
      type: { type: "string" }
    },
    required: ["href"],
    additionalProperties: !0
  }
}, hL = {
  type: "object",
  properties: Object.assign({ engine: {
    type: "string",
    enum: ["flexsearch", "typesense"],
    default: "flexsearch"
  }, ai: LH, filters: DH, placement: {
    type: "string",
    default: "navbar"
  }, shortcuts: {
    type: "array",
    items: { type: "string" },
    default: ["/"]
  }, suggestedPages: {
    type: "array",
    items: FH
  } }, _r.properties),
  additionalProperties: !1
}, mL = {
  type: "object",
  properties: Object.assign({ ignoreDetection: { type: "boolean" }, modes: {
    type: "array",
    items: { type: "string" },
    default: ["light", "dark"]
  } }, _r.properties),
  additionalProperties: !1
}, gL = {
  type: "object",
  properties: {
    nextButton: {
      type: "object",
      properties: Object.assign({ text: { type: "string", default: "Next page" } }, _r.properties),
      additionalProperties: !1,
      default: {}
    },
    previousButton: {
      type: "object",
      properties: Object.assign({ text: { type: "string", default: "Previous page" } }, _r.properties),
      additionalProperties: !1,
      default: {}
    }
  },
  additionalProperties: !1
}, yL = {
  type: "object",
  properties: {
    elementFormat: { type: "string", default: "icon" },
    copy: {
      type: "object",
      properties: Object.assign({}, _r.properties),
      additionalProperties: !1,
      default: { hide: !1 }
    },
    report: {
      type: "object",
      properties: Object.assign({ tooltipText: { type: "string" }, buttonText: { type: "string" }, label: { type: "string" } }, _r.properties),
      additionalProperties: !1,
      default: { hide: !1 }
    },
    expand: {
      type: "object",
      properties: Object.assign({}, _r.properties),
      additionalProperties: !1,
      default: { hide: !1 }
    },
    collapse: {
      type: "object",
      properties: Object.assign({}, _r.properties),
      additionalProperties: !1,
      default: { hide: !1 }
    }
  },
  additionalProperties: !1
}, vL = {
  type: "object",
  properties: {
    frontMatterKeysToResolve: {
      type: "array",
      items: { type: "string" },
      default: ["image", "links"]
    },
    partialsFolders: {
      type: "array",
      items: { type: "string" },
      default: ["_partials"]
    },
    lastUpdatedBlock: {
      type: "object",
      properties: Object.assign({ format: {
        type: "string",
        enum: ["timeago", "iso", "long", "short"],
        default: "timeago"
      }, locale: { type: "string" } }, _r.properties),
      additionalProperties: !1,
      default: {}
    },
    toc: {
      type: "object",
      properties: Object.assign({ header: { type: "string", default: "On this page" }, depth: { type: "integer", default: 3, minimum: 1 } }, _r.properties),
      additionalProperties: !1,
      default: {}
    },
    editPage: {
      type: "object",
      properties: Object.assign({ baseUrl: { type: "string" } }, _r.properties),
      additionalProperties: !1,
      default: {}
    }
  },
  additionalProperties: !1,
  default: {}
}, Vm = Object.assign(Object.assign({}, Ew), { properties: Object.assign(Object.assign({}, Ew.properties), NH.properties) }), zH = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    scriptUrl: { type: "string" },
    pageViewEventName: { type: "string" }
  },
  additionalProperties: !1,
  required: ["scriptUrl"]
}, qH = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    apiKey: { type: "string" },
    head: { type: "boolean" },
    respectDNT: { type: "boolean" },
    exclude: { type: "array", items: { type: "string" } },
    outboundClickEventName: { type: "string" },
    pageViewEventName: { type: "string" },
    amplitudeConfig: { type: "object", additionalProperties: !0 }
  },
  additionalProperties: !1,
  required: ["apiKey"]
}, BH = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    orgId: { type: "string" }
  },
  additionalProperties: !1,
  required: ["orgId"]
}, UH = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    appId: { type: "string" }
  },
  additionalProperties: !1,
  required: ["appId"]
}, VH = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    writeKey: { type: "string", minLength: 10 },
    trackPage: { type: "boolean" },
    dataPlaneUrl: { type: "string" },
    controlPlaneUrl: { type: "string" },
    sdkUrl: { type: "string" },
    loadOptions: { type: "object", additionalProperties: !0 }
  },
  additionalProperties: !1,
  required: ["writeKey"]
}, WH = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    writeKey: { type: "string", minLength: 10 },
    trackPage: { type: "boolean" },
    includeTitleInPageCall: { type: "boolean" },
    host: { type: "string" }
  },
  additionalProperties: !1,
  required: ["writeKey"]
}, HH = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    trackingId: { type: "string" },
    gtmAuth: { type: "string" },
    gtmPreview: { type: "string" },
    defaultDataLayer: {},
    dataLayerName: { type: "string" },
    enableWebVitalsTracking: { type: "boolean" },
    selfHostedOrigin: { type: "string" },
    pageViewEventName: { type: "string" }
  },
  additionalProperties: !1,
  required: ["trackingId"]
}, bL = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    trackingId: { type: "string" },
    conversionId: { type: "string" },
    floodlightId: { type: "string" },
    optimizeId: { type: "string" },
    exclude: { type: "array", items: { type: "string" } }
  },
  additionalProperties: !1,
  required: ["trackingId"]
}, QH = {
  type: "object",
  properties: {
    includeInDevelopment: { type: "boolean" },
    trackingId: { type: "string" },
    conversionId: { type: "string" },
    floodlightId: { type: "string" },
    head: { type: "boolean" },
    respectDNT: { type: "boolean" },
    exclude: { type: "array", items: { type: "string" } },
    optimizeId: { type: "string" },
    anonymizeIp: { type: "boolean" },
    cookieExpires: { type: "number" },
    // All enabled tracking configs
    trackers: {
      type: "object",
      additionalProperties: bL
    }
  },
  additionalProperties: !1,
  required: ["trackingId"]
}, wL = {
  type: "object",
  properties: {
    adobe: zH,
    amplitude: qH,
    fullstory: BH,
    heap: UH,
    rudderstack: VH,
    segment: WH,
    gtm: HH,
    ga: QH
  }
}, SL = {
  type: "object",
  properties: Object.assign({ items: {
    type: "array",
    items: {
      type: "object",
      properties: {
        label: { type: "string" },
        external: { type: "boolean" },
        link: { type: "string" },
        separatorLine: { type: "boolean" }
      },
      additionalProperties: !0
    },
    default: []
  }, hideLoginButton: { type: "boolean" } }, _r.properties),
  additionalProperties: !1
}, xL = {
  type: "object",
  properties: {
    hide: { type: "boolean" },
    showForUnversioned: {
      type: "boolean"
    }
  }
}, EL = {
  type: "object",
  properties: {
    hide: { type: "boolean" },
    prefixItems: {
      type: "array",
      items: {
        type: "object",
        properties: {
          label: { type: "string" },
          labelTranslationKey: { type: "string" },
          page: { type: "string" }
        },
        additionalProperties: !1,
        default: {}
      }
    }
  },
  additionalProperties: !1
}, YH = {
  type: "object",
  additionalProperties: !1,
  required: ["title", "property"],
  properties: {
    type: {
      type: "string",
      enum: ["select", "checkboxes", "date-range"],
      default: "checkboxes"
    },
    title: { type: "string" },
    titleTranslationKey: { type: "string" },
    property: { type: "string" },
    parentFilter: { type: "string" },
    valuesMapping: { type: "object", additionalProperties: { type: "string" } },
    missingCategoryName: { type: "string" },
    missingCategoryNameTranslationKey: { type: "string" },
    options: { type: "array", items: { type: "string" } }
  }
}, GH = {
  type: "object",
  additionalProperties: !0,
  required: ["slug", "items"],
  properties: {
    slug: { type: "string" },
    filters: { type: "array", items: YH },
    groupByFirstFilter: { type: "boolean" },
    filterValuesCasing: {
      type: "string",
      enum: ["sentence", "original", "lowercase", "uppercase"]
    },
    items: v1,
    requiredPermission: { type: "string" },
    separateVersions: { type: "boolean" },
    title: { type: "string" },
    titleTranslationKey: { type: "string" },
    description: { type: "string" },
    descriptionTranslationKey: { type: "string" }
  }
}, _L = {
  type: "object",
  patternProperties: {
    ".*": GH
  }
}, OL = {
  type: "object",
  additionalProperties: !0,
  required: [],
  properties: {
    /**
     * @deprecated Should use `reunite.ignoreLint` instead
     */
    ignoreNonCompliant: { type: "boolean", default: !1 },
    teamMetadataProperty: {
      type: "object",
      properties: {
        property: { type: "string" },
        label: { type: "string" },
        default: { type: "string" }
      }
    },
    levels: {
      type: "array",
      items: {
        type: "object",
        required: ["name"],
        properties: {
          name: { type: "string" },
          color: { type: "string" },
          extends: { type: "array", items: { type: "string" } },
          rules: {
            type: "object",
            additionalProperties: {
              oneOf: [{ type: "string" }, { type: "object" }]
            }
          }
        },
        additionalProperties: !1
      }
    },
    targets: {
      type: "array",
      items: {
        type: "object",
        required: ["where"],
        properties: {
          minimumLevel: { type: "string" },
          rules: { type: "object", additionalProperties: !0 },
          where: {
            type: "object",
            required: ["metadata"],
            properties: {
              metadata: { type: "object", additionalProperties: { type: "string" } }
            },
            additionalProperties: !1
          }
        },
        additionalProperties: !1
      }
    },
    ignore: {
      type: "array",
      items: { type: "string" }
    }
  }
}, Gn = {
  type: "object",
  properties: {
    /**
     * @deprecated Should use `plugins` instead
     */
    imports: {
      type: "array",
      items: { type: "string" }
    },
    logo: aL,
    navbar: lL,
    products: uL,
    footer: cL,
    sidebar: pL,
    scripts: fL,
    links: dL,
    feedback: Qg,
    search: hL,
    colorMode: mL,
    navigation: gL,
    codeSnippet: yL,
    markdown: vL,
    openapi: Vm,
    graphql: Bm,
    analytics: wL,
    userMenu: SL,
    versionPicker: xL,
    breadcrumbs: EL,
    catalog: _L,
    scorecard: OL
  },
  additionalProperties: !0
};
Object.assign(Object.assign({}, Gn), { additionalProperties: !1 });
const kL = "https://redocly.com/sso/teams";
var mp;
(function(e) {
  e.OIDC = "OIDC", e.SAML2 = "SAML2";
})(mp || (mp = {}));
var gp;
(function(e) {
  e.SERVICE_ACCOUNT = "SERVICE_ACCOUNT", e.OAUTH2 = "OAUTH2";
})(gp || (gp = {}));
const KH = "redocly::teams-rbac", XH = "redocly::route-rbac";
var _w;
(function(e) {
  e.STACKED = "stacked", e.THREE_PANEL = "three-panel";
})(_w || (_w = {}));
function Ow(e, t) {
  return Object.fromEntries(Object.entries(e).map(([r, n]) => {
    if (r !== t)
      return typeof n != "object" || !n ? [r, n] : Array.isArray(n) ? [
        r,
        n.map((i) => typeof i == "object" ? Ow(i, t) : i)
      ] : [r, Ow(n, t)];
  }).filter(Boolean));
}
const JH = {
  type: "object",
  additionalProperties: { type: "string" }
}, ZH = {
  type: "object",
  additionalProperties: !1,
  patternProperties: {
    "^[a-zA-Z0-9_-]+$": {
      type: "string",
      pattern: "^https?://[^\\s/$.?#].[^\\s]*$"
    }
  }
}, Pd = {
  type: "string",
  enum: ["error", "warn", "off"]
}, e7 = {
  type: "object",
  additionalProperties: !1,
  properties: {
    schemaCheck: Pd,
    statusCodeCheck: Pd,
    contentTypeCheck: Pd,
    successCriteriaCheck: Pd
  }
}, t7 = {
  type: "object",
  additionalProperties: !1,
  properties: {
    event: {
      type: "string",
      enum: ["schedule"]
    },
    interval: { type: "string", pattern: "^[1-9]\\d*[mhdw]$" }
  },
  required: ["event"]
}, r7 = {
  type: "object",
  properties: {
    ignoreLint: {
      oneOf: [
        { type: "boolean", default: !1 },
        {
          type: "object",
          additionalProperties: { type: "boolean" }
        }
      ]
    },
    ignoreLinkChecker: { type: "boolean" },
    ignoreMarkdocErrors: { type: "boolean" },
    jobs: {
      type: "array",
      items: {
        type: "object",
        properties: {
          path: {
            type: "string",
            pattern: "^(?!\\.\\./)(/[a-zA-Z0-9_\\-\\./]+|./[a-zA-Z0-9_\\-\\./]+|[a-zA-Z0-9_\\-\\./]+)$"
          },
          agent: {
            type: "string",
            enum: ["respect"]
          },
          trigger: t7,
          inputs: JH,
          servers: ZH,
          severity: e7
        },
        required: ["path", "trigger", "agent"],
        additionalProperties: !1
      }
    }
  },
  additionalProperties: !1
}, n7 = {
  type: "object",
  properties: {
    end_session_endpoint: { type: "string" },
    token_endpoint: { type: "string" },
    authorization_endpoint: { type: "string" },
    jwks_uri: { type: "string" }
  },
  required: ["token_endpoint", "authorization_endpoint"],
  additionalProperties: !0
}, i7 = {
  type: "object",
  properties: {
    type: { type: "string", const: mp.OIDC },
    title: { type: "string" },
    pkce: { type: "boolean", default: !1 },
    configurationUrl: { type: "string", minLength: 1 },
    configuration: n7,
    clientId: { type: "string", minLength: 1 },
    clientSecret: { type: "string", minLength: 0 },
    teamsClaimName: { type: "string" },
    teamsClaimMap: { type: "object", additionalProperties: { type: "string" } },
    defaultTeams: { type: "array", items: { type: "string" } },
    scopes: { type: "array", items: { type: "string" } },
    tokenExpirationTime: { type: "number" },
    authorizationRequestCustomParams: { type: "object", additionalProperties: { type: "string" } },
    tokenRequestCustomParams: { type: "object", additionalProperties: { type: "string" } },
    audience: { type: "array", items: { type: "string" } }
  },
  required: ["type", "clientId"],
  oneOf: [{ required: ["configurationUrl"] }, { required: ["configuration"] }],
  additionalProperties: !1
}, o7 = {
  type: "object",
  properties: {
    type: { type: "string", const: mp.SAML2 },
    title: { type: "string" },
    issuerId: { type: "string" },
    entityId: { type: "string" },
    ssoUrl: { type: "string" },
    x509PublicCert: { type: "string" },
    teamsAttributeName: { type: "string", default: kL },
    teamsAttributeMap: { type: "object", additionalProperties: { type: "string" } },
    defaultTeams: { type: "array", items: { type: "string" } }
  },
  additionalProperties: !1,
  required: ["type", "issuerId", "ssoUrl", "x509PublicCert"]
}, s7 = {
  oneOf: [i7, o7],
  discriminator: { propertyName: "type" }
}, a7 = {
  type: "object",
  additionalProperties: s7
}, l7 = {
  oneOf: [
    {
      type: "array",
      items: {
        type: "string",
        enum: ["REDOCLY", "CORPORATE", "GUEST"]
      },
      uniqueItems: !0
    },
    {
      type: "string",
      enum: ["REDOCLY", "CORPORATE", "GUEST"]
    }
  ]
}, u7 = {
  type: "object",
  properties: {
    to: { type: "string" },
    type: { type: "number", default: 301 }
  },
  additionalProperties: !1
}, c7 = {
  type: "object",
  additionalProperties: u7,
  default: {}
}, AL = {
  type: "object",
  additionalProperties: {
    oneOf: [{ type: "string" }, { type: "object" }]
  }
}, PL = {
  type: "object",
  properties: {
    root: { type: "string" },
    output: { type: "string", pattern: "(.ya?ml|.json)$" },
    rbac: { type: "object", additionalProperties: !0 },
    openapi: Vm,
    graphql: Bm,
    /**
     * @deprecated left for backwards compatibility
     */
    theme: {
      type: "object",
      properties: {
        openapi: Vm,
        graphql: Bm
      },
      additionalProperties: !1
    },
    title: { type: "string" },
    metadata: { type: "object", additionalProperties: !0 },
    rules: AL,
    decorators: { type: "object", additionalProperties: !0 },
    preprocessors: { type: "object", additionalProperties: !0 }
  },
  required: ["root"]
}, p7 = {
  type: "object",
  additionalProperties: !0
}, f7 = {
  type: "object",
  additionalProperties: {
    type: "object",
    additionalProperties: !0
  }
}, d7 = {
  type: "object",
  properties: {
    title: { type: "string" },
    description: { type: "string" },
    siteUrl: { type: "string" },
    image: { type: "string" },
    keywords: {
      oneOf: [{ type: "array", items: { type: "string" } }, { type: "string" }]
    },
    lang: { type: "string" },
    jsonLd: { type: "object" },
    meta: {
      type: "array",
      items: {
        type: "object",
        properties: {
          name: { type: "string" },
          content: { type: "string" }
        },
        required: ["name", "content"],
        additionalProperties: !1
      }
    }
  },
  additionalProperties: !1
}, h7 = {
  type: "object",
  properties: {
    folders: { type: "array", items: { type: "string" } }
  },
  additionalProperties: !1
}, qs = {
  type: "object",
  additionalProperties: { type: "string" }
}, TL = {
  type: "object",
  properties: {
    teamNamePatterns: { type: "array", items: { type: "string" } },
    teamFolders: { type: "array", items: { type: "string" } },
    teamFoldersBaseRoles: qs,
    cms: qs,
    // deprecated in favor of reunite
    reunite: qs,
    features: {
      type: "object",
      properties: {
        aiSearch: qs
      },
      additionalProperties: !1
    },
    content: {
      type: "object",
      properties: {
        "**": qs
      },
      additionalProperties: qs
    }
  },
  additionalProperties: qs
}, m7 = {
  type: "object",
  properties: { static: { type: "string" } },
  additionalProperties: !1,
  required: ["static"]
}, g7 = {
  type: "object",
  properties: { idp: { type: "string" } },
  additionalProperties: !1,
  required: ["idp"]
}, y7 = {
  type: "object",
  properties: {
    type: { type: "string", const: "GRAVITEE" },
    apiBaseUrl: { type: "string" },
    env: { type: "string" },
    allowApiProductsOutsideCatalog: { type: "boolean", default: !1 },
    stage: { type: "string", default: "non-production" },
    auth: {
      oneOf: [m7, g7]
    }
  },
  additionalProperties: !1,
  required: ["type", "apiBaseUrl"]
}, v7 = {
  type: "object",
  properties: {
    type: { type: "string", const: gp.OAUTH2 },
    tokenEndpoint: { type: "string" },
    clientId: { type: "string" },
    clientSecret: { type: "string" }
  },
  additionalProperties: !1,
  required: ["type", "tokenEndpoint", "clientId", "clientSecret"]
}, b7 = {
  type: "object",
  properties: {
    type: { type: "string", const: gp.SERVICE_ACCOUNT },
    serviceAccountEmail: { type: "string" },
    serviceAccountPrivateKey: { type: "string" }
  },
  additionalProperties: !1,
  required: ["type", "serviceAccountEmail", "serviceAccountPrivateKey"]
}, kw = {
  type: "object",
  properties: {
    type: { type: "string", const: "APIGEE_X" },
    apiUrl: { type: "string" },
    stage: { type: "string", default: "non-production" },
    organizationName: { type: "string" },
    ignoreApiProducts: { type: "array", items: { type: "string" } },
    allowApiProductsOutsideCatalog: { type: "boolean", default: !1 },
    auth: {
      type: "object",
      oneOf: [v7, b7],
      discriminator: { propertyName: "type" }
    }
  },
  additionalProperties: !1,
  required: ["type", "organizationName", "auth"]
}, w7 = Object.assign(Object.assign({}, kw), { properties: Object.assign(Object.assign({}, kw.properties), { type: { type: "string", const: "APIGEE_EDGE" } }) }), S7 = {
  type: "object",
  oneOf: [kw, w7, y7],
  discriminator: { propertyName: "type" }
}, x7 = {
  type: "object",
  required: ["adapters"],
  additionalProperties: !1,
  properties: {
    adapters: {
      type: "array",
      items: S7
    }
  }
}, QA = {
  type: "object",
  properties: {
    defaultLocale: {
      type: "string"
    },
    locales: {
      type: "array",
      items: {
        type: "object",
        properties: {
          code: {
            type: "string"
          },
          name: {
            type: "string"
          }
        },
        required: ["code"]
      }
    }
  },
  additionalProperties: !1,
  required: ["defaultLocale"]
}, E7 = {
  type: "object",
  properties: {
    name: { type: "string" },
    value: { type: "string" }
  },
  additionalProperties: !1,
  required: ["name", "value"]
}, Aw = {
  type: "object",
  properties: {
    /**
     * @deprecated Should use `plugins` instead
     */
    imports: {
      type: "array",
      items: { type: "string" }
    },
    licenseKey: { type: "string" },
    redirects: c7,
    seo: d7,
    rbac: TL,
    apiFunctions: h7,
    requiresLogin: { type: "boolean" },
    responseHeaders: {
      type: "object",
      additionalProperties: {
        type: "array",
        items: E7
      }
    },
    mockServer: {
      type: "object",
      properties: {
        off: { type: "boolean", default: !1 },
        position: { type: "string", enum: ["first", "last", "replace", "off"], default: "first" },
        strictExamples: { type: "boolean", default: !1 },
        errorIfForcedExampleNotFound: { type: "boolean", default: !1 },
        description: { type: "string" }
      }
    },
    apis: {
      type: "object",
      additionalProperties: PL
    },
    rules: AL,
    decorators: { type: "object", additionalProperties: !0 },
    preprocessors: { type: "object", additionalProperties: !0 },
    ssoDirect: a7,
    sso: l7,
    residency: { type: "string" },
    developerOnboarding: x7,
    removeAttribution: { type: "boolean" },
    i18n: QA,
    // deprecated
    l10n: QA,
    metadata: p7,
    metadataGlobs: f7,
    ignore: {
      type: "array",
      items: {
        type: "string"
      }
    },
    /**
     * @deprecated properties moved to the root of the config
     */
    theme: Gn,
    reunite: r7,
    // Ex theme properties
    logo: aL,
    navbar: lL,
    products: uL,
    footer: cL,
    sidebar: pL,
    scripts: fL,
    links: dL,
    feedback: Qg,
    search: hL,
    colorMode: mL,
    navigation: gL,
    codeSnippet: yL,
    markdown: vL,
    openapi: Vm,
    graphql: Bm,
    analytics: wL,
    userMenu: SL,
    versionPicker: xL,
    breadcrumbs: EL,
    catalog: _L,
    scorecard: OL
  },
  default: { redirects: {} },
  additionalProperties: !0
}, _7 = Object.assign(Object.assign({}, Ow(Aw, "default")), { additionalProperties: !1 }), O7 = Object.assign(Object.assign({ $id: "root-redocly-config" }, Aw), { properties: Object.assign(Object.assign({ plugins: {
  type: "array",
  items: { type: "string" }
} }, Aw.properties), { env: {
  type: "object",
  additionalProperties: _7
  // TODO: if we want full validation we need to override apis, theme and the root
} }), default: {}, additionalProperties: !1 }), Pw = {
  type: "object",
  properties: {
    logo: Gn.properties.logo,
    navbar: Gn.properties.navbar,
    footer: Gn.properties.footer,
    sidebar: Gn.properties.sidebar,
    search: Gn.properties.search,
    codeSnippet: Gn.properties.codeSnippet,
    breadcrumbs: Gn.properties.breadcrumbs,
    openapi: Gn.properties.openapi,
    feedback: Gn.properties.feedback,
    analytics: {
      type: "object",
      properties: {
        ga: bL
      }
    }
  },
  additionalProperties: !0,
  default: {}
}, k7 = {
  $id: "product-config-override",
  type: "object",
  properties: Object.assign(Object.assign({}, Pw.properties), {
    apis: {
      type: "object",
      additionalProperties: PL
    },
    /**
     * @deprecated left for backwards compatibility
     */
    theme: Pw
  }),
  additionalProperties: !1
}, A7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ApigeeDevOnboardingIntegrationAuthType() {
    return gp;
  },
  get AuthProviderType() {
    return mp;
  },
  DEFAULT_TEAM_CLAIM_NAME: kL,
  get LayoutVariant() {
    return _w;
  },
  REDOCLY_ROUTE_RBAC: XH,
  REDOCLY_TEAMS_RBAC: KH,
  productConfigOverrideSchema: k7,
  productThemeOverrideSchema: Pw,
  rbacConfigSchema: TL,
  redocConfigSchema: Ew,
  rootRedoclyConfigSchema: O7
}, Symbol.toStringTag, { value: "Module" })), P7 = /* @__PURE__ */ Di(A7);
var Td = {}, Cd = { exports: {} }, Ab = {}, Bs = {}, nc = {}, Pb = {}, Tb = {}, Cb = {}, YA;
function Wm() {
  return YA || (YA = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.nil = e._Code = e.Name = e.IDENTIFIER = e._CodeOrName = void 0, e._ = i, e.str = o, e.addCodeArg = a, e.strConcat = f, e.stringify = m, e.safeStringify = v, e.getProperty = S, e.getEsmExportName = y, e.regexpCode = E;
    class t {
    }
    e._CodeOrName = t, e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    class r extends t {
      constructor(g) {
        if (super(), !e.IDENTIFIER.test(g))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = g;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return !1;
      }
      get names() {
        return { [this.str]: 1 };
      }
    }
    e.Name = r;
    class n extends t {
      constructor(g) {
        super(), this._items = typeof g == "string" ? [g] : g;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return !1;
        const g = this._items[0];
        return g === "" || g === '""';
      }
      get str() {
        var g;
        return (g = this._str) !== null && g !== void 0 ? g : this._str = this._items.reduce((b, A) => `${b}${A}`, "");
      }
      get names() {
        var g;
        return (g = this._names) !== null && g !== void 0 ? g : this._names = this._items.reduce((b, A) => (A instanceof r && (b[A.str] = (b[A.str] || 0) + 1), b), {});
      }
    }
    e._Code = n, e.nil = new n("");
    function i(x, ...g) {
      const b = [x[0]];
      let A = 0;
      for (; A < g.length; )
        a(b, g[A]), b.push(x[++A]);
      return new n(b);
    }
    const s = new n("+");
    function o(x, ...g) {
      const b = [v(x[0])];
      let A = 0;
      for (; A < g.length; )
        b.push(s), a(b, g[A]), b.push(s, v(x[++A]));
      return l(b), new n(b);
    }
    function a(x, g) {
      g instanceof n ? x.push(...g._items) : g instanceof r ? x.push(g) : x.push(d(g));
    }
    function l(x) {
      let g = 1;
      for (; g < x.length - 1; ) {
        if (x[g] === s) {
          const b = u(x[g - 1], x[g + 1]);
          if (b !== void 0) {
            x.splice(g - 1, 3, b);
            continue;
          }
          x[g++] = "+";
        }
        g++;
      }
    }
    function u(x, g) {
      if (g === '""')
        return x;
      if (x === '""')
        return g;
      if (typeof x == "string")
        return g instanceof r || x[x.length - 1] !== '"' ? void 0 : typeof g != "string" ? `${x.slice(0, -1)}${g}"` : g[0] === '"' ? x.slice(0, -1) + g.slice(1) : void 0;
      if (typeof g == "string" && g[0] === '"' && !(x instanceof r))
        return `"${x}${g.slice(1)}`;
    }
    function f(x, g) {
      return g.emptyStr() ? x : x.emptyStr() ? g : o`${x}${g}`;
    }
    function d(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : v(Array.isArray(x) ? x.join(",") : x);
    }
    function m(x) {
      return new n(v(x));
    }
    function v(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    function S(x) {
      return typeof x == "string" && e.IDENTIFIER.test(x) ? new n(`.${x}`) : i`[${x}]`;
    }
    function y(x) {
      if (typeof x == "string" && e.IDENTIFIER.test(x))
        return new n(`${x}`);
      throw new Error(`CodeGen: invalid export name: ${x}, use explicit $id name mapping`);
    }
    function E(x) {
      return new n(x.toString());
    }
  }(Cb)), Cb;
}
var $b = {}, GA;
function KA() {
  return GA || (GA = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ValueScope = e.ValueScopeName = e.Scope = e.varKinds = e.UsedValueState = void 0;
    const t = Wm();
    class r extends Error {
      constructor(u) {
        super(`CodeGen: "code" for ${u} not defined`), this.value = u.value;
      }
    }
    var n;
    (function(l) {
      l[l.Started = 0] = "Started", l[l.Completed = 1] = "Completed";
    })(n || (e.UsedValueState = n = {})), e.varKinds = {
      const: new t.Name("const"),
      let: new t.Name("let"),
      var: new t.Name("var")
    };
    class i {
      constructor({ prefixes: u, parent: f } = {}) {
        this._names = {}, this._prefixes = u, this._parent = f;
      }
      toName(u) {
        return u instanceof t.Name ? u : this.name(u);
      }
      name(u) {
        return new t.Name(this._newName(u));
      }
      _newName(u) {
        const f = this._names[u] || this._nameGroup(u);
        return `${u}${f.index++}`;
      }
      _nameGroup(u) {
        var f, d;
        if (!((d = (f = this._parent) === null || f === void 0 ? void 0 : f._prefixes) === null || d === void 0) && d.has(u) || this._prefixes && !this._prefixes.has(u))
          throw new Error(`CodeGen: prefix "${u}" is not allowed in this scope`);
        return this._names[u] = { prefix: u, index: 0 };
      }
    }
    e.Scope = i;
    class s extends t.Name {
      constructor(u, f) {
        super(f), this.prefix = u;
      }
      setValue(u, { property: f, itemIndex: d }) {
        this.value = u, this.scopePath = (0, t._)`.${new t.Name(f)}[${d}]`;
      }
    }
    e.ValueScopeName = s;
    const o = (0, t._)`\n`;
    class a extends i {
      constructor(u) {
        super(u), this._values = {}, this._scope = u.scope, this.opts = { ...u, _n: u.lines ? o : t.nil };
      }
      get() {
        return this._scope;
      }
      name(u) {
        return new s(u, this._newName(u));
      }
      value(u, f) {
        var d;
        if (f.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const m = this.toName(u), { prefix: v } = m, S = (d = f.key) !== null && d !== void 0 ? d : f.ref;
        let y = this._values[v];
        if (y) {
          const g = y.get(S);
          if (g)
            return g;
        } else
          y = this._values[v] = /* @__PURE__ */ new Map();
        y.set(S, m);
        const E = this._scope[v] || (this._scope[v] = []), x = E.length;
        return E[x] = f.ref, m.setValue(f, { property: v, itemIndex: x }), m;
      }
      getValue(u, f) {
        const d = this._values[u];
        if (d)
          return d.get(f);
      }
      scopeRefs(u, f = this._values) {
        return this._reduceValues(f, (d) => {
          if (d.scopePath === void 0)
            throw new Error(`CodeGen: name "${d}" has no value`);
          return (0, t._)`${u}${d.scopePath}`;
        });
      }
      scopeCode(u = this._values, f, d) {
        return this._reduceValues(u, (m) => {
          if (m.value === void 0)
            throw new Error(`CodeGen: name "${m}" has no value`);
          return m.value.code;
        }, f, d);
      }
      _reduceValues(u, f, d = {}, m) {
        let v = t.nil;
        for (const S in u) {
          const y = u[S];
          if (!y)
            continue;
          const E = d[S] = d[S] || /* @__PURE__ */ new Map();
          y.forEach((x) => {
            if (E.has(x))
              return;
            E.set(x, n.Started);
            let g = f(x);
            if (g) {
              const b = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
              v = (0, t._)`${v}${b} ${x} = ${g};${this.opts._n}`;
            } else if (g = m == null ? void 0 : m(x))
              v = (0, t._)`${v}${g}${this.opts._n}`;
            else
              throw new r(x);
            E.set(x, n.Completed);
          });
        }
        return v;
      }
    }
    e.ValueScope = a;
  }($b)), $b;
}
var XA;
function ot() {
  return XA || (XA = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.operators = e.varKinds = e.ValueScopeName = e.ValueScope = e.Scope = e.Name = e.regexpCode = e.stringify = e.getProperty = e.nil = e.strConcat = e.str = e._ = void 0, e.not = ce, e.and = G, e.or = K;
    const t = Wm(), r = KA();
    var n = Wm();
    Object.defineProperty(e, "_", { enumerable: !0, get: function() {
      return n._;
    } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
      return n.str;
    } }), Object.defineProperty(e, "strConcat", { enumerable: !0, get: function() {
      return n.strConcat;
    } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
      return n.nil;
    } }), Object.defineProperty(e, "getProperty", { enumerable: !0, get: function() {
      return n.getProperty;
    } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
      return n.stringify;
    } }), Object.defineProperty(e, "regexpCode", { enumerable: !0, get: function() {
      return n.regexpCode;
    } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
      return n.Name;
    } });
    var i = KA();
    Object.defineProperty(e, "Scope", { enumerable: !0, get: function() {
      return i.Scope;
    } }), Object.defineProperty(e, "ValueScope", { enumerable: !0, get: function() {
      return i.ValueScope;
    } }), Object.defineProperty(e, "ValueScopeName", { enumerable: !0, get: function() {
      return i.ValueScopeName;
    } }), Object.defineProperty(e, "varKinds", { enumerable: !0, get: function() {
      return i.varKinds;
    } }), e.operators = {
      GT: new t._Code(">"),
      GTE: new t._Code(">="),
      LT: new t._Code("<"),
      LTE: new t._Code("<="),
      EQ: new t._Code("==="),
      NEQ: new t._Code("!=="),
      NOT: new t._Code("!"),
      OR: new t._Code("||"),
      AND: new t._Code("&&"),
      ADD: new t._Code("+")
    };
    class s {
      optimizeNodes() {
        return this;
      }
      optimizeNames(j, H) {
        return this;
      }
    }
    class o extends s {
      constructor(j, H, B) {
        super(), this.varKind = j, this.name = H, this.rhs = B;
      }
      render({ es5: j, _n: H }) {
        const B = j ? r.varKinds.var : this.varKind, pe = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${B} ${this.name}${pe};` + H;
      }
      optimizeNames(j, H) {
        if (j[this.name.str])
          return this.rhs && (this.rhs = le(this.rhs, j, H)), this;
      }
      get names() {
        return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
      }
    }
    class a extends s {
      constructor(j, H, B) {
        super(), this.lhs = j, this.rhs = H, this.sideEffects = B;
      }
      render({ _n: j }) {
        return `${this.lhs} = ${this.rhs};` + j;
      }
      optimizeNames(j, H) {
        if (!(this.lhs instanceof t.Name && !j[this.lhs.str] && !this.sideEffects))
          return this.rhs = le(this.rhs, j, H), this;
      }
      get names() {
        const j = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
        return ae(j, this.rhs);
      }
    }
    class l extends a {
      constructor(j, H, B, pe) {
        super(j, B, pe), this.op = H;
      }
      render({ _n: j }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + j;
      }
    }
    class u extends s {
      constructor(j) {
        super(), this.label = j, this.names = {};
      }
      render({ _n: j }) {
        return `${this.label}:` + j;
      }
    }
    class f extends s {
      constructor(j) {
        super(), this.label = j, this.names = {};
      }
      render({ _n: j }) {
        return `break${this.label ? ` ${this.label}` : ""};` + j;
      }
    }
    class d extends s {
      constructor(j) {
        super(), this.error = j;
      }
      render({ _n: j }) {
        return `throw ${this.error};` + j;
      }
      get names() {
        return this.error.names;
      }
    }
    class m extends s {
      constructor(j) {
        super(), this.code = j;
      }
      render({ _n: j }) {
        return `${this.code};` + j;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(j, H) {
        return this.code = le(this.code, j, H), this;
      }
      get names() {
        return this.code instanceof t._CodeOrName ? this.code.names : {};
      }
    }
    class v extends s {
      constructor(j = []) {
        super(), this.nodes = j;
      }
      render(j) {
        return this.nodes.reduce((H, B) => H + B.render(j), "");
      }
      optimizeNodes() {
        const { nodes: j } = this;
        let H = j.length;
        for (; H--; ) {
          const B = j[H].optimizeNodes();
          Array.isArray(B) ? j.splice(H, 1, ...B) : B ? j[H] = B : j.splice(H, 1);
        }
        return j.length > 0 ? this : void 0;
      }
      optimizeNames(j, H) {
        const { nodes: B } = this;
        let pe = B.length;
        for (; pe--; ) {
          const he = B[pe];
          he.optimizeNames(j, H) || (ue(j, he.names), B.splice(pe, 1));
        }
        return B.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((j, H) => Y(j, H.names), {});
      }
    }
    class S extends v {
      render(j) {
        return "{" + j._n + super.render(j) + "}" + j._n;
      }
    }
    class y extends v {
    }
    class E extends S {
    }
    E.kind = "else";
    class x extends S {
      constructor(j, H) {
        super(H), this.condition = j;
      }
      render(j) {
        let H = `if(${this.condition})` + super.render(j);
        return this.else && (H += "else " + this.else.render(j)), H;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const j = this.condition;
        if (j === !0)
          return this.nodes;
        let H = this.else;
        if (H) {
          const B = H.optimizeNodes();
          H = this.else = Array.isArray(B) ? new E(B) : B;
        }
        if (H)
          return j === !1 ? H instanceof x ? H : H.nodes : this.nodes.length ? this : new x(ce(j), H instanceof x ? [H] : H.nodes);
        if (!(j === !1 || !this.nodes.length))
          return this;
      }
      optimizeNames(j, H) {
        var B;
        if (this.else = (B = this.else) === null || B === void 0 ? void 0 : B.optimizeNames(j, H), !!(super.optimizeNames(j, H) || this.else))
          return this.condition = le(this.condition, j, H), this;
      }
      get names() {
        const j = super.names;
        return ae(j, this.condition), this.else && Y(j, this.else.names), j;
      }
    }
    x.kind = "if";
    class g extends S {
    }
    g.kind = "for";
    class b extends g {
      constructor(j) {
        super(), this.iteration = j;
      }
      render(j) {
        return `for(${this.iteration})` + super.render(j);
      }
      optimizeNames(j, H) {
        if (super.optimizeNames(j, H))
          return this.iteration = le(this.iteration, j, H), this;
      }
      get names() {
        return Y(super.names, this.iteration.names);
      }
    }
    class A extends g {
      constructor(j, H, B, pe) {
        super(), this.varKind = j, this.name = H, this.from = B, this.to = pe;
      }
      render(j) {
        const H = j.es5 ? r.varKinds.var : this.varKind, { name: B, from: pe, to: he } = this;
        return `for(${H} ${B}=${pe}; ${B}<${he}; ${B}++)` + super.render(j);
      }
      get names() {
        const j = ae(super.names, this.from);
        return ae(j, this.to);
      }
    }
    class P extends g {
      constructor(j, H, B, pe) {
        super(), this.loop = j, this.varKind = H, this.name = B, this.iterable = pe;
      }
      render(j) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(j);
      }
      optimizeNames(j, H) {
        if (super.optimizeNames(j, H))
          return this.iterable = le(this.iterable, j, H), this;
      }
      get names() {
        return Y(super.names, this.iterable.names);
      }
    }
    class k extends S {
      constructor(j, H, B) {
        super(), this.name = j, this.args = H, this.async = B;
      }
      render(j) {
        return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(j);
      }
    }
    k.kind = "func";
    class $ extends v {
      render(j) {
        return "return " + super.render(j);
      }
    }
    $.kind = "return";
    class I extends S {
      render(j) {
        let H = "try" + super.render(j);
        return this.catch && (H += this.catch.render(j)), this.finally && (H += this.finally.render(j)), H;
      }
      optimizeNodes() {
        var j, H;
        return super.optimizeNodes(), (j = this.catch) === null || j === void 0 || j.optimizeNodes(), (H = this.finally) === null || H === void 0 || H.optimizeNodes(), this;
      }
      optimizeNames(j, H) {
        var B, pe;
        return super.optimizeNames(j, H), (B = this.catch) === null || B === void 0 || B.optimizeNames(j, H), (pe = this.finally) === null || pe === void 0 || pe.optimizeNames(j, H), this;
      }
      get names() {
        const j = super.names;
        return this.catch && Y(j, this.catch.names), this.finally && Y(j, this.finally.names), j;
      }
    }
    class F extends S {
      constructor(j) {
        super(), this.error = j;
      }
      render(j) {
        return `catch(${this.error})` + super.render(j);
      }
    }
    F.kind = "catch";
    class L extends S {
      render(j) {
        return "finally" + super.render(j);
      }
    }
    L.kind = "finally";
    class Q {
      constructor(j, H = {}) {
        this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...H, _n: H.lines ? `
` : "" }, this._extScope = j, this._scope = new r.Scope({ parent: j }), this._nodes = [new y()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(j) {
        return this._scope.name(j);
      }
      // reserves unique name in the external scope
      scopeName(j) {
        return this._extScope.name(j);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(j, H) {
        const B = this._extScope.value(j, H);
        return (this._values[B.prefix] || (this._values[B.prefix] = /* @__PURE__ */ new Set())).add(B), B;
      }
      getScopeValue(j, H) {
        return this._extScope.getValue(j, H);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(j) {
        return this._extScope.scopeRefs(j, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(j, H, B, pe) {
        const he = this._scope.toName(H);
        return B !== void 0 && pe && (this._constants[he.str] = B), this._leafNode(new o(j, he, B)), he;
      }
      // `const` declaration (`var` in es5 mode)
      const(j, H, B) {
        return this._def(r.varKinds.const, j, H, B);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(j, H, B) {
        return this._def(r.varKinds.let, j, H, B);
      }
      // `var` declaration with optional assignment
      var(j, H, B) {
        return this._def(r.varKinds.var, j, H, B);
      }
      // assignment code
      assign(j, H, B) {
        return this._leafNode(new a(j, H, B));
      }
      // `+=` code
      add(j, H) {
        return this._leafNode(new l(j, e.operators.ADD, H));
      }
      // appends passed SafeExpr to code or executes Block
      code(j) {
        return typeof j == "function" ? j() : j !== t.nil && this._leafNode(new m(j)), this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...j) {
        const H = ["{"];
        for (const [B, pe] of j)
          H.length > 1 && H.push(","), H.push(B), (B !== pe || this.opts.es5) && (H.push(":"), (0, t.addCodeArg)(H, pe));
        return H.push("}"), new t._Code(H);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(j, H, B) {
        if (this._blockNode(new x(j)), H && B)
          this.code(H).else().code(B).endIf();
        else if (H)
          this.code(H).endIf();
        else if (B)
          throw new Error('CodeGen: "else" body without "then" body');
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(j) {
        return this._elseNode(new x(j));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new E());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(x, E);
      }
      _for(j, H) {
        return this._blockNode(j), H && this.code(H).endFor(), this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(j, H) {
        return this._for(new b(j), H);
      }
      // `for` statement for a range of values
      forRange(j, H, B, pe, he = this.opts.es5 ? r.varKinds.var : r.varKinds.let) {
        const Ae = this._scope.toName(j);
        return this._for(new A(he, Ae, H, B), () => pe(Ae));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(j, H, B, pe = r.varKinds.const) {
        const he = this._scope.toName(j);
        if (this.opts.es5) {
          const Ae = H instanceof t.Name ? H : this.var("_arr", H);
          return this.forRange("_i", 0, (0, t._)`${Ae}.length`, (C) => {
            this.var(he, (0, t._)`${Ae}[${C}]`), B(he);
          });
        }
        return this._for(new P("of", pe, he, H), () => B(he));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(j, H, B, pe = this.opts.es5 ? r.varKinds.var : r.varKinds.const) {
        if (this.opts.ownProperties)
          return this.forOf(j, (0, t._)`Object.keys(${H})`, B);
        const he = this._scope.toName(j);
        return this._for(new P("in", pe, he, H), () => B(he));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(g);
      }
      // `label` statement
      label(j) {
        return this._leafNode(new u(j));
      }
      // `break` statement
      break(j) {
        return this._leafNode(new f(j));
      }
      // `return` statement
      return(j) {
        const H = new $();
        if (this._blockNode(H), this.code(j), H.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode($);
      }
      // `try` statement
      try(j, H, B) {
        if (!H && !B)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const pe = new I();
        if (this._blockNode(pe), this.code(j), H) {
          const he = this.name("e");
          this._currNode = pe.catch = new F(he), H(he);
        }
        return B && (this._currNode = pe.finally = new L(), this.code(B)), this._endBlockNode(F, L);
      }
      // `throw` statement
      throw(j) {
        return this._leafNode(new d(j));
      }
      // start self-balancing block
      block(j, H) {
        return this._blockStarts.push(this._nodes.length), j && this.code(j).endBlock(H), this;
      }
      // end the current self-balancing block
      endBlock(j) {
        const H = this._blockStarts.pop();
        if (H === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const B = this._nodes.length - H;
        if (B < 0 || j !== void 0 && B !== j)
          throw new Error(`CodeGen: wrong number of nodes: ${B} vs ${j} expected`);
        return this._nodes.length = H, this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(j, H = t.nil, B, pe) {
        return this._blockNode(new k(j, H, B)), pe && this.code(pe).endFunc(), this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(k);
      }
      optimize(j = 1) {
        for (; j-- > 0; )
          this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
      }
      _leafNode(j) {
        return this._currNode.nodes.push(j), this;
      }
      _blockNode(j) {
        this._currNode.nodes.push(j), this._nodes.push(j);
      }
      _endBlockNode(j, H) {
        const B = this._currNode;
        if (B instanceof j || H && B instanceof H)
          return this._nodes.pop(), this;
        throw new Error(`CodeGen: not in block "${H ? `${j.kind}/${H.kind}` : j.kind}"`);
      }
      _elseNode(j) {
        const H = this._currNode;
        if (!(H instanceof x))
          throw new Error('CodeGen: "else" without "if"');
        return this._currNode = H.else = j, this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const j = this._nodes;
        return j[j.length - 1];
      }
      set _currNode(j) {
        const H = this._nodes;
        H[H.length - 1] = j;
      }
    }
    e.CodeGen = Q;
    function Y(q, j) {
      for (const H in j)
        q[H] = (q[H] || 0) + (j[H] || 0);
      return q;
    }
    function ae(q, j) {
      return j instanceof t._CodeOrName ? Y(q, j.names) : q;
    }
    function le(q, j, H) {
      if (q instanceof t.Name)
        return B(q);
      if (!pe(q))
        return q;
      return new t._Code(q._items.reduce((he, Ae) => (Ae instanceof t.Name && (Ae = B(Ae)), Ae instanceof t._Code ? he.push(...Ae._items) : he.push(Ae), he), []));
      function B(he) {
        const Ae = H[he.str];
        return Ae === void 0 || j[he.str] !== 1 ? he : (delete j[he.str], Ae);
      }
      function pe(he) {
        return he instanceof t._Code && he._items.some((Ae) => Ae instanceof t.Name && j[Ae.str] === 1 && H[Ae.str] !== void 0);
      }
    }
    function ue(q, j) {
      for (const H in j)
        q[H] = (q[H] || 0) - (j[H] || 0);
    }
    function ce(q) {
      return typeof q == "boolean" || typeof q == "number" || q === null ? !q : (0, t._)`!${te(q)}`;
    }
    const be = z(e.operators.AND);
    function G(...q) {
      return q.reduce(be);
    }
    const ee = z(e.operators.OR);
    function K(...q) {
      return q.reduce(ee);
    }
    function z(q) {
      return (j, H) => j === t.nil ? H : H === t.nil ? j : (0, t._)`${te(j)} ${q} ${te(H)}`;
    }
    function te(q) {
      return q instanceof t.Name ? q : (0, t._)`(${q})`;
    }
  }(Tb)), Tb;
}
var Bt = {}, JA;
function ct() {
  if (JA) return Bt;
  JA = 1, Object.defineProperty(Bt, "__esModule", { value: !0 }), Bt.Type = Bt.mergeEvaluated = void 0, Bt.toHash = r, Bt.alwaysValidSchema = n, Bt.checkUnknownRules = i, Bt.schemaHasRules = s, Bt.schemaHasRulesButRef = o, Bt.schemaRefOrVal = a, Bt.unescapeFragment = l, Bt.escapeFragment = u, Bt.escapeJsonPointer = f, Bt.unescapeJsonPointer = d, Bt.eachItem = m, Bt.evaluatedPropsToName = S, Bt.setEvaluated = y, Bt.useFunc = x, Bt.getErrorPath = b, Bt.checkStrictMode = A;
  const e = ot(), t = Wm();
  function r(P) {
    const k = {};
    for (const $ of P)
      k[$] = !0;
    return k;
  }
  function n(P, k) {
    return typeof k == "boolean" ? k : Object.keys(k).length === 0 ? !0 : (i(P, k), !s(k, P.self.RULES.all));
  }
  function i(P, k = P.schema) {
    const { opts: $, self: I } = P;
    if (!$.strictSchema || typeof k == "boolean")
      return;
    const F = I.RULES.keywords;
    for (const L in k)
      F[L] || A(P, `unknown keyword: "${L}"`);
  }
  function s(P, k) {
    if (typeof P == "boolean")
      return !P;
    for (const $ in P)
      if (k[$])
        return !0;
    return !1;
  }
  function o(P, k) {
    if (typeof P == "boolean")
      return !P;
    for (const $ in P)
      if ($ !== "$ref" && k.all[$])
        return !0;
    return !1;
  }
  function a({ topSchemaRef: P, schemaPath: k }, $, I, F) {
    if (!F) {
      if (typeof $ == "number" || typeof $ == "boolean")
        return $;
      if (typeof $ == "string")
        return (0, e._)`${$}`;
    }
    return (0, e._)`${P}${k}${(0, e.getProperty)(I)}`;
  }
  function l(P) {
    return d(decodeURIComponent(P));
  }
  function u(P) {
    return encodeURIComponent(f(P));
  }
  function f(P) {
    return typeof P == "number" ? `${P}` : P.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function d(P) {
    return P.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  function m(P, k) {
    if (Array.isArray(P))
      for (const $ of P)
        k($);
    else
      k(P);
  }
  function v({ mergeNames: P, mergeToName: k, mergeValues: $, resultToName: I }) {
    return (F, L, Q, Y) => {
      const ae = Q === void 0 ? L : Q instanceof e.Name ? (L instanceof e.Name ? P(F, L, Q) : k(F, L, Q), Q) : L instanceof e.Name ? (k(F, Q, L), L) : $(L, Q);
      return Y === e.Name && !(ae instanceof e.Name) ? I(F, ae) : ae;
    };
  }
  Bt.mergeEvaluated = {
    props: v({
      mergeNames: (P, k, $) => P.if((0, e._)`${$} !== true && ${k} !== undefined`, () => {
        P.if((0, e._)`${k} === true`, () => P.assign($, !0), () => P.assign($, (0, e._)`${$} || {}`).code((0, e._)`Object.assign(${$}, ${k})`));
      }),
      mergeToName: (P, k, $) => P.if((0, e._)`${$} !== true`, () => {
        k === !0 ? P.assign($, !0) : (P.assign($, (0, e._)`${$} || {}`), y(P, $, k));
      }),
      mergeValues: (P, k) => P === !0 ? !0 : { ...P, ...k },
      resultToName: S
    }),
    items: v({
      mergeNames: (P, k, $) => P.if((0, e._)`${$} !== true && ${k} !== undefined`, () => P.assign($, (0, e._)`${k} === true ? true : ${$} > ${k} ? ${$} : ${k}`)),
      mergeToName: (P, k, $) => P.if((0, e._)`${$} !== true`, () => P.assign($, k === !0 ? !0 : (0, e._)`${$} > ${k} ? ${$} : ${k}`)),
      mergeValues: (P, k) => P === !0 ? !0 : Math.max(P, k),
      resultToName: (P, k) => P.var("items", k)
    })
  };
  function S(P, k) {
    if (k === !0)
      return P.var("props", !0);
    const $ = P.var("props", (0, e._)`{}`);
    return k !== void 0 && y(P, $, k), $;
  }
  function y(P, k, $) {
    Object.keys($).forEach((I) => P.assign((0, e._)`${k}${(0, e.getProperty)(I)}`, !0));
  }
  const E = {};
  function x(P, k) {
    return P.scopeValue("func", {
      ref: k,
      code: E[k.code] || (E[k.code] = new t._Code(k.code))
    });
  }
  var g;
  (function(P) {
    P[P.Num = 0] = "Num", P[P.Str = 1] = "Str";
  })(g || (Bt.Type = g = {}));
  function b(P, k, $) {
    if (P instanceof e.Name) {
      const I = k === g.Num;
      return $ ? I ? (0, e._)`"[" + ${P} + "]"` : (0, e._)`"['" + ${P} + "']"` : I ? (0, e._)`"/" + ${P}` : (0, e._)`"/" + ${P}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return $ ? (0, e.getProperty)(P).toString() : "/" + f(P);
  }
  function A(P, k, $ = P.opts.strictSchema) {
    if ($) {
      if (k = `strict mode: ${k}`, $ === !0)
        throw new Error(k);
      P.self.logger.warn(k);
    }
  }
  return Bt;
}
var $d = {}, ZA;
function pi() {
  if (ZA) return $d;
  ZA = 1, Object.defineProperty($d, "__esModule", { value: !0 });
  const e = ot(), t = {
    // validation function arguments
    data: new e.Name("data"),
    // data passed to validation function
    // args passed from referencing schema
    valCxt: new e.Name("valCxt"),
    // validation/data context - should not be used directly, it is destructured to the names below
    instancePath: new e.Name("instancePath"),
    parentData: new e.Name("parentData"),
    parentDataProperty: new e.Name("parentDataProperty"),
    rootData: new e.Name("rootData"),
    // root data - same as the data passed to the first/top validation function
    dynamicAnchors: new e.Name("dynamicAnchors"),
    // used to support recursiveRef and dynamicRef
    isAllOfVariant: new e.Name("isAllOfVariant"),
    // used to check in runtime if the current function (ref) is called from allOf
    // function scoped variables
    vErrors: new e.Name("vErrors"),
    // null or array of validation errors
    errors: new e.Name("errors"),
    // counter of validation errors
    this: new e.Name("this"),
    // "globals"
    self: new e.Name("self"),
    scope: new e.Name("scope"),
    // JTD serialize/parse name for JSON string and position
    json: new e.Name("json"),
    jsonPos: new e.Name("jsonPos"),
    jsonLen: new e.Name("jsonLen"),
    jsonPart: new e.Name("jsonPart")
  };
  return $d.default = t, $d;
}
var eP;
function Gg() {
  return eP || (eP = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.keyword$DataError = e.keywordError = void 0, e.reportError = i, e.reportExtraError = s, e.resetErrorsCount = o, e.extendErrors = a;
    const t = ot(), r = ct(), n = pi();
    e.keywordError = {
      message: ({ keyword: E }) => (0, t.str)`must pass "${E}" keyword validation`
    }, e.keyword$DataError = {
      message: ({ keyword: E, schemaType: x }) => x ? (0, t.str)`"${E}" keyword must be ${x} ($data)` : (0, t.str)`"${E}" keyword is invalid ($data)`
    };
    function i(E, x = e.keywordError, g, b) {
      const { it: A } = E, { gen: P, compositeRule: k, allErrors: $ } = A, I = d(E, x, g);
      b ?? (k || $) ? l(P, I) : u(A, (0, t._)`[${I}]`);
    }
    function s(E, x = e.keywordError, g) {
      const { it: b } = E, { gen: A, compositeRule: P, allErrors: k } = b, $ = d(E, x, g);
      l(A, $), P || k || u(b, n.default.vErrors);
    }
    function o(E, x) {
      E.assign(n.default.errors, x), E.if((0, t._)`${n.default.vErrors} !== null`, () => E.if(x, () => E.assign((0, t._)`${n.default.vErrors}.length`, x), () => E.assign(n.default.vErrors, null)));
    }
    function a({ gen: E, keyword: x, schemaValue: g, data: b, errsCount: A, it: P }) {
      if (A === void 0)
        throw new Error("ajv implementation error");
      const k = E.name("err");
      E.forRange("i", A, n.default.errors, ($) => {
        E.const(k, (0, t._)`${n.default.vErrors}[${$}]`), E.if((0, t._)`${k}.instancePath === undefined`, () => E.assign((0, t._)`${k}.instancePath`, (0, t.strConcat)(n.default.instancePath, P.errorPath))), E.assign((0, t._)`${k}.schemaPath`, (0, t.str)`${P.errSchemaPath}/${x}`), P.opts.verbose && (E.assign((0, t._)`${k}.schema`, g), E.assign((0, t._)`${k}.data`, b));
      });
    }
    function l(E, x) {
      const g = E.const("err", x);
      E.if((0, t._)`${n.default.vErrors} === null`, () => E.assign(n.default.vErrors, (0, t._)`[${g}]`), (0, t._)`${n.default.vErrors}.push(${g})`), E.code((0, t._)`${n.default.errors}++`);
    }
    function u(E, x) {
      const { gen: g, validateName: b, schemaEnv: A } = E;
      A.$async ? g.throw((0, t._)`new ${E.ValidationError}(${x})`) : (g.assign((0, t._)`${b}.errors`, x), g.return(!1));
    }
    const f = {
      keyword: new t.Name("keyword"),
      schemaPath: new t.Name("schemaPath"),
      // also used in JTD errors
      params: new t.Name("params"),
      propertyName: new t.Name("propertyName"),
      message: new t.Name("message"),
      schema: new t.Name("schema"),
      parentSchema: new t.Name("parentSchema")
    };
    function d(E, x, g) {
      const { createErrors: b } = E.it;
      return b === !1 ? (0, t._)`{}` : m(E, x, g);
    }
    function m(E, x, g = {}) {
      const { gen: b, it: A } = E, P = [
        v(A, g),
        S(E, g)
      ];
      return y(E, x, P), b.object(...P);
    }
    function v({ errorPath: E }, { instancePath: x }) {
      const g = x ? (0, t.str)`${E}${(0, r.getErrorPath)(x, r.Type.Str)}` : E;
      return [n.default.instancePath, (0, t.strConcat)(n.default.instancePath, g)];
    }
    function S({ keyword: E, it: { errSchemaPath: x } }, { schemaPath: g, parentSchema: b }) {
      let A = b ? x : (0, t.str)`${x}/${E}`;
      return g && (A = (0, t.str)`${A}${(0, r.getErrorPath)(g, r.Type.Str)}`), [f.schemaPath, A];
    }
    function y(E, { params: x, message: g }, b) {
      const { keyword: A, data: P, schemaValue: k, it: $ } = E, { opts: I, propertyName: F, topSchemaRef: L, schemaPath: Q } = $;
      b.push([f.keyword, A], [f.params, typeof x == "function" ? x(E) : x || (0, t._)`{}`]), I.messages && b.push([f.message, typeof g == "function" ? g(E) : g]), I.verbose && b.push([f.schema, k], [f.parentSchema, (0, t._)`${L}${Q}`], [n.default.data, P]), F && b.push([f.propertyName, F]);
    }
  }(Pb)), Pb;
}
var tP;
function T7() {
  if (tP) return nc;
  tP = 1, Object.defineProperty(nc, "__esModule", { value: !0 }), nc.topBoolOrEmptySchema = i, nc.boolOrEmptySchema = s;
  const e = Gg(), t = ot(), r = pi(), n = {
    message: "boolean schema is false"
  };
  function i(a) {
    const { gen: l, schema: u, validateName: f } = a;
    u === !1 ? o(a, !1) : typeof u == "object" && u.$async === !0 ? l.return(r.default.data) : (l.assign((0, t._)`${f}.errors`, null), l.return(!0));
  }
  function s(a, l) {
    const { gen: u, schema: f } = a;
    f === !1 ? (u.var(l, !1), o(a)) : u.var(l, !0);
  }
  function o(a, l) {
    const { gen: u, data: f } = a, d = {
      gen: u,
      keyword: "false schema",
      data: f,
      schema: !1,
      schemaCode: !1,
      schemaValue: !1,
      params: {},
      it: a
    };
    (0, e.reportError)(d, n, void 0, l);
  }
  return nc;
}
var Qn = {}, ic = {}, rP;
function CL() {
  if (rP) return ic;
  rP = 1, Object.defineProperty(ic, "__esModule", { value: !0 }), ic.isJSONType = r, ic.getRules = n;
  const e = ["string", "number", "integer", "boolean", "null", "object", "array"], t = new Set(e);
  function r(i) {
    return typeof i == "string" && t.has(i);
  }
  function n() {
    const i = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...i, integer: !0, boolean: !0, null: !0 },
      rules: [{ rules: [] }, i.number, i.string, i.array, i.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  }
  return ic;
}
var rl = {}, nP;
function $L() {
  if (nP) return rl;
  nP = 1, Object.defineProperty(rl, "__esModule", { value: !0 }), rl.schemaHasRulesForType = e, rl.shouldUseGroup = t, rl.shouldUseRule = r;
  function e({ schema: n, self: i }, s) {
    const o = i.RULES.types[s];
    return o && o !== !0 && t(n, o);
  }
  function t(n, i) {
    return i.rules.some((s) => r(n, s));
  }
  function r(n, i) {
    var s;
    return n[i.keyword] !== void 0 || ((s = i.definition.implements) === null || s === void 0 ? void 0 : s.some((o) => n[o] !== void 0));
  }
  return rl;
}
var iP;
function Hm() {
  if (iP) return Qn;
  iP = 1, Object.defineProperty(Qn, "__esModule", { value: !0 }), Qn.DataType = void 0, Qn.getSchemaTypes = o, Qn.getJSONTypes = a, Qn.coerceAndCheckDataType = l, Qn.checkDataType = v, Qn.checkDataTypes = S, Qn.reportTypeError = E;
  const e = CL(), t = $L(), r = Gg(), n = ot(), i = ct();
  var s;
  (function(g) {
    g[g.Correct = 0] = "Correct", g[g.Wrong = 1] = "Wrong";
  })(s || (Qn.DataType = s = {}));
  function o(g) {
    const b = a(g.type);
    if (b.includes("null")) {
      if (g.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!b.length && g.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      g.nullable === !0 && b.push("null");
    }
    return b;
  }
  function a(g) {
    const b = Array.isArray(g) ? g : g ? [g] : [];
    if (b.every(e.isJSONType))
      return b;
    throw new Error("type must be JSONType or JSONType[]: " + b.join(","));
  }
  function l(g, b) {
    const { gen: A, data: P, opts: k } = g, $ = f(b, k.coerceTypes), I = b.length > 0 && !($.length === 0 && b.length === 1 && (0, t.schemaHasRulesForType)(g, b[0]));
    if (I) {
      const F = S(b, P, k.strictNumbers, s.Wrong);
      A.if(F, () => {
        $.length ? d(g, b, $) : E(g);
      });
    }
    return I;
  }
  const u = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function f(g, b) {
    return b ? g.filter((A) => u.has(A) || b === "array" && A === "array") : [];
  }
  function d(g, b, A) {
    const { gen: P, data: k, opts: $ } = g, I = P.let("dataType", (0, n._)`typeof ${k}`), F = P.let("coerced", (0, n._)`undefined`);
    $.coerceTypes === "array" && P.if((0, n._)`${I} == 'object' && Array.isArray(${k}) && ${k}.length == 1`, () => P.assign(k, (0, n._)`${k}[0]`).assign(I, (0, n._)`typeof ${k}`).if(S(b, k, $.strictNumbers), () => P.assign(F, k))), P.if((0, n._)`${F} !== undefined`);
    for (const Q of A)
      (u.has(Q) || Q === "array" && $.coerceTypes === "array") && L(Q);
    P.else(), E(g), P.endIf(), P.if((0, n._)`${F} !== undefined`, () => {
      P.assign(k, F), m(g, F);
    });
    function L(Q) {
      switch (Q) {
        case "string":
          P.elseIf((0, n._)`${I} == "number" || ${I} == "boolean"`).assign(F, (0, n._)`"" + ${k}`).elseIf((0, n._)`${k} === null`).assign(F, (0, n._)`""`);
          return;
        case "number":
          P.elseIf((0, n._)`${I} == "boolean" || ${k} === null
              || (${I} == "string" && ${k} && ${k} == +${k})`).assign(F, (0, n._)`+${k}`);
          return;
        case "integer":
          P.elseIf((0, n._)`${I} === "boolean" || ${k} === null
              || (${I} === "string" && ${k} && ${k} == +${k} && !(${k} % 1))`).assign(F, (0, n._)`+${k}`);
          return;
        case "boolean":
          P.elseIf((0, n._)`${k} === "false" || ${k} === 0 || ${k} === null`).assign(F, !1).elseIf((0, n._)`${k} === "true" || ${k} === 1`).assign(F, !0);
          return;
        case "null":
          P.elseIf((0, n._)`${k} === "" || ${k} === 0 || ${k} === false`), P.assign(F, null);
          return;
        case "array":
          P.elseIf((0, n._)`${I} === "string" || ${I} === "number"
              || ${I} === "boolean" || ${k} === null`).assign(F, (0, n._)`[${k}]`);
      }
    }
  }
  function m({ gen: g, parentData: b, parentDataProperty: A }, P) {
    g.if((0, n._)`${b} !== undefined`, () => g.assign((0, n._)`${b}[${A}]`, P));
  }
  function v(g, b, A, P = s.Correct) {
    const k = P === s.Correct ? n.operators.EQ : n.operators.NEQ;
    let $;
    switch (g) {
      case "null":
        return (0, n._)`${b} ${k} null`;
      case "array":
        $ = (0, n._)`Array.isArray(${b})`;
        break;
      case "object":
        $ = (0, n._)`${b} && typeof ${b} == "object" && !Array.isArray(${b})`;
        break;
      case "integer":
        $ = I((0, n._)`!(${b} % 1) && !isNaN(${b})`);
        break;
      case "number":
        $ = I();
        break;
      default:
        return (0, n._)`typeof ${b} ${k} ${g}`;
    }
    return P === s.Correct ? $ : (0, n.not)($);
    function I(F = n.nil) {
      return (0, n.and)((0, n._)`typeof ${b} == "number"`, F, A ? (0, n._)`isFinite(${b})` : n.nil);
    }
  }
  function S(g, b, A, P) {
    if (g.length === 1)
      return v(g[0], b, A, P);
    let k;
    const $ = (0, i.toHash)(g);
    if ($.array && $.object) {
      const I = (0, n._)`typeof ${b} != "object"`;
      k = $.null ? I : (0, n._)`!${b} || ${I}`, delete $.null, delete $.array, delete $.object;
    } else
      k = n.nil;
    $.number && delete $.integer;
    for (const I in $)
      k = (0, n.and)(k, v(I, b, A, P));
    return k;
  }
  const y = {
    message: ({ schema: g }) => `must be ${g}`,
    params: ({ schema: g, schemaValue: b }) => typeof g == "string" ? (0, n._)`{type: ${g}}` : (0, n._)`{type: ${b}}`
  };
  function E(g) {
    const b = x(g);
    (0, r.reportError)(b, y);
  }
  function x(g) {
    const { gen: b, data: A, schema: P } = g, k = (0, i.schemaRefOrVal)(g, P, "type");
    return {
      gen: b,
      keyword: "type",
      data: A,
      schema: P.type,
      schemaCode: k,
      schemaValue: k,
      parentSchema: P,
      params: {},
      it: g
    };
  }
  return Qn;
}
var Rd = {}, oP;
function C7() {
  if (oP) return Rd;
  oP = 1, Object.defineProperty(Rd, "__esModule", { value: !0 }), Rd.assignDefaults = r;
  const e = ot(), t = ct();
  function r(i, s) {
    const { properties: o, items: a } = i.schema;
    if (s === "object" && o)
      for (const l in o)
        n(i, l, o[l].default);
    else s === "array" && Array.isArray(a) && a.forEach((l, u) => n(i, u, l.default));
  }
  function n(i, s, o) {
    const { gen: a, compositeRule: l, data: u, opts: f } = i;
    if (o === void 0)
      return;
    const d = (0, e._)`${u}${(0, e.getProperty)(s)}`;
    if (l) {
      (0, t.checkStrictMode)(i, `default is ignored for: ${d}`);
      return;
    }
    let m = (0, e._)`${d} === undefined`;
    f.useDefaults === "empty" && (m = (0, e._)`${m} || ${d} === null || ${d} === ""`), a.if(m, (0, e._)`${d} = ${(0, e.stringify)(o)}`);
  }
  return Rd;
}
var Us = {}, Rr = {}, sP;
function fi() {
  if (sP) return Rr;
  sP = 1, Object.defineProperty(Rr, "__esModule", { value: !0 }), Rr.checkReportMissingProp = i, Rr.checkMissingProp = s, Rr.reportMissingProp = o, Rr.hasPropFunc = a, Rr.isOwnProperty = l, Rr.propertyInData = u, Rr.noPropertyInData = f, Rr.allSchemaProperties = d, Rr.schemaProperties = m, Rr.callValidateCode = v, Rr.usePattern = y, Rr.validateArray = E, Rr.validateUnion = x;
  const e = ot(), t = ct(), r = pi(), n = ct();
  function i(g, b) {
    const { gen: A, data: P, it: k } = g;
    A.if(f(A, P, b, k.opts.ownProperties), () => {
      g.setParams({ missingProperty: (0, e._)`${b}` }, !0), g.error();
    });
  }
  function s({ gen: g, data: b, it: { opts: A } }, P, k) {
    return (0, e.or)(...P.map(($) => (0, e.and)(f(g, b, $, A.ownProperties), (0, e._)`${k} = ${$}`)));
  }
  function o(g, b) {
    g.setParams({ missingProperty: b }, !0), g.error();
  }
  function a(g) {
    return g.scopeValue("func", {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ref: Object.prototype.hasOwnProperty,
      code: (0, e._)`Object.prototype.hasOwnProperty`
    });
  }
  function l(g, b, A) {
    return (0, e._)`${a(g)}.call(${b}, ${A})`;
  }
  function u(g, b, A, P) {
    const k = (0, e._)`${b}${(0, e.getProperty)(A)} !== undefined`;
    return P ? (0, e._)`${k} && ${l(g, b, A)}` : k;
  }
  function f(g, b, A, P) {
    const k = (0, e._)`${b}${(0, e.getProperty)(A)} === undefined`;
    return P ? (0, e.or)(k, (0, e.not)(l(g, b, A))) : k;
  }
  function d(g) {
    return g ? Object.keys(g).filter((b) => b !== "__proto__") : [];
  }
  function m(g, b) {
    return d(b).filter((A) => !(0, t.alwaysValidSchema)(g, b[A]));
  }
  function v({ schemaCode: g, data: b, it: { gen: A, topSchemaRef: P, schemaPath: k, errorPath: $ }, it: I }, F, L, Q) {
    const Y = Q ? (0, e._)`${g}, ${b}, ${P}${k}` : b, ae = [
      [r.default.instancePath, (0, e.strConcat)(r.default.instancePath, $)],
      [r.default.parentData, I.parentData],
      [r.default.parentDataProperty, I.parentDataProperty],
      [r.default.rootData, r.default.rootData],
      [r.default.isAllOfVariant, I.isAllOfVariant ? 1 : 0]
    ];
    I.opts.dynamicRef && ae.push([r.default.dynamicAnchors, r.default.dynamicAnchors]);
    const le = (0, e._)`${Y}, ${A.object(...ae)}`;
    return L !== e.nil ? (0, e._)`${F}.call(${L}, ${le})` : (0, e._)`${F}(${le})`;
  }
  const S = (0, e._)`new RegExp`;
  function y({ gen: g, it: { opts: b } }, A) {
    const P = b.unicodeRegExp ? "u" : "", { regExp: k } = b.code, $ = k(A, P);
    return g.scopeValue("pattern", {
      key: $.toString(),
      ref: $,
      code: (0, e._)`${k.code === "new RegExp" ? S : (0, n.useFunc)(g, k)}(${A}, ${P})`
    });
  }
  function E(g) {
    const { gen: b, data: A, keyword: P, it: k } = g, $ = b.name("valid");
    if (k.allErrors) {
      const F = b.let("valid", !0);
      return I(() => b.assign(F, !1)), F;
    }
    return b.var($, !0), I(() => b.break()), $;
    function I(F) {
      const L = b.const("len", (0, e._)`${A}.length`);
      b.forRange("i", 0, L, (Q) => {
        g.subschema({
          keyword: P,
          dataProp: Q,
          dataPropType: t.Type.Num
        }, $), b.if((0, e.not)($), F);
      });
    }
  }
  function x(g) {
    const { gen: b, schema: A, keyword: P, parentSchema: k, it: $ } = g;
    if (!Array.isArray(A))
      throw new Error("ajv implementation error");
    if ($.opts.discriminator && k.discriminator || A.some((Q) => (0, t.alwaysValidSchema)($, Q)) && !$.opts.unevaluated)
      return;
    const F = b.let("valid", !1), L = b.name("_valid");
    b.block(() => A.forEach((Q, Y) => {
      const ae = g.subschema({
        keyword: P,
        schemaProp: Y,
        compositeRule: !0
      }, L);
      b.assign(F, (0, e._)`${F} || ${L}`), g.mergeValidEvaluated(ae, L) || b.if((0, e.not)(F));
    })), g.result(F, () => g.reset(), () => g.error(!0));
  }
  return Rr;
}
var aP;
function $7() {
  if (aP) return Us;
  aP = 1, Object.defineProperty(Us, "__esModule", { value: !0 }), Us.macroKeywordCode = i, Us.funcKeywordCode = s, Us.validSchemaType = f, Us.validateKeywordUsage = d;
  const e = ot(), t = pi(), r = fi(), n = Gg();
  function i(m, v) {
    const { gen: S, keyword: y, schema: E, parentSchema: x, it: g } = m, b = v.macro.call(g.self, E, x, g), A = u(S, y, b);
    g.opts.validateSchema !== !1 && g.self.validateSchema(b, !0);
    const P = S.name("valid");
    m.subschema({
      schema: b,
      schemaPath: e.nil,
      errSchemaPath: `${g.errSchemaPath}/${y}`,
      topSchemaRef: A,
      compositeRule: !0
    }, P), m.pass(P, () => m.error(!0));
  }
  function s(m, v) {
    var S;
    const { gen: y, keyword: E, schema: x, parentSchema: g, $data: b, it: A } = m;
    l(A, v);
    const P = !b && v.compile ? v.compile.call(A.self, x, g, A) : v.validate, k = u(y, E, P), $ = y.let("valid");
    m.block$data($, I), m.ok((S = v.valid) !== null && S !== void 0 ? S : $);
    function I() {
      if (v.errors === !1)
        Q(), v.modifying && o(m), Y(() => m.error());
      else {
        const ae = v.async ? F() : L();
        v.modifying && o(m), Y(() => a(m, ae));
      }
    }
    function F() {
      const ae = y.let("ruleErrs", null);
      return y.try(() => Q((0, e._)`await `), (le) => y.assign($, !1).if((0, e._)`${le} instanceof ${A.ValidationError}`, () => y.assign(ae, (0, e._)`${le}.errors`), () => y.throw(le))), ae;
    }
    function L() {
      const ae = (0, e._)`${k}.errors`;
      return y.assign(ae, null), Q(e.nil), ae;
    }
    function Q(ae = v.async ? (0, e._)`await ` : e.nil) {
      const le = A.opts.passContext ? t.default.this : t.default.self, ue = !("compile" in v && !b || v.schema === !1);
      y.assign($, (0, e._)`${ae}${(0, r.callValidateCode)(m, k, le, ue)}`, v.modifying);
    }
    function Y(ae) {
      var le;
      y.if((0, e.not)((le = v.valid) !== null && le !== void 0 ? le : $), ae);
    }
  }
  function o(m) {
    const { gen: v, data: S, it: y } = m;
    v.if(y.parentData, () => v.assign(S, (0, e._)`${y.parentData}[${y.parentDataProperty}]`));
  }
  function a(m, v) {
    const { gen: S } = m;
    S.if((0, e._)`Array.isArray(${v})`, () => {
      S.assign(t.default.vErrors, (0, e._)`${t.default.vErrors} === null ? ${v} : ${t.default.vErrors}.concat(${v})`).assign(t.default.errors, (0, e._)`${t.default.vErrors}.length`), (0, n.extendErrors)(m);
    }, () => m.error());
  }
  function l({ schemaEnv: m }, v) {
    if (v.async && !m.$async)
      throw new Error("async keyword in sync schema");
  }
  function u(m, v, S) {
    if (S === void 0)
      throw new Error(`keyword "${v}" failed to compile`);
    return m.scopeValue("keyword", typeof S == "function" ? { ref: S } : { ref: S, code: (0, e.stringify)(S) });
  }
  function f(m, v, S = !1) {
    return !v.length || v.some((y) => y === "array" ? Array.isArray(m) : y === "object" ? m && typeof m == "object" && !Array.isArray(m) : typeof m == y || S && typeof m > "u");
  }
  function d({ schema: m, opts: v, self: S, errSchemaPath: y }, E, x) {
    if (Array.isArray(E.keyword) ? !E.keyword.includes(x) : E.keyword !== x)
      throw new Error("ajv implementation error");
    const g = E.dependencies;
    if (g != null && g.some((b) => !Object.prototype.hasOwnProperty.call(m, b)))
      throw new Error(`parent schema must have dependencies of ${x}: ${g.join(",")}`);
    if (E.validateSchema && !E.validateSchema(m[x])) {
      const A = `keyword "${x}" value is invalid at path "${y}": ` + S.errorsText(E.validateSchema.errors);
      if (v.validateSchema === "log")
        S.logger.error(A);
      else
        throw new Error(A);
    }
  }
  return Us;
}
var nl = {}, lP;
function R7() {
  if (lP) return nl;
  lP = 1, Object.defineProperty(nl, "__esModule", { value: !0 }), nl.getSubschema = r, nl.extendSubschemaData = n, nl.extendSubschemaMode = i;
  const e = ot(), t = ct();
  function r(s, { keyword: o, schemaProp: a, schema: l, schemaPath: u, errSchemaPath: f, topSchemaRef: d }) {
    if (o !== void 0 && l !== void 0)
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    if (o !== void 0) {
      const m = s.schema[o];
      return a === void 0 ? {
        schema: m,
        schemaPath: (0, e._)`${s.schemaPath}${(0, e.getProperty)(o)}`,
        errSchemaPath: `${s.errSchemaPath}/${o}`
      } : {
        schema: m[a],
        schemaPath: (0, e._)`${s.schemaPath}${(0, e.getProperty)(o)}${(0, e.getProperty)(a)}`,
        errSchemaPath: `${s.errSchemaPath}/${o}/${(0, t.escapeFragment)(a)}`
      };
    }
    if (l !== void 0) {
      if (u === void 0 || f === void 0 || d === void 0)
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      return {
        schema: l,
        schemaPath: u,
        topSchemaRef: d,
        errSchemaPath: f
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  function n(s, o, { dataProp: a, dataPropType: l, data: u, dataTypes: f, propertyName: d }) {
    if (u !== void 0 && a !== void 0)
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    const { gen: m } = o;
    if (a !== void 0) {
      const { errorPath: S, dataPathArr: y, opts: E } = o, x = m.let("data", (0, e._)`${o.data}${(0, e.getProperty)(a)}`, !0);
      v(x), s.errorPath = (0, e.str)`${S}${(0, t.getErrorPath)(a, l, E.jsPropertySyntax)}`, s.parentDataProperty = (0, e._)`${a}`, s.dataPathArr = [...y, s.parentDataProperty];
    }
    if (u !== void 0) {
      const S = u instanceof e.Name ? u : m.let("data", u, !0);
      v(S), d !== void 0 && (s.propertyName = d);
    }
    f && (s.dataTypes = f);
    function v(S) {
      s.data = S, s.dataLevel = o.dataLevel + 1, s.dataTypes = [], o.definedProperties = /* @__PURE__ */ new Set(), s.parentData = o.data, s.dataNames = [...o.dataNames, S];
    }
  }
  function i(s, { jtdDiscriminator: o, jtdMetadata: a, compositeRule: l, createErrors: u, allErrors: f }) {
    l !== void 0 && (s.compositeRule = l), u !== void 0 && (s.createErrors = u), f !== void 0 && (s.allErrors = f), s.jtdDiscriminator = o, s.jtdMetadata = a;
  }
  return nl;
}
var Zi = {}, Rb, uP;
function RL() {
  return uP || (uP = 1, Rb = function e(t, r) {
    if (t === r) return !0;
    if (t && r && typeof t == "object" && typeof r == "object") {
      if (t.constructor !== r.constructor) return !1;
      var n, i, s;
      if (Array.isArray(t)) {
        if (n = t.length, n != r.length) return !1;
        for (i = n; i-- !== 0; )
          if (!e(t[i], r[i])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === r.source && t.flags === r.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === r.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === r.toString();
      if (s = Object.keys(t), n = s.length, n !== Object.keys(r).length) return !1;
      for (i = n; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(r, s[i])) return !1;
      for (i = n; i-- !== 0; ) {
        var o = s[i];
        if (!e(t[o], r[o])) return !1;
      }
      return !0;
    }
    return t !== t && r !== r;
  }), Rb;
}
var Ib = { exports: {} }, cP;
function I7() {
  if (cP) return Ib.exports;
  cP = 1;
  var e = Ib.exports = function(n, i, s) {
    typeof i == "function" && (s = i, i = {}), s = i.cb || s;
    var o = typeof s == "function" ? s : s.pre || function() {
    }, a = s.post || function() {
    };
    t(i, o, a, n, "", n);
  };
  e.keywords = {
    additionalItems: !0,
    items: !0,
    contains: !0,
    additionalProperties: !0,
    propertyNames: !0,
    not: !0,
    if: !0,
    then: !0,
    else: !0
  }, e.arrayKeywords = {
    items: !0,
    allOf: !0,
    anyOf: !0,
    oneOf: !0
  }, e.propsKeywords = {
    $defs: !0,
    definitions: !0,
    properties: !0,
    patternProperties: !0,
    dependencies: !0
  }, e.skipKeywords = {
    default: !0,
    enum: !0,
    const: !0,
    required: !0,
    maximum: !0,
    minimum: !0,
    exclusiveMaximum: !0,
    exclusiveMinimum: !0,
    multipleOf: !0,
    maxLength: !0,
    minLength: !0,
    pattern: !0,
    format: !0,
    maxItems: !0,
    minItems: !0,
    uniqueItems: !0,
    maxProperties: !0,
    minProperties: !0
  };
  function t(n, i, s, o, a, l, u, f, d, m) {
    if (o && typeof o == "object" && !Array.isArray(o)) {
      i(o, a, l, u, f, d, m);
      for (var v in o) {
        var S = o[v];
        if (Array.isArray(S)) {
          if (v in e.arrayKeywords)
            for (var y = 0; y < S.length; y++)
              t(n, i, s, S[y], a + "/" + v + "/" + y, l, a, v, o, y);
        } else if (v in e.propsKeywords) {
          if (S && typeof S == "object")
            for (var E in S)
              t(n, i, s, S[E], a + "/" + v + "/" + r(E), l, a, v, o, E);
        } else (v in e.keywords || n.allKeys && !(v in e.skipKeywords)) && t(n, i, s, S, a + "/" + v, l, a, v, o);
      }
      s(o, a, l, u, f, d, m);
    }
  }
  function r(n) {
    return n.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  return Ib.exports;
}
var pP;
function Kg() {
  if (pP) return Zi;
  pP = 1, Object.defineProperty(Zi, "__esModule", { value: !0 }), Zi.inlineRef = i, Zi.getFullPath = l, Zi._getFullPath = u, Zi.normalizeId = d, Zi.resolveUrl = m, Zi.getSchemaRefs = S;
  const e = ct(), t = RL(), r = I7(), n = /* @__PURE__ */ new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  function i(y, E = !0) {
    return typeof y == "boolean" ? !0 : E === !0 ? !o(y) : E ? a(y) <= E : !1;
  }
  const s = /* @__PURE__ */ new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  function o(y) {
    for (const E in y) {
      if (s.has(E))
        return !0;
      const x = y[E];
      if (Array.isArray(x) && x.some(o) || typeof x == "object" && o(x))
        return !0;
    }
    return !1;
  }
  function a(y) {
    let E = 0;
    for (const x in y) {
      if (x === "$ref")
        return 1 / 0;
      if (E++, !n.has(x) && (typeof y[x] == "object" && (0, e.eachItem)(y[x], (g) => E += a(g)), E === 1 / 0))
        return 1 / 0;
    }
    return E;
  }
  function l(y, E = "", x) {
    x !== !1 && (E = d(E));
    const g = y.parse(E);
    return u(y, g);
  }
  function u(y, E) {
    return y.serialize(E).split("#")[0] + "#";
  }
  const f = /#\/?$/;
  function d(y) {
    return y ? y.replace(f, "") : "";
  }
  function m(y, E, x) {
    return x = d(x), y.resolve(E, x);
  }
  const v = /^[a-z_][-a-z0-9._]*$/i;
  function S(y, E) {
    if (typeof y == "boolean")
      return {};
    const { schemaId: x, uriResolver: g } = this.opts, b = d(y[x] || E), A = { "": b }, P = l(g, b, !1), k = {}, $ = /* @__PURE__ */ new Set();
    return r(y, { allKeys: !0 }, (L, Q, Y, ae) => {
      if (ae === void 0)
        return;
      const le = P + Q;
      let ue = A[ae];
      typeof L[x] == "string" && (ue = ce.call(this, L[x])), be.call(this, L.$anchor), be.call(this, L.$dynamicAnchor), A[Q] = ue;
      function ce(G) {
        const ee = this.opts.uriResolver.resolve;
        if (G = d(ue ? ee(ue, G) : G), $.has(G))
          throw F(G);
        $.add(G);
        let K = this.refs[G];
        return typeof K == "string" && (K = this.refs[K]), typeof K == "object" ? I(L, K.schema, G) : G !== d(le) && (G[0] === "#" ? (I(L, k[G], G), k[G] = L) : this.refs[G] = le), G;
      }
      function be(G) {
        if (typeof G == "string") {
          if (!v.test(G))
            throw new Error(`invalid anchor "${G}"`);
          ce.call(this, `#${G}`);
        }
      }
    }), k;
    function I(L, Q, Y) {
      if (Q !== void 0 && !t(L, Q))
        throw F(Y);
    }
    function F(L) {
      return new Error(`reference "${L}" resolves to more than one schema`);
    }
  }
  return Zi;
}
var fP;
function Xg() {
  if (fP) return Bs;
  fP = 1, Object.defineProperty(Bs, "__esModule", { value: !0 }), Bs.KeywordCxt = void 0, Bs.validateFunctionCode = m, Bs.getData = Ae;
  const e = T7(), t = Hm(), r = $L(), n = Hm(), i = C7(), s = $7(), o = R7(), a = ot(), l = pi(), u = Kg(), f = ct(), d = Gg();
  function m(C) {
    if (P(C) && ($(C), A(C))) {
      E(C);
      return;
    }
    v(C, () => (0, e.topBoolOrEmptySchema)(C));
  }
  function v({ gen: C, validateName: N, schema: J, schemaEnv: X, opts: oe }, U) {
    oe.code.es5 ? C.func(N, (0, a._)`${l.default.data}, ${l.default.valCxt}`, X.$async, () => {
      C.code((0, a._)`"use strict"; ${g(J, oe)}`), y(C, oe), C.code(U);
    }) : C.func(N, (0, a._)`${l.default.data}, ${S(oe)}`, X.$async, () => C.code(g(J, oe)).code(U));
  }
  function S(C) {
    return (0, a._)`{${l.default.instancePath}="", ${l.default.parentData}, ${l.default.parentDataProperty}, ${l.default.rootData}=${l.default.data}${C.dynamicRef ? (0, a._)`, ${l.default.dynamicAnchors}={}` : a.nil}, ${l.default.isAllOfVariant} = 0}={}`;
  }
  function y(C, N) {
    C.if(l.default.valCxt, () => {
      C.var(l.default.instancePath, (0, a._)`${l.default.valCxt}.${l.default.instancePath}`), C.var(l.default.parentData, (0, a._)`${l.default.valCxt}.${l.default.parentData}`), C.var(l.default.parentDataProperty, (0, a._)`${l.default.valCxt}.${l.default.parentDataProperty}`), C.var(l.default.rootData, (0, a._)`${l.default.valCxt}.${l.default.rootData}`), C.var(l.default.isAllOfVariant, (0, a._)`${l.default.valCxt}.${l.default.isAllOfVariant}`), N.dynamicRef && C.var(l.default.dynamicAnchors, (0, a._)`${l.default.valCxt}.${l.default.dynamicAnchors}`);
    }, () => {
      C.var(l.default.instancePath, (0, a._)`""`), C.var(l.default.parentData, (0, a._)`undefined`), C.var(l.default.parentDataProperty, (0, a._)`undefined`), C.var(l.default.rootData, l.default.data), C.var(l.default.isAllOfVariant, (0, a._)`0`), N.dynamicRef && C.var(l.default.dynamicAnchors, (0, a._)`{}`);
    });
  }
  function E(C) {
    const { schema: N, opts: J, gen: X } = C;
    v(C, () => {
      J.$comment && N.$comment && ae(C), L(C), X.let(l.default.vErrors, null), X.let(l.default.errors, 0), J.unevaluated && x(C), I(C), le(C);
    });
  }
  function x(C) {
    const { gen: N, validateName: J } = C;
    C.evaluated = N.const("evaluated", (0, a._)`${J}.evaluated`), N.if((0, a._)`${C.evaluated}.dynamicProps`, () => N.assign((0, a._)`${C.evaluated}.props`, (0, a._)`undefined`)), N.if((0, a._)`${C.evaluated}.dynamicItems`, () => N.assign((0, a._)`${C.evaluated}.items`, (0, a._)`undefined`));
  }
  function g(C, N) {
    const J = typeof C == "object" && C[N.schemaId];
    return J && (N.code.source || N.code.process) ? (0, a._)`/*# sourceURL=${J} */` : a.nil;
  }
  function b(C, N) {
    if (P(C) && ($(C), A(C))) {
      k(C, N);
      return;
    }
    (0, e.boolOrEmptySchema)(C, N);
  }
  function A({ schema: C, self: N }) {
    if (typeof C == "boolean")
      return !C;
    for (const J in C)
      if (N.RULES.all[J])
        return !0;
    return !1;
  }
  function P(C) {
    return typeof C.schema != "boolean";
  }
  function k(C, N) {
    const { schema: J, gen: X, opts: oe } = C;
    oe.$comment && J.$comment && ae(C), Q(C), Y(C);
    const U = X.const("_errs", l.default.errors);
    I(C, U), X.var(N, (0, a._)`${U} === ${l.default.errors}`);
  }
  function $(C) {
    (0, f.checkUnknownRules)(C), F(C);
  }
  function I(C, N) {
    if (C.opts.jtd)
      return ce(C, [], !1, N);
    const J = (0, t.getSchemaTypes)(C.schema), X = (0, t.coerceAndCheckDataType)(C, J);
    ce(C, J, !X, N);
  }
  function F(C) {
    const { schema: N, errSchemaPath: J, opts: X, self: oe } = C;
    N.$ref && X.ignoreKeywordsWithRef && (0, f.schemaHasRulesButRef)(N, oe.RULES) && oe.logger.warn(`$ref: keywords ignored in schema at path "${J}"`);
  }
  function L(C) {
    const { schema: N, opts: J } = C;
    N.default !== void 0 && J.useDefaults && J.strictSchema && (0, f.checkStrictMode)(C, "default is ignored in the schema root");
  }
  function Q(C) {
    const N = C.schema[C.opts.schemaId];
    N && (C.baseId = (0, u.resolveUrl)(C.opts.uriResolver, C.baseId, N));
  }
  function Y(C) {
    if (C.schema.$async && !C.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function ae({ gen: C, schemaEnv: N, schema: J, errSchemaPath: X, opts: oe }) {
    const U = J.$comment;
    if (oe.$comment === !0)
      C.code((0, a._)`${l.default.self}.logger.log(${U})`);
    else if (typeof oe.$comment == "function") {
      const V = (0, a.str)`${X}/$comment`, ye = C.scopeValue("root", { ref: N.root });
      C.code((0, a._)`${l.default.self}.opts.$comment(${U}, ${V}, ${ye}.schema)`);
    }
  }
  function le(C) {
    const { gen: N, schemaEnv: J, validateName: X, ValidationError: oe, opts: U } = C;
    J.$async ? N.if((0, a._)`${l.default.errors} === 0`, () => N.return(l.default.data), () => N.throw((0, a._)`new ${oe}(${l.default.vErrors})`)) : (N.assign((0, a._)`${X}.errors`, l.default.vErrors), U.unevaluated && ue(C), N.return((0, a._)`${l.default.errors} === 0`));
  }
  function ue({ gen: C, evaluated: N, props: J, items: X }) {
    J instanceof a.Name && C.assign((0, a._)`${N}.props`, J), X instanceof a.Name && C.assign((0, a._)`${N}.items`, X);
  }
  function ce(C, N, J, X) {
    const { gen: oe, schema: U, data: V, allErrors: ye, opts: de, self: Ce } = C, { RULES: Se } = Ce;
    if (U.$ref && (de.ignoreKeywordsWithRef || !(0, f.schemaHasRulesButRef)(U, Se))) {
      oe.block(() => B(C, "$ref", Se.all.$ref.definition));
      return;
    }
    de.jtd || G(C, N), oe.block(() => {
      for (const M of Se.rules)
        O(M);
      O(Se.post);
    });
    function O(M) {
      (0, r.shouldUseGroup)(U, M) && (M.type ? (oe.if((0, n.checkDataType)(M.type, V, de.strictNumbers)), be(C, M), N.length === 1 && N[0] === M.type && J && (oe.else(), (0, n.reportTypeError)(C)), oe.endIf()) : be(C, M), ye || oe.if((0, a._)`${l.default.errors} === ${X || 0}`));
    }
  }
  function be(C, N) {
    const { gen: J, schema: X, opts: { useDefaults: oe } } = C;
    oe && (0, i.assignDefaults)(C, N.type), J.block(() => {
      for (const V of N.rules)
        ((0, r.shouldUseRule)(X, V) || U(X, V)) && B(C, V.keyword, V.definition, N.type);
    });
    function U(V, ye) {
      return !!(ye.keyword === "unevaluatedProperties" && (V.properties || V.patternProperties) && !C.isAllOfVariant && C.opts.defaultUnevaluatedProperties === !1);
    }
  }
  function G(C, N) {
    C.schemaEnv.meta || !C.opts.strictTypes || (ee(C, N), C.opts.allowUnionTypes || K(C, N), z(C, C.dataTypes));
  }
  function ee(C, N) {
    if (N.length) {
      if (!C.dataTypes.length) {
        C.dataTypes = N;
        return;
      }
      N.forEach((J) => {
        q(C.dataTypes, J) || j(C, `type "${J}" not allowed by context "${C.dataTypes.join(",")}"`);
      }), C.dataTypes = C.dataTypes.filter((J) => q(N, J));
    }
  }
  function K(C, N) {
    N.length > 1 && !(N.length === 2 && N.includes("null")) && j(C, "use allowUnionTypes to allow union type keyword");
  }
  function z(C, N) {
    const J = C.self.RULES.all;
    for (const X in J) {
      const oe = J[X];
      if (typeof oe == "object" && (0, r.shouldUseRule)(C.schema, oe)) {
        const { type: U } = oe.definition;
        U.length && !U.some((V) => te(N, V)) && j(C, `missing type "${U.join(",")}" for keyword "${X}"`);
      }
    }
  }
  function te(C, N) {
    return C.includes(N) || N === "number" && C.includes("integer");
  }
  function q(C, N) {
    return C.includes(N) || N === "integer" && C.includes("number");
  }
  function j(C, N) {
    const J = C.schemaEnv.baseId + C.errSchemaPath;
    N += ` at "${J}" (strictTypes)`, (0, f.checkStrictMode)(C, N, C.opts.strictTypes);
  }
  class H {
    constructor(N, J, X) {
      if ((0, s.validateKeywordUsage)(N, J, X), this.gen = N.gen, this.allErrors = N.allErrors, this.keyword = X, this.data = N.data, this.schema = N.schema[X], this.$data = J.$data && N.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, f.schemaRefOrVal)(N, this.schema, X, this.$data), this.schemaType = J.schemaType, this.parentSchema = N.schema, this.params = {}, this.it = N, this.def = J, this.$data)
        this.schemaCode = N.gen.const("vSchema", Ae(this.$data, N));
      else if (this.schemaCode = this.schemaValue, !(0, s.validSchemaType)(this.schema, J.schemaType, J.allowUndefined))
        throw new Error(`${X} value must be ${JSON.stringify(J.schemaType)}`);
      ("code" in J ? J.trackErrors : J.errors !== !1) && (this.errsCount = N.gen.const("_errs", l.default.errors));
    }
    result(N, J, X) {
      this.failResult((0, a.not)(N), J, X);
    }
    failResult(N, J, X) {
      this.gen.if(N), X ? X() : this.error(), J ? (this.gen.else(), J(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    pass(N, J) {
      this.failResult((0, a.not)(N), void 0, J);
    }
    fail(N) {
      if (N === void 0) {
        this.error(), this.allErrors || this.gen.if(!1);
        return;
      }
      this.gen.if(N), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    fail$data(N) {
      if (!this.$data)
        return this.fail(N);
      const { schemaCode: J } = this;
      this.fail((0, a._)`${J} !== undefined && (${(0, a.or)(this.invalid$data(), N)})`);
    }
    error(N, J, X) {
      if (J) {
        this.setParams(J), this._error(N, X), this.setParams({});
        return;
      }
      this._error(N, X);
    }
    _error(N, J) {
      (N ? d.reportExtraError : d.reportError)(this, this.def.error, J);
    }
    $dataError() {
      (0, d.reportError)(this, this.def.$dataError || d.keyword$DataError);
    }
    reset() {
      if (this.errsCount === void 0)
        throw new Error('add "trackErrors" to keyword definition');
      (0, d.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(N) {
      this.allErrors || this.gen.if(N);
    }
    setParams(N, J) {
      J ? Object.assign(this.params, N) : this.params = N;
    }
    block$data(N, J, X = a.nil) {
      this.gen.block(() => {
        this.check$data(N, X), J();
      });
    }
    check$data(N = a.nil, J = a.nil) {
      if (!this.$data)
        return;
      const { gen: X, schemaCode: oe, schemaType: U, def: V } = this;
      X.if((0, a.or)((0, a._)`${oe} === undefined`, J)), N !== a.nil && X.assign(N, !0), (U.length || V.validateSchema) && (X.elseIf(this.invalid$data()), this.$dataError(), N !== a.nil && X.assign(N, !1)), X.else();
    }
    invalid$data() {
      const { gen: N, schemaCode: J, schemaType: X, def: oe, it: U } = this;
      return (0, a.or)(V(), ye());
      function V() {
        if (X.length) {
          if (!(J instanceof a.Name))
            throw new Error("ajv implementation error");
          const de = Array.isArray(X) ? X : [X];
          return (0, a._)`${(0, n.checkDataTypes)(de, J, U.opts.strictNumbers, n.DataType.Wrong)}`;
        }
        return a.nil;
      }
      function ye() {
        if (oe.validateSchema) {
          const de = N.scopeValue("validate$data", { ref: oe.validateSchema });
          return (0, a._)`!${de}(${J})`;
        }
        return a.nil;
      }
    }
    subschema(N, J, X) {
      const oe = (0, o.getSubschema)(this.it, N);
      (0, o.extendSubschemaData)(oe, this.it, N), (0, o.extendSubschemaMode)(oe, N);
      const U = {
        ...this.it,
        ...oe,
        items: void 0,
        props: void 0,
        isAllOfVariant: X
      };
      return b(U, J), U;
    }
    mergeEvaluated(N, J) {
      const { it: X, gen: oe } = this;
      X.opts.unevaluated && (X.props !== !0 && N.props !== void 0 && (X.props = f.mergeEvaluated.props(oe, N.props, X.props, J)), X.items !== !0 && N.items !== void 0 && (X.items = f.mergeEvaluated.items(oe, N.items, X.items, J)));
    }
    mergeValidEvaluated(N, J) {
      const { it: X, gen: oe } = this;
      if (X.opts.unevaluated && (X.props !== !0 || X.items !== !0))
        return oe.if(J, () => this.mergeEvaluated(N, a.Name)), !0;
    }
  }
  Bs.KeywordCxt = H;
  function B(C, N, J, X) {
    const oe = new H(C, J, N);
    "code" in J ? J.code(oe, X) : oe.$data && J.validate ? (0, s.funcKeywordCode)(oe, J) : "macro" in J ? (0, s.macroKeywordCode)(oe, J) : (J.compile || J.validate) && (0, s.funcKeywordCode)(oe, J);
  }
  const pe = /^\/(?:[^~]|~0|~1)*$/, he = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function Ae(C, { dataLevel: N, dataNames: J, dataPathArr: X }) {
    let oe, U;
    if (C === "")
      return l.default.rootData;
    if (C[0] === "/") {
      if (!pe.test(C))
        throw new Error(`Invalid JSON-pointer: ${C}`);
      oe = C, U = l.default.rootData;
    } else {
      const Ce = he.exec(C);
      if (!Ce)
        throw new Error(`Invalid JSON-pointer: ${C}`);
      const Se = +Ce[1];
      if (oe = Ce[2], oe === "#") {
        if (Se >= N)
          throw new Error(de("property/index", Se));
        return X[N - Se];
      }
      if (Se > N)
        throw new Error(de("data", Se));
      if (U = J[N - Se], !oe)
        return U;
    }
    let V = U;
    const ye = oe.split("/");
    for (const Ce of ye)
      Ce && (U = (0, a._)`${U}${(0, a.getProperty)((0, f.unescapeJsonPointer)(Ce))}`, V = (0, a._)`${V} && ${U}`);
    return V;
    function de(Ce, Se) {
      return `Cannot access ${Ce} ${Se} levels up, current level is ${N}`;
    }
  }
  return Bs;
}
var Id = {}, dP;
function IL() {
  if (dP) return Id;
  dP = 1, Object.defineProperty(Id, "__esModule", { value: !0 });
  class e extends Error {
    constructor(r) {
      super("validation failed"), this.errors = r, this.ajv = this.validation = !0;
    }
  }
  return Id.default = e, Id;
}
var Nd = {}, hP;
function NL() {
  if (hP) return Nd;
  hP = 1, Object.defineProperty(Nd, "__esModule", { value: !0 });
  const e = Kg();
  class t extends Error {
    constructor(n, i, s, o) {
      super(o || `can't resolve reference ${s} from id ${i}`), this.missingRef = (0, e.resolveUrl)(n, i, s), this.missingSchema = (0, e.normalizeId)((0, e.getFullPath)(n, this.missingRef));
    }
  }
  return Nd.default = t, Nd;
}
var eo = {}, mP;
function Jg() {
  if (mP) return eo;
  mP = 1, Object.defineProperty(eo, "__esModule", { value: !0 }), eo.SchemaEnv = void 0, eo.compileSchema = a, eo.resolveRef = l, eo.getCompilingSchema = f, eo.resolveSchema = v;
  const e = ot(), t = IL(), r = pi(), n = Kg(), i = ct(), s = Xg();
  class o {
    constructor(x) {
      var g;
      this.refs = {}, this.dynamicAnchors = {};
      let b;
      typeof x.schema == "object" && (b = x.schema), this.schema = x.schema, this.schemaId = x.schemaId, this.root = x.root || this, this.baseId = (g = x.baseId) !== null && g !== void 0 ? g : (0, n.normalizeId)(b == null ? void 0 : b[x.schemaId || "$id"]), this.schemaPath = x.schemaPath, this.localRefs = x.localRefs, this.meta = x.meta, this.$async = b == null ? void 0 : b.$async, this.refs = {};
    }
  }
  eo.SchemaEnv = o;
  function a(E) {
    const x = f.call(this, E);
    if (x)
      return x;
    const g = (0, n.getFullPath)(this.opts.uriResolver, E.root.baseId), { es5: b, lines: A } = this.opts.code, { ownProperties: P } = this.opts, k = new e.CodeGen(this.scope, { es5: b, lines: A, ownProperties: P });
    let $;
    E.$async && ($ = k.scopeValue("Error", {
      ref: t.default,
      code: (0, e._)`require("ajv/dist/runtime/validation_error").default`
    }));
    const I = k.scopeName("validate");
    E.validateName = I;
    const F = {
      gen: k,
      allErrors: this.opts.allErrors,
      data: r.default.data,
      parentData: r.default.parentData,
      parentDataProperty: r.default.parentDataProperty,
      dataNames: [r.default.data],
      dataPathArr: [e.nil],
      // TODO can its length be used as dataLevel if nil is removed?
      dataLevel: 0,
      dataTypes: [],
      definedProperties: /* @__PURE__ */ new Set(),
      topSchemaRef: k.scopeValue("schema", this.opts.code.source === !0 ? { ref: E.schema, code: (0, e.stringify)(E.schema) } : { ref: E.schema }),
      validateName: I,
      ValidationError: $,
      schema: E.schema,
      schemaEnv: E,
      rootId: g,
      baseId: E.baseId || g,
      schemaPath: e.nil,
      errSchemaPath: E.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, e._)`""`,
      opts: this.opts,
      self: this
    };
    let L;
    try {
      this._compilations.add(E), (0, s.validateFunctionCode)(F), k.optimize(this.opts.code.optimize);
      const Q = k.toString();
      L = `const visitedNodesForRef = new WeakMap(); ${k.scopeRefs(r.default.scope)}return ${Q}`, this.opts.code.process && (L = this.opts.code.process(L, E));
      const ae = new Function(`${r.default.self}`, `${r.default.scope}`, L)(this, this.scope.get());
      if (this.scope.value(I, { ref: ae }), ae.errors = null, ae.schema = E.schema, ae.schemaEnv = E, E.$async && (ae.$async = !0), this.opts.code.source === !0 && (ae.source = { validateName: I, validateCode: Q, scopeValues: k._values }), this.opts.unevaluated) {
        const { props: le, items: ue } = F;
        ae.evaluated = {
          props: le instanceof e.Name ? void 0 : le,
          items: ue instanceof e.Name ? void 0 : ue,
          dynamicProps: le instanceof e.Name,
          dynamicItems: ue instanceof e.Name
        }, ae.source && (ae.source.evaluated = (0, e.stringify)(ae.evaluated));
      }
      return E.validate = ae, E;
    } catch (Q) {
      throw delete E.validate, delete E.validateName, L && this.logger.error("Error compiling schema, function code:", L), Q;
    } finally {
      this._compilations.delete(E);
    }
  }
  function l(E, x, g) {
    var b;
    const A = (0, n.resolveUrl)(this.opts.uriResolver, x, g), P = E.refs[A];
    if (P)
      return P;
    let k = m.call(this, E, A);
    if (k === void 0) {
      const $ = (b = E.localRefs) === null || b === void 0 ? void 0 : b[A], { schemaId: I } = this.opts;
      $ && (k = new o({ schema: $, schemaId: I, root: E, baseId: x }));
    }
    if (k === void 0 && this.opts.loadSchemaSync) {
      const $ = this.opts.loadSchemaSync(x, g, A);
      $ && !(this.refs[A] || this.schemas[A]) && (this.addSchema($, A, void 0), k = m.call(this, E, A));
    }
    if (k !== void 0)
      return E.refs[A] = u.call(this, k);
  }
  function u(E) {
    return (0, n.inlineRef)(E.schema, this.opts.inlineRefs) ? E.schema : E.validate ? E : a.call(this, E);
  }
  function f(E) {
    for (const x of this._compilations)
      if (d(x, E))
        return x;
  }
  function d(E, x) {
    return E.schema === x.schema && E.root === x.root && E.baseId === x.baseId;
  }
  function m(E, x) {
    let g;
    for (; typeof (g = this.refs[x]) == "string"; )
      x = g;
    return g || this.schemas[x] || v.call(this, E, x);
  }
  function v(E, x) {
    const g = this.opts.uriResolver.parse(x), b = (0, n._getFullPath)(this.opts.uriResolver, g);
    let A = (0, n.getFullPath)(this.opts.uriResolver, E.baseId, void 0);
    if (Object.keys(E.schema).length > 0 && b === A)
      return y.call(this, g, E);
    const P = (0, n.normalizeId)(b), k = this.refs[P] || this.schemas[P];
    if (typeof k == "string") {
      const $ = v.call(this, E, k);
      return typeof ($ == null ? void 0 : $.schema) != "object" ? void 0 : y.call(this, g, $);
    }
    if (typeof (k == null ? void 0 : k.schema) == "object") {
      if (k.validate || a.call(this, k), P === (0, n.normalizeId)(x)) {
        const { schema: $ } = k, { schemaId: I } = this.opts, F = $[I];
        return F && (A = (0, n.resolveUrl)(this.opts.uriResolver, A, F)), new o({ schema: $, schemaId: I, root: E, baseId: A });
      }
      return y.call(this, g, k);
    }
  }
  const S = /* @__PURE__ */ new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
  function y(E, { baseId: x, schema: g, root: b }) {
    var A;
    if (((A = E.fragment) === null || A === void 0 ? void 0 : A[0]) !== "/")
      return;
    for (const $ of E.fragment.slice(1).split("/")) {
      if (typeof g == "boolean")
        return;
      const I = g[(0, i.unescapeFragment)($)];
      if (I === void 0)
        return;
      g = I;
      const F = typeof g == "object" && g[this.opts.schemaId];
      !S.has($) && F && (x = (0, n.resolveUrl)(this.opts.uriResolver, x, F));
    }
    let P;
    if (typeof g != "boolean" && g.$ref && !(0, i.schemaHasRulesButRef)(g, this.RULES)) {
      const $ = (0, n.resolveUrl)(this.opts.uriResolver, x, g.$ref);
      P = v.call(this, b, $);
    }
    const { schemaId: k } = this.opts;
    if (P = P || new o({ schema: g, schemaId: k, root: b, baseId: x }), P.schema !== P.root.schema)
      return P;
  }
  return eo;
}
const N7 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", j7 = "Meta-schema for $data reference (JSON AnySchema extension proposal)", L7 = "object", M7 = [
  "$data"
], D7 = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
}, F7 = !1, z7 = {
  $id: N7,
  description: j7,
  type: L7,
  required: M7,
  properties: D7,
  additionalProperties: F7
};
var jd = {}, Nb = {}, oc = {}, gP;
function Tw() {
  if (gP) return oc;
  gP = 1, Object.defineProperty(oc, "__esModule", { value: !0 }), oc.serialize = void 0;
  function e(s) {
    let o = i(s), a;
    try {
      a = new URL(o.startUrl);
    } catch (u) {
      return u.message && console.error(u.message + " " + o.startUrl), "";
    }
    if (s.scheme !== void 0 && !o.temporarySchemeAndHostUsed && !o.temporarySchemeUsed ? a.protocol = s.scheme.toLowerCase() : a.protocol = "", s.host !== void 0 && !o.temporarySchemeAndHostUsed && !o.temporaryHostUsed ? a.host = s.host : a.host = "", s.port && (a.port = String(s.port)), s.path && (a.pathname = s.path), s.userinfo) {
      let u = s.userinfo.split(":");
      u[0] && (a.username = u[0]), u[1] && (a.password = u[1]);
    }
    s.query && (a.search = s.query), s.fragment && (a.hash = s.fragment);
    let l = a.toString();
    return !s.path && l.endsWith("/") && (l = l.slice(0, -1)), o.temporarySchemeAndHostUsed && (l = l.replace(n, ""), l.startsWith("/") && (l = l.slice(1))), o.temporaryHostUsed && (l = l.replace(r, "")), o.temporarySchemeUsed && (l = l.replace(t, "")), l;
  }
  oc.serialize = e;
  const t = "https:", r = "_remove_me_host_", n = t + "//" + r;
  function i(s) {
    let o = {
      startUrl: "",
      temporaryHostUsed: !1,
      temporarySchemeUsed: !1,
      temporarySchemeAndHostUsed: !1
    };
    return s.scheme && s.host ? (o.startUrl = s.scheme + "://" + s.host, o) : s.host ? (o.temporarySchemeUsed = !0, o.startUrl = t + s.host, o) : s.scheme ? s.path ? (o.startUrl = s.scheme + ":" + s.path, o) : (o.temporaryHostUsed = !0, o.startUrl = s.scheme + ":" + r, o) : (o.temporarySchemeAndHostUsed = !0, o.startUrl = n, o);
  }
  return oc;
}
var sc = {}, yP;
function Cw() {
  if (yP) return sc;
  yP = 1, Object.defineProperty(sc, "__esModule", { value: !0 }), sc.parse = void 0;
  function e(n) {
    let i = {
      path: "",
      fragment: void 0,
      host: void 0,
      port: void 0,
      query: void 0,
      reference: void 0,
      scheme: void 0,
      userinfo: void 0
    };
    n.includes("#") && (i.fragment = "");
    let { parsed: s, addedDefaultScheme: o, addedTemporaryHost: a, error: l } = r(n);
    if (l || s === void 0)
      return i.error = l, i;
    if (typeof s.protocol !== void 0 && s.protocol !== "" && !o && (i.scheme = String(s.protocol).replace(":", "")), typeof s.username !== void 0 && s.username !== "") {
      let u = s.username;
      s.password && (u += ":" + s.password), i.userinfo = u;
    }
    return typeof s.hostname !== void 0 && s.hostname !== "" && !a && (i.host = s.hostname, i.host.startsWith("[") && (i.host = i.host.substring(1), i.host = i.host.slice(0, -1))), typeof s.port !== void 0 && s.port !== "" && (i.port = Number(s.port)), typeof s.pathname !== void 0 && s.pathname !== "/" && (i.path = s.pathname, a && i.path.startsWith("/") && (i.path = i.path.substring(1))), typeof s.search !== void 0 && s.search !== "" && (i.query = s.search.replace("?", "")), typeof s.hash !== void 0 && s.hash !== "" && (i.fragment = s.hash.replace("#", "")), i.scheme === void 0 && i.userinfo === void 0 && i.host === void 0 && i.port === void 0 && !i.path && i.query === void 0 ? i.reference = "same-document" : i.scheme === void 0 ? i.reference = "relative" : i.fragment === void 0 ? i.reference = "absolute" : i.reference = "uri", i;
  }
  sc.parse = e;
  const t = "_remove_me_host/";
  function r(n) {
    let i = {
      parsed: void 0,
      addedDefaultScheme: !1,
      addedTemporaryHost: !1,
      error: void 0
    }, s;
    try {
      return i.parsed = new URL(n), i;
    } catch (o) {
      s = o;
    }
    if (n.startsWith("//"))
      try {
        return i.parsed = new URL("https:" + n), i.addedDefaultScheme = !0, i;
      } catch {
        return i.error = s.message, i;
      }
    try {
      return i.parsed = new URL("https://" + t + n), i.addedDefaultScheme = !0, i.addedTemporaryHost = !0, i;
    } catch {
    }
    return i.error = s.message, i;
  }
  return sc;
}
var Vs = {}, vP;
function q7() {
  if (vP) return Vs;
  vP = 1, Object.defineProperty(Vs, "__esModule", { value: !0 }), Vs.resolveComponents = Vs.resolve = void 0;
  const e = Cw(), t = Tw();
  function r(s, o, a) {
    const l = Object.assign({ scheme: "null" }, a), u = n((0, e.parse)(s), (0, e.parse)(o), l, !0);
    return (0, t.serialize)(u);
  }
  Vs.resolve = r;
  function n(s, o, a, l) {
    const u = {};
    return l || (s = (0, e.parse)((0, t.serialize)(s)), o = (0, e.parse)((0, t.serialize)(o))), a = a || {}, !a.tolerant && o.scheme ? (u.scheme = o.scheme, u.userinfo = o.userinfo, u.host = o.host, u.port = o.port, u.path = i(o.path || ""), u.query = o.query) : (o.userinfo !== void 0 || o.host !== void 0 || o.port !== void 0 ? (u.userinfo = o.userinfo, u.host = o.host, u.port = o.port, u.path = i(o.path || ""), u.query = o.query) : (o.path ? (o.path.charAt(0) === "/" ? u.path = i(o.path) : ((s.userinfo !== void 0 || s.host !== void 0 || s.port !== void 0) && !s.path ? u.path = "/" + o.path : s.path ? u.path = s.path.slice(0, s.path.lastIndexOf("/") + 1) + o.path : u.path = o.path, u.path = i(u.path)), u.query = o.query) : (u.path = s.path, o.query !== void 0 ? u.query = o.query : u.query = s.query), u.userinfo = s.userinfo, u.host = s.host, u.port = s.port), u.scheme = s.scheme), u.fragment = o.fragment, u;
  }
  Vs.resolveComponents = n;
  function i(s) {
    const o = /^\.\.?\//u, a = /^\/\.(?:\/|$)/u, l = /^\/\.\.(?:\/|$)/u, u = /^\/?(?:.|\n)*?(?=\/|$)/u, f = [];
    for (; s.length; )
      if (s.match(o))
        s = s.replace(o, "");
      else if (s.match(a))
        s = s.replace(a, "/");
      else if (s.match(l))
        s = s.replace(l, "/"), f.pop();
      else if (s === "." || s === "..")
        s = "";
      else {
        const d = s.match(u);
        if (d) {
          const m = d[0];
          s = s.slice(m.length), f.push(m);
        } else
          throw new Error("Unexpected dot segment condition");
      }
    return f.join("");
  }
  return Vs;
}
var bP;
function B7() {
  return bP || (bP = 1, function(e) {
    var t = ft && ft.__createBinding || (Object.create ? function(a, l, u, f) {
      f === void 0 && (f = u);
      var d = Object.getOwnPropertyDescriptor(l, u);
      (!d || ("get" in d ? !l.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
        return l[u];
      } }), Object.defineProperty(a, f, d);
    } : function(a, l, u, f) {
      f === void 0 && (f = u), a[f] = l[u];
    }), r = ft && ft.__exportStar || function(a, l) {
      for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.normalize = e.equal = void 0;
    const n = Tw(), i = Cw();
    r(q7(), e), r(Tw(), e), r(Cw(), e);
    function s(a, l) {
      let u, f;
      return typeof a == "string" ? u = (0, n.serialize)((0, i.parse)(a)) : u = (0, n.serialize)(a), typeof l == "string" ? f = (0, n.serialize)((0, i.parse)(l)) : f = (0, n.serialize)(l), u.toLowerCase() === f.toLowerCase();
    }
    e.equal = s;
    function o(a) {
      return typeof a == "string" ? (0, n.serialize)((0, i.parse)(a)) : (0, i.parse)((0, n.serialize)(a));
    }
    e.normalize = o;
  }(Nb)), Nb;
}
var wP;
function U7() {
  if (wP) return jd;
  wP = 1, Object.defineProperty(jd, "__esModule", { value: !0 });
  const e = B7();
  return e.code = 'require("ajv/dist/runtime/uri").default', jd.default = e, jd;
}
var SP;
function V7() {
  return SP || (SP = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
    var t = Xg();
    Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
      return t.KeywordCxt;
    } });
    var r = ot();
    Object.defineProperty(e, "_", { enumerable: !0, get: function() {
      return r._;
    } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
      return r.str;
    } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
      return r.stringify;
    } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
      return r.nil;
    } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
      return r.Name;
    } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
      return r.CodeGen;
    } });
    const n = IL(), i = NL(), s = CL(), o = Jg(), a = ot(), l = Kg(), u = Hm(), f = ct(), d = z7, m = U7(), v = (K, z) => new RegExp(K, z);
    v.code = "new RegExp";
    const S = [
      "removeAdditional",
      "useDefaults",
      "coerceTypes",
      "defaultUnevaluatedProperties",
      "defaultAdditionalProperties"
    ], y = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]), E = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    }, x = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    }, g = 200;
    function b(K) {
      var z, te, q, j, H, B, pe, he, Ae, C, N, J, X, oe, U, V, ye, de, Ce, Se, O, M, se, ve, ge;
      const Oe = K.strict, ke = (z = K.code) === null || z === void 0 ? void 0 : z.optimize, Me = ke === !0 || ke === void 0 ? 1 : ke || 0, Ve = (q = (te = K.code) === null || te === void 0 ? void 0 : te.regExp) !== null && q !== void 0 ? q : v, Je = (j = K.uriResolver) !== null && j !== void 0 ? j : m.default;
      return {
        strictSchema: (B = (H = K.strictSchema) !== null && H !== void 0 ? H : Oe) !== null && B !== void 0 ? B : !0,
        strictNumbers: (he = (pe = K.strictNumbers) !== null && pe !== void 0 ? pe : Oe) !== null && he !== void 0 ? he : !0,
        strictTypes: (C = (Ae = K.strictTypes) !== null && Ae !== void 0 ? Ae : Oe) !== null && C !== void 0 ? C : "log",
        strictTuples: (J = (N = K.strictTuples) !== null && N !== void 0 ? N : Oe) !== null && J !== void 0 ? J : "log",
        strictRequired: (oe = (X = K.strictRequired) !== null && X !== void 0 ? X : Oe) !== null && oe !== void 0 ? oe : !1,
        code: K.code ? { ...K.code, optimize: Me, regExp: Ve } : { optimize: Me, regExp: Ve },
        loopRequired: (U = K.loopRequired) !== null && U !== void 0 ? U : g,
        loopEnum: (V = K.loopEnum) !== null && V !== void 0 ? V : g,
        meta: (ye = K.meta) !== null && ye !== void 0 ? ye : !0,
        messages: (de = K.messages) !== null && de !== void 0 ? de : !0,
        inlineRefs: (Ce = K.inlineRefs) !== null && Ce !== void 0 ? Ce : !0,
        schemaId: (Se = K.schemaId) !== null && Se !== void 0 ? Se : "$id",
        addUsedSchema: (O = K.addUsedSchema) !== null && O !== void 0 ? O : !0,
        validateSchema: (M = K.validateSchema) !== null && M !== void 0 ? M : !0,
        validateFormats: (se = K.validateFormats) !== null && se !== void 0 ? se : !0,
        unicodeRegExp: (ve = K.unicodeRegExp) !== null && ve !== void 0 ? ve : !0,
        int32range: (ge = K.int32range) !== null && ge !== void 0 ? ge : !0,
        uriResolver: Je
      };
    }
    class A {
      constructor(z = {}) {
        this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), z = this.opts = { ...z, ...b(z) };
        const { es5: te, lines: q } = this.opts.code;
        this.scope = new a.ValueScope({ scope: {}, prefixes: y, es5: te, lines: q }), this.logger = Y(z.logger);
        const j = z.validateFormats;
        z.validateFormats = !1, this.RULES = (0, s.getRules)(), P.call(this, E, z, "NOT SUPPORTED"), P.call(this, x, z, "DEPRECATED", "warn"), this._metaOpts = L.call(this), z.formats && I.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), z.keywords && F.call(this, z.keywords), typeof z.meta == "object" && this.addMetaSchema(z.meta), $.call(this), z.validateFormats = j;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data: z, meta: te, schemaId: q } = this.opts;
        let j = d;
        q === "id" && (j = { ...d }, j.id = j.$id, delete j.$id), te && z && this.addMetaSchema(j, j[q], !1);
      }
      defaultMeta() {
        const { meta: z, schemaId: te } = this.opts;
        return this.opts.defaultMeta = typeof z == "object" ? z[te] || z : void 0;
      }
      validate(z, te) {
        let q;
        if (typeof z == "string") {
          if (q = this.getSchema(z), !q)
            throw new Error(`no schema with key or ref "${z}"`);
        } else
          q = this.compile(z);
        const j = q(te);
        return "$async" in q || (this.errors = q.errors), j;
      }
      compile(z, te) {
        const q = this._addSchema(z, te);
        return q.validate || this._compileSchemaEnv(q);
      }
      compileAsync(z, te) {
        if (typeof this.opts.loadSchema != "function")
          throw new Error("options.loadSchema should be a function");
        const { loadSchema: q } = this.opts;
        return j.call(this, z, te);
        async function j(C, N) {
          await H.call(this, C.$schema);
          const J = this._addSchema(C, N);
          return J.validate || B.call(this, J);
        }
        async function H(C) {
          C && !this.getSchema(C) && await j.call(this, { $ref: C }, !0);
        }
        async function B(C) {
          try {
            return this._compileSchemaEnv(C);
          } catch (N) {
            if (!(N instanceof i.default))
              throw N;
            return pe.call(this, N), await he.call(this, N.missingSchema), B.call(this, C);
          }
        }
        function pe({ missingSchema: C, missingRef: N }) {
          if (this.refs[C])
            throw new Error(`AnySchema ${C} is loaded but ${N} cannot be resolved`);
        }
        async function he(C) {
          const N = await Ae.call(this, C);
          this.refs[C] || await H.call(this, N.$schema), this.refs[C] || this.addSchema(N, C, te);
        }
        async function Ae(C) {
          const N = this._loading[C];
          if (N)
            return N;
          try {
            return await (this._loading[C] = q(C));
          } finally {
            delete this._loading[C];
          }
        }
      }
      // Adds schema to the instance
      addSchema(z, te, q, j = this.opts.validateSchema) {
        if (Array.isArray(z)) {
          for (const B of z)
            this.addSchema(B, void 0, q, j);
          return this;
        }
        let H;
        if (typeof z == "object") {
          const { schemaId: B } = this.opts;
          if (H = z[B], H !== void 0 && typeof H != "string")
            throw new Error(`schema ${B} must be string`);
        }
        return te = (0, l.normalizeId)(te || H), this._checkUnique(te), this.schemas[te] = this._addSchema(z, q, te, j, !0), this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(z, te, q = this.opts.validateSchema) {
        return this.addSchema(z, te, !0, q), this;
      }
      //  Validate schema against its meta-schema
      validateSchema(z, te) {
        if (typeof z == "boolean")
          return !0;
        let q;
        if (q = z.$schema, q !== void 0 && typeof q != "string")
          throw new Error("$schema must be a string");
        if (q = q || this.opts.defaultMeta || this.defaultMeta(), !q)
          return this.logger.warn("meta-schema not available"), this.errors = null, !0;
        const j = this.validate(q, z);
        if (!j && te) {
          const H = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(H);
          else
            throw new Error(H);
        }
        return j;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(z) {
        let te;
        for (; typeof (te = k.call(this, z)) == "string"; )
          z = te;
        if (te === void 0) {
          const { schemaId: q } = this.opts, j = new o.SchemaEnv({ schema: {}, schemaId: q });
          if (te = o.resolveSchema.call(this, j, z), !te)
            return;
          this.refs[z] = te;
        }
        return te.validate || this._compileSchemaEnv(te);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(z) {
        if (z instanceof RegExp)
          return this._removeAllSchemas(this.schemas, z), this._removeAllSchemas(this.refs, z), this;
        switch (typeof z) {
          case "undefined":
            return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
          case "string": {
            const te = k.call(this, z);
            return typeof te == "object" && this._cache.delete(te.schema), delete this.schemas[z], delete this.refs[z], this;
          }
          case "object": {
            const te = z;
            this._cache.delete(te);
            let q = z[this.opts.schemaId];
            return q && (q = (0, l.normalizeId)(q), delete this.schemas[q], delete this.refs[q]), this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(z) {
        for (const te of z)
          this.addKeyword(te);
        return this;
      }
      addKeyword(z, te) {
        let q;
        if (typeof z == "string")
          q = z, typeof te == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), te.keyword = q);
        else if (typeof z == "object" && te === void 0) {
          if (te = z, q = te.keyword, Array.isArray(q) && !q.length)
            throw new Error("addKeywords: keyword must be string or non-empty array");
        } else
          throw new Error("invalid addKeywords parameters");
        if (le.call(this, q, te), !te)
          return (0, f.eachItem)(q, (H) => ue.call(this, H)), this;
        be.call(this, te);
        const j = {
          ...te,
          type: (0, u.getJSONTypes)(te.type),
          schemaType: (0, u.getJSONTypes)(te.schemaType)
        };
        return (0, f.eachItem)(q, j.type.length === 0 ? (H) => ue.call(this, H, j) : (H) => j.type.forEach((B) => ue.call(this, H, j, B))), this;
      }
      getKeyword(z) {
        const te = this.RULES.all[z];
        return typeof te == "object" ? te.definition : !!te;
      }
      // Remove keyword
      removeKeyword(z) {
        const { RULES: te } = this;
        delete te.keywords[z], delete te.all[z];
        for (const q of te.rules) {
          const j = q.rules.findIndex((H) => H.keyword === z);
          j >= 0 && q.rules.splice(j, 1);
        }
        return this;
      }
      // Add format
      addFormat(z, te) {
        return typeof te == "string" && (te = new RegExp(te)), this.formats[z] = te, this;
      }
      errorsText(z = this.errors, { separator: te = ", ", dataVar: q = "data" } = {}) {
        return !z || z.length === 0 ? "No errors" : z.map((j) => `${q}${j.instancePath} ${j.message}`).reduce((j, H) => j + te + H);
      }
      $dataMetaSchema(z, te) {
        const q = this.RULES.all;
        z = JSON.parse(JSON.stringify(z));
        for (const j of te) {
          const H = j.split("/").slice(1);
          let B = z;
          for (const pe of H)
            B = B[pe];
          for (const pe in q) {
            const he = q[pe];
            if (typeof he != "object")
              continue;
            const { $data: Ae } = he.definition, C = B[pe];
            Ae && C && (B[pe] = ee(C));
          }
        }
        return z;
      }
      _removeAllSchemas(z, te) {
        for (const q in z) {
          const j = z[q];
          (!te || te.test(q)) && (typeof j == "string" ? delete z[q] : j && !j.meta && (this._cache.delete(j.schema), delete z[q]));
        }
      }
      _addSchema(z, te, q, j = this.opts.validateSchema, H = this.opts.addUsedSchema) {
        let B;
        const { schemaId: pe } = this.opts;
        if (typeof z == "object")
          B = z[pe];
        else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          if (typeof z != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let he = this._cache.get(z);
        if (he !== void 0)
          return he;
        q = (0, l.normalizeId)(B || q);
        const Ae = l.getSchemaRefs.call(this, z, q);
        return he = new o.SchemaEnv({ schema: z, schemaId: pe, meta: te, baseId: q, localRefs: Ae }), this._cache.set(he.schema, he), H && !q.startsWith("#") && (q && this._checkUnique(q), this.refs[q] = he), j && this.validateSchema(z, !0), he;
      }
      _checkUnique(z) {
        if (this.schemas[z] || this.refs[z])
          throw new Error(`schema with key or id "${z}" already exists`);
      }
      _compileSchemaEnv(z) {
        if (z.meta ? this._compileMetaSchema(z) : o.compileSchema.call(this, z), !z.validate)
          throw new Error("ajv implementation error");
        return z.validate;
      }
      _compileMetaSchema(z) {
        const te = this.opts;
        this.opts = this._metaOpts;
        try {
          o.compileSchema.call(this, z);
        } finally {
          this.opts = te;
        }
      }
    }
    A.ValidationError = n.default, A.MissingRefError = i.default, e.default = A;
    function P(K, z, te, q = "error") {
      for (const j in K) {
        const H = j;
        H in z && this.logger[q](`${te}: option ${j}. ${K[H]}`);
      }
    }
    function k(K) {
      return K = (0, l.normalizeId)(K), this.schemas[K] || this.refs[K];
    }
    function $() {
      const K = this.opts.schemas;
      if (K)
        if (Array.isArray(K))
          this.addSchema(K);
        else
          for (const z in K)
            this.addSchema(K[z], z);
    }
    function I() {
      for (const K in this.opts.formats) {
        const z = this.opts.formats[K];
        z && this.addFormat(K, z);
      }
    }
    function F(K) {
      if (Array.isArray(K)) {
        this.addVocabulary(K);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const z in K) {
        const te = K[z];
        te.keyword || (te.keyword = z), this.addKeyword(te);
      }
    }
    function L() {
      const K = { ...this.opts };
      for (const z of S)
        delete K[z];
      return K;
    }
    const Q = { log() {
    }, warn() {
    }, error() {
    } };
    function Y(K) {
      if (K === !1)
        return Q;
      if (K === void 0)
        return console;
      if (K.log && K.warn && K.error)
        return K;
      throw new Error("logger must implement log, warn and error methods");
    }
    const ae = /^[a-z_$][a-z0-9_$:-]*$/i;
    function le(K, z) {
      const { RULES: te } = this;
      if ((0, f.eachItem)(K, (q) => {
        if (te.keywords[q])
          throw new Error(`Keyword ${q} is already defined`);
        if (!ae.test(q))
          throw new Error(`Keyword ${q} has invalid name`);
      }), !!z && z.$data && !("code" in z || "validate" in z))
        throw new Error('$data keyword must have "code" or "validate" function');
    }
    function ue(K, z, te) {
      var q;
      const j = z == null ? void 0 : z.post;
      if (te && j)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES: H } = this;
      let B = j ? H.post : H.rules.find(({ type: he }) => he === te);
      if (B || (B = { type: te, rules: [] }, H.rules.push(B)), H.keywords[K] = !0, !z)
        return;
      const pe = {
        keyword: K,
        definition: {
          ...z,
          type: (0, u.getJSONTypes)(z.type),
          schemaType: (0, u.getJSONTypes)(z.schemaType)
        }
      };
      z.before ? ce.call(this, B, pe, z.before) : B.rules.push(pe), H.all[K] = pe, (q = z.implements) === null || q === void 0 || q.forEach((he) => this.addKeyword(he));
    }
    function ce(K, z, te) {
      const q = K.rules.findIndex((j) => j.keyword === te);
      q >= 0 ? K.rules.splice(q, 0, z) : (K.rules.push(z), this.logger.warn(`rule ${te} is not defined`));
    }
    function be(K) {
      let { metaSchema: z } = K;
      z !== void 0 && (K.$data && this.opts.$data && (z = ee(z)), K.validateSchema = this.compile(z, !0));
    }
    const G = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function ee(K) {
      return { anyOf: [K, G] };
    }
  }(Ab)), Ab;
}
var Ld = {}, Md = {}, Dd = {}, xP;
function W7() {
  if (xP) return Dd;
  xP = 1, Object.defineProperty(Dd, "__esModule", { value: !0 });
  const e = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  return Dd.default = e, Dd;
}
var il = {}, EP;
function b1() {
  if (EP) return il;
  EP = 1, Object.defineProperty(il, "__esModule", { value: !0 }), il.getValidate = a, il.callRef = l;
  const e = NL(), t = fi(), r = ot(), n = pi(), i = Jg(), s = ct(), o = {
    keyword: "$ref",
    schemaType: "string",
    code(u) {
      const { gen: f, schema: d, it: m } = u, { baseId: v, schemaEnv: S, validateName: y, opts: E, self: x } = m, { root: g } = S;
      if ((d === "#" || d === "#/") && v === g.baseId)
        return A();
      const b = i.resolveRef.call(x, g, v, d);
      if (b === void 0)
        throw new e.default(m.opts.uriResolver, v, d);
      if (b instanceof i.SchemaEnv)
        return P(b);
      return k(b);
      function A() {
        if (S === g)
          return l(u, y, S, S.$async);
        const $ = f.scopeValue("root", { ref: g });
        return l(u, (0, r._)`${$}.validate`, g, g.$async);
      }
      function P($) {
        const I = a(u, $);
        l(u, I, $, $.$async);
      }
      function k($) {
        const I = f.scopeValue("schema", E.code.source === !0 ? { ref: $, code: (0, r.stringify)($) } : { ref: $ }), F = f.name("valid"), L = u.subschema(
          {
            schema: $,
            dataTypes: [],
            schemaPath: r.nil,
            topSchemaRef: I,
            errSchemaPath: d
          },
          F,
          m.isAllOfVariant
          // pass isAllOfVariant into inlined $ref
        );
        u.mergeEvaluated(L), u.ok(F);
      }
    }
  };
  function a(u, f) {
    const { gen: d } = u;
    return f.validate ? d.scopeValue("validate", { ref: f.validate }) : (0, r._)`${d.scopeValue("wrapper", { ref: f })}.validate`;
  }
  function l(u, f, d, m) {
    const { gen: v, it: S } = u, { allErrors: y, schemaEnv: E, opts: x } = S, g = x.passContext ? n.default.this : r.nil;
    m ? b() : A();
    function b() {
      if (!E.$async)
        throw new Error("async schema referenced by sync schema");
      const $ = v.let("valid");
      v.try(() => {
        v.code((0, r._)`await ${(0, t.callValidateCode)(u, f, g)}`), k(f), y || v.assign($, !0);
      }, (I) => {
        v.if((0, r._)`!(${I} instanceof ${S.ValidationError})`, () => v.throw(I)), P(I), y || v.assign($, !1);
      }), u.ok($);
    }
    function A() {
      const $ = v.name("visitedNodes");
      v.code((0, r._)`const ${$} = (typeof visitedNodesForRef !== 'undefined') && visitedNodesForRef.get(${f}) || new Set()`), v.if((0, r._)`!${$}.has(${u.data})`, () => {
        v.code((0, r._)`if (typeof visitedNodesForRef !== 'undefined') visitedNodesForRef.set(${f}, ${$})`), v.code((0, r._)`const dataNode = ${u.data}`), v.code((0, r._)`if (typeof dataNode === "object" && dataNode !== null) ${$}.add(dataNode)`);
        const I = u.result((0, t.callValidateCode)(u, f, g), () => k(f), () => P(f));
        return v.code((0, r._)`${$}.delete(dataNode)`), I;
      });
    }
    function P($) {
      const I = (0, r._)`${$}.errors`;
      v.assign(n.default.vErrors, (0, r._)`${n.default.vErrors} === null ? ${I} : ${n.default.vErrors}.concat(${I})`), v.assign(n.default.errors, (0, r._)`${n.default.vErrors}.length`);
    }
    function k($) {
      var I;
      if (!S.opts.unevaluated)
        return;
      const F = (I = d == null ? void 0 : d.validate) === null || I === void 0 ? void 0 : I.evaluated;
      if (S.props !== !0)
        if (F && !F.dynamicProps)
          F.props !== void 0 && (S.props = s.mergeEvaluated.props(v, F.props, S.props));
        else {
          const L = v.var("props", (0, r._)`${$}.evaluated.props`);
          S.props = s.mergeEvaluated.props(v, L, S.props, r.Name);
        }
      if (S.items !== !0)
        if (F && !F.dynamicItems)
          F.items !== void 0 && (S.items = s.mergeEvaluated.items(v, F.items, S.items));
        else {
          const L = v.var("items", (0, r._)`${$}.evaluated.items`);
          S.items = s.mergeEvaluated.items(v, L, S.items, r.Name);
        }
    }
  }
  return il.default = o, il;
}
var _P;
function H7() {
  if (_P) return Md;
  _P = 1, Object.defineProperty(Md, "__esModule", { value: !0 });
  const e = W7(), t = b1(), r = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    e.default,
    t.default
  ];
  return Md.default = r, Md;
}
var Fd = {}, zd = {}, OP;
function Q7() {
  if (OP) return zd;
  OP = 1, Object.defineProperty(zd, "__esModule", { value: !0 });
  const e = ot(), t = e.operators, r = {
    maximum: { okStr: "<=", ok: t.LTE, fail: t.GT },
    minimum: { okStr: ">=", ok: t.GTE, fail: t.LT },
    exclusiveMaximum: { okStr: "<", ok: t.LT, fail: t.GTE },
    exclusiveMinimum: { okStr: ">", ok: t.GT, fail: t.LTE }
  }, n = {
    message: ({ keyword: s, schemaCode: o }) => (0, e.str)`must be ${r[s].okStr} ${o}`,
    params: ({ keyword: s, schemaCode: o }) => (0, e._)`{comparison: ${r[s].okStr}, limit: ${o}}`
  }, i = {
    keyword: Object.keys(r),
    type: "number",
    schemaType: "number",
    $data: !0,
    error: n,
    code(s) {
      const { keyword: o, data: a, schemaCode: l } = s;
      s.fail$data((0, e._)`${a} ${r[o].fail} ${l} || isNaN(${a})`);
    }
  };
  return zd.default = i, zd;
}
var qd = {}, kP;
function Y7() {
  if (kP) return qd;
  kP = 1, Object.defineProperty(qd, "__esModule", { value: !0 });
  const e = ot(), r = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: !0,
    error: {
      message: ({ schemaCode: n }) => (0, e.str)`must be multiple of ${n}`,
      params: ({ schemaCode: n }) => (0, e._)`{multipleOf: ${n}}`
    },
    code(n) {
      const { gen: i, data: s, schemaCode: o, it: a } = n, l = a.opts.multipleOfPrecision, u = i.let("res"), f = l ? (0, e._)`Math.abs(Math.round(${u}) - ${u}) > 1e-${l}` : (0, e._)`${u} !== parseInt(${u})`;
      n.fail$data((0, e._)`(${o} === 0 || (${u} = ${s}/${o}, ${f}))`);
    }
  };
  return qd.default = r, qd;
}
var Bd = {}, Ud = {}, AP;
function G7() {
  if (AP) return Ud;
  AP = 1, Object.defineProperty(Ud, "__esModule", { value: !0 }), Ud.default = e;
  function e(t) {
    const r = t.length;
    let n = 0, i = 0, s;
    for (; i < r; )
      n++, s = t.charCodeAt(i++), s >= 55296 && s <= 56319 && i < r && (s = t.charCodeAt(i), (s & 64512) === 56320 && i++);
    return n;
  }
  return e.code = 'require("ajv/dist/runtime/ucs2length").default', Ud;
}
var PP;
function K7() {
  if (PP) return Bd;
  PP = 1, Object.defineProperty(Bd, "__esModule", { value: !0 });
  const e = ot(), t = ct(), r = G7(), i = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: s, schemaCode: o }) {
        const a = s === "maxLength" ? "more" : "fewer";
        return (0, e.str)`must NOT have ${a} than ${o} characters`;
      },
      params: ({ schemaCode: s }) => (0, e._)`{limit: ${s}}`
    },
    code(s) {
      const { keyword: o, data: a, schemaCode: l, it: u } = s, f = o === "maxLength" ? e.operators.GT : e.operators.LT, d = u.opts.unicode === !1 ? (0, e._)`${a}.length` : (0, e._)`${(0, t.useFunc)(s.gen, r.default)}(${a})`;
      s.fail$data((0, e._)`${d} ${f} ${l}`);
    }
  };
  return Bd.default = i, Bd;
}
var Vd = {}, TP;
function X7() {
  if (TP) return Vd;
  TP = 1, Object.defineProperty(Vd, "__esModule", { value: !0 });
  const e = fi(), t = ot(), n = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: i }) => (0, t.str)`must match pattern "${i}"`,
      params: ({ schemaCode: i }) => (0, t._)`{pattern: ${i}}`
    },
    code(i) {
      const { data: s, $data: o, schema: a, schemaCode: l, it: u } = i, f = u.opts.unicodeRegExp ? "u" : "", d = o ? (0, t._)`(new RegExp(${l}, ${f}))` : (0, e.usePattern)(i, a);
      i.fail$data((0, t._)`!${d}.test(${s})`);
    }
  };
  return Vd.default = n, Vd;
}
var Wd = {}, CP;
function J7() {
  if (CP) return Wd;
  CP = 1, Object.defineProperty(Wd, "__esModule", { value: !0 });
  const e = ot(), r = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: n, schemaCode: i }) {
        const s = n === "maxProperties" ? "more" : "fewer";
        return (0, e.str)`must NOT have ${s} than ${i} properties`;
      },
      params: ({ schemaCode: n }) => (0, e._)`{limit: ${n}}`
    },
    code(n) {
      const { keyword: i, data: s, schemaCode: o } = n, a = i === "maxProperties" ? e.operators.GT : e.operators.LT;
      n.fail$data((0, e._)`Object.keys(${s}).length ${a} ${o}`);
    }
  };
  return Wd.default = r, Wd;
}
var Hd = {}, $P;
function Z7() {
  if ($P) return Hd;
  $P = 1, Object.defineProperty(Hd, "__esModule", { value: !0 });
  const e = fi(), t = ot(), r = ct(), i = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: !0,
    error: {
      message: ({ params: { missingProperty: s } }) => (0, t.str)`must have required property '${s}'`,
      params: ({ params: { missingProperty: s } }) => (0, t._)`{missingProperty: ${s}}`
    },
    code(s) {
      const { gen: o, schema: a, schemaCode: l, data: u, $data: f, it: d } = s, { opts: m } = d;
      if (!f && a.length === 0)
        return;
      const v = a.length >= m.loopRequired;
      if (d.allErrors ? S() : y(), m.strictRequired) {
        const g = s.parentSchema.properties, { definedProperties: b } = s.it;
        for (const A of a)
          if ((g == null ? void 0 : g[A]) === void 0 && !b.has(A)) {
            const P = d.schemaEnv.baseId + d.errSchemaPath, k = `required property "${A}" is not defined at "${P}" (strictRequired)`;
            (0, r.checkStrictMode)(d, k, d.opts.strictRequired);
          }
      }
      function S() {
        if (v || f)
          s.block$data(t.nil, E);
        else
          for (const g of a)
            (0, e.checkReportMissingProp)(s, g);
      }
      function y() {
        const g = o.let("missing");
        if (v || f) {
          const b = o.let("valid", !0);
          s.block$data(b, () => x(g, b)), s.ok(b);
        } else
          o.if((0, e.checkMissingProp)(s, a, g)), (0, e.reportMissingProp)(s, g), o.else();
      }
      function E() {
        o.forOf("prop", l, (g) => {
          s.setParams({ missingProperty: g }), o.if((0, e.noPropertyInData)(o, u, g, m.ownProperties), () => s.error());
        });
      }
      function x(g, b) {
        s.setParams({ missingProperty: g }), o.forOf(g, l, () => {
          o.assign(b, (0, e.propertyInData)(o, u, g, m.ownProperties)), o.if((0, t.not)(b), () => {
            s.error(), o.break();
          });
        }, t.nil);
      }
    }
  };
  return Hd.default = i, Hd;
}
var Qd = {}, RP;
function eQ() {
  if (RP) return Qd;
  RP = 1, Object.defineProperty(Qd, "__esModule", { value: !0 });
  const e = ot(), r = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: n, schemaCode: i }) {
        const s = n === "maxItems" ? "more" : "fewer";
        return (0, e.str)`must NOT have ${s} than ${i} items`;
      },
      params: ({ schemaCode: n }) => (0, e._)`{limit: ${n}}`
    },
    code(n) {
      const { keyword: i, data: s, schemaCode: o } = n, a = i === "maxItems" ? e.operators.GT : e.operators.LT;
      n.fail$data((0, e._)`${s}.length ${a} ${o}`);
    }
  };
  return Qd.default = r, Qd;
}
var Yd = {}, Gd = {}, IP;
function w1() {
  if (IP) return Gd;
  IP = 1, Object.defineProperty(Gd, "__esModule", { value: !0 });
  const e = RL();
  return e.code = 'require("ajv/dist/runtime/equal").default', Gd.default = e, Gd;
}
var NP;
function tQ() {
  if (NP) return Yd;
  NP = 1, Object.defineProperty(Yd, "__esModule", { value: !0 });
  const e = Hm(), t = ot(), r = ct(), n = w1(), s = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: !0,
    error: {
      message: ({ params: { i: o, j: a } }) => (0, t.str)`must NOT have duplicate items (items ## ${a} and ${o} are identical)`,
      params: ({ params: { i: o, j: a } }) => (0, t._)`{i: ${o}, j: ${a}}`
    },
    code(o) {
      const { gen: a, data: l, $data: u, schema: f, parentSchema: d, schemaCode: m, it: v } = o;
      if (!u && !f)
        return;
      const S = a.let("valid"), y = d.items ? (0, e.getSchemaTypes)(d.items) : [];
      o.block$data(S, E, (0, t._)`${m} === false`), o.ok(S);
      function E() {
        const A = a.let("i", (0, t._)`${l}.length`), P = a.let("j");
        o.setParams({ i: A, j: P }), a.assign(S, !0), a.if((0, t._)`${A} > 1`, () => (x() ? g : b)(A, P));
      }
      function x() {
        return y.length > 0 && !y.some((A) => A === "object" || A === "array");
      }
      function g(A, P) {
        const k = a.name("item"), $ = (0, e.checkDataTypes)(y, k, v.opts.strictNumbers, e.DataType.Wrong), I = a.const("indices", (0, t._)`{}`);
        a.for((0, t._)`;${A}--;`, () => {
          a.let(k, (0, t._)`${l}[${A}]`), a.if($, (0, t._)`continue`), y.length > 1 && a.if((0, t._)`typeof ${k} == "string"`, (0, t._)`${k} += "_"`), a.if((0, t._)`typeof ${I}[${k}] == "number"`, () => {
            a.assign(P, (0, t._)`${I}[${k}]`), o.error(), a.assign(S, !1).break();
          }).code((0, t._)`${I}[${k}] = ${A}`);
        });
      }
      function b(A, P) {
        const k = (0, r.useFunc)(a, n.default), $ = a.name("outer");
        a.label($).for((0, t._)`;${A}--;`, () => a.for((0, t._)`${P} = ${A}; ${P}--;`, () => a.if((0, t._)`${k}(${l}[${A}], ${l}[${P}])`, () => {
          o.error(), a.assign(S, !1).break($);
        })));
      }
    }
  };
  return Yd.default = s, Yd;
}
var Kd = {}, jP;
function rQ() {
  if (jP) return Kd;
  jP = 1, Object.defineProperty(Kd, "__esModule", { value: !0 });
  const e = ot(), t = ct(), r = w1(), i = {
    keyword: "const",
    $data: !0,
    error: {
      message: "must be equal to constant",
      params: ({ schemaCode: s }) => (0, e._)`{allowedValue: ${s}}`
    },
    code(s) {
      const { gen: o, data: a, $data: l, schemaCode: u, schema: f } = s;
      l || f && typeof f == "object" ? s.fail$data((0, e._)`!${(0, t.useFunc)(o, r.default)}(${a}, ${u})`) : s.fail((0, e._)`${f} !== ${a}`);
    }
  };
  return Kd.default = i, Kd;
}
var Xd = {}, LP;
function nQ() {
  if (LP) return Xd;
  LP = 1, Object.defineProperty(Xd, "__esModule", { value: !0 });
  const e = ot(), t = ct(), r = w1(), i = {
    keyword: "enum",
    schemaType: "array",
    $data: !0,
    error: {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode: s }) => (0, e._)`{allowedValues: ${s}}`
    },
    code(s) {
      const { gen: o, data: a, $data: l, schema: u, schemaCode: f, it: d } = s;
      if (!l && u.length === 0)
        throw new Error("enum must have non-empty array");
      const m = u.length >= d.opts.loopEnum;
      let v;
      const S = () => v ?? (v = (0, t.useFunc)(o, r.default));
      let y;
      if (m || l)
        y = o.let("valid"), s.block$data(y, E);
      else {
        if (!Array.isArray(u))
          throw new Error("ajv implementation error");
        const g = o.const("vSchema", f);
        y = (0, e.or)(...u.map((b, A) => x(g, A)));
      }
      s.pass(y);
      function E() {
        o.assign(y, !1), o.forOf("v", f, (g) => o.if((0, e._)`${S()}(${a}, ${g})`, () => o.assign(y, !0).break()));
      }
      function x(g, b) {
        const A = u[b];
        return typeof A == "object" && A !== null ? (0, e._)`${S()}(${a}, ${g}[${b}])` : (0, e._)`${a} === ${A}`;
      }
    }
  };
  return Xd.default = i, Xd;
}
var MP;
function iQ() {
  if (MP) return Fd;
  MP = 1, Object.defineProperty(Fd, "__esModule", { value: !0 });
  const e = Q7(), t = Y7(), r = K7(), n = X7(), i = J7(), s = Z7(), o = eQ(), a = tQ(), l = rQ(), u = nQ(), f = [
    // number
    e.default,
    t.default,
    // string
    r.default,
    n.default,
    // object
    i.default,
    s.default,
    // array
    o.default,
    a.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    l.default,
    u.default
  ];
  return Fd.default = f, Fd;
}
var Jd = {}, ac = {}, DP;
function jL() {
  if (DP) return ac;
  DP = 1, Object.defineProperty(ac, "__esModule", { value: !0 }), ac.validateAdditionalItems = i;
  const e = ot(), t = ct(), n = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: s } }) => (0, e.str)`must NOT have more than ${s} items`,
      params: ({ params: { len: s } }) => (0, e._)`{limit: ${s}}`
    },
    code(s) {
      const { parentSchema: o, it: a } = s, { items: l } = o;
      if (!Array.isArray(l)) {
        (0, t.checkStrictMode)(a, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      i(s, l);
    }
  };
  function i(s, o) {
    const { gen: a, schema: l, data: u, keyword: f, it: d } = s;
    d.items = !0;
    const m = a.const("len", (0, e._)`${u}.length`);
    if (l === !1)
      s.setParams({ len: o.length }), s.pass((0, e._)`${m} <= ${o.length}`);
    else if (typeof l == "object" && !(0, t.alwaysValidSchema)(d, l)) {
      const S = a.var("valid", (0, e._)`${m} <= ${o.length}`);
      a.if((0, e.not)(S), () => v(S)), s.ok(S);
    }
    function v(S) {
      a.forRange("i", o.length, m, (y) => {
        s.subschema({ keyword: f, dataProp: y, dataPropType: t.Type.Num }, S), d.allErrors || a.if((0, e.not)(S), () => a.break());
      });
    }
  }
  return ac.default = n, ac;
}
var Zd = {}, lc = {}, FP;
function LL() {
  if (FP) return lc;
  FP = 1, Object.defineProperty(lc, "__esModule", { value: !0 }), lc.validateTuple = i;
  const e = ot(), t = ct(), r = fi(), n = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(s) {
      const { schema: o, it: a } = s;
      if (Array.isArray(o))
        return i(s, "additionalItems", o);
      a.items = !0, !(0, t.alwaysValidSchema)(a, o) && s.ok((0, r.validateArray)(s));
    }
  };
  function i(s, o, a = s.schema) {
    const { gen: l, parentSchema: u, data: f, keyword: d, it: m } = s;
    y(u), m.opts.unevaluated && a.length && m.items !== !0 && (m.items = t.mergeEvaluated.items(l, a.length, m.items));
    const v = l.name("valid"), S = l.const("len", (0, e._)`${f}.length`);
    a.forEach((E, x) => {
      (0, t.alwaysValidSchema)(m, E) || (l.if((0, e._)`${S} > ${x}`, () => s.subschema({
        keyword: d,
        schemaProp: x,
        dataProp: x
      }, v)), s.ok(v));
    });
    function y(E) {
      const { opts: x, errSchemaPath: g } = m, b = a.length, A = b === E.minItems && (b === E.maxItems || E[o] === !1);
      if (x.strictTuples && !A) {
        const P = `"${d}" is ${b}-tuple, but minItems or maxItems/${o} are not specified or different at path "${g}"`;
        (0, t.checkStrictMode)(m, P, x.strictTuples);
      }
    }
  }
  return lc.default = n, lc;
}
var zP;
function oQ() {
  if (zP) return Zd;
  zP = 1, Object.defineProperty(Zd, "__esModule", { value: !0 });
  const e = LL(), t = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (r) => (0, e.validateTuple)(r, "items")
  };
  return Zd.default = t, Zd;
}
var eh = {}, qP;
function sQ() {
  if (qP) return eh;
  qP = 1, Object.defineProperty(eh, "__esModule", { value: !0 });
  const e = ot(), t = ct(), r = fi(), n = jL(), s = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: o } }) => (0, e.str)`must NOT have more than ${o} items`,
      params: ({ params: { len: o } }) => (0, e._)`{limit: ${o}}`
    },
    code(o) {
      const { schema: a, parentSchema: l, it: u } = o, { prefixItems: f } = l;
      u.items = !0, !(0, t.alwaysValidSchema)(u, a) && (f ? (0, n.validateAdditionalItems)(o, f) : o.ok((0, r.validateArray)(o)));
    }
  };
  return eh.default = s, eh;
}
var th = {}, BP;
function aQ() {
  if (BP) return th;
  BP = 1, Object.defineProperty(th, "__esModule", { value: !0 });
  const e = ot(), t = ct(), n = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: !0,
    error: {
      message: ({ params: { min: i, max: s } }) => s === void 0 ? (0, e.str)`must contain at least ${i} valid item(s)` : (0, e.str)`must contain at least ${i} and no more than ${s} valid item(s)`,
      params: ({ params: { min: i, max: s } }) => s === void 0 ? (0, e._)`{minContains: ${i}}` : (0, e._)`{minContains: ${i}, maxContains: ${s}}`
    },
    code(i) {
      const { gen: s, schema: o, parentSchema: a, data: l, it: u } = i;
      let f, d;
      const { minContains: m, maxContains: v } = a;
      u.opts.next ? (f = m === void 0 ? 1 : m, d = v) : f = 1;
      const S = s.const("len", (0, e._)`${l}.length`);
      if (i.setParams({ min: f, max: d }), d === void 0 && f === 0) {
        (0, t.checkStrictMode)(u, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
        return;
      }
      if (d !== void 0 && f > d) {
        (0, t.checkStrictMode)(u, '"minContains" > "maxContains" is always invalid'), i.fail();
        return;
      }
      if ((0, t.alwaysValidSchema)(u, o)) {
        let b = (0, e._)`${S} >= ${f}`;
        d !== void 0 && (b = (0, e._)`${b} && ${S} <= ${d}`), i.pass(b);
        return;
      }
      u.items = !0;
      const y = s.name("valid");
      d === void 0 && f === 1 ? x(y, () => s.if(y, () => s.break())) : f === 0 ? (s.let(y, !0), d !== void 0 && s.if((0, e._)`${l}.length > 0`, E)) : (s.let(y, !1), E()), i.result(y, () => i.reset());
      function E() {
        const b = s.name("_valid"), A = s.let("count", 0);
        x(b, () => s.if(b, () => g(A)));
      }
      function x(b, A) {
        s.forRange("i", 0, S, (P) => {
          i.subschema({
            keyword: "contains",
            dataProp: P,
            dataPropType: t.Type.Num,
            compositeRule: !0
          }, b), A();
        });
      }
      function g(b) {
        s.code((0, e._)`${b}++`), d === void 0 ? s.if((0, e._)`${b} >= ${f}`, () => s.assign(y, !0).break()) : (s.if((0, e._)`${b} > ${d}`, () => s.assign(y, !1).break()), f === 1 ? s.assign(y, !0) : s.if((0, e._)`${b} >= ${f}`, () => s.assign(y, !0)));
      }
    }
  };
  return th.default = n, th;
}
var jb = {}, UP;
function S1() {
  return UP || (UP = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.error = void 0, e.validatePropertyDeps = o, e.validateSchemaDeps = a;
    const t = ot(), r = ct(), n = fi();
    e.error = {
      message: ({ params: { property: l, depsCount: u, deps: f } }) => {
        const d = u === 1 ? "property" : "properties";
        return (0, t.str)`must have ${d} ${f} when property ${l} is present`;
      },
      params: ({ params: { property: l, depsCount: u, deps: f, missingProperty: d } }) => (0, t._)`{property: ${l},
    missingProperty: ${d},
    depsCount: ${u},
    deps: ${f}}`
      // TODO change to reference
    };
    const i = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: e.error,
      code(l) {
        const [u, f] = s(l);
        o(l, u), a(l, f);
      }
    };
    function s({ schema: l }) {
      const u = {}, f = {};
      for (const d in l) {
        if (d === "__proto__")
          continue;
        const m = Array.isArray(l[d]) ? u : f;
        m[d] = l[d];
      }
      return [u, f];
    }
    function o(l, u = l.schema) {
      const { gen: f, data: d, it: m } = l;
      if (Object.keys(u).length === 0)
        return;
      const v = f.let("missing");
      for (const S in u) {
        const y = u[S];
        if (y.length === 0)
          continue;
        const E = (0, n.propertyInData)(f, d, S, m.opts.ownProperties);
        l.setParams({
          property: S,
          depsCount: y.length,
          deps: y.join(", ")
        }), m.allErrors ? f.if(E, () => {
          for (const x of y)
            (0, n.checkReportMissingProp)(l, x);
        }) : (f.if((0, t._)`${E} && (${(0, n.checkMissingProp)(l, y, v)})`), (0, n.reportMissingProp)(l, v), f.else());
      }
    }
    function a(l, u = l.schema) {
      const { gen: f, data: d, keyword: m, it: v } = l, S = f.name("valid");
      for (const y in u)
        (0, r.alwaysValidSchema)(v, u[y]) || (f.if(
          (0, n.propertyInData)(f, d, y, v.opts.ownProperties),
          () => {
            const E = l.subschema({ keyword: m, schemaProp: y }, S);
            l.mergeValidEvaluated(E, S);
          },
          () => f.var(S, !0)
          // TODO var
        ), l.ok(S));
    }
    e.default = i;
  }(jb)), jb;
}
var rh = {}, VP;
function lQ() {
  if (VP) return rh;
  VP = 1, Object.defineProperty(rh, "__esModule", { value: !0 });
  const e = ot(), t = ct(), n = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: {
      message: "property name must be valid",
      params: ({ params: i }) => (0, e._)`{propertyName: ${i.propertyName}}`
    },
    code(i) {
      const { gen: s, schema: o, data: a, it: l } = i;
      if ((0, t.alwaysValidSchema)(l, o))
        return;
      const u = s.name("valid");
      s.forIn("key", a, (f) => {
        i.setParams({ propertyName: f }), i.subschema({
          keyword: "propertyNames",
          data: f,
          dataTypes: ["string"],
          propertyName: f,
          compositeRule: !0
        }, u), s.if((0, e.not)(u), () => {
          i.error(!0), l.allErrors || s.break();
        });
      }), i.ok(u);
    }
  };
  return rh.default = n, rh;
}
var nh = {}, WP;
function ML() {
  if (WP) return nh;
  WP = 1, Object.defineProperty(nh, "__esModule", { value: !0 });
  const e = fi(), t = ot(), r = pi(), n = ct(), s = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: !0,
    trackErrors: !0,
    error: {
      message: "must NOT have additional properties",
      params: ({ params: o }) => (0, t._)`{additionalProperty: ${o.additionalProperty}}`
    },
    code(o) {
      const { gen: a, parentSchema: l, data: u, errsCount: f, it: d } = o, { schema: m = d.opts.defaultAdditionalProperties } = o;
      if (!f)
        throw new Error("ajv implementation error");
      const { allErrors: v, opts: S } = d;
      if (d.props = !0, S.removeAdditional !== "all" && (0, n.alwaysValidSchema)(d, m))
        return;
      const y = (0, e.allSchemaProperties)(l.properties), E = (0, e.allSchemaProperties)(l.patternProperties);
      x(), o.ok((0, t._)`${f} === ${r.default.errors}`);
      function x() {
        a.forIn("key", u, (k) => {
          !y.length && !E.length ? A(k) : a.if(g(k), () => A(k));
        });
      }
      function g(k) {
        let $;
        if (y.length > 8) {
          const I = (0, n.schemaRefOrVal)(d, l.properties, "properties");
          $ = (0, e.isOwnProperty)(a, I, k);
        } else y.length ? $ = (0, t.or)(...y.map((I) => (0, t._)`${k} === ${I}`)) : $ = t.nil;
        return E.length && ($ = (0, t.or)($, ...E.map((I) => (0, t._)`${(0, e.usePattern)(o, I)}.test(${k})`))), (0, t.not)($);
      }
      function b(k) {
        a.code((0, t._)`delete ${u}[${k}]`);
      }
      function A(k) {
        if (S.removeAdditional === "all" || S.removeAdditional && m === !1) {
          b(k);
          return;
        }
        if (m === !1) {
          o.setParams({ additionalProperty: k }), o.error(), v || a.break();
          return;
        }
        if (typeof m == "object" && !(0, n.alwaysValidSchema)(d, m)) {
          const $ = a.name("valid");
          S.removeAdditional === "failing" ? (P(k, $, !1), a.if((0, t.not)($), () => {
            o.reset(), b(k);
          })) : (P(k, $), v || a.if((0, t.not)($), () => a.break()));
        }
      }
      function P(k, $, I) {
        const F = {
          keyword: "additionalProperties",
          dataProp: k,
          dataPropType: n.Type.Str
        };
        I === !1 && Object.assign(F, {
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }), o.subschema(F, $);
      }
    }
  };
  return nh.default = s, nh;
}
var ih = {}, HP;
function uQ() {
  if (HP) return ih;
  HP = 1, Object.defineProperty(ih, "__esModule", { value: !0 });
  const e = Xg(), t = fi(), r = ct(), n = ML(), i = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(s) {
      const { gen: o, schema: a, parentSchema: l, data: u, it: f } = s;
      (f.opts.removeAdditional === "all" && l.additionalProperties === void 0 || f.opts.defaultAdditionalProperties === !1) && n.default.code(new e.KeywordCxt(f, n.default, "additionalProperties"));
      const d = (0, t.allSchemaProperties)(a);
      for (const E of d)
        f.definedProperties.add(E);
      f.opts.unevaluated && d.length && f.props !== !0 && (f.props = r.mergeEvaluated.props(o, (0, r.toHash)(d), f.props));
      const m = d.filter((E) => !(0, r.alwaysValidSchema)(f, a[E]));
      if (m.length === 0)
        return;
      const v = o.name("valid");
      for (const E of m)
        S(E) ? y(E) : (o.if((0, t.propertyInData)(o, u, E, f.opts.ownProperties)), y(E), f.allErrors || o.else().var(v, !0), o.endIf()), s.it.definedProperties.add(E), s.ok(v);
      function S(E) {
        return f.opts.useDefaults && !f.compositeRule && a[E].default !== void 0;
      }
      function y(E) {
        s.subschema({
          keyword: "properties",
          schemaProp: E,
          dataProp: E
        }, v);
      }
    }
  };
  return ih.default = i, ih;
}
var oh = {}, QP;
function cQ() {
  if (QP) return oh;
  QP = 1, Object.defineProperty(oh, "__esModule", { value: !0 });
  const e = fi(), t = ot(), r = ct(), n = ct(), i = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(s) {
      const { gen: o, schema: a, data: l, parentSchema: u, it: f } = s, { opts: d } = f, m = (0, e.allSchemaProperties)(a), v = m.filter((A) => (0, r.alwaysValidSchema)(f, a[A]));
      if (m.length === 0 || v.length === m.length && (!f.opts.unevaluated || f.props === !0))
        return;
      const S = d.strictSchema && !d.allowMatchingProperties && u.properties, y = o.name("valid");
      f.props !== !0 && !(f.props instanceof t.Name) && (f.props = (0, n.evaluatedPropsToName)(o, f.props));
      const { props: E } = f;
      x();
      function x() {
        for (const A of m)
          S && g(A), f.allErrors ? b(A) : (o.var(y, !0), b(A), o.if(y));
      }
      function g(A) {
        for (const P in S)
          new RegExp(A).test(P) && (0, r.checkStrictMode)(f, `property ${P} matches pattern ${A} (use allowMatchingProperties)`);
      }
      function b(A) {
        o.forIn("key", l, (P) => {
          o.if((0, t._)`${(0, e.usePattern)(s, A)}.test(${P})`, () => {
            const k = v.includes(A);
            k || s.subschema({
              keyword: "patternProperties",
              schemaProp: A,
              dataProp: P,
              dataPropType: n.Type.Str
            }, y), f.opts.unevaluated && E !== !0 ? o.assign((0, t._)`${E}[${P}]`, !0) : !k && !f.allErrors && o.if((0, t.not)(y), () => o.break());
          });
        });
      }
    }
  };
  return oh.default = i, oh;
}
var sh = {}, YP;
function pQ() {
  if (YP) return sh;
  YP = 1, Object.defineProperty(sh, "__esModule", { value: !0 });
  const e = ct(), t = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    code(r) {
      const { gen: n, schema: i, it: s } = r;
      if ((0, e.alwaysValidSchema)(s, i)) {
        r.fail();
        return;
      }
      const o = n.name("valid");
      r.subschema({
        keyword: "not",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, o), r.failResult(o, () => r.reset(), () => r.error());
    },
    error: { message: "must NOT be valid" }
  };
  return sh.default = t, sh;
}
var ah = {}, GP;
function fQ() {
  if (GP) return ah;
  GP = 1, Object.defineProperty(ah, "__esModule", { value: !0 });
  const t = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: !0,
    code: fi().validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  return ah.default = t, ah;
}
var lh = {}, KP;
function dQ() {
  if (KP) return lh;
  KP = 1, Object.defineProperty(lh, "__esModule", { value: !0 });
  const e = ot(), t = ct(), n = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: !0,
    error: {
      message: "must match exactly one schema in oneOf",
      params: ({ params: i }) => (0, e._)`{passingSchemas: ${i.passing}}`
    },
    code(i) {
      const { gen: s, schema: o, parentSchema: a, it: l } = i;
      if (!Array.isArray(o))
        throw new Error("ajv implementation error");
      if (l.opts.discriminator && a.discriminator)
        return;
      const u = o, f = s.let("valid", !1), d = s.let("passing", null), m = s.name("_valid");
      i.setParams({ passing: d }), s.block(v), i.result(f, () => i.reset(), () => i.error(!0));
      function v() {
        u.forEach((S, y) => {
          let E;
          (0, t.alwaysValidSchema)(l, S) ? s.var(m, !0) : E = i.subschema({
            keyword: "oneOf",
            schemaProp: y,
            compositeRule: !0
          }, m), y > 0 && s.if((0, e._)`${m} && ${f}`).assign(f, !1).assign(d, (0, e._)`[${d}, ${y}]`).else(), s.if(m, () => {
            s.assign(f, !0), s.assign(d, y), E && i.mergeEvaluated(E, e.Name);
          });
        });
      }
    }
  };
  return lh.default = n, lh;
}
var uh = {}, XP;
function hQ() {
  if (XP) return uh;
  XP = 1, Object.defineProperty(uh, "__esModule", { value: !0 });
  const e = ct(), t = {
    keyword: "allOf",
    schemaType: "array",
    code(r) {
      const { gen: n, schema: i, it: s } = r;
      if (!Array.isArray(i))
        throw new Error("ajv implementation error");
      const o = n.name("valid");
      i.forEach((a, l) => {
        if ((0, e.alwaysValidSchema)(s, a))
          return;
        const u = r.subschema({ keyword: "allOf", schemaProp: l }, o, !0);
        r.ok(o), r.mergeEvaluated(u);
      });
    }
  };
  return uh.default = t, uh;
}
var ch = {}, JP;
function mQ() {
  if (JP) return ch;
  JP = 1, Object.defineProperty(ch, "__esModule", { value: !0 });
  const e = ot(), t = ct(), n = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    error: {
      message: ({ params: s }) => (0, e.str)`must match "${s.ifClause}" schema`,
      params: ({ params: s }) => (0, e._)`{failingKeyword: ${s.ifClause}}`
    },
    code(s) {
      const { gen: o, parentSchema: a, it: l } = s;
      a.then === void 0 && a.else === void 0 && (0, t.checkStrictMode)(l, '"if" without "then" and "else" is ignored');
      const u = i(l, "then"), f = i(l, "else");
      if (!u && !f)
        return;
      const d = o.let("valid", !0), m = o.name("_valid");
      if (v(), s.reset(), u && f) {
        const y = o.let("ifClause");
        s.setParams({ ifClause: y }), o.if(m, S("then", y), S("else", y));
      } else u ? o.if(m, S("then")) : o.if((0, e.not)(m), S("else"));
      s.pass(d, () => s.error(!0));
      function v() {
        const y = s.subschema({
          keyword: "if",
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }, m);
        s.mergeEvaluated(y);
      }
      function S(y, E) {
        return () => {
          const x = s.subschema({ keyword: y }, m);
          o.assign(d, m), s.mergeValidEvaluated(x, d), E ? o.assign(E, (0, e._)`${y}`) : s.setParams({ ifClause: y });
        };
      }
    }
  };
  function i(s, o) {
    const a = s.schema[o];
    return a !== void 0 && !(0, t.alwaysValidSchema)(s, a);
  }
  return ch.default = n, ch;
}
var ph = {}, ZP;
function gQ() {
  if (ZP) return ph;
  ZP = 1, Object.defineProperty(ph, "__esModule", { value: !0 });
  const e = ct(), t = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword: r, parentSchema: n, it: i }) {
      n.if === void 0 && (0, e.checkStrictMode)(i, `"${r}" without "if" is ignored`);
    }
  };
  return ph.default = t, ph;
}
var eT;
function yQ() {
  if (eT) return Jd;
  eT = 1, Object.defineProperty(Jd, "__esModule", { value: !0 }), Jd.default = E;
  const e = jL(), t = oQ(), r = LL(), n = sQ(), i = aQ(), s = S1(), o = lQ(), a = ML(), l = uQ(), u = cQ(), f = pQ(), d = fQ(), m = dQ(), v = hQ(), S = mQ(), y = gQ();
  function E(x = !1) {
    const g = [
      // any
      f.default,
      d.default,
      m.default,
      v.default,
      S.default,
      y.default,
      // object
      o.default,
      a.default,
      s.default,
      l.default,
      u.default
    ];
    return x ? g.push(t.default, n.default) : g.push(e.default, r.default), g.push(i.default), g;
  }
  return Jd;
}
var fh = {}, uc = {}, tT;
function DL() {
  if (tT) return uc;
  tT = 1, Object.defineProperty(uc, "__esModule", { value: !0 }), uc.dynamicAnchor = s;
  const e = ot(), t = pi(), r = Jg(), n = b1(), i = {
    keyword: "$dynamicAnchor",
    schemaType: "string",
    code: (a) => s(a, a.schema)
  };
  function s(a, l) {
    const { gen: u, it: f } = a;
    f.schemaEnv.root.dynamicAnchors[l] = !0;
    const d = (0, e._)`${t.default.dynamicAnchors}${(0, e.getProperty)(l)}`, m = f.errSchemaPath === "#" ? f.validateName : o(a);
    u.if((0, e._)`!${d}`, () => u.assign(d, m));
  }
  function o(a) {
    const { schemaEnv: l, schema: u, self: f } = a.it, { root: d, baseId: m, localRefs: v, meta: S } = l.root, { schemaId: y } = f.opts, E = new r.SchemaEnv({ schema: u, schemaId: y, root: d, baseId: m, localRefs: v, meta: S });
    return r.compileSchema.call(f, E), (0, n.getValidate)(a, E);
  }
  return uc.default = i, uc;
}
var cc = {}, rT;
function FL() {
  if (rT) return cc;
  rT = 1, Object.defineProperty(cc, "__esModule", { value: !0 }), cc.dynamicRef = i;
  const e = ot(), t = pi(), r = b1(), n = {
    keyword: "$dynamicRef",
    schemaType: "string",
    code: (s) => i(s, s.schema)
  };
  function i(s, o) {
    const { gen: a, keyword: l, it: u } = s;
    if (o[0] !== "#")
      throw new Error(`"${l}" only supports hash fragment reference`);
    const f = o.slice(1);
    if (u.allErrors)
      d();
    else {
      const v = a.let("valid", !1);
      d(v), s.ok(v);
    }
    function d(v) {
      if (u.schemaEnv.root.dynamicAnchors[f]) {
        const S = a.let("_v", (0, e._)`${t.default.dynamicAnchors}${(0, e.getProperty)(f)}`);
        a.if(S, m(S, v), m(u.validateName, v));
      } else
        m(u.validateName, v)();
    }
    function m(v, S) {
      return S ? () => a.block(() => {
        (0, r.callRef)(s, v), a.let(S, !0);
      }) : () => (0, r.callRef)(s, v);
    }
  }
  return cc.default = n, cc;
}
var dh = {}, nT;
function vQ() {
  if (nT) return dh;
  nT = 1, Object.defineProperty(dh, "__esModule", { value: !0 });
  const e = DL(), t = ct(), r = {
    keyword: "$recursiveAnchor",
    schemaType: "boolean",
    code(n) {
      n.schema ? (0, e.dynamicAnchor)(n, "") : (0, t.checkStrictMode)(n.it, "$recursiveAnchor: false is ignored");
    }
  };
  return dh.default = r, dh;
}
var hh = {}, iT;
function bQ() {
  if (iT) return hh;
  iT = 1, Object.defineProperty(hh, "__esModule", { value: !0 });
  const e = FL(), t = {
    keyword: "$recursiveRef",
    schemaType: "string",
    code: (r) => (0, e.dynamicRef)(r, r.schema)
  };
  return hh.default = t, hh;
}
var oT;
function wQ() {
  if (oT) return fh;
  oT = 1, Object.defineProperty(fh, "__esModule", { value: !0 });
  const e = DL(), t = FL(), r = vQ(), n = bQ(), i = [e.default, t.default, r.default, n.default];
  return fh.default = i, fh;
}
var mh = {}, gh = {}, sT;
function SQ() {
  if (sT) return gh;
  sT = 1, Object.defineProperty(gh, "__esModule", { value: !0 });
  const e = S1(), t = {
    keyword: "dependentRequired",
    type: "object",
    schemaType: "object",
    error: e.error,
    code: (r) => (0, e.validatePropertyDeps)(r)
  };
  return gh.default = t, gh;
}
var yh = {}, aT;
function xQ() {
  if (aT) return yh;
  aT = 1, Object.defineProperty(yh, "__esModule", { value: !0 });
  const e = S1(), t = {
    keyword: "dependentSchemas",
    type: "object",
    schemaType: "object",
    code: (r) => (0, e.validateSchemaDeps)(r)
  };
  return yh.default = t, yh;
}
var vh = {}, lT;
function EQ() {
  if (lT) return vh;
  lT = 1, Object.defineProperty(vh, "__esModule", { value: !0 });
  const e = ct(), t = {
    keyword: ["maxContains", "minContains"],
    type: "array",
    schemaType: "number",
    code({ keyword: r, parentSchema: n, it: i }) {
      n.contains === void 0 && (0, e.checkStrictMode)(i, `"${r}" without "contains" is ignored`);
    }
  };
  return vh.default = t, vh;
}
var uT;
function _Q() {
  if (uT) return mh;
  uT = 1, Object.defineProperty(mh, "__esModule", { value: !0 });
  const e = SQ(), t = xQ(), r = EQ(), n = [e.default, t.default, r.default];
  return mh.default = n, mh;
}
var bh = {}, wh = {}, cT;
function OQ() {
  if (cT) return wh;
  cT = 1, Object.defineProperty(wh, "__esModule", { value: !0 });
  const e = ot(), t = ct(), r = pi(), i = {
    keyword: "unevaluatedProperties",
    type: "object",
    schemaType: ["boolean", "object"],
    allowUndefined: !0,
    trackErrors: !0,
    error: {
      message: "must NOT have unevaluated properties",
      params: ({ params: s }) => (0, e._)`{unevaluatedProperty: ${s.unevaluatedProperty}}`
    },
    code(s) {
      const { gen: o, schema: a = s.it.opts.defaultUnevaluatedProperties, data: l, errsCount: u, it: f } = s, d = s.schema === void 0 && s.it.opts.defaultUnevaluatedProperties === !1;
      if (!u)
        throw new Error("ajv implementation error");
      const { allErrors: m, props: v } = f;
      if (v instanceof e.Name)
        o.if((0, e._)`${v} !== true`, () => o.forIn("key", l, (x) => o.if(y(v, x), () => S(x))));
      else if (v !== !0) {
        const x = () => o.forIn("key", l, (g) => v === void 0 ? S(g) : o.if(E(v, g), () => S(g)));
        d && f.errorPath.emptyStr() ? o.if((0, e._)`${r.default.isAllOfVariant} === 0`, x) : x();
      }
      d || (f.props = !0), s.ok((0, e._)`${u} === ${r.default.errors}`);
      function S(x) {
        if (a === !1) {
          s.setParams({ unevaluatedProperty: x }), s.error(), m || o.break();
          return;
        }
        if (!(0, t.alwaysValidSchema)(f, a)) {
          const g = o.name("valid");
          s.subschema({
            keyword: "unevaluatedProperties",
            dataProp: x,
            dataPropType: t.Type.Str
          }, g), m || o.if((0, e.not)(g), () => o.break());
        }
      }
      function y(x, g) {
        return (0, e._)`!${x} || !${x}[${g}]`;
      }
      function E(x, g) {
        const b = [];
        for (const A in x)
          x[A] === !0 && b.push((0, e._)`${g} !== ${A}`);
        return (0, e.and)(...b);
      }
    }
  };
  return wh.default = i, wh;
}
var Sh = {}, pT;
function kQ() {
  if (pT) return Sh;
  pT = 1, Object.defineProperty(Sh, "__esModule", { value: !0 });
  const e = ot(), t = ct(), n = {
    keyword: "unevaluatedItems",
    type: "array",
    schemaType: ["boolean", "object"],
    error: {
      message: ({ params: { len: i } }) => (0, e.str)`must NOT have more than ${i} items`,
      params: ({ params: { len: i } }) => (0, e._)`{limit: ${i}}`
    },
    code(i) {
      const { gen: s, schema: o, data: a, it: l } = i, u = l.items || 0;
      if (u === !0)
        return;
      const f = s.const("len", (0, e._)`${a}.length`);
      if (o === !1)
        i.setParams({ len: u }), i.fail((0, e._)`${f} > ${u}`);
      else if (typeof o == "object" && !(0, t.alwaysValidSchema)(l, o)) {
        const m = s.var("valid", (0, e._)`${f} <= ${u}`);
        s.if((0, e.not)(m), () => d(m, u)), i.ok(m);
      }
      l.items = !0;
      function d(m, v) {
        s.forRange("i", v, f, (S) => {
          i.subschema({ keyword: "unevaluatedItems", dataProp: S, dataPropType: t.Type.Num }, m), l.allErrors || s.if((0, e.not)(m), () => s.break());
        });
      }
    }
  };
  return Sh.default = n, Sh;
}
var fT;
function AQ() {
  if (fT) return bh;
  fT = 1, Object.defineProperty(bh, "__esModule", { value: !0 });
  const e = OQ(), t = kQ(), r = [e.default, t.default];
  return bh.default = r, bh;
}
var xh = {}, Eh = {}, dT;
function PQ() {
  if (dT) return Eh;
  dT = 1, Object.defineProperty(Eh, "__esModule", { value: !0 });
  const e = ot(), r = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: n }) => (0, e.str)`must match format "${n}"`,
      params: ({ schemaCode: n }) => (0, e._)`{format: ${n}}`
    },
    code(n, i) {
      const { gen: s, data: o, $data: a, schema: l, schemaCode: u, it: f } = n, { opts: d, errSchemaPath: m, schemaEnv: v, self: S } = f;
      if (!d.validateFormats)
        return;
      a ? y() : E();
      function y() {
        const x = s.scopeValue("formats", {
          ref: S.formats,
          code: d.code.formats
        }), g = s.const("fDef", (0, e._)`${x}[${u}]`), b = s.let("fType"), A = s.let("format");
        s.if((0, e._)`typeof ${g} == "object" && !(${g} instanceof RegExp)`, () => s.assign(b, (0, e._)`${g}.type || "string"`).assign(A, (0, e._)`${g}.validate`), () => s.assign(b, (0, e._)`"string"`).assign(A, g)), n.fail$data((0, e.or)(P(), k()));
        function P() {
          return d.strictSchema === !1 ? e.nil : (0, e._)`${u} && !${A}`;
        }
        function k() {
          const $ = v.$async ? (0, e._)`(${g}.async ? await ${A}(${o}) : ${A}(${o}))` : (0, e._)`${A}(${o})`, I = (0, e._)`(typeof ${A} == "function" ? ${$} : ${A}.test(${o}))`;
          return (0, e._)`${A} && ${A} !== true && ${b} === ${i} && !${I}`;
        }
      }
      function E() {
        const x = S.formats[l];
        if (!x) {
          P();
          return;
        }
        if (x === !0)
          return;
        const [g, b, A] = k(x);
        g === i && n.pass($());
        function P() {
          if (d.strictSchema === !1) {
            S.logger.warn(I());
            return;
          }
          throw new Error(I());
          function I() {
            return `unknown format "${l}" ignored in schema at path "${m}"`;
          }
        }
        function k(I) {
          const F = I instanceof RegExp ? (0, e.regexpCode)(I) : d.code.formats ? (0, e._)`${d.code.formats}${(0, e.getProperty)(l)}` : void 0, L = s.scopeValue("formats", { key: l, ref: I, code: F });
          return typeof I == "object" && !(I instanceof RegExp) ? [I.type || "string", I.validate, (0, e._)`${L}.validate`] : ["string", I, L];
        }
        function $() {
          if (typeof x == "object" && !(x instanceof RegExp) && x.async) {
            if (!v.$async)
              throw new Error("async format in sync schema");
            return (0, e._)`await ${A}(${o})`;
          }
          return typeof b == "function" ? (0, e._)`${A}(${o})` : (0, e._)`${A}.test(${o})`;
        }
      }
    }
  };
  return Eh.default = r, Eh;
}
var hT;
function TQ() {
  if (hT) return xh;
  hT = 1, Object.defineProperty(xh, "__esModule", { value: !0 });
  const t = [PQ().default];
  return xh.default = t, xh;
}
var Ws = {}, mT;
function CQ() {
  return mT || (mT = 1, Object.defineProperty(Ws, "__esModule", { value: !0 }), Ws.contentVocabulary = Ws.metadataVocabulary = void 0, Ws.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ], Ws.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ]), Ws;
}
var gT;
function $Q() {
  if (gT) return Ld;
  gT = 1, Object.defineProperty(Ld, "__esModule", { value: !0 });
  const e = H7(), t = iQ(), r = yQ(), n = wQ(), i = _Q(), s = AQ(), o = TQ(), a = CQ(), l = [
    n.default,
    e.default,
    t.default,
    (0, r.default)(!0),
    o.default,
    a.metadataVocabulary,
    a.contentVocabulary,
    i.default,
    s.default
  ];
  return Ld.default = l, Ld;
}
var _h = {}, pc = {}, yT;
function RQ() {
  if (yT) return pc;
  yT = 1, Object.defineProperty(pc, "__esModule", { value: !0 }), pc.DiscrError = void 0;
  var e;
  return function(t) {
    t.Tag = "tag", t.Mapping = "mapping";
  }(e || (pc.DiscrError = e = {})), pc;
}
var vT;
function IQ() {
  if (vT) return _h;
  vT = 1, Object.defineProperty(_h, "__esModule", { value: !0 });
  const e = ot(), t = RQ(), r = Jg(), n = ct(), s = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: {
      message: ({ params: { discrError: o, tagName: a } }) => o === t.DiscrError.Tag ? `tag "${a}" must be string` : `value of tag "${a}" must be in oneOf or anyOf`,
      params: ({ params: { discrError: o, tag: a, tagName: l } }) => (0, e._)`{error: ${o}, tag: ${l}, tagValue: ${a}}`
    },
    code(o) {
      const { gen: a, data: l, schema: u, parentSchema: f, it: d } = o, m = f.oneOf ? "oneOf" : f.anyOf ? "anyOf" : void 0;
      if (!d.opts.discriminator)
        throw new Error("discriminator: requires discriminator option");
      const v = u.propertyName;
      if (typeof v != "string")
        throw new Error("discriminator: requires propertyName");
      if (!m)
        throw new Error("discriminator: requires oneOf or anyOf composite keyword");
      const S = f[m], y = a.let("valid", !1), E = a.const("tag", (0, e._)`${l}${(0, e.getProperty)(v)}`);
      a.if((0, e._)`typeof ${E} == "string"`, () => x(), () => o.error(!1, { discrError: t.DiscrError.Tag, tag: E, tagName: v })), o.ok(y);
      function x() {
        const A = b();
        a.if(!1);
        for (const P in A)
          a.elseIf((0, e._)`${E} === ${P}`), a.assign(y, g(A[P]));
        a.else(), o.error(!1, { discrError: t.DiscrError.Mapping, tag: E, tagName: v }), a.endIf();
      }
      function g(A) {
        const P = a.name("valid"), k = o.subschema({ keyword: m, schemaProp: A }, P);
        return o.mergeEvaluated(k, e.Name), P;
      }
      function b() {
        var A;
        const P = {}, k = I(f);
        let $ = !0;
        for (let Q = 0; Q < S.length; Q++) {
          let Y = S[Q];
          const ae = Y == null ? void 0 : Y.$ref;
          if (ae && u.mapping) {
            const { mapping: ue } = u, ce = Object.keys(ue).filter((be) => ue[be] === Y.$ref);
            if (ce.length) {
              for (const be of ce)
                L(be, Q);
              continue;
            }
          }
          ae && !(0, n.schemaHasRulesButRef)(Y, d.self.RULES) && (Y = r.resolveRef.call(d.self, d.schemaEnv.root, d.baseId, ae), Y instanceof r.SchemaEnv && (Y = Y.schema));
          const le = (A = Y == null ? void 0 : Y.properties) === null || A === void 0 ? void 0 : A[v];
          if (typeof le != "object")
            throw new Error(`discriminator: ${m} subschemas (or referenced schemas) must have "properties/${v}" or match mapping`);
          $ = $ && (k || I(Y)), F(le, Q);
        }
        if (!$)
          throw new Error(`discriminator: "${v}" must be required`);
        return P;
        function I({ required: Q }) {
          return Array.isArray(Q) && Q.includes(v);
        }
        function F(Q, Y) {
          if (Q.const)
            L(Q.const, Y);
          else if (Q.enum)
            for (const ae of Q.enum)
              L(ae, Y);
          else
            throw new Error(`discriminator: "properties/${v}" must have "const" or "enum"`);
        }
        function L(Q, Y) {
          if (typeof Q != "string" || Q in P)
            throw new Error(`discriminator: "${v}" values must be unique strings`);
          P[Q] = Y;
        }
      }
    }
  };
  return _h.default = s, _h;
}
var Oh = {};
const NQ = "https://json-schema.org/draft/2020-12/schema", jQ = "https://json-schema.org/draft/2020-12/schema", LQ = {
  "https://json-schema.org/draft/2020-12/vocab/core": !0,
  "https://json-schema.org/draft/2020-12/vocab/applicator": !0,
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0,
  "https://json-schema.org/draft/2020-12/vocab/validation": !0,
  "https://json-schema.org/draft/2020-12/vocab/meta-data": !0,
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0,
  "https://json-schema.org/draft/2020-12/vocab/content": !0
}, MQ = "meta", DQ = "Core and Validation specifications meta-schema", FQ = [
  {
    $ref: "meta/core"
  },
  {
    $ref: "meta/applicator"
  },
  {
    $ref: "meta/unevaluated"
  },
  {
    $ref: "meta/validation"
  },
  {
    $ref: "meta/meta-data"
  },
  {
    $ref: "meta/format-annotation"
  },
  {
    $ref: "meta/content"
  }
], zQ = [
  "object",
  "boolean"
], qQ = "This meta-schema also defines keywords that have appeared in previous drafts in order to prevent incompatible extensions as they remain in common use.", BQ = {
  definitions: {
    $comment: '"definitions" has been replaced by "$defs".',
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    deprecated: !0,
    default: {}
  },
  dependencies: {
    $comment: '"dependencies" has been split and replaced by "dependentSchemas" and "dependentRequired" in order to serve their differing semantics.',
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $dynamicRef: "#meta"
        },
        {
          $ref: "meta/validation#/$defs/stringArray"
        }
      ]
    },
    deprecated: !0,
    default: {}
  },
  $recursiveAnchor: {
    $comment: '"$recursiveAnchor" has been replaced by "$dynamicAnchor".',
    $ref: "meta/core#/$defs/anchorString",
    deprecated: !0
  },
  $recursiveRef: {
    $comment: '"$recursiveRef" has been replaced by "$dynamicRef".',
    $ref: "meta/core#/$defs/uriReferenceString",
    deprecated: !0
  }
}, UQ = {
  $schema: NQ,
  $id: jQ,
  $vocabulary: LQ,
  $dynamicAnchor: MQ,
  title: DQ,
  allOf: FQ,
  type: zQ,
  $comment: qQ,
  properties: BQ
}, VQ = "https://json-schema.org/draft/2020-12/schema", WQ = "https://json-schema.org/draft/2020-12/meta/applicator", HQ = {
  "https://json-schema.org/draft/2020-12/vocab/applicator": !0
}, QQ = "meta", YQ = "Applicator vocabulary meta-schema", GQ = [
  "object",
  "boolean"
], KQ = {
  prefixItems: {
    $ref: "#/$defs/schemaArray"
  },
  items: {
    $dynamicRef: "#meta"
  },
  contains: {
    $dynamicRef: "#meta"
  },
  additionalProperties: {
    $dynamicRef: "#meta"
  },
  properties: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    propertyNames: {
      format: "regex"
    },
    default: {}
  },
  dependentSchemas: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    default: {}
  },
  propertyNames: {
    $dynamicRef: "#meta"
  },
  if: {
    $dynamicRef: "#meta"
  },
  then: {
    $dynamicRef: "#meta"
  },
  else: {
    $dynamicRef: "#meta"
  },
  allOf: {
    $ref: "#/$defs/schemaArray"
  },
  anyOf: {
    $ref: "#/$defs/schemaArray"
  },
  oneOf: {
    $ref: "#/$defs/schemaArray"
  },
  not: {
    $dynamicRef: "#meta"
  }
}, XQ = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $dynamicRef: "#meta"
    }
  }
}, JQ = {
  $schema: VQ,
  $id: WQ,
  $vocabulary: HQ,
  $dynamicAnchor: QQ,
  title: YQ,
  type: GQ,
  properties: KQ,
  $defs: XQ
}, ZQ = "https://json-schema.org/draft/2020-12/schema", eY = "https://json-schema.org/draft/2020-12/meta/unevaluated", tY = {
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0
}, rY = "meta", nY = "Unevaluated applicator vocabulary meta-schema", iY = [
  "object",
  "boolean"
], oY = {
  unevaluatedItems: {
    $dynamicRef: "#meta"
  },
  unevaluatedProperties: {
    $dynamicRef: "#meta"
  }
}, sY = {
  $schema: ZQ,
  $id: eY,
  $vocabulary: tY,
  $dynamicAnchor: rY,
  title: nY,
  type: iY,
  properties: oY
}, aY = "https://json-schema.org/draft/2020-12/schema", lY = "https://json-schema.org/draft/2020-12/meta/content", uY = {
  "https://json-schema.org/draft/2020-12/vocab/content": !0
}, cY = "meta", pY = "Content vocabulary meta-schema", fY = [
  "object",
  "boolean"
], dY = {
  contentEncoding: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentSchema: {
    $dynamicRef: "#meta"
  }
}, hY = {
  $schema: aY,
  $id: lY,
  $vocabulary: uY,
  $dynamicAnchor: cY,
  title: pY,
  type: fY,
  properties: dY
}, mY = "https://json-schema.org/draft/2020-12/schema", gY = "https://json-schema.org/draft/2020-12/meta/core", yY = {
  "https://json-schema.org/draft/2020-12/vocab/core": !0
}, vY = "meta", bY = "Core vocabulary meta-schema", wY = [
  "object",
  "boolean"
], SY = {
  $id: {
    $ref: "#/$defs/uriReferenceString",
    $comment: "Non-empty fragments not allowed.",
    pattern: "^[^#]*#?$"
  },
  $schema: {
    $ref: "#/$defs/uriString"
  },
  $ref: {
    $ref: "#/$defs/uriReferenceString"
  },
  $anchor: {
    $ref: "#/$defs/anchorString"
  },
  $dynamicRef: {
    $ref: "#/$defs/uriReferenceString"
  },
  $dynamicAnchor: {
    $ref: "#/$defs/anchorString"
  },
  $vocabulary: {
    type: "object",
    propertyNames: {
      $ref: "#/$defs/uriString"
    },
    additionalProperties: {
      type: "boolean"
    }
  },
  $comment: {
    type: "string"
  },
  $defs: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    }
  }
}, xY = {
  anchorString: {
    type: "string",
    pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
  },
  uriString: {
    type: "string",
    format: "uri"
  },
  uriReferenceString: {
    type: "string",
    format: "uri-reference"
  }
}, EY = {
  $schema: mY,
  $id: gY,
  $vocabulary: yY,
  $dynamicAnchor: vY,
  title: bY,
  type: wY,
  properties: SY,
  $defs: xY
}, _Y = "https://json-schema.org/draft/2020-12/schema", OY = "https://json-schema.org/draft/2020-12/meta/format-annotation", kY = {
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0
}, AY = "meta", PY = "Format vocabulary meta-schema for annotation results", TY = [
  "object",
  "boolean"
], CY = {
  format: {
    type: "string"
  }
}, $Y = {
  $schema: _Y,
  $id: OY,
  $vocabulary: kY,
  $dynamicAnchor: AY,
  title: PY,
  type: TY,
  properties: CY
}, RY = "https://json-schema.org/draft/2020-12/schema", IY = "https://json-schema.org/draft/2020-12/meta/meta-data", NY = {
  "https://json-schema.org/draft/2020-12/vocab/meta-data": !0
}, jY = "meta", LY = "Meta-data vocabulary meta-schema", MY = [
  "object",
  "boolean"
], DY = {
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: !0,
  deprecated: {
    type: "boolean",
    default: !1
  },
  readOnly: {
    type: "boolean",
    default: !1
  },
  writeOnly: {
    type: "boolean",
    default: !1
  },
  examples: {
    type: "array",
    items: !0
  }
}, FY = {
  $schema: RY,
  $id: IY,
  $vocabulary: NY,
  $dynamicAnchor: jY,
  title: LY,
  type: MY,
  properties: DY
}, zY = "https://json-schema.org/draft/2020-12/schema", qY = "https://json-schema.org/draft/2020-12/meta/validation", BY = {
  "https://json-schema.org/draft/2020-12/vocab/validation": !0
}, UY = "meta", VY = "Validation vocabulary meta-schema", WY = [
  "object",
  "boolean"
], HY = {
  type: {
    anyOf: [
      {
        $ref: "#/$defs/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/$defs/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  const: !0,
  enum: {
    type: "array",
    items: !0
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  maxItems: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  maxContains: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minContains: {
    $ref: "#/$defs/nonNegativeInteger",
    default: 1
  },
  maxProperties: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/$defs/stringArray"
  },
  dependentRequired: {
    type: "object",
    additionalProperties: {
      $ref: "#/$defs/stringArray"
    }
  }
}, QY = {
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    $ref: "#/$defs/nonNegativeInteger",
    default: 0
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: !0,
    default: []
  }
}, YY = {
  $schema: zY,
  $id: qY,
  $vocabulary: BY,
  $dynamicAnchor: UY,
  title: VY,
  type: WY,
  properties: HY,
  $defs: QY
};
var bT;
function GY() {
  if (bT) return Oh;
  bT = 1, Object.defineProperty(Oh, "__esModule", { value: !0 }), Oh.default = u;
  const e = UQ, t = JQ, r = sY, n = hY, i = EY, s = $Y, o = FY, a = YY, l = ["/properties"];
  function u(f) {
    return [
      e,
      t,
      r,
      n,
      i,
      d(this, s),
      o,
      d(this, a)
    ].forEach((m) => this.addMetaSchema(m, void 0, !1)), this;
    function d(m, v) {
      return f ? m.$dataMetaSchema(v, l) : v;
    }
  }
  return Oh;
}
var wT;
function KY() {
  return wT || (wT = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = void 0;
    const r = V7(), n = $Q(), i = IQ(), s = GY(), o = "https://json-schema.org/draft/2020-12/schema";
    class a extends r.default {
      constructor(d = {}) {
        super({
          ...d,
          dynamicRef: !0,
          next: !0,
          unevaluated: !0
        });
      }
      _addVocabularies() {
        super._addVocabularies(), n.default.forEach((d) => this.addVocabulary(d)), this.opts.discriminator && this.addKeyword(i.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        const { $data: d, meta: m } = this.opts;
        m && (s.default.call(this, d), this.refs["http://json-schema.org/schema"] = o);
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(o) ? o : void 0);
      }
    }
    e.exports = t = a, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = a;
    var l = Xg();
    Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
      return l.KeywordCxt;
    } });
    var u = ot();
    Object.defineProperty(t, "_", { enumerable: !0, get: function() {
      return u._;
    } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
      return u.str;
    } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
      return u.stringify;
    } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
      return u.nil;
    } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
      return u.Name;
    } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
      return u.CodeGen;
    } });
  }(Cd, Cd.exports)), Cd.exports;
}
var ST;
function XY() {
  if (ST) return Td;
  ST = 1, Object.defineProperty(Td, "__esModule", { value: !0 }), Td.getNodeTypesFromJSONSchema = o;
  const e = KY(), t = xn(), r = new e.default({
    strictSchema: !1,
    allowUnionTypes: !0,
    useDefaults: !0,
    allErrors: !0,
    discriminator: !0,
    strictTypes: !1,
    verbose: !0
  });
  function n(a, l) {
    if (l.some((u) => typeof u == "function"))
      throw new Error("Unexpected oneOf inside oneOf.");
    return (u) => {
      let f = a.findIndex((d) => r.validate(d, u));
      return f === -1 && (f = 0), l[f];
    };
  }
  function i(a, l, u) {
    var f;
    if (!l || typeof l == "boolean")
      throw new Error(`Unexpected schema in ${a}.`);
    if (l instanceof Array)
      throw new Error(`Unexpected array schema in ${a}. Try using oneOf instead.`);
    if (l.type === "null")
      throw new Error(`Unexpected null schema type in ${a} schema.`);
    if (l.type instanceof Array)
      throw new Error(`Unexpected array schema type in ${a} schema. Try using oneOf instead.`);
    if (l.type === "string" || l.type === "number" || l.type === "integer" || l.type === "boolean") {
      const { default: d, format: m, ...v } = l;
      return v;
    }
    if (l.type === "object" && !l.properties && !l.oneOf) {
      if (l.additionalProperties === void 0 || l.additionalProperties === !0)
        return { type: "object" };
      if (l.additionalProperties === !1)
        return { type: "object", properties: {} };
    }
    if (l.allOf)
      throw new Error(`Unexpected allOf in ${a}.`);
    if (l.anyOf)
      throw new Error(`Unexpected anyOf in ${a}.`);
    if ((0, t.isPlainObject)(l.properties) || (0, t.isPlainObject)(l.additionalProperties) || (0, t.isPlainObject)(l.items) && ((0, t.isPlainObject)(l.items.properties) || (0, t.isPlainObject)(l.items.additionalProperties) || l.items.oneOf))
      return s(a, l, u);
    if (l.oneOf)
      if (l.discriminator) {
        const d = (f = l.discriminator) == null ? void 0 : f.propertyName;
        if (!d)
          throw new Error(`Unexpected discriminator without a propertyName in ${a}.`);
        const m = l.oneOf.map((v, S) => {
          var x;
          if (typeof v == "boolean")
            throw new Error(`Unexpected boolean schema in ${a} at position ${S} in oneOf.`);
          const y = (x = v == null ? void 0 : v.properties) == null ? void 0 : x[d];
          if (!y || typeof y == "boolean")
            throw new Error(`Unexpected property '${y}' schema in ${a} at position ${S} in oneOf.`);
          const E = y.const;
          return i(E, v, u);
        });
        return (v, S) => {
          if ((0, t.isPlainObject)(v)) {
            const y = v[d];
            if (typeof y == "string" && u[y])
              return y;
          }
          return n(l.oneOf, m)(v, S);
        };
      } else {
        const d = l.oneOf.map((m, v) => i(a + "_" + v, m, u));
        return n(l.oneOf, d);
      }
    return l;
  }
  function s(a, l, u) {
    if (!l || typeof l == "boolean")
      throw new Error(`Unexpected schema in ${a}.`);
    if (l instanceof Array)
      throw new Error(`Unexpected array schema in ${a}. Try using oneOf instead.`);
    if (l.type === "null")
      throw new Error(`Unexpected null schema type in ${a} schema.`);
    if (l.type instanceof Array)
      throw new Error(`Unexpected array schema type in ${a} schema. Try using oneOf instead.`);
    const f = {};
    for (const [S, y] of Object.entries(l.properties || {}))
      f[S] = i(a + "." + S, y, u);
    let d;
    (0, t.isPlainObject)(l.additionalProperties) && (d = i(a + "_additionalProperties", l.additionalProperties, u)), l.additionalProperties === !0 && (d = {});
    let m;
    (0, t.isPlainObject)(l.items) && ((0, t.isPlainObject)(l.items.properties) || (0, t.isPlainObject)(l.items.additionalProperties) || l.items.oneOf) && (m = i(a + "_items", l.items, u));
    let v = l.required;
    return l.oneOf && l.oneOf.every((S) => !!S.required) && (v = (S) => {
      const y = l.oneOf.map((x) => [
        ...l.required || [],
        ...x.required
      ]);
      let E = y.findIndex((x) => x.every((g) => S[g] !== void 0));
      return E === -1 && (E = 0), y[E];
    }), u[a] = { properties: f, additionalProperties: d, items: m, required: v }, a;
  }
  function o(a, l) {
    const u = {};
    return i(a, l, u), u;
  }
  return Td;
}
var xT;
function JY() {
  if (xT) return el;
  xT = 1, Object.defineProperty(el, "__esModule", { value: !0 }), el.ConfigTypes = void 0, el.createConfigTypes = $e;
  const e = P7, t = Fn(), r = y1(), n = xn(), i = XY(), s = [
    "info-contact",
    "operation-operationId",
    "tag-description",
    "tags-alphabetical",
    "info-license-url",
    "info-license-strict",
    "info-license",
    "no-ambiguous-paths",
    "no-enum-type-mismatch",
    "no-http-verbs-in-paths",
    "no-identical-paths",
    "no-invalid-parameter-examples",
    "no-invalid-schema-examples",
    "no-path-trailing-slash",
    "operation-2xx-response",
    "operation-4xx-response",
    "operation-description",
    "operation-operationId-unique",
    "operation-operationId-url-safe",
    "operation-parameters-unique",
    "operation-singular-tag",
    "operation-summary",
    "operation-tag-defined",
    "parameter-description",
    "path-declaration-must-exist",
    "path-excludes-patterns",
    "path-http-verbs-order",
    "path-not-include-query",
    "path-params-defined",
    "path-parameters-defined",
    "path-segment-plural",
    "paths-kebab-case",
    "required-string-property-missing-min-length",
    "response-contains-header",
    "scalar-property-missing-example",
    "security-defined",
    "spec-strict-refs",
    "no-unresolved-refs",
    "no-required-schema-properties-undefined",
    "no-schema-type-mismatch",
    "boolean-parameter-prefixes",
    "request-mime-type",
    "response-contains-property",
    "response-mime-type"
  ], o = [
    "info-contact",
    "operation-operationId",
    "tag-description",
    "tags-alphabetical",
    "info-license-url",
    "info-license-strict",
    "info-license",
    "no-ambiguous-paths",
    "no-enum-type-mismatch",
    "no-http-verbs-in-paths",
    "no-identical-paths",
    "no-invalid-parameter-examples",
    "no-invalid-schema-examples",
    "no-path-trailing-slash",
    "operation-2xx-response",
    "operation-4xx-response",
    "operation-description",
    "operation-operationId-unique",
    "operation-operationId-url-safe",
    "operation-parameters-unique",
    "operation-singular-tag",
    "operation-summary",
    "operation-tag-defined",
    "parameter-description",
    "path-declaration-must-exist",
    "path-excludes-patterns",
    "path-http-verbs-order",
    "path-not-include-query",
    "path-params-defined",
    "path-parameters-defined",
    "path-segment-plural",
    "paths-kebab-case",
    "required-string-property-missing-min-length",
    "response-contains-header",
    "scalar-property-missing-example",
    "security-defined",
    "spec-strict-refs",
    "no-unresolved-refs",
    "no-required-schema-properties-undefined",
    "no-schema-type-mismatch",
    "boolean-parameter-prefixes",
    "component-name-unique",
    "no-empty-servers",
    "no-example-value-and-externalValue",
    "no-invalid-media-type-examples",
    "no-server-example.com",
    "no-server-trailing-slash",
    "no-server-variables-empty-enum",
    "no-undefined-server-variable",
    "no-unused-components",
    "operation-4xx-problem-details-rfc7807",
    "request-mime-type",
    "response-contains-property",
    "response-mime-type",
    "spec-components-invalid-map-name",
    "array-parameter-serialization"
  ], a = [
    "info-contact",
    "info-license-strict",
    "operation-operationId",
    "tag-description",
    "tags-alphabetical",
    "channels-kebab-case",
    "no-channel-trailing-slash"
  ], l = [
    "info-contact",
    "info-license-strict",
    "operation-operationId",
    "tag-description",
    "tags-alphabetical",
    "channels-kebab-case",
    "no-channel-trailing-slash"
  ], u = [
    "sourceDescription-type",
    "workflowId-unique",
    "stepId-unique",
    "sourceDescription-name-unique",
    "sourceDescriptions-not-empty",
    "workflow-dependsOn",
    "parameters-unique",
    "step-onSuccess-unique",
    "step-onFailure-unique",
    "respect-supported-versions",
    "requestBody-replacements-unique",
    "no-criteria-xpath",
    "criteria-unique"
  ], f = ["info-contact"], d = [
    ...s,
    ...o,
    ...a,
    ...l,
    ...u,
    ...f,
    "spec",
    // TODO: depricated in favor of struct
    "struct"
  ], m = {
    properties: {
      extends: {
        type: "array",
        items: {
          type: "string"
        }
      },
      rules: "Rules",
      oas2Rules: "Rules",
      oas3_0Rules: "Rules",
      oas3_1Rules: "Rules",
      async2Rules: "Rules",
      arazzo1Rules: "Rules",
      preprocessors: { type: "object" },
      oas2Preprocessors: { type: "object" },
      oas3_0Preprocessors: { type: "object" },
      oas3_1Preprocessors: { type: "object" },
      async2Preprocessors: { type: "object" },
      arazzoPreprocessors: { type: "object" },
      decorators: { type: "object" },
      oas2Decorators: { type: "object" },
      oas3_0Decorators: { type: "object" },
      oas3_1Decorators: { type: "object" },
      async2Decorators: { type: "object" },
      arazzo1Decorators: { type: "object" }
    }
  }, v = (Pe) => ({
    ...Pe.rootRedoclyConfigSchema,
    properties: {
      ...Pe.rootRedoclyConfigSchema.properties,
      ...m.properties,
      apis: "ConfigApis",
      // Override apis with internal format
      "features.openapi": "ConfigReferenceDocs",
      // deprecated
      "features.mockServer": "ConfigMockServer",
      // deprecated
      organization: { type: "string" },
      region: { enum: ["us", "eu"] },
      telemetry: { enum: ["on", "off"] },
      resolve: {
        properties: {
          http: "ConfigHTTP",
          doNotResolveExamples: { type: "boolean" }
        }
      },
      files: {
        type: "array",
        items: {
          type: "string"
        }
      }
    }
  }), S = {
    properties: {},
    additionalProperties: "ConfigApisProperties"
  }, y = (Pe) => {
    var Re;
    return {
      ...Pe["rootRedoclyConfigSchema.apis_additionalProperties"],
      properties: {
        ...(Re = Pe["rootRedoclyConfigSchema.apis_additionalProperties"]) == null ? void 0 : Re.properties,
        labels: {
          type: "array",
          items: {
            type: "string"
          }
        },
        ...m.properties,
        "features.openapi": "ConfigReferenceDocs",
        // deprecated
        "features.mockServer": "ConfigMockServer",
        // deprecated
        files: {
          type: "array",
          items: {
            type: "string"
          }
        }
      }
    };
  }, E = {
    properties: {
      headers: {
        type: "array",
        items: {
          type: "string"
        }
      }
    }
  }, x = {
    properties: {},
    additionalProperties: (Pe, Re) => {
      if (Re.startsWith("rule/"))
        return typeof Pe == "string" ? { enum: ["error", "warn", "off"] } : "Assert";
      if (Re.startsWith("assert/"))
        return typeof Pe == "string" ? { enum: ["error", "warn", "off"] } : "Assert";
      if (d.includes(Re) || (0, n.isCustomRuleId)(Re))
        return typeof Pe == "string" ? { enum: ["error", "warn", "off"] } : "ObjectRule";
      if (Re === "metadata-schema" || Re === "custom-fields-schema")
        return "Schema";
    }
  }, g = {
    properties: {
      severity: { enum: ["error", "warn", "off"] }
    },
    additionalProperties: {},
    required: ["severity"]
  }, b = {
    properties: {},
    additionalProperties: {}
  };
  function A(Pe) {
    return {
      properties: {
        type: {
          enum: [.../* @__PURE__ */ new Set(["any", ...Pe, "SpecExtension"])]
        },
        property: (Re) => Array.isArray(Re) ? { type: "array", items: { type: "string" } } : Re === null ? null : { type: "string" },
        filterInParentKeys: { type: "array", items: { type: "string" } },
        filterOutParentKeys: { type: "array", items: { type: "string" } },
        matchParentKeys: { type: "string" }
      },
      required: ["type"]
    };
  }
  const P = {
    properties: {
      enum: { type: "array", items: { type: "string" } },
      pattern: { type: "string" },
      notPattern: { type: "string" },
      casing: {
        enum: [
          "camelCase",
          "kebab-case",
          "snake_case",
          "PascalCase",
          "MACRO_CASE",
          "COBOL-CASE",
          "flatcase"
        ]
      },
      mutuallyExclusive: { type: "array", items: { type: "string" } },
      mutuallyRequired: { type: "array", items: { type: "string" } },
      required: { type: "array", items: { type: "string" } },
      requireAny: { type: "array", items: { type: "string" } },
      disallowed: { type: "array", items: { type: "string" } },
      defined: { type: "boolean" },
      // undefined: { type: 'boolean' }, // TODO: Remove `undefined` assertion from codebase overall
      nonEmpty: { type: "boolean" },
      minLength: { type: "integer" },
      maxLength: { type: "integer" },
      ref: (Pe) => typeof Pe == "string" ? { type: "string" } : { type: "boolean" },
      const: (Pe) => {
        if (typeof Pe == "string")
          return { type: "string" };
        if (typeof Pe == "number")
          return { type: "number" };
        if (typeof Pe == "boolean")
          return { type: "boolean" };
      }
    },
    additionalProperties: (Pe, Re) => {
      if (/^\w+\/\w+$/.test(Re))
        return { type: "object" };
    }
  }, k = {
    properties: {
      subject: "AssertionDefinitionSubject",
      assertions: "AssertionDefinitionAssertions"
    },
    required: ["subject", "assertions"]
  }, $ = {
    properties: {
      subject: "AssertionDefinitionSubject",
      assertions: "AssertionDefinitionAssertions",
      where: (0, t.listOf)("AssertDefinition"),
      message: { type: "string" },
      suggest: { type: "array", items: { type: "string" } },
      severity: { enum: ["error", "warn", "off"] }
    },
    required: ["subject", "assertions"]
  }, I = {
    properties: {
      label: { type: "string" },
      lang: {
        enum: [
          "curl",
          "C#",
          "Go",
          "Java",
          "Java8+Apache",
          "JavaScript",
          "Node.js",
          "PHP",
          "Python",
          "R",
          "Ruby"
        ]
      }
    },
    required: ["lang"]
  }, F = {
    properties: {
      enum: { type: "string" },
      enumSingleValue: { type: "string" },
      enumArray: { type: "string" },
      default: { type: "string" },
      deprecated: { type: "string" },
      example: { type: "string" },
      examples: { type: "string" },
      nullable: { type: "string" },
      recursive: { type: "string" },
      arrayOf: { type: "string" },
      webhook: { type: "string" },
      authorizations: { type: "string" },
      tryItAuthBasicUsername: { type: "string" },
      tryItAuthBasicPassword: { type: "string" }
    }
  }, L = {
    properties: {
      beforeInfo: (0, t.listOf)("CommonConfigSidebarLinks"),
      end: (0, t.listOf)("CommonConfigSidebarLinks")
    }
  }, Q = {
    properties: {
      label: { type: "string" },
      link: { type: "string" },
      target: { type: "string" }
    },
    required: ["label", "link"]
  }, Y = {
    properties: {
      main: { type: "string" },
      light: { type: "string" },
      dark: { type: "string" },
      contrastText: { type: "string" }
    }
  }, ae = {
    properties: {
      backgroundColor: { type: "string" },
      borderColor: { type: "string" },
      color: { type: "string" },
      tabTextColor: { type: "string" }
    }
  }, le = {
    properties: (0, n.pickObjectProps)(Y.properties, ["light", "dark"])
  }, ue = {
    properties: {
      basic: { type: "string" },
      delete: { type: "string" },
      get: { type: "string" },
      head: { type: "string" },
      link: { type: "string" },
      options: { type: "string" },
      patch: { type: "string" },
      post: { type: "string" },
      put: { type: "string" }
    }
  }, ce = {
    properties: {
      error: "CommonColorProps",
      info: "CommonColorProps",
      redirect: "CommonColorProps",
      success: "CommonColorProps"
    }
  }, be = {
    properties: (0, n.omitObjectProps)(Y.properties, ["dark"])
  }, G = {
    properties: {
      primary: { type: "string" },
      secondary: { type: "string" },
      light: { type: "string" }
    }
  }, ee = {
    properties: {
      accent: "CommonThemeColors",
      border: "BorderThemeColors",
      error: "CommonThemeColors",
      http: "HttpColors",
      primary: "CommonThemeColors",
      responses: "ResponseColors",
      secondary: "SecondaryColors",
      success: "CommonThemeColors",
      text: "TextThemeColors",
      tonalOffset: { type: "number" },
      warning: "CommonThemeColors"
    }
  }, K = {
    properties: {
      fontSize: { type: "string" },
      padding: { type: "string" },
      minWidth: { type: "string" }
    }
  }, z = {
    properties: {
      small: "SizeProps",
      medium: "SizeProps",
      large: "SizeProps",
      xlarge: "SizeProps"
    }
  }, te = {
    properties: {
      fontFamily: { type: "string" },
      fontSize: { type: "string" },
      fontWeight: { type: "string" },
      lineHeight: { type: "string" }
    }
  }, q = {
    properties: {
      ...(0, n.omitObjectProps)(te.properties, ["fontSize", "lineHeight"]),
      borderRadius: { type: "string" },
      hoverStyle: { type: "string" },
      boxShadow: { type: "string" },
      hoverBoxShadow: { type: "string" },
      sizes: "Sizes"
    }
  }, j = {
    properties: (0, n.pickObjectProps)(te.properties, ["fontSize", "lineHeight"])
  }, H = {
    properties: {
      medium: "BadgeFontConfig",
      small: "BadgeFontConfig"
    }
  }, B = {
    properties: {
      ...(0, n.omitObjectProps)(te.properties, ["fontSize", "lineHeight"]),
      borderRadius: { type: "string" },
      color: { type: "string" },
      sizes: "BadgeSizes"
    }
  }, pe = {
    properties: {
      top: { type: "string" },
      width: { type: "string" },
      height: { type: "string" }
    }
  }, he = {
    properties: {
      borderRadius: { type: "string" },
      backgroundColor: { type: "string" }
    }
  }, Ae = {
    properties: {
      fullWidth: { type: "boolean" }
    }
  }, C = {
    properties: {
      buttons: "ButtonsConfig",
      httpBadges: "HttpBadgesConfig",
      layoutControls: "LabelControls",
      panels: "Panels",
      tryItButton: "TryItButton",
      tryItSendButton: "TryItButton"
    }
  }, N = {
    properties: {
      small: { type: "string" },
      medium: { type: "string" },
      large: { type: "string" }
    }
  }, J = {
    properties: {
      maxWidth: "Breakpoints"
    }
  }, X = {
    properties: {
      maxWidth: "Breakpoints",
      middlePanelMaxWidth: "Breakpoints"
    }
  }, oe = {
    properties: {
      showDarkRightPanel: { type: "boolean" },
      stacked: "StackedConfig",
      "three-panel": "ThreePanelConfig"
    }
  }, U = {
    properties: {
      backgroundColor: { type: "string" },
      border: { type: "string" }
    }
  }, V = {
    properties: {
      breakFieldNames: { type: "boolean" },
      caretColor: { type: "string" },
      caretSize: { type: "string" },
      constraints: "SchemaColorsConfig",
      defaultDetailsWidth: { type: "string" },
      examples: "SchemaColorsConfig",
      labelsTextSize: { type: "string" },
      linesColor: { type: "string" },
      nestedBackground: { type: "string" },
      nestingSpacing: { type: "string" },
      requireLabelColor: { type: "string" },
      typeNameColor: { type: "string" },
      typeTitleColor: { type: "string" }
    }
  }, ye = {
    properties: {
      subItemsColor: { type: "string" },
      textTransform: { type: "string" },
      fontWeight: { type: "string" }
    }
  }, de = {
    properties: (0, n.pickObjectProps)(ye.properties, ["textTransform"])
  }, Ce = {
    properties: {
      unit: { type: "number" },
      paddingHorizontal: { type: "string" },
      paddingVertical: { type: "string" },
      offsetTop: { type: "string" },
      offsetLeft: { type: "string" },
      offsetNesting: { type: "string" }
    }
  }, Se = {
    properties: {
      ...(0, n.omitObjectProps)(te.properties, ["fontWeight", "lineHeight"]),
      activeBgColor: { type: "string" },
      activeTextColor: { type: "string" },
      backgroundColor: { type: "string" },
      borderRadius: { type: "string" },
      breakPath: { type: "boolean" },
      caretColor: { type: "string" },
      caretSize: { type: "string" },
      groupItems: "GroupItemsConfig",
      level1items: "Level1Items",
      rightLineColor: { type: "string" },
      separatorLabelColor: { type: "string" },
      showAtBreakpoint: { type: "string" },
      spacing: "SpacingConfig",
      textColor: { type: "string" },
      width: { type: "string" }
    }
  }, O = {
    properties: {
      ...te.properties,
      color: { type: "string" },
      transform: { type: "string" }
    }
  }, M = {
    properties: {
      ...te.properties,
      backgroundColor: { type: "string" },
      color: { type: "string" },
      wordBreak: {
        enum: [
          "break-all",
          "break-word",
          "keep-all",
          "normal",
          "revert",
          "unset",
          "inherit",
          "initial"
        ]
      },
      wrap: { type: "boolean" }
    }
  }, se = {
    properties: (0, n.omitObjectProps)(te.properties, ["fontSize"])
  }, ve = {
    properties: {
      color: { type: "string" },
      hover: { type: "string" },
      textDecoration: { type: "string" },
      hoverTextDecoration: { type: "string" },
      visited: { type: "string" }
    }
  }, ge = {
    properties: {
      code: "CodeConfig",
      fieldName: "FontConfig",
      ...(0, n.pickObjectProps)(te.properties, ["fontSize", "fontFamily"]),
      fontWeightBold: { type: "string" },
      fontWeightLight: { type: "string" },
      fontWeightRegular: { type: "string" },
      heading1: "Heading",
      heading2: "Heading",
      heading3: "Heading",
      headings: "HeadingsConfig",
      lineHeight: { type: "string" },
      links: "LinksConfig",
      optimizeSpeed: { type: "boolean" },
      rightPanelHeading: "Heading",
      smoothing: { enum: ["auto", "none", "antialiased", "subpixel-antialiased", "grayscale"] }
    }
  }, Oe = {
    properties: {
      color: { type: "string" },
      ...(0, n.omitObjectProps)(te.properties, ["fontWeight"])
    }
  }, ke = {
    properties: {
      backgroundColor: { type: "string" },
      borderRadius: { type: "string" },
      tokens: "TokenProps"
    }
  }, Me = {
    properties: {
      gutter: { type: "string" },
      maxHeight: { type: "string" },
      maxWidth: { type: "string" }
    }
  }, Ve = {
    properties: {
      backgroundColor: { type: "string" },
      color: { type: "string" }
    }
  }, Je = {
    properties: {
      custom: { type: "string" }
    }
  }, He = {
    properties: {
      DownloadButton: "ButtonOverrides",
      NextSectionButton: "ButtonOverrides"
    }
  }, Ue = {
    properties: {
      backgroundColor: { type: "string" },
      panelBackgroundColor: { type: "string" },
      panelControlsBackgroundColor: { type: "string" },
      showAtBreakpoint: { type: "string" },
      textColor: { type: "string" },
      width: { type: "string" }
    }
  }, Ot = {
    properties: { borderRadius: { type: "string" } }
  }, D = {
    properties: {
      sectionHorizontal: { type: "number" },
      sectionVertical: { type: "number" },
      unit: { type: "number" }
    }
  }, we = {
    properties: {
      breakpoints: "Breakpoints",
      codeBlock: "CodeBlock",
      colors: "ThemeColors",
      components: "ConfigThemeComponents",
      layout: "Layout",
      logo: "ConfigThemeLogo",
      fab: "Fab",
      overrides: "Overrides",
      rightPanel: "RightPanel",
      schema: "ConfigThemeSchema",
      shape: "Shape",
      sidebar: "Sidebar",
      spacing: "ThemeSpacing",
      typography: "Typography",
      links: { properties: { color: { type: "string" } } },
      // deprecated
      codeSample: { properties: { backgroundColor: { type: "string" } } }
      // deprecated
    }
  }, Ee = {
    properties: {
      skipOptionalParameters: { type: "boolean" },
      languages: (0, t.listOf)("ConfigLanguage")
    },
    required: ["languages"]
  }, _e = {
    properties: {
      theme: "ConfigTheme",
      corsProxyUrl: { type: "string" },
      ctrlFHijack: { type: "boolean" },
      defaultSampleLanguage: { type: "string" },
      disableDeepLinks: { type: "boolean" },
      disableSearch: { type: "boolean" },
      disableSidebar: { type: "boolean" },
      downloadDefinitionUrl: { type: "string" },
      expandDefaultServerVariables: { type: "boolean" },
      enumSkipQuotes: { type: "boolean" },
      expandDefaultRequest: { type: "boolean" },
      expandDefaultResponse: { type: "boolean" },
      expandResponses: { type: "string" },
      expandSingleSchemaField: { type: "boolean" },
      generateCodeSamples: "GenerateCodeSamples",
      generatedPayloadSamplesMaxDepth: { type: "number" },
      hideDownloadButton: { type: "boolean" },
      hideHostname: { type: "boolean" },
      hideInfoSection: { type: "boolean" },
      hideLoading: { type: "boolean" },
      hideLogo: { type: "boolean" },
      hideRequestPayloadSample: { type: "boolean" },
      hideRightPanel: { type: "boolean" },
      hideSchemaPattern: { type: "boolean" },
      hideSchemaTitles: { type: "boolean" },
      hideSingleRequestSampleTab: { type: "boolean" },
      hideSecuritySection: { type: "boolean" },
      hideTryItPanel: { type: "boolean" },
      hideFab: { type: "boolean" },
      hideOneOfDescription: { type: "boolean" },
      htmlTemplate: { type: "string" },
      jsonSampleExpandLevel: (Pe) => typeof Pe == "number" ? { type: "number", minimum: 1 } : { type: "string" },
      labels: "ConfigLabels",
      layout: { enum: ["stacked", "three-panel"] },
      maxDisplayedEnumValues: { type: "number" },
      menuToggle: { type: "boolean" },
      nativeScrollbars: { type: "boolean" },
      noAutoAuth: { type: "boolean" },
      // deprecated
      oAuth2RedirectURI: { type: "string" },
      onDeepLinkClick: { type: "object" },
      onlyRequiredInSamples: { type: "boolean" },
      pagination: { enum: ["none", "section", "item"] },
      pathInMiddlePanel: { type: "boolean" },
      payloadSampleIdx: { type: "number", minimum: 0 },
      requestInterceptor: { type: "object" },
      requiredPropsFirst: { type: "boolean" },
      routingBasePath: { type: "string" },
      routingStrategy: { type: "string" },
      // deprecated
      samplesTabsMaxCount: { type: "number" },
      schemaExpansionLevel: (Pe) => typeof Pe == "number" ? { type: "number", minimum: 0 } : { type: "string" },
      schemaDefinitionsTagName: { type: "string" },
      minCharacterLengthToInitSearch: { type: "number", minimum: 1 },
      maxResponseHeadersToShowInTryIt: { type: "number", minimum: 0 },
      scrollYOffset: (Pe) => typeof Pe == "number" ? { type: "number" } : { type: "string" },
      searchAutoExpand: { type: "boolean" },
      searchFieldLevelBoost: { type: "number", minimum: 0 },
      searchMaxDepth: { type: "number", minimum: 1 },
      searchMode: { enum: ["default", "path-only"] },
      searchOperationTitleBoost: { type: "number" },
      searchTagTitleBoost: { type: "number" },
      sendXUserAgentInTryIt: { type: "boolean" },
      showChangeLayoutButton: { type: "boolean" },
      showConsole: { type: "boolean" },
      // deprecated
      showExtensions: (Pe) => typeof Pe == "boolean" ? { type: "boolean" } : {
        type: "array",
        items: {
          type: "string"
        }
      },
      showNextButton: { type: "boolean" },
      showRightPanelToggle: { type: "boolean" },
      showSecuritySchemeType: { type: "boolean" },
      showWebhookVerb: { type: "boolean" },
      showObjectSchemaExamples: { type: "boolean" },
      disableTryItRequestUrlEncoding: { type: "boolean" },
      sidebarLinks: "ConfigSidebarLinks",
      sideNavStyle: { enum: ["summary-only", "path-first", "id-only", "path-only"] },
      simpleOneOfTypeLabel: { type: "boolean" },
      sortEnumValuesAlphabetically: { type: "boolean" },
      sortOperationsAlphabetically: { type: "boolean" },
      sortPropsAlphabetically: { type: "boolean" },
      sortTagsAlphabetically: { type: "boolean" },
      suppressWarnings: { type: "boolean" },
      // deprecated
      unstable_externalDescription: { type: "boolean" },
      // deprecated
      unstable_ignoreMimeParameters: { type: "boolean" },
      untrustedDefinition: { type: "boolean" },
      mockServer: {
        properties: {
          url: { type: "string" },
          position: { enum: ["first", "last", "replace", "off"] },
          description: { type: "string" }
        }
      },
      showAccessMode: { type: "boolean" },
      preserveOriginalExtensionsName: { type: "boolean" },
      markdownHeadingsAnchorLevel: { type: "number" }
    },
    additionalProperties: {}
  }, Te = {
    properties: {
      strictExamples: { type: "boolean" },
      errorIfForcedExampleNotFound: { type: "boolean" }
    }
  };
  function $e(Pe, Re) {
    const Qe = Object.values(r.SpecVersion).flatMap((rt) => {
      const ut = Re != null && Re.styleguide ? Re.styleguide.extendTypes((0, r.getTypes)(rt), rt) : (0, r.getTypes)(rt);
      return Object.keys(ut);
    }), ht = (0, i.getNodeTypesFromJSONSchema)("rootRedoclyConfigSchema", Pe);
    return {
      ...Be,
      ConfigRoot: v(ht),
      // This is the REAL config root type
      ConfigApisProperties: y(ht),
      AssertionDefinitionSubject: A(Qe),
      ...ht
    };
  }
  const Be = {
    Assert: $,
    ConfigApis: S,
    ConfigStyleguide: m,
    ConfigReferenceDocs: _e,
    ConfigMockServer: Te,
    ConfigHTTP: E,
    ConfigLanguage: I,
    ConfigLabels: F,
    ConfigSidebarLinks: L,
    CommonConfigSidebarLinks: Q,
    ConfigTheme: we,
    AssertDefinition: k,
    ThemeColors: ee,
    CommonThemeColors: Y,
    BorderThemeColors: le,
    HttpColors: ue,
    ResponseColors: ce,
    SecondaryColors: be,
    TextThemeColors: G,
    Sizes: z,
    ButtonsConfig: q,
    CommonColorProps: ae,
    BadgeFontConfig: j,
    BadgeSizes: H,
    HttpBadgesConfig: B,
    LabelControls: pe,
    Panels: he,
    TryItButton: Ae,
    Breakpoints: N,
    StackedConfig: J,
    ThreePanelConfig: X,
    SchemaColorsConfig: U,
    SizeProps: K,
    Level1Items: de,
    SpacingConfig: Ce,
    FontConfig: te,
    CodeConfig: M,
    HeadingsConfig: se,
    LinksConfig: ve,
    TokenProps: Oe,
    CodeBlock: ke,
    ConfigThemeLogo: Me,
    Fab: Ve,
    ButtonOverrides: Je,
    Overrides: He,
    ObjectRule: g,
    Schema: b,
    RightPanel: Ue,
    Rules: x,
    Shape: Ot,
    ThemeSpacing: D,
    GenerateCodeSamples: Ee,
    GroupItemsConfig: ye,
    ConfigThemeComponents: C,
    Layout: oe,
    ConfigThemeSchema: V,
    Sidebar: Se,
    Heading: O,
    Typography: ge,
    AssertionDefinitionAssertions: P
  };
  return el.ConfigTypes = $e(e.rootRedoclyConfigSchema), el;
}
var ET;
function ZY() {
  if (ET) return Si;
  ET = 1, Object.defineProperty(Si, "__esModule", { value: !0 }), Si.OasVersion = void 0, Si.bundleConfig = S, Si.bundle = y, Si.bundleFromString = E, Si.bundleDocument = x, Si.mapTypeToComponent = g;
  const e = m1(), t = N9(), r = Fn(), n = j9(), i = y1(), s = lu(), o = q9(), a = B9(), l = xn(), u = U9(), f = V9(), d = W9(), m = JY();
  var v;
  (function(P) {
    P.Version2 = "oas2", P.Version3_0 = "oas3_0", P.Version3_1 = "oas3_1";
  })(v || (Si.OasVersion = v = {}));
  async function S(P, k) {
    const $ = (0, r.normalizeTypes)(m.ConfigTypes), I = {
      problems: [],
      oasVersion: i.SpecVersion.OAS3_0,
      refTypes: /* @__PURE__ */ new Map(),
      visitorsData: {}
    }, F = (0, t.normalizeVisitors)([
      {
        severity: "error",
        ruleId: "configBundler",
        visitor: {
          ref: {
            leave(L, Q, Y) {
              b(L, Y, Q);
            }
          }
        }
      }
    ], $);
    return (0, n.walkDocument)({
      document: P,
      rootType: $.ConfigRoot,
      normalizedVisitors: F,
      resolvedRefMap: k,
      ctx: I
    }), P.parsed ?? {};
  }
  async function y(P) {
    var Q;
    const { ref: k, doc: $, externalRefResolver: I = new e.BaseResolver(P.config.resolve), base: F = null } = P;
    if (!(k || $))
      throw new Error(`Document or reference is required.
`);
    const L = $ === void 0 ? await I.resolveDocument(F, k, !0) : $;
    if (L instanceof Error)
      throw L;
    return (Q = P.collectSpecData) == null || Q.call(P, L.parsed), x({
      document: L,
      ...P,
      config: P.config.styleguide,
      externalRefResolver: I
    });
  }
  async function E(P) {
    const { source: k, absoluteRef: $, externalRefResolver: I = new e.BaseResolver(P.config.resolve) } = P, F = (0, e.makeDocumentFromString)(k, $ || "/");
    return x({
      document: F,
      ...P,
      externalRefResolver: I,
      config: P.config.styleguide
    });
  }
  async function x(P) {
    const { document: k, config: $, customTypes: I, externalRefResolver: F, dereference: L = !1, skipRedoclyRegistryRefs: Q = !1, removeUnusedComponents: Y = !1, keepUrlRefs: ae = !1 } = P, le = (0, i.detectSpec)(k.parsed), ue = (0, i.getMajorSpecVersion)(le), ce = $.getRulesForSpecVersion(ue), be = (0, r.normalizeTypes)($.extendTypes(I ?? (0, i.getTypes)(le), le), $), G = (0, o.initRules)(ce, $, "preprocessors", le), ee = (0, o.initRules)(ce, $, "decorators", le), K = {
      problems: [],
      oasVersion: le,
      refTypes: /* @__PURE__ */ new Map(),
      visitorsData: {}
    };
    Y && ee.push({
      severity: "error",
      ruleId: "remove-unused-components",
      visitor: ue === i.SpecMajorVersion.OAS2 ? (0, f.RemoveUnusedComponents)({}) : (0, d.RemoveUnusedComponents)({})
    });
    let z = await (0, e.resolveDocument)({
      rootDocument: k,
      rootType: be.Root,
      externalRefResolver: F
    });
    G.length > 0 && ((0, n.walkDocument)({
      document: k,
      rootType: be.Root,
      normalizedVisitors: (0, t.normalizeVisitors)(G, be),
      resolvedRefMap: z,
      ctx: K
    }), z = await (0, e.resolveDocument)({
      rootDocument: k,
      rootType: be.Root,
      externalRefResolver: F
    }));
    const te = (0, t.normalizeVisitors)([
      {
        severity: "error",
        ruleId: "bundler",
        visitor: A(ue, L, Q, k, z, ae)
      },
      ...ee
    ], be);
    return (0, n.walkDocument)({
      document: k,
      rootType: be.Root,
      normalizedVisitors: te,
      resolvedRefMap: z,
      ctx: K
    }), {
      bundle: k,
      problems: K.problems.map((q) => $.addProblemToIgnore(q)),
      fileDependencies: F.getFiles(),
      rootType: be.Root,
      refTypes: K.refTypes,
      visitorsData: K.visitorsData
    };
  }
  function g(P, k) {
    switch (k) {
      case i.SpecMajorVersion.OAS3:
        switch (P) {
          case "Schema":
            return "schemas";
          case "Parameter":
            return "parameters";
          case "Response":
            return "responses";
          case "Example":
            return "examples";
          case "RequestBody":
            return "requestBodies";
          case "Header":
            return "headers";
          case "SecuritySchema":
            return "securitySchemes";
          case "Link":
            return "links";
          case "Callback":
            return "callbacks";
          default:
            return null;
        }
      case i.SpecMajorVersion.OAS2:
        switch (P) {
          case "Schema":
            return "definitions";
          case "Parameter":
            return "parameters";
          case "Response":
            return "responses";
          default:
            return null;
        }
      case i.SpecMajorVersion.Async2:
        switch (P) {
          case "Schema":
            return "schemas";
          case "Parameter":
            return "parameters";
          default:
            return null;
        }
      case i.SpecMajorVersion.Async3:
        switch (P) {
          case "Schema":
            return "schemas";
          case "Parameter":
            return "parameters";
          default:
            return null;
        }
      case i.SpecMajorVersion.Arazzo1:
        switch (P) {
          case "Root.workflows_items.parameters_items":
          case "Root.workflows_items.steps_items.parameters_items":
            return "parameters";
          default:
            return null;
        }
      case i.SpecMajorVersion.Overlay1:
        switch (P) {
          default:
            return null;
        }
    }
  }
  function b(P, k, $) {
    if (!(0, l.isPlainObject)(k.node))
      $.parent[$.key] = k.node;
    else {
      delete P.$ref;
      const I = Object.assign({}, k.node, P);
      Object.assign(P, I);
    }
  }
  function A(P, k, $, I, F, L) {
    let Q, Y;
    const ae = {
      ref: {
        leave(G, ee, K) {
          if (!K.location || K.node === void 0) {
            (0, a.reportUnresolvedRef)(K, ee.report, ee.location);
            return;
          }
          if (K.location.source === I.source && K.location.source === ee.location.source && ee.type.name !== "scalar" && !k || $ && (0, u.isRedoclyRegistryURL)(G.$ref) || L && (0, s.isAbsoluteUrl)(G.$ref))
            return;
          const z = g(ee.type.name, P);
          z ? k ? (ue(z, K, ee), b(G, K, ee)) : (G.$ref = ue(z, K, ee), le(G, K, ee)) : b(G, K, ee);
        }
      },
      Example: {
        leave(G, ee) {
          if ((0, s.isExternalValue)(G) && G.value === void 0) {
            const K = ee.resolve({ $ref: G.externalValue });
            if (!K.location || K.node === void 0) {
              (0, a.reportUnresolvedRef)(K, ee.report, ee.location);
              return;
            }
            if (L && (0, s.isAbsoluteUrl)(G.externalValue))
              return;
            G.value = ee.resolve({ $ref: G.externalValue }).node, delete G.externalValue;
          }
        }
      },
      Root: {
        enter(G, ee) {
          Y = ee.location, P === i.SpecMajorVersion.OAS3 ? Q = G.components = G.components || {} : P === i.SpecMajorVersion.OAS2 ? Q = G : P === i.SpecMajorVersion.Async2 ? Q = G.components = G.components || {} : P === i.SpecMajorVersion.Async3 ? Q = G.components = G.components || {} : P === i.SpecMajorVersion.Arazzo1 && (Q = G.components = G.components || {});
        }
      }
    };
    P === i.SpecMajorVersion.OAS3 && (ae.DiscriminatorMapping = {
      leave(G, ee) {
        for (const K of Object.keys(G)) {
          const z = G[K], te = ee.resolve({ $ref: z });
          if (!te.location || te.node === void 0) {
            (0, a.reportUnresolvedRef)(te, ee.report, ee.location.child(K));
            return;
          }
          const q = g("Schema", P);
          G[K] = ue(q, te, ee);
        }
      }
    });
    function le(G, ee, K) {
      const z = (0, e.makeRefId)(K.location.source.absoluteRef, G.$ref);
      F.set(z, {
        document: I,
        isRemote: !1,
        node: ee.node,
        nodePointer: G.$ref,
        resolved: !0
      });
    }
    function ue(G, ee, K) {
      Q[G] = Q[G] || {};
      const z = be(ee, G, K);
      return Q[G][z] = ee.node, P === i.SpecMajorVersion.OAS3 || P === i.SpecMajorVersion.Async2 || P === i.SpecMajorVersion.Async3 ? `#/components/${G}/${z}` : `#/${G}/${z}`;
    }
    function ce(G, ee, K) {
      var z;
      return (0, s.isRef)(G) && ((z = K.resolve(G, Y.absolutePointer).location) == null ? void 0 : z.absolutePointer) === ee.location.absolutePointer ? !0 : (0, l.dequal)(G, ee.node);
    }
    function be(G, ee, K) {
      const [z, te] = [G.location.source.absoluteRef, G.location.pointer], q = Q[ee];
      let j = "";
      const H = te.slice(2).split("/").filter(l.isTruthy);
      for (; H.length > 0; )
        if (j = H.pop() + (j ? `-${j}` : ""), !q || !q[j] || ce(q[j], G, K))
          return j;
      if (j = (0, s.refBaseName)(z) + (j ? `_${j}` : ""), !q[j] || ce(q[j], G, K))
        return j;
      const B = j;
      let pe = 2;
      for (; q[j] && !ce(q[j], G, K); )
        j = `${B}-${pe}`, pe++;
      return q[j] || K.report({
        message: `Two schemas are referenced with the same name but different content. Renamed ${B} to ${j}.`,
        location: K.location,
        forceSeverity: "warn"
      }), j;
    }
    return ae;
  }
  return Si;
}
var Lb = {}, Sr = {}, _T;
function eG() {
  if (_T) return Sr;
  _T = 1, Object.defineProperty(Sr, "__esModule", { value: !0 }), Sr.ConfigValidationError = void 0, Sr.parsePresetName = n, Sr.transformApiDefinitionsToApis = i, Sr.prefixRules = a, Sr.mergeExtends = l, Sr.getMergedConfig = u, Sr.checkForDeprecatedFields = f, Sr.transformConfig = d, Sr.getResolveConfig = v, Sr.getUniquePlugins = S, Sr.deepCloneMapWithJSON = E, Sr.isDeprecatedPluginFormat = x, Sr.isCommonJsPlugin = g;
  const e = xn(), t = zL(), r = rL();
  function n(b) {
    if (b.indexOf("/") > -1) {
      const [A, P] = b.split("/");
      return { pluginId: A, configName: P };
    } else
      return { pluginId: "", configName: b };
  }
  function i(b) {
    if (!b)
      return;
    const A = {};
    for (const [P, k] of Object.entries(b))
      A[P] = { root: k };
    return A;
  }
  function s({ plugins: b, extends: A, rules: P, oas2Rules: k, oas3_0Rules: $, oas3_1Rules: I, async2Rules: F, async3Rules: L, arazzo1Rules: Q, overlay1Rules: Y, preprocessors: ae, oas2Preprocessors: le, oas3_0Preprocessors: ue, oas3_1Preprocessors: ce, async2Preprocessors: be, async3Preprocessors: G, arazzo1Preprocessors: ee, overlay1Preprocessors: K, decorators: z, oas2Decorators: te, oas3_0Decorators: q, oas3_1Decorators: j, async2Decorators: H, async3Decorators: B, arazzo1Decorators: pe, overlay1Decorators: he, ...Ae }) {
    var N;
    const C = {
      plugins: b,
      extends: A,
      rules: P,
      oas2Rules: k,
      oas3_0Rules: $,
      oas3_1Rules: I,
      async2Rules: F,
      async3Rules: L,
      arazzo1Rules: Q,
      overlay1Rules: Y,
      preprocessors: ae,
      oas2Preprocessors: le,
      oas3_0Preprocessors: ue,
      oas3_1Preprocessors: ce,
      async2Preprocessors: be,
      async3Preprocessors: G,
      arazzo1Preprocessors: ee,
      overlay1Preprocessors: K,
      decorators: z,
      oas2Decorators: te,
      oas3_0Decorators: q,
      oas3_1Decorators: j,
      async2Decorators: H,
      async3Decorators: B,
      arazzo1Decorators: pe,
      overlay1Decorators: he,
      doNotResolveExamples: (N = Ae.resolve) == null ? void 0 : N.doNotResolveExamples
    };
    if (Ae.lint && Ae.styleguide || Object.values(C).some(e.isDefined) && (Ae.lint || Ae.styleguide))
      throw new Error(`Do not use 'lint', 'styleguide' and flat syntax together. 
See more about the configuration in the docs: https://redocly.com/docs/cli/configuration/ 
`);
    return {
      styleguideConfig: Object.values(C).some(e.isDefined) ? C : void 0,
      rawConfigRest: Ae
    };
  }
  function o(b) {
    if (!b)
      return;
    const A = {};
    for (const [P, { lint: k, ...$ }] of Object.entries(b)) {
      const { styleguideConfig: I, rawConfigRest: F } = s($);
      A[P] = {
        styleguide: I || k,
        ...F
      };
    }
    return A;
  }
  function a(b, A) {
    if (!A)
      return b;
    const P = {};
    for (const k of Object.keys(b))
      P[`${A}/${k}`] = b[k];
    return P;
  }
  function l(b) {
    const A = {
      rules: {},
      oas2Rules: {},
      oas3_0Rules: {},
      oas3_1Rules: {},
      async2Rules: {},
      async3Rules: {},
      arazzo1Rules: {},
      overlay1Rules: {},
      preprocessors: {},
      oas2Preprocessors: {},
      oas3_0Preprocessors: {},
      oas3_1Preprocessors: {},
      async2Preprocessors: {},
      async3Preprocessors: {},
      arazzo1Preprocessors: {},
      overlay1Preprocessors: {},
      decorators: {},
      oas2Decorators: {},
      oas3_0Decorators: {},
      oas3_1Decorators: {},
      async2Decorators: {},
      async3Decorators: {},
      arazzo1Decorators: {},
      overlay1Decorators: {},
      plugins: [],
      pluginPaths: [],
      extendPaths: []
    };
    for (const P of b) {
      if (P.extends)
        throw new Error(`'extends' is not supported in shared configs yet:
${JSON.stringify(P, null, 2)}`);
      (0, e.assignConfig)(A.rules, P.rules), (0, e.assignConfig)(A.oas2Rules, P.oas2Rules), (0, e.assignOnlyExistingConfig)(A.oas2Rules, P.rules), (0, e.assignConfig)(A.oas3_0Rules, P.oas3_0Rules), (0, e.assignOnlyExistingConfig)(A.oas3_0Rules, P.rules), (0, e.assignConfig)(A.oas3_1Rules, P.oas3_1Rules), (0, e.assignOnlyExistingConfig)(A.oas3_1Rules, P.rules), (0, e.assignConfig)(A.async2Rules, P.async2Rules), (0, e.assignOnlyExistingConfig)(A.async2Rules, P.rules), (0, e.assignConfig)(A.async3Rules, P.async3Rules), (0, e.assignOnlyExistingConfig)(A.async3Rules, P.rules), (0, e.assignConfig)(A.arazzo1Rules, P.arazzo1Rules), (0, e.assignOnlyExistingConfig)(A.arazzo1Rules, P.rules), (0, e.assignConfig)(A.overlay1Rules, P.overlay1Rules), (0, e.assignOnlyExistingConfig)(A.overlay1Rules, P.rules), (0, e.assignConfig)(A.preprocessors, P.preprocessors), (0, e.assignConfig)(A.oas2Preprocessors, P.oas2Preprocessors), (0, e.assignOnlyExistingConfig)(A.oas2Preprocessors, P.preprocessors), (0, e.assignConfig)(A.oas3_0Preprocessors, P.oas3_0Preprocessors), (0, e.assignOnlyExistingConfig)(A.oas3_0Preprocessors, P.preprocessors), (0, e.assignConfig)(A.oas3_1Preprocessors, P.oas3_1Preprocessors), (0, e.assignOnlyExistingConfig)(A.oas3_1Preprocessors, P.preprocessors), (0, e.assignConfig)(A.async2Preprocessors, P.async2Preprocessors), (0, e.assignOnlyExistingConfig)(A.async2Preprocessors, P.preprocessors), (0, e.assignConfig)(A.async3Preprocessors, P.async3Preprocessors), (0, e.assignOnlyExistingConfig)(A.async3Preprocessors, P.preprocessors), (0, e.assignConfig)(A.arazzo1Preprocessors, P.arazzo1Preprocessors), (0, e.assignOnlyExistingConfig)(A.arazzo1Preprocessors, P.preprocessors), (0, e.assignConfig)(A.overlay1Preprocessors, P.overlay1Preprocessors), (0, e.assignOnlyExistingConfig)(A.overlay1Preprocessors, P.preprocessors), (0, e.assignConfig)(A.decorators, P.decorators), (0, e.assignConfig)(A.oas2Decorators, P.oas2Decorators), (0, e.assignOnlyExistingConfig)(A.oas2Decorators, P.decorators), (0, e.assignConfig)(A.oas3_0Decorators, P.oas3_0Decorators), (0, e.assignOnlyExistingConfig)(A.oas3_0Decorators, P.decorators), (0, e.assignConfig)(A.oas3_1Decorators, P.oas3_1Decorators), (0, e.assignOnlyExistingConfig)(A.oas3_1Decorators, P.decorators), (0, e.assignConfig)(A.async2Decorators, P.async2Decorators), (0, e.assignOnlyExistingConfig)(A.async2Decorators, P.decorators), (0, e.assignConfig)(A.async3Decorators, P.async3Decorators), (0, e.assignOnlyExistingConfig)(A.async3Decorators, P.decorators), (0, e.assignConfig)(A.arazzo1Decorators, P.arazzo1Decorators), (0, e.assignOnlyExistingConfig)(A.arazzo1Decorators, P.decorators), (0, e.assignConfig)(A.overlay1Decorators, P.overlay1Decorators), (0, e.assignOnlyExistingConfig)(A.overlay1Decorators, P.decorators), A.plugins.push(...P.plugins || []), A.pluginPaths.push(...P.pluginPaths || []), A.extendPaths.push(...new Set(P.extendPaths));
    }
    return A;
  }
  function u(b, A) {
    var $, I, F, L, Q, Y, ae;
    const P = [
      ...Object.values(b.apis).map((le) => {
        var ue;
        return (ue = le == null ? void 0 : le.styleguide) == null ? void 0 : ue.extendPaths;
      }),
      (I = ($ = b.rawConfig) == null ? void 0 : $.styleguide) == null ? void 0 : I.extendPaths
    ].flat().filter(e.isTruthy), k = [
      ...Object.values(b.apis).map((le) => {
        var ue;
        return (ue = le == null ? void 0 : le.styleguide) == null ? void 0 : ue.pluginPaths;
      }),
      (L = (F = b.rawConfig) == null ? void 0 : F.styleguide) == null ? void 0 : L.pluginPaths
    ].flat().filter(e.isTruthy);
    return A ? new t.Config({
      ...b.rawConfig,
      styleguide: {
        ...b.apis[A] ? b.apis[A].styleguide : b.rawConfig.styleguide,
        extendPaths: P,
        pluginPaths: k
      },
      theme: {
        ...b.rawConfig.theme,
        ...(Q = b.apis[A]) == null ? void 0 : Q.theme
      },
      files: [...b.files, ...((ae = (Y = b.apis) == null ? void 0 : Y[A]) == null ? void 0 : ae.files) ?? []]
      // TODO: merge everything else here
    }, b.configFile) : b;
  }
  function f(b, A, P, k, $) {
    const I = P.apis && Object.values(P.apis).some((F) => F[b]);
    P[b] && A === null && (0, e.showWarningForDeprecatedField)(b, void 0, k, $), P[b] && A && P[A] && (0, e.showErrorForDeprecatedField)(b, A), P[b] && k && P[k] && (0, e.showErrorForDeprecatedField)(b, A, k), (P[b] || I) && (0, e.showWarningForDeprecatedField)(b, A, k, $);
  }
  function d(b) {
    var ae, le;
    const A = [
      ["apiDefinitions", "apis", void 0, void 0],
      ["referenceDocs", "openapi", "theme", void 0],
      [
        "lint",
        void 0,
        void 0,
        "https://redocly.com/docs/api-registry/guides/migration-guide-config-file/#changed-properties"
      ],
      [
        "styleguide",
        void 0,
        void 0,
        "https://redocly.com/docs/api-registry/guides/migration-guide-config-file/#changed-properties"
      ],
      ["features.openapi", "openapi", "theme", void 0]
    ];
    for (const [ue, ce, be, G] of A)
      f(ue, ce, b, be, G);
    const { apis: P, apiDefinitions: k, referenceDocs: $, lint: I, ...F } = b, { styleguideConfig: L, rawConfigRest: Q } = s(F), Y = {
      theme: {
        openapi: {
          ...$,
          ...b["features.openapi"],
          ...(ae = b.theme) == null ? void 0 : ae.openapi
        },
        mockServer: {
          ...b["features.mockServer"],
          ...(le = b.theme) == null ? void 0 : le.mockServer
        }
      },
      apis: o(P) || i(k),
      styleguide: L || I,
      ...Q
    };
    return m(Y), Y;
  }
  function m(b) {
    var P, k;
    let A = { ...(P = b.styleguide) == null ? void 0 : P.rules };
    for (const $ of Object.values(b.apis || {}))
      A = { ...A, ...(k = $ == null ? void 0 : $.styleguide) == null ? void 0 : k.rules };
    for (const $ of Object.keys(A))
      $.startsWith("assert/") && r.logger.warn(`
The 'assert/' syntax in ${$} is deprecated. Update your configuration to use 'rule/' instead. Examples and more information: https://redocly.com/docs/cli/rules/configurable-rules/
`);
  }
  function v(b) {
    var A;
    return {
      http: {
        headers: ((A = b == null ? void 0 : b.http) == null ? void 0 : A.headers) ?? [],
        customFetch: void 0
      }
    };
  }
  function S(b) {
    const A = /* @__PURE__ */ new Set(), P = [];
    for (const k of b)
      A.has(k.id) ? k.id && r.logger.warn(`Duplicate plugin id "${r.colorize.red(k.id)}".
`) : (P.push(k), A.add(k.id));
    return P;
  }
  class y extends Error {
  }
  Sr.ConfigValidationError = y;
  function E(b) {
    return new Map(JSON.parse(JSON.stringify([...b])));
  }
  function x(b) {
    return b !== void 0 && typeof b == "object" && "id" in b;
  }
  function g(b) {
    return typeof b == "function";
  }
  return Sr;
}
var OT;
function zL() {
  return OT || (OT = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Config = e.StyleguideConfig = e.IGNORE_FILE = void 0;
    const t = hp, r = f1(), n = xw(), i = xn(), s = y1(), o = h1(), a = eG(), l = lu();
    e.IGNORE_FILE = ".redocly.lint-ignore.yaml";
    const u = `# This file instructs Redocly's linter to ignore the rules contained for specific parts of your API.
# See https://redocly.com/docs/cli/ for more information.
`;
    function f(S) {
      return S ? (0, i.doesYamlFileExist)(S) ? r.join(r.dirname(S), e.IGNORE_FILE) : r.join(S, e.IGNORE_FILE) : o.isBrowser ? void 0 : r.join(process.cwd(), e.IGNORE_FILE);
    }
    class d {
      constructor(y, E) {
        this.rawConfig = y, this.configFile = E, this.ignore = {}, this._usedRules = /* @__PURE__ */ new Set(), this._usedVersions = /* @__PURE__ */ new Set(), this.plugins = y.plugins || [], this.doNotResolveExamples = !!y.doNotResolveExamples, this.recommendedFallback = y.recommendedFallback || !1, m([
          "rules",
          "oas2Rules",
          "oas3_0Rules",
          "oas3_1Rules",
          "async2Rules",
          "async3Rules",
          "arazzo1Rules",
          "overlay1Rules"
        ], y), this.rules = {
          [s.SpecVersion.OAS2]: { ...y.rules, ...y.oas2Rules },
          [s.SpecVersion.OAS3_0]: { ...y.rules, ...y.oas3_0Rules },
          [s.SpecVersion.OAS3_1]: { ...y.rules, ...y.oas3_1Rules },
          [s.SpecVersion.Async2]: { ...y.rules, ...y.async2Rules },
          [s.SpecVersion.Async3]: { ...y.rules, ...y.async3Rules },
          [s.SpecVersion.Arazzo1]: { ...y.rules, ...y.arazzo1Rules },
          [s.SpecVersion.Overlay1]: { ...y.rules, ...y.overlay1Rules }
        }, this.preprocessors = {
          [s.SpecVersion.OAS2]: { ...y.preprocessors, ...y.oas2Preprocessors },
          [s.SpecVersion.OAS3_0]: { ...y.preprocessors, ...y.oas3_0Preprocessors },
          [s.SpecVersion.OAS3_1]: { ...y.preprocessors, ...y.oas3_1Preprocessors },
          [s.SpecVersion.Async2]: { ...y.preprocessors, ...y.async2Preprocessors },
          [s.SpecVersion.Async3]: { ...y.preprocessors, ...y.async3Preprocessors },
          [s.SpecVersion.Arazzo1]: { ...y.arazzo1Preprocessors },
          [s.SpecVersion.Overlay1]: { ...y.preprocessors, ...y.overlay1Preprocessors }
        }, this.decorators = {
          [s.SpecVersion.OAS2]: { ...y.decorators, ...y.oas2Decorators },
          [s.SpecVersion.OAS3_0]: { ...y.decorators, ...y.oas3_0Decorators },
          [s.SpecVersion.OAS3_1]: { ...y.decorators, ...y.oas3_1Decorators },
          [s.SpecVersion.Async2]: { ...y.decorators, ...y.async2Decorators },
          [s.SpecVersion.Async3]: { ...y.decorators, ...y.async3Decorators },
          [s.SpecVersion.Arazzo1]: { ...y.arazzo1Decorators },
          [s.SpecVersion.Overlay1]: { ...y.decorators, ...y.overlay1Decorators }
        }, this.extendPaths = y.extendPaths || [], this.pluginPaths = y.pluginPaths || [], this.resolveIgnore(f(E));
      }
      resolveIgnore(y) {
        if (!(!y || !(0, i.doesYamlFileExist)(y))) {
          this.ignore = (0, n.parseYaml)(t.readFileSync(y, "utf-8")) || {}, m(Object.keys(this.ignore), this.ignore);
          for (const E of Object.keys(this.ignore)) {
            this.ignore[(0, l.isAbsoluteUrl)(E) ? E : r.resolve(r.dirname(y), E)] = this.ignore[E];
            for (const x of Object.keys(this.ignore[E]))
              this.ignore[E][x] = new Set(this.ignore[E][x]);
            (0, l.isAbsoluteUrl)(E) || delete this.ignore[E];
          }
        }
      }
      saveIgnore() {
        const y = this.configFile ? r.dirname(this.configFile) : process.cwd(), E = r.join(y, e.IGNORE_FILE), x = {};
        for (const g of Object.keys(this.ignore)) {
          const b = (0, l.isAbsoluteUrl)(g) ? g : (0, i.slash)(r.relative(y, g)), A = x[b] = this.ignore[g];
          for (const P of Object.keys(A))
            A[P] = Array.from(A[P]);
        }
        t.writeFileSync(E, u + (0, n.stringifyYaml)(x));
      }
      addIgnore(y) {
        const E = this.ignore, x = y.location[0];
        if (x.pointer === void 0)
          return;
        const g = E[x.source.absoluteRef] = E[x.source.absoluteRef] || {};
        (g[y.ruleId] = g[y.ruleId] || /* @__PURE__ */ new Set()).add(x.pointer);
      }
      addProblemToIgnore(y) {
        const E = y.location[0];
        if (E.pointer === void 0)
          return y;
        const g = (this.ignore[E.source.absoluteRef] || {})[y.ruleId], b = g && g.has(E.pointer);
        return b ? {
          ...y,
          ignored: b
        } : y;
      }
      extendTypes(y, E) {
        let x = y;
        for (const g of this.plugins)
          if (g.typeExtension !== void 0)
            switch (E) {
              case s.SpecVersion.OAS3_0:
              case s.SpecVersion.OAS3_1:
                if (!g.typeExtension.oas3)
                  continue;
                x = g.typeExtension.oas3(x, E);
                break;
              case s.SpecVersion.OAS2:
                if (!g.typeExtension.oas2)
                  continue;
                x = g.typeExtension.oas2(x, E);
                break;
              case s.SpecVersion.Async2:
                if (!g.typeExtension.async2)
                  continue;
                x = g.typeExtension.async2(x, E);
                break;
              case s.SpecVersion.Async3:
                if (!g.typeExtension.async3)
                  continue;
                x = g.typeExtension.async3(x, E);
                break;
              case s.SpecVersion.Arazzo1:
                if (!g.typeExtension.arazzo1)
                  continue;
                x = g.typeExtension.arazzo1(x, E);
                break;
              case s.SpecVersion.Overlay1:
                if (!g.typeExtension.overlay1)
                  continue;
                x = g.typeExtension.overlay1(x, E);
                break;
              default:
                throw new Error("Not implemented");
            }
        return x;
      }
      getRuleSettings(y, E) {
        this._usedRules.add(y), this._usedVersions.add(E);
        const x = this.rules[E][y] || "off";
        return typeof x == "string" ? {
          severity: x
        } : { severity: "error", ...x };
      }
      getPreprocessorSettings(y, E) {
        this._usedRules.add(y), this._usedVersions.add(E);
        const x = this.preprocessors[E][y] || "off";
        return typeof x == "string" ? {
          severity: x === "on" ? "error" : x
        } : { severity: "error", ...x };
      }
      getDecoratorSettings(y, E) {
        this._usedRules.add(y), this._usedVersions.add(E);
        const x = this.decorators[E][y] || "off";
        return typeof x == "string" ? {
          severity: x === "on" ? "error" : x
        } : { severity: "error", ...x };
      }
      getUnusedRules() {
        const y = [], E = [], x = [];
        for (const g of Array.from(this._usedVersions))
          y.push(...Object.keys(this.rules[g]).filter((b) => !this._usedRules.has(b))), E.push(...Object.keys(this.decorators[g]).filter((b) => !this._usedRules.has(b))), x.push(...Object.keys(this.preprocessors[g]).filter((b) => !this._usedRules.has(b)));
        return {
          rules: y,
          preprocessors: x,
          decorators: E
        };
      }
      getRulesForSpecVersion(y) {
        switch (y) {
          case s.SpecMajorVersion.OAS3:
            const E = [];
            return this.plugins.forEach((k) => {
              var $;
              return (($ = k.preprocessors) == null ? void 0 : $.oas3) && E.push(k.preprocessors.oas3);
            }), this.plugins.forEach((k) => {
              var $;
              return (($ = k.rules) == null ? void 0 : $.oas3) && E.push(k.rules.oas3);
            }), this.plugins.forEach((k) => {
              var $;
              return (($ = k.decorators) == null ? void 0 : $.oas3) && E.push(k.decorators.oas3);
            }), E;
          case s.SpecMajorVersion.OAS2:
            const x = [];
            return this.plugins.forEach((k) => {
              var $;
              return (($ = k.preprocessors) == null ? void 0 : $.oas2) && x.push(k.preprocessors.oas2);
            }), this.plugins.forEach((k) => {
              var $;
              return (($ = k.rules) == null ? void 0 : $.oas2) && x.push(k.rules.oas2);
            }), this.plugins.forEach((k) => {
              var $;
              return (($ = k.decorators) == null ? void 0 : $.oas2) && x.push(k.decorators.oas2);
            }), x;
          case s.SpecMajorVersion.Async2:
            const g = [];
            return this.plugins.forEach((k) => {
              var $;
              return (($ = k.preprocessors) == null ? void 0 : $.async2) && g.push(k.preprocessors.async2);
            }), this.plugins.forEach((k) => {
              var $;
              return (($ = k.rules) == null ? void 0 : $.async2) && g.push(k.rules.async2);
            }), this.plugins.forEach((k) => {
              var $;
              return (($ = k.decorators) == null ? void 0 : $.async2) && g.push(k.decorators.async2);
            }), g;
          case s.SpecMajorVersion.Async3:
            const b = [];
            return this.plugins.forEach((k) => {
              var $;
              return (($ = k.preprocessors) == null ? void 0 : $.async3) && b.push(k.preprocessors.async3);
            }), this.plugins.forEach((k) => {
              var $;
              return (($ = k.rules) == null ? void 0 : $.async3) && b.push(k.rules.async3);
            }), this.plugins.forEach((k) => {
              var $;
              return (($ = k.decorators) == null ? void 0 : $.async3) && b.push(k.decorators.async3);
            }), b;
          case s.SpecMajorVersion.Arazzo1:
            const A = [];
            return this.plugins.forEach((k) => {
              var $;
              return (($ = k.preprocessors) == null ? void 0 : $.arazzo1) && A.push(k.preprocessors.arazzo1);
            }), this.plugins.forEach((k) => {
              var $;
              return (($ = k.rules) == null ? void 0 : $.arazzo1) && A.push(k.rules.arazzo1);
            }), this.plugins.forEach((k) => {
              var $;
              return (($ = k.decorators) == null ? void 0 : $.arazzo1) && A.push(k.decorators.arazzo1);
            }), A;
          case s.SpecMajorVersion.Overlay1:
            const P = [];
            return this.plugins.forEach((k) => {
              var $;
              return (($ = k.preprocessors) == null ? void 0 : $.overlay1) && P.push(k.preprocessors.overlay1);
            }), this.plugins.forEach((k) => {
              var $;
              return (($ = k.rules) == null ? void 0 : $.overlay1) && P.push(k.rules.overlay1);
            }), this.plugins.forEach((k) => {
              var $;
              return (($ = k.decorators) == null ? void 0 : $.overlay1) && P.push(k.decorators.overlay1);
            }), P;
        }
      }
      skipRules(y) {
        for (const E of y || [])
          for (const x of Object.values(s.SpecVersion))
            if (this.rules[x][E])
              this.rules[x][E] = "off";
            else if (Array.isArray(this.rules[x].assertions))
              for (const g of this.rules[x].assertions)
                g.assertionId === E && (g.severity = "off");
      }
      skipPreprocessors(y) {
        for (const E of y || [])
          for (const x of Object.values(s.SpecVersion))
            this.preprocessors[x][E] && (this.preprocessors[x][E] = "off");
      }
      skipDecorators(y) {
        for (const E of y || [])
          for (const x of Object.values(s.SpecVersion))
            this.decorators[x][E] && (this.decorators[x][E] = "off");
      }
    }
    e.StyleguideConfig = d;
    function m(S, y) {
      for (const E of S)
        y[E] && (0, i.isPlainObject)(y[E]) && "spec" in y[E] && ((0, i.showWarningForDeprecatedField)("spec", "struct"), y[E].struct = y[E].spec, delete y[E].spec);
    }
    class v {
      constructor(y, E) {
        this.rawConfig = y, this.configFile = E, this.apis = y.apis || {}, this.styleguide = new d(y.styleguide || {}, E), this.theme = y.theme || {}, this.resolve = (0, a.getResolveConfig)(y == null ? void 0 : y.resolve), this.region = y.region, this.organization = y.organization, this.files = y.files || [], this.telemetry = y.telemetry;
      }
    }
    e.Config = v;
  }(Lb)), Lb;
}
var Mb = {}, kT;
function tG() {
  return kT || (kT = 1, function(e) {
    (function(t, r) {
      r(e);
    })(ft, function(t) {
      t.__esModule = !0;
      var r = {}, n = Object.prototype.hasOwnProperty, i = { memoize: function(d) {
        var m = arguments.length <= 1 || arguments[1] === void 0 ? r : arguments[1], v = m.cache || {};
        return function() {
          for (var S = arguments.length, y = Array(S), E = 0; E < S; E++)
            y[E] = arguments[E];
          var x = String(y[0]);
          return m.caseSensitive === !1 && (x = x.toLowerCase()), n.call(v, x) ? v[x] : v[x] = d.apply(this, y);
        };
      }, debounce: function(d, m) {
        if (typeof m == "function") {
          var v = d;
          d = m, m = v;
        }
        var S = m && m.delay || m || 0, y = void 0, E = void 0, x = void 0;
        return function() {
          for (var g = arguments.length, b = Array(g), A = 0; A < g; A++)
            b[A] = arguments[A];
          y = b, E = this, x || (x = setTimeout(function() {
            d.apply(E, y), y = E = x = null;
          }, S));
        };
      }, bind: function(d, m, v) {
        var S = v.value;
        return { configurable: !0, get: function() {
          var E = S.bind(this);
          return Object.defineProperty(this, m, { value: E, configurable: !0, writable: !0 }), E;
        } };
      } }, s = l(i.memoize), o = l(i.debounce), a = l(function(f, d) {
        return f.bind(d);
      }, function() {
        return i.bind;
      });
      t.memoize = s, t.debounce = o, t.bind = a, t.default = { memoize: s, debounce: o, bind: a };
      function l(f, d) {
        d = d || f.decorate || u(f);
        var m = d();
        return function() {
          for (var v = arguments.length, S = Array(v), y = 0; y < v; y++)
            S[y] = arguments[y];
          var E = S.length;
          return (E < 2 ? d : E > 2 ? m : f).apply(void 0, S);
        };
      }
      function u(f) {
        return function(d) {
          return typeof d == "function" ? f(d) : function(m, v, S) {
            S.value = f(S.value, d, m, v, S);
          };
        };
      }
    });
  }(Mb)), Mb;
}
var Db = { exports: {} }, AT;
function rG() {
  return AT || (AT = 1, function(e) {
    var t = Object.prototype.hasOwnProperty, r = "~";
    function n() {
    }
    Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (r = !1));
    function i(l, u, f) {
      this.fn = l, this.context = u, this.once = f || !1;
    }
    function s(l, u, f, d, m) {
      if (typeof f != "function")
        throw new TypeError("The listener must be a function");
      var v = new i(f, d || l, m), S = r ? r + u : u;
      return l._events[S] ? l._events[S].fn ? l._events[S] = [l._events[S], v] : l._events[S].push(v) : (l._events[S] = v, l._eventsCount++), l;
    }
    function o(l, u) {
      --l._eventsCount === 0 ? l._events = new n() : delete l._events[u];
    }
    function a() {
      this._events = new n(), this._eventsCount = 0;
    }
    a.prototype.eventNames = function() {
      var u = [], f, d;
      if (this._eventsCount === 0) return u;
      for (d in f = this._events)
        t.call(f, d) && u.push(r ? d.slice(1) : d);
      return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(f)) : u;
    }, a.prototype.listeners = function(u) {
      var f = r ? r + u : u, d = this._events[f];
      if (!d) return [];
      if (d.fn) return [d.fn];
      for (var m = 0, v = d.length, S = new Array(v); m < v; m++)
        S[m] = d[m].fn;
      return S;
    }, a.prototype.listenerCount = function(u) {
      var f = r ? r + u : u, d = this._events[f];
      return d ? d.fn ? 1 : d.length : 0;
    }, a.prototype.emit = function(u, f, d, m, v, S) {
      var y = r ? r + u : u;
      if (!this._events[y]) return !1;
      var E = this._events[y], x = arguments.length, g, b;
      if (E.fn) {
        switch (E.once && this.removeListener(u, E.fn, void 0, !0), x) {
          case 1:
            return E.fn.call(E.context), !0;
          case 2:
            return E.fn.call(E.context, f), !0;
          case 3:
            return E.fn.call(E.context, f, d), !0;
          case 4:
            return E.fn.call(E.context, f, d, m), !0;
          case 5:
            return E.fn.call(E.context, f, d, m, v), !0;
          case 6:
            return E.fn.call(E.context, f, d, m, v, S), !0;
        }
        for (b = 1, g = new Array(x - 1); b < x; b++)
          g[b - 1] = arguments[b];
        E.fn.apply(E.context, g);
      } else {
        var A = E.length, P;
        for (b = 0; b < A; b++)
          switch (E[b].once && this.removeListener(u, E[b].fn, void 0, !0), x) {
            case 1:
              E[b].fn.call(E[b].context);
              break;
            case 2:
              E[b].fn.call(E[b].context, f);
              break;
            case 3:
              E[b].fn.call(E[b].context, f, d);
              break;
            case 4:
              E[b].fn.call(E[b].context, f, d, m);
              break;
            default:
              if (!g) for (P = 1, g = new Array(x - 1); P < x; P++)
                g[P - 1] = arguments[P];
              E[b].fn.apply(E[b].context, g);
          }
      }
      return !0;
    }, a.prototype.on = function(u, f, d) {
      return s(this, u, f, d, !1);
    }, a.prototype.once = function(u, f, d) {
      return s(this, u, f, d, !0);
    }, a.prototype.removeListener = function(u, f, d, m) {
      var v = r ? r + u : u;
      if (!this._events[v]) return this;
      if (!f)
        return o(this, v), this;
      var S = this._events[v];
      if (S.fn)
        S.fn === f && (!m || S.once) && (!d || S.context === d) && o(this, v);
      else {
        for (var y = 0, E = [], x = S.length; y < x; y++)
          (S[y].fn !== f || m && !S[y].once || d && S[y].context !== d) && E.push(S[y]);
        E.length ? this._events[v] = E.length === 1 ? E[0] : E : o(this, v);
      }
      return this;
    }, a.prototype.removeAllListeners = function(u) {
      var f;
      return u ? (f = r ? r + u : u, this._events[f] && o(this, f)) : (this._events = new n(), this._eventsCount = 0), this;
    }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = r, a.EventEmitter = a, e.exports = a;
  }(Db)), Db.exports;
}
var Fb, PT;
function nG() {
  if (PT) return Fb;
  PT = 1;
  var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString;
  return Fb = function(n, i, s) {
    if (t.call(i) !== "[object Function]")
      throw new TypeError("iterator must be a function");
    var o = n.length;
    if (o === +o)
      for (var a = 0; a < o; a++)
        i.call(s, n[a], a, n);
    else
      for (var l in n)
        e.call(n, l) && i.call(s, n[l], l, n);
  }, Fb;
}
var zb, TT;
function qL() {
  if (TT) return zb;
  TT = 1;
  var e = nG();
  zb = t;
  function t(r, n, i) {
    if (arguments.length === 3)
      return t.set(r, n, i);
    if (arguments.length === 2)
      return t.get(r, n);
    var s = t.bind(t, r);
    for (var o in t)
      t.hasOwnProperty(o) && (s[o] = t[o].bind(s, r));
    return s;
  }
  return t.get = function(n, i) {
    for (var s = Array.isArray(i) ? i : t.parse(i), o = 0; o < s.length; ++o) {
      var a = s[o];
      if (!(typeof n == "object" && a in n))
        throw new Error("Invalid reference token: " + a);
      n = n[a];
    }
    return n;
  }, t.set = function(n, i, s) {
    var o = Array.isArray(i) ? i : t.parse(i), a = o[0];
    if (o.length === 0)
      throw Error("Can not set the root object");
    for (var l = 0; l < o.length - 1; ++l) {
      var u = o[l];
      typeof u != "string" && typeof u != "number" && (u = String(u)), !(u === "__proto__" || u === "constructor" || u === "prototype") && (u === "-" && Array.isArray(n) && (u = n.length), a = o[l + 1], u in n || (a.match(/^(\d+|-)$/) ? n[u] = [] : n[u] = {}), n = n[u]);
    }
    return a === "-" && Array.isArray(n) && (a = n.length), n[a] = s, this;
  }, t.remove = function(r, n) {
    var i = Array.isArray(n) ? n : t.parse(n), s = i[i.length - 1];
    if (s === void 0)
      throw new Error('Invalid JSON pointer for remove: "' + n + '"');
    var o = t.get(r, i.slice(0, -1));
    if (Array.isArray(o)) {
      var a = +s;
      if (s === "" && isNaN(a))
        throw new Error('Invalid array index: "' + s + '"');
      Array.prototype.splice.call(o, a, 1);
    } else
      delete o[s];
  }, t.dict = function(n, i) {
    var s = {};
    return t.walk(n, function(o, a) {
      s[a] = o;
    }, i), s;
  }, t.walk = function(n, i, s) {
    var o = [];
    s = s || function(a) {
      var l = Object.prototype.toString.call(a);
      return l === "[object Object]" || l === "[object Array]";
    }, function a(l) {
      e(l, function(u, f) {
        o.push(String(f)), s(u) ? a(u) : i(u, t.compile(o)), o.pop();
      });
    }(n);
  }, t.has = function(n, i) {
    try {
      t.get(n, i);
    } catch {
      return !1;
    }
    return !0;
  }, t.escape = function(n) {
    return n.toString().replace(/~/g, "~0").replace(/\//g, "~1");
  }, t.unescape = function(n) {
    return n.replace(/~1/g, "/").replace(/~0/g, "~");
  }, t.parse = function(n) {
    if (n === "")
      return [];
    if (n.charAt(0) !== "/")
      throw new Error("Invalid JSON pointer: " + n);
    return n.substring(1).split(/\//).map(t.unescape);
  }, t.compile = function(n) {
    return n.length === 0 ? "" : "/" + n.map(t.escape).join("/");
  }, zb;
}
var qb = { exports: {} }, CT;
function iG() {
  return CT || (CT = 1, function(e, t) {
    (function(r, n) {
      e.exports = n();
    })(ft, function() {
      function r() {
      }
      return r.prototype.encodeReserved = function(n) {
        return n.split(/(%[0-9A-Fa-f]{2})/g).map(function(i) {
          return /%[0-9A-Fa-f]/.test(i) || (i = encodeURI(i).replace(/%5B/g, "[").replace(/%5D/g, "]")), i;
        }).join("");
      }, r.prototype.encodeUnreserved = function(n) {
        return encodeURIComponent(n).replace(/[!'()*]/g, function(i) {
          return "%" + i.charCodeAt(0).toString(16).toUpperCase();
        });
      }, r.prototype.encodeValue = function(n, i, s) {
        return i = n === "+" || n === "#" ? this.encodeReserved(i) : this.encodeUnreserved(i), s ? this.encodeUnreserved(s) + "=" + i : i;
      }, r.prototype.isDefined = function(n) {
        return n != null;
      }, r.prototype.isKeyOperator = function(n) {
        return n === ";" || n === "&" || n === "?";
      }, r.prototype.getValues = function(n, i, s, o) {
        var a = n[s], l = [];
        if (this.isDefined(a) && a !== "")
          if (typeof a == "string" || typeof a == "number" || typeof a == "boolean")
            a = a.toString(), o && o !== "*" && (a = a.substring(0, parseInt(o, 10))), l.push(this.encodeValue(i, a, this.isKeyOperator(i) ? s : null));
          else if (o === "*")
            Array.isArray(a) ? a.filter(this.isDefined).forEach(function(f) {
              l.push(this.encodeValue(i, f, this.isKeyOperator(i) ? s : null));
            }, this) : Object.keys(a).forEach(function(f) {
              this.isDefined(a[f]) && l.push(this.encodeValue(i, a[f], f));
            }, this);
          else {
            var u = [];
            Array.isArray(a) ? a.filter(this.isDefined).forEach(function(f) {
              u.push(this.encodeValue(i, f));
            }, this) : Object.keys(a).forEach(function(f) {
              this.isDefined(a[f]) && (u.push(this.encodeUnreserved(f)), u.push(this.encodeValue(i, a[f].toString())));
            }, this), this.isKeyOperator(i) ? l.push(this.encodeUnreserved(s) + "=" + u.join(",")) : u.length !== 0 && l.push(u.join(","));
          }
        else
          i === ";" ? this.isDefined(a) && l.push(this.encodeUnreserved(s)) : a === "" && (i === "&" || i === "?") ? l.push(this.encodeUnreserved(s) + "=") : a === "" && l.push("");
        return l;
      }, r.prototype.parse = function(n) {
        var i = this, s = ["+", "#", ".", "/", ";", "?", "&"];
        return {
          expand: function(o) {
            return n.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(a, l, u) {
              if (l) {
                var f = null, d = [];
                if (s.indexOf(l.charAt(0)) !== -1 && (f = l.charAt(0), l = l.substr(1)), l.split(/,/g).forEach(function(v) {
                  var S = /([^:\*]*)(?::(\d+)|(\*))?/.exec(v);
                  d.push.apply(d, i.getValues(o, f, S[1], S[2] || S[3]));
                }), f && f !== "+") {
                  var m = ",";
                  return f === "?" ? m = "&" : f !== "#" && (m = f), (d.length !== 0 ? f : "") + d.join(m);
                } else
                  return d.join(",");
              } else
                return i.encodeReserved(u);
            });
          }
        };
      }, new r();
    });
  }(qb)), qb.exports;
}
var Bb = { exports: {} }, $T;
function oG() {
  return $T || ($T = 1, function(e) {
    var t = typeof window < "u" ? window : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? self : {};
    /**
     * Prism: Lightweight, robust, elegant syntax highlighting
     *
     * @license MIT <https://opensource.org/licenses/MIT>
     * @author Lea Verou <https://lea.verou.me>
     * @namespace
     * @public
     */
    var r = function(n) {
      var i = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, s = 0, o = {}, a = {
        /**
         * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
         * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
         * additional languages or plugins yourself.
         *
         * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
         *
         * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.manual = true;
         * // add a new <script> to load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        manual: n.Prism && n.Prism.manual,
        /**
         * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
         * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
         * own worker, you don't want it to do this.
         *
         * By setting this value to `true`, Prism will not add its own listeners to the worker.
         *
         * You obviously have to change this value before Prism executes. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.disableWorkerMessageHandler = true;
         * // Load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        disableWorkerMessageHandler: n.Prism && n.Prism.disableWorkerMessageHandler,
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function g(b) {
            return b instanceof l ? new l(b.type, g(b.content), b.alias) : Array.isArray(b) ? b.map(g) : b.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(g) {
            return Object.prototype.toString.call(g).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(g) {
            return g.__id || Object.defineProperty(g, "__id", { value: ++s }), g.__id;
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function g(b, A) {
            A = A || {};
            var P, k;
            switch (a.util.type(b)) {
              case "Object":
                if (k = a.util.objId(b), A[k])
                  return A[k];
                P = /** @type {Record<string, any>} */
                {}, A[k] = P;
                for (var $ in b)
                  b.hasOwnProperty($) && (P[$] = g(b[$], A));
                return (
                  /** @type {any} */
                  P
                );
              case "Array":
                return k = a.util.objId(b), A[k] ? A[k] : (P = [], A[k] = P, /** @type {Array} */
                /** @type {any} */
                b.forEach(function(I, F) {
                  P[F] = g(I, A);
                }), /** @type {any} */
                P);
              default:
                return b;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(g) {
            for (; g; ) {
              var b = i.exec(g.className);
              if (b)
                return b[1].toLowerCase();
              g = g.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(g, b) {
            g.className = g.className.replace(RegExp(i, "gi"), ""), g.classList.add("language-" + b);
          },
          /**
           * Returns the script element that is currently executing.
           *
           * This does __not__ work for line script element.
           *
           * @returns {HTMLScriptElement | null}
           */
          currentScript: function() {
            if (typeof document > "u")
              return null;
            if ("currentScript" in document)
              return (
                /** @type {any} */
                document.currentScript
              );
            try {
              throw new Error();
            } catch (P) {
              var g = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(P.stack) || [])[1];
              if (g) {
                var b = document.getElementsByTagName("script");
                for (var A in b)
                  if (b[A].src == g)
                    return b[A];
              }
              return null;
            }
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(g, b, A) {
            for (var P = "no-" + b; g; ) {
              var k = g.classList;
              if (k.contains(b))
                return !0;
              if (k.contains(P))
                return !1;
              g = g.parentElement;
            }
            return !!A;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: o,
          plaintext: o,
          text: o,
          txt: o,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(g, b) {
            var A = a.util.clone(a.languages[g]);
            for (var P in b)
              A[P] = b[P];
            return A;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(g, b, A, P) {
            P = P || /** @type {any} */
            a.languages;
            var k = P[g], $ = {};
            for (var I in k)
              if (k.hasOwnProperty(I)) {
                if (I == b)
                  for (var F in A)
                    A.hasOwnProperty(F) && ($[F] = A[F]);
                A.hasOwnProperty(I) || ($[I] = k[I]);
              }
            var L = P[g];
            return P[g] = $, a.languages.DFS(a.languages, function(Q, Y) {
              Y === L && Q != g && (this[Q] = $);
            }), $;
          },
          // Traverse a language definition with Depth First Search
          DFS: function g(b, A, P, k) {
            k = k || {};
            var $ = a.util.objId;
            for (var I in b)
              if (b.hasOwnProperty(I)) {
                A.call(b, I, b[I], P || I);
                var F = b[I], L = a.util.type(F);
                L === "Object" && !k[$(F)] ? (k[$(F)] = !0, g(F, A, null, k)) : L === "Array" && !k[$(F)] && (k[$(F)] = !0, g(F, A, I, k));
              }
          }
        },
        plugins: {},
        /**
         * This is the most high-level function in Prisms API.
         * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
         * each one of them.
         *
         * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
         *
         * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
         * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
         * @memberof Prism
         * @public
         */
        highlightAll: function(g, b) {
          a.highlightAllUnder(document, g, b);
        },
        /**
         * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
         * {@link Prism.highlightElement} on each one of them.
         *
         * The following hooks will be run:
         * 1. `before-highlightall`
         * 2. `before-all-elements-highlight`
         * 3. All hooks of {@link Prism.highlightElement} for each element.
         *
         * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
         * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
         * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
         * @memberof Prism
         * @public
         */
        highlightAllUnder: function(g, b, A) {
          var P = {
            callback: A,
            container: g,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          a.hooks.run("before-highlightall", P), P.elements = Array.prototype.slice.apply(P.container.querySelectorAll(P.selector)), a.hooks.run("before-all-elements-highlight", P);
          for (var k = 0, $; $ = P.elements[k++]; )
            a.highlightElement($, b === !0, P.callback);
        },
        /**
         * Highlights the code inside a single element.
         *
         * The following hooks will be run:
         * 1. `before-sanity-check`
         * 2. `before-highlight`
         * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
         * 4. `before-insert`
         * 5. `after-highlight`
         * 6. `complete`
         *
         * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
         * the element's language.
         *
         * @param {Element} element The element containing the code.
         * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
         * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
         * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
         * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
         *
         * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
         * asynchronous highlighting to work. You can build your own bundle on the
         * [Download page](https://prismjs.com/download.html).
         * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
         * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
         * @memberof Prism
         * @public
         */
        highlightElement: function(g, b, A) {
          var P = a.util.getLanguage(g), k = a.languages[P];
          a.util.setLanguage(g, P);
          var $ = g.parentElement;
          $ && $.nodeName.toLowerCase() === "pre" && a.util.setLanguage($, P);
          var I = g.textContent, F = {
            element: g,
            language: P,
            grammar: k,
            code: I
          };
          function L(Y) {
            F.highlightedCode = Y, a.hooks.run("before-insert", F), F.element.innerHTML = F.highlightedCode, a.hooks.run("after-highlight", F), a.hooks.run("complete", F), A && A.call(F.element);
          }
          if (a.hooks.run("before-sanity-check", F), $ = F.element.parentElement, $ && $.nodeName.toLowerCase() === "pre" && !$.hasAttribute("tabindex") && $.setAttribute("tabindex", "0"), !F.code) {
            a.hooks.run("complete", F), A && A.call(F.element);
            return;
          }
          if (a.hooks.run("before-highlight", F), !F.grammar) {
            L(a.util.encode(F.code));
            return;
          }
          if (b && n.Worker) {
            var Q = new Worker(a.filename);
            Q.onmessage = function(Y) {
              L(Y.data);
            }, Q.postMessage(JSON.stringify({
              language: F.language,
              code: F.code,
              immediateClose: !0
            }));
          } else
            L(a.highlight(F.code, F.grammar, F.language));
        },
        /**
         * Low-level function, only use if you know what youre doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(g, b, A) {
          var P = {
            code: g,
            grammar: b,
            language: A
          };
          if (a.hooks.run("before-tokenize", P), !P.grammar)
            throw new Error('The language "' + P.language + '" has no grammar.');
          return P.tokens = a.tokenize(P.code, P.grammar), a.hooks.run("after-tokenize", P), l.stringify(a.util.encode(P.tokens), P.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(g, b) {
          var A = b.rest;
          if (A) {
            for (var P in A)
              b[P] = A[P];
            delete b.rest;
          }
          var k = new d();
          return m(k, k.head, g), f(g, k, b, k.head, 0), S(k);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(g, b) {
            var A = a.hooks.all;
            A[g] = A[g] || [], A[g].push(b);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(g, b) {
            var A = a.hooks.all[g];
            if (!(!A || !A.length))
              for (var P = 0, k; k = A[P++]; )
                k(b);
          }
        },
        Token: l
      };
      n.Prism = a;
      function l(g, b, A, P) {
        this.type = g, this.content = b, this.alias = A, this.length = (P || "").length | 0;
      }
      l.stringify = function g(b, A) {
        if (typeof b == "string")
          return b;
        if (Array.isArray(b)) {
          var P = "";
          return b.forEach(function(L) {
            P += g(L, A);
          }), P;
        }
        var k = {
          type: b.type,
          content: g(b.content, A),
          tag: "span",
          classes: ["token", b.type],
          attributes: {},
          language: A
        }, $ = b.alias;
        $ && (Array.isArray($) ? Array.prototype.push.apply(k.classes, $) : k.classes.push($)), a.hooks.run("wrap", k);
        var I = "";
        for (var F in k.attributes)
          I += " " + F + '="' + (k.attributes[F] || "").replace(/"/g, "&quot;") + '"';
        return "<" + k.tag + ' class="' + k.classes.join(" ") + '"' + I + ">" + k.content + "</" + k.tag + ">";
      };
      function u(g, b, A, P) {
        g.lastIndex = b;
        var k = g.exec(A);
        if (k && P && k[1]) {
          var $ = k[1].length;
          k.index += $, k[0] = k[0].slice($);
        }
        return k;
      }
      function f(g, b, A, P, k, $) {
        for (var I in A)
          if (!(!A.hasOwnProperty(I) || !A[I])) {
            var F = A[I];
            F = Array.isArray(F) ? F : [F];
            for (var L = 0; L < F.length; ++L) {
              if ($ && $.cause == I + "," + L)
                return;
              var Q = F[L], Y = Q.inside, ae = !!Q.lookbehind, le = !!Q.greedy, ue = Q.alias;
              if (le && !Q.pattern.global) {
                var ce = Q.pattern.toString().match(/[imsuy]*$/)[0];
                Q.pattern = RegExp(Q.pattern.source, ce + "g");
              }
              for (var be = Q.pattern || Q, G = P.next, ee = k; G !== b.tail && !($ && ee >= $.reach); ee += G.value.length, G = G.next) {
                var K = G.value;
                if (b.length > g.length)
                  return;
                if (!(K instanceof l)) {
                  var z = 1, te;
                  if (le) {
                    if (te = u(be, ee, g, ae), !te || te.index >= g.length)
                      break;
                    var B = te.index, q = te.index + te[0].length, j = ee;
                    for (j += G.value.length; B >= j; )
                      G = G.next, j += G.value.length;
                    if (j -= G.value.length, ee = j, G.value instanceof l)
                      continue;
                    for (var H = G; H !== b.tail && (j < q || typeof H.value == "string"); H = H.next)
                      z++, j += H.value.length;
                    z--, K = g.slice(ee, j), te.index -= ee;
                  } else if (te = u(be, 0, K, ae), !te)
                    continue;
                  var B = te.index, pe = te[0], he = K.slice(0, B), Ae = K.slice(B + pe.length), C = ee + K.length;
                  $ && C > $.reach && ($.reach = C);
                  var N = G.prev;
                  he && (N = m(b, N, he), ee += he.length), v(b, N, z);
                  var J = new l(I, Y ? a.tokenize(pe, Y) : pe, ue, pe);
                  if (G = m(b, N, J), Ae && m(b, G, Ae), z > 1) {
                    var X = {
                      cause: I + "," + L,
                      reach: C
                    };
                    f(g, b, A, G.prev, ee, X), $ && X.reach > $.reach && ($.reach = X.reach);
                  }
                }
              }
            }
          }
      }
      function d() {
        var g = { value: null, prev: null, next: null }, b = { value: null, prev: g, next: null };
        g.next = b, this.head = g, this.tail = b, this.length = 0;
      }
      function m(g, b, A) {
        var P = b.next, k = { value: A, prev: b, next: P };
        return b.next = k, P.prev = k, g.length++, k;
      }
      function v(g, b, A) {
        for (var P = b.next, k = 0; k < A && P !== g.tail; k++)
          P = P.next;
        b.next = P, P.prev = b, g.length -= k;
      }
      function S(g) {
        for (var b = [], A = g.head.next; A !== g.tail; )
          b.push(A.value), A = A.next;
        return b;
      }
      if (!n.document)
        return n.addEventListener && (a.disableWorkerMessageHandler || n.addEventListener("message", function(g) {
          var b = JSON.parse(g.data), A = b.language, P = b.code, k = b.immediateClose;
          n.postMessage(a.highlight(P, a.languages[A], A)), k && n.close();
        }, !1)), a;
      var y = a.util.currentScript();
      y && (a.filename = y.src, y.hasAttribute("data-manual") && (a.manual = !0));
      function E() {
        a.manual || a.highlightAll();
      }
      if (!a.manual) {
        var x = document.readyState;
        x === "loading" || x === "interactive" && y && y.defer ? document.addEventListener("DOMContentLoaded", E) : window.requestAnimationFrame ? window.requestAnimationFrame(E) : window.setTimeout(E, 16);
      }
      return a;
    }(t);
    e.exports && (e.exports = r), typeof ft < "u" && (ft.Prism = r), r.languages.markup = {
      comment: {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: !0
      },
      prolog: {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: !0
      },
      doctype: {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: !0,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: !0,
            greedy: !0,
            inside: null
            // see below
          },
          string: {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: !0
          },
          punctuation: /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          name: /[^\s<>'"]+/
        }
      },
      cdata: {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: !0
      },
      tag: {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: !0,
        inside: {
          tag: {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              punctuation: /^<\/?/,
              namespace: /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: !0
                }
              ]
            }
          },
          punctuation: /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              namespace: /^[^\s>\/:]+:/
            }
          }
        }
      },
      entity: [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    }, r.languages.markup.tag.inside["attr-value"].inside.entity = r.languages.markup.entity, r.languages.markup.doctype.inside["internal-subset"].inside = r.languages.markup, r.hooks.add("wrap", function(n) {
      n.type === "entity" && (n.attributes.title = n.content.replace(/&amp;/, "&"));
    }), Object.defineProperty(r.languages.markup.tag, "addInlined", {
      /**
       * Adds an inlined language to markup.
       *
       * An example of an inlined language is CSS with `<style>` tags.
       *
       * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addInlined('style', 'css');
       */
      value: function(i, s) {
        var o = {};
        o["language-" + s] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: !0,
          inside: r.languages[s]
        }, o.cdata = /^<!\[CDATA\[|\]\]>$/i;
        var a = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: o
          }
        };
        a["language-" + s] = {
          pattern: /[\s\S]+/,
          inside: r.languages[s]
        };
        var l = {};
        l[i] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return i;
          }), "i"),
          lookbehind: !0,
          greedy: !0,
          inside: a
        }, r.languages.insertBefore("markup", "cdata", l);
      }
    }), Object.defineProperty(r.languages.markup.tag, "addAttribute", {
      /**
       * Adds an pattern to highlight languages embedded in HTML attributes.
       *
       * An example of an inlined language is CSS with `style` attributes.
       *
       * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addAttribute('style', 'css');
       */
      value: function(n, i) {
        r.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + n + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: !0,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                value: {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: !0,
                  alias: [i, "language-" + i],
                  inside: r.languages[i]
                },
                punctuation: [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    }), r.languages.html = r.languages.markup, r.languages.mathml = r.languages.markup, r.languages.svg = r.languages.markup, r.languages.xml = r.languages.extend("markup", {}), r.languages.ssml = r.languages.xml, r.languages.atom = r.languages.xml, r.languages.rss = r.languages.xml, function(n) {
      var i = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      n.languages.css = {
        comment: /\/\*[\s\S]*?\*\//,
        atrule: {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + i.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            rule: /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: !0,
              alias: "selector"
            },
            keyword: {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: !0
            }
            // See rest below
          }
        },
        url: {
          // https://drafts.csswg.org/css-values-3/#urls
          pattern: RegExp("\\burl\\((?:" + i.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: !0,
          inside: {
            function: /^url/i,
            punctuation: /^\(|\)$/,
            string: {
              pattern: RegExp("^" + i.source + "$"),
              alias: "url"
            }
          }
        },
        selector: {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + i.source + ")*(?=\\s*\\{)"),
          lookbehind: !0
        },
        string: {
          pattern: i,
          greedy: !0
        },
        property: {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: !0
        },
        important: /!important\b/i,
        function: {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: !0
        },
        punctuation: /[(){};:,]/
      }, n.languages.css.atrule.inside.rest = n.languages.css;
      var s = n.languages.markup;
      s && (s.tag.addInlined("style", "css"), s.tag.addAttribute("style", "css"));
    }(r), r.languages.clike = {
      comment: [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: !0,
        inside: {
          punctuation: /[.\\]/
        }
      },
      keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      boolean: /\b(?:false|true)\b/,
      function: /\b\w+(?=\()/,
      number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      punctuation: /[{}[\];(),.:]/
    }, r.languages.javascript = r.languages.extend("clike", {
      "class-name": [
        r.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: !0
        }
      ],
      keyword: [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: !0
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: !0
        }
      ],
      // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
      function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      number: {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + // constant
          (/NaN|Infinity/.source + "|" + // binary integer
          /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
          /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: !0
      },
      operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    }), r.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, r.languages.insertBefore("javascript", "keyword", {
      regex: {
        pattern: RegExp(
          // lookbehind
          // eslint-disable-next-line regexp/no-dupe-characters-character-class
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
          // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
          // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
          // with the only syntax, so we have to define 2 different regex patterns.
          /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
          /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
          /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: !0,
            alias: "language-regex",
            inside: r.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      // This must be declared before keyword because we use "function" inside the look-forward
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      parameter: [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: !0,
          inside: r.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: !0,
          inside: r.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: !0,
          inside: r.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: !0,
          inside: r.languages.javascript
        }
      ],
      constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    }), r.languages.insertBefore("javascript", "string", {
      hashbang: {
        pattern: /^#!.*/,
        greedy: !0,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: !0,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: !0,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: r.languages.javascript
            }
          },
          string: /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: !0,
        greedy: !0,
        alias: "property"
      }
    }), r.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: !0,
        alias: "property"
      }
    }), r.languages.markup && (r.languages.markup.tag.addInlined("script", "javascript"), r.languages.markup.tag.addAttribute(
      /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
      "javascript"
    )), r.languages.js = r.languages.javascript, function() {
      if (typeof r > "u" || typeof document > "u")
        return;
      Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector);
      var n = "Loading", i = function(y, E) {
        return " Error " + y + " while fetching file: " + E;
      }, s = " Error: File does not exist or is empty", o = {
        js: "javascript",
        py: "python",
        rb: "ruby",
        ps1: "powershell",
        psm1: "powershell",
        sh: "bash",
        bat: "batch",
        h: "c",
        tex: "latex"
      }, a = "data-src-status", l = "loading", u = "loaded", f = "failed", d = "pre[data-src]:not([" + a + '="' + u + '"]):not([' + a + '="' + l + '"])';
      function m(y, E, x) {
        var g = new XMLHttpRequest();
        g.open("GET", y, !0), g.onreadystatechange = function() {
          g.readyState == 4 && (g.status < 400 && g.responseText ? E(g.responseText) : g.status >= 400 ? x(i(g.status, g.statusText)) : x(s));
        }, g.send(null);
      }
      function v(y) {
        var E = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(y || "");
        if (E) {
          var x = Number(E[1]), g = E[2], b = E[3];
          return g ? b ? [x, Number(b)] : [x, void 0] : [x, x];
        }
      }
      r.hooks.add("before-highlightall", function(y) {
        y.selector += ", " + d;
      }), r.hooks.add("before-sanity-check", function(y) {
        var E = (
          /** @type {HTMLPreElement} */
          y.element
        );
        if (E.matches(d)) {
          y.code = "", E.setAttribute(a, l);
          var x = E.appendChild(document.createElement("CODE"));
          x.textContent = n;
          var g = E.getAttribute("data-src"), b = y.language;
          if (b === "none") {
            var A = (/\.(\w+)$/.exec(g) || [, "none"])[1];
            b = o[A] || A;
          }
          r.util.setLanguage(x, b), r.util.setLanguage(E, b);
          var P = r.plugins.autoloader;
          P && P.loadLanguages(b), m(
            g,
            function(k) {
              E.setAttribute(a, u);
              var $ = v(E.getAttribute("data-range"));
              if ($) {
                var I = k.split(/\r\n?|\n/g), F = $[0], L = $[1] == null ? I.length : $[1];
                F < 0 && (F += I.length), F = Math.max(0, Math.min(F - 1, I.length)), L < 0 && (L += I.length), L = Math.max(0, Math.min(L, I.length)), k = I.slice(F, L).join(`
`), E.hasAttribute("data-start") || E.setAttribute("data-start", String(F + 1));
              }
              x.textContent = k, r.highlightElement(x);
            },
            function(k) {
              E.setAttribute(a, f), x.textContent = k;
            }
          );
        }
      }), r.plugins.fileHighlight = {
        /**
         * Executes the File Highlight plugin for all matching `pre` elements under the given container.
         *
         * Note: Elements which are already loaded or currently loading will not be touched by this method.
         *
         * @param {ParentNode} [container=document]
         */
        highlight: function(E) {
          for (var x = (E || document).querySelectorAll(d), g = 0, b; b = x[g++]; )
            r.highlightElement(b);
        }
      };
      var S = !1;
      r.fileHighlight = function() {
        S || (console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead."), S = !0), r.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    }();
  }(Bb)), Bb.exports;
}
var RT = {}, IT;
function sG() {
  return IT || (IT = 1, function(e) {
    var t = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b", r = {
      pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
      lookbehind: !0,
      alias: "punctuation",
      // this looks reasonably well in all themes
      inside: null
      // see below
    }, n = {
      bash: r,
      environment: {
        pattern: RegExp("\\$" + t),
        alias: "constant"
      },
      variable: [
        // [0]: Arithmetic Environment
        {
          pattern: /\$?\(\([\s\S]+?\)\)/,
          greedy: !0,
          inside: {
            // If there is a $ sign at the beginning highlight $(( and )) as variable
            variable: [
              {
                pattern: /(^\$\(\([\s\S]+)\)\)/,
                lookbehind: !0
              },
              /^\$\(\(/
            ],
            number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
            // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
            operator: /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
            // If there is no $ sign at the beginning highlight (( and )) as punctuation
            punctuation: /\(\(?|\)\)?|,|;/
          }
        },
        // [1]: Command Substitution
        {
          pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
          greedy: !0,
          inside: {
            variable: /^\$\(|^`|\)$|`$/
          }
        },
        // [2]: Brace expansion
        {
          pattern: /\$\{[^}]+\}/,
          greedy: !0,
          inside: {
            operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
            punctuation: /[\[\]]/,
            environment: {
              pattern: RegExp("(\\{)" + t),
              lookbehind: !0,
              alias: "constant"
            }
          }
        },
        /\$(?:\w+|[#?*!@$])/
      ],
      // Escape sequences from echo and printf's manuals, and escaped quotes.
      entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
    };
    e.languages.bash = {
      shebang: {
        pattern: /^#!\s*\/.*/,
        alias: "important"
      },
      comment: {
        pattern: /(^|[^"{\\$])#.*/,
        lookbehind: !0
      },
      "function-name": [
        // a) function foo {
        // b) foo() {
        // c) function foo() {
        // but not foo {
        {
          // a) and c)
          pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
          lookbehind: !0,
          alias: "function"
        },
        {
          // b)
          pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
          alias: "function"
        }
      ],
      // Highlight variable names as variables in for and select beginnings.
      "for-or-select": {
        pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
        alias: "variable",
        lookbehind: !0
      },
      // Highlight variable names as variables in the left-hand part
      // of assignments (= and +=).
      "assign-left": {
        pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
        inside: {
          environment: {
            pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + t),
            lookbehind: !0,
            alias: "constant"
          }
        },
        alias: "variable",
        lookbehind: !0
      },
      // Highlight parameter names as variables
      parameter: {
        pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
        alias: "variable",
        lookbehind: !0
      },
      string: [
        // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
        {
          pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
          lookbehind: !0,
          greedy: !0,
          inside: n
        },
        // Here-document with quotes around the tag
        //  No expansion (so no inside).
        {
          pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
          lookbehind: !0,
          greedy: !0,
          inside: {
            bash: r
          }
        },
        // Normal string
        {
          // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
          pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
          lookbehind: !0,
          greedy: !0,
          inside: n
        },
        {
          // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
          pattern: /(^|[^$\\])'[^']*'/,
          lookbehind: !0,
          greedy: !0
        },
        {
          // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
          pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
          greedy: !0,
          inside: {
            entity: n.entity
          }
        }
      ],
      environment: {
        pattern: RegExp("\\$?" + t),
        alias: "constant"
      },
      variable: n.variable,
      function: {
        pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
        lookbehind: !0
      },
      keyword: {
        pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
        lookbehind: !0
      },
      // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
      builtin: {
        pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
        lookbehind: !0,
        // Alias added to make those easier to distinguish from strings.
        alias: "class-name"
      },
      boolean: {
        pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
        lookbehind: !0
      },
      "file-descriptor": {
        pattern: /\B&\d\b/,
        alias: "important"
      },
      operator: {
        // Lots of redirections here, but not just that.
        pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
        inside: {
          "file-descriptor": {
            pattern: /^\d/,
            alias: "important"
          }
        }
      },
      punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
      number: {
        pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
        lookbehind: !0
      }
    }, r.inside = e.languages.bash;
    for (var i = [
      "comment",
      "function-name",
      "for-or-select",
      "assign-left",
      "parameter",
      "string",
      "environment",
      "function",
      "keyword",
      "builtin",
      "boolean",
      "file-descriptor",
      "operator",
      "punctuation",
      "number"
    ], s = n.variable[1].inside, o = 0; o < i.length; o++)
      s[i[o]] = e.languages.bash[i[o]];
    e.languages.sh = e.languages.bash, e.languages.shell = e.languages.bash;
  }(Prism)), RT;
}
var NT = {}, jT;
function aG() {
  return jT || (jT = 1, Prism.languages.c = Prism.languages.extend("clike", {
    comment: {
      pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
      greedy: !0
    },
    string: {
      // https://en.cppreference.com/w/c/language/string_literal
      pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
      lookbehind: !0
    },
    keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
    operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
  }), Prism.languages.insertBefore("c", "string", {
    char: {
      // https://en.cppreference.com/w/c/language/character_constant
      pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
      greedy: !0
    }
  }), Prism.languages.insertBefore("c", "string", {
    macro: {
      // allow for multiline macro definitions
      // spaces after the # character compile fine with gcc
      pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
      lookbehind: !0,
      greedy: !0,
      alias: "property",
      inside: {
        string: [
          {
            // highlight the path of the include statement as a string
            pattern: /^(#\s*include\s*)<[^>]+>/,
            lookbehind: !0
          },
          Prism.languages.c.string
        ],
        char: Prism.languages.c.char,
        comment: Prism.languages.c.comment,
        "macro-name": [
          {
            pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
            lookbehind: !0
          },
          {
            pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
            lookbehind: !0,
            alias: "function"
          }
        ],
        // highlight macro directives as keywords
        directive: {
          pattern: /^(#\s*)[a-z]+/,
          lookbehind: !0,
          alias: "keyword"
        },
        "directive-hash": /^#/,
        punctuation: /##|\\(?=[\r\n])/,
        expression: {
          pattern: /\S[\s\S]*/,
          inside: Prism.languages.c
        }
      }
    }
  }), Prism.languages.insertBefore("c", "function", {
    // highlight predefined macros as constants
    constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
  }), delete Prism.languages.c.boolean), NT;
}
var LT = {}, MT;
function lG() {
  return MT || (MT = 1, Prism.languages.clike = {
    comment: [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: !0,
        greedy: !0
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: !0,
      inside: {
        punctuation: /[.\\]/
      }
    },
    keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    boolean: /\b(?:false|true)\b/,
    function: /\b\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    punctuation: /[{}[\];(),.:]/
  }), LT;
}
var DT = {}, FT;
function uG() {
  return FT || (FT = 1, function(e) {
    var t = /#(?!\{).+/, r = {
      pattern: /#\{[^}]+\}/,
      alias: "variable"
    };
    e.languages.coffeescript = e.languages.extend("javascript", {
      comment: t,
      string: [
        // Strings are multiline
        {
          pattern: /'(?:\\[\s\S]|[^\\'])*'/,
          greedy: !0
        },
        {
          // Strings are multiline
          pattern: /"(?:\\[\s\S]|[^\\"])*"/,
          greedy: !0,
          inside: {
            interpolation: r
          }
        }
      ],
      keyword: /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/,
      "class-member": {
        pattern: /@(?!\d)\w+/,
        alias: "variable"
      }
    }), e.languages.insertBefore("coffeescript", "comment", {
      "multiline-comment": {
        pattern: /###[\s\S]+?###/,
        alias: "comment"
      },
      // Block regexp can contain comments and interpolation
      "block-regex": {
        pattern: /\/{3}[\s\S]*?\/{3}/,
        alias: "regex",
        inside: {
          comment: t,
          interpolation: r
        }
      }
    }), e.languages.insertBefore("coffeescript", "string", {
      "inline-javascript": {
        pattern: /`(?:\\[\s\S]|[^\\`])*`/,
        inside: {
          delimiter: {
            pattern: /^`|`$/,
            alias: "punctuation"
          },
          script: {
            pattern: /[\s\S]+/,
            alias: "language-javascript",
            inside: e.languages.javascript
          }
        }
      },
      // Block strings
      "multiline-string": [
        {
          pattern: /'''[\s\S]*?'''/,
          greedy: !0,
          alias: "string"
        },
        {
          pattern: /"""[\s\S]*?"""/,
          greedy: !0,
          alias: "string",
          inside: {
            interpolation: r
          }
        }
      ]
    }), e.languages.insertBefore("coffeescript", "keyword", {
      // Object property
      property: /(?!\d)\w+(?=\s*:(?!:))/
    }), delete e.languages.coffeescript["template-string"], e.languages.coffee = e.languages.coffeescript;
  }(Prism)), DT;
}
var zT = {}, qT;
function cG() {
  return qT || (qT = 1, function(e) {
    var t = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, r = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
      return t.source;
    });
    e.languages.cpp = e.languages.extend("c", {
      "class-name": [
        {
          pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
            return t.source;
          })),
          lookbehind: !0
        },
        // This is intended to capture the class name of method implementations like:
        //   void foo::bar() const {}
        // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
        // it starts with an uppercase letter. This approximation should give decent results.
        /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
        // This will capture the class name before destructors like:
        //   Foo::~Foo() {}
        /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
        // This also intends to capture the class name of method implementations but here the class has template
        // parameters, so it can't be a namespace (until C++ adds generic namespaces).
        /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
      ],
      keyword: t,
      number: {
        pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
        greedy: !0
      },
      operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
      boolean: /\b(?:false|true)\b/
    }), e.languages.insertBefore("cpp", "string", {
      module: {
        // https://en.cppreference.com/w/cpp/language/modules
        pattern: RegExp(
          /(\b(?:import|module)\s+)/.source + "(?:" + // header-name
          /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
          /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
            return r;
          }) + ")"
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          string: /^[<"][\s\S]+/,
          operator: /:/,
          punctuation: /\./
        }
      },
      "raw-string": {
        pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
        alias: "string",
        greedy: !0
      }
    }), e.languages.insertBefore("cpp", "keyword", {
      "generic-function": {
        pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
        inside: {
          function: /^\w+/,
          generic: {
            pattern: /<[\s\S]+/,
            alias: "class-name",
            inside: e.languages.cpp
          }
        }
      }
    }), e.languages.insertBefore("cpp", "operator", {
      "double-colon": {
        pattern: /::/,
        alias: "punctuation"
      }
    }), e.languages.insertBefore("cpp", "class-name", {
      // the base clause is an optional list of parent classes
      // https://en.cppreference.com/w/cpp/language/class
      "base-clause": {
        pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
        lookbehind: !0,
        greedy: !0,
        inside: e.languages.extend("cpp", {})
      }
    }), e.languages.insertBefore("inside", "double-colon", {
      // All untokenized words that are not namespaces should be class names
      "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
    }, e.languages.cpp["base-clause"]);
  }(Prism)), zT;
}
var BT = {}, UT;
function pG() {
  return UT || (UT = 1, function(e) {
    function t(ee, K) {
      return ee.replace(/<<(\d+)>>/g, function(z, te) {
        return "(?:" + K[+te] + ")";
      });
    }
    function r(ee, K, z) {
      return RegExp(t(ee, K), "");
    }
    function n(ee, K) {
      for (var z = 0; z < K; z++)
        ee = ee.replace(/<<self>>/g, function() {
          return "(?:" + ee + ")";
        });
      return ee.replace(/<<self>>/g, "[^\\s\\S]");
    }
    var i = {
      // keywords which represent a return or variable type
      type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
      // keywords which are used to declare a type
      typeDeclaration: "class enum interface record struct",
      // contextual keywords
      // ("var" and "dynamic" are missing because they are used like types)
      contextual: "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
      // all other keywords
      other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield"
    };
    function s(ee) {
      return "\\b(?:" + ee.trim().replace(/ /g, "|") + ")\\b";
    }
    var o = s(i.typeDeclaration), a = RegExp(s(i.type + " " + i.typeDeclaration + " " + i.contextual + " " + i.other)), l = s(i.typeDeclaration + " " + i.contextual + " " + i.other), u = s(i.type + " " + i.typeDeclaration + " " + i.other), f = n(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2), d = n(/\((?:[^()]|<<self>>)*\)/.source, 2), m = /@?\b[A-Za-z_]\w*\b/.source, v = t(/<<0>>(?:\s*<<1>>)?/.source, [m, f]), S = t(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [l, v]), y = /\[\s*(?:,\s*)*\]/.source, E = t(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [S, y]), x = t(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [f, d, y]), g = t(/\(<<0>>+(?:,<<0>>+)+\)/.source, [x]), b = t(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [g, S, y]), A = {
      keyword: a,
      punctuation: /[<>()?,.:[\]]/
    }, P = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source, k = /"(?:\\.|[^\\"\r\n])*"/.source, $ = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
    e.languages.csharp = e.languages.extend("clike", {
      string: [
        {
          pattern: r(/(^|[^$\\])<<0>>/.source, [$]),
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: r(/(^|[^@$\\])<<0>>/.source, [k]),
          lookbehind: !0,
          greedy: !0
        }
      ],
      "class-name": [
        {
          // Using static
          // using static System.Math;
          pattern: r(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [S]),
          lookbehind: !0,
          inside: A
        },
        {
          // Using alias (type)
          // using Project = PC.MyCompany.Project;
          pattern: r(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [m, b]),
          lookbehind: !0,
          inside: A
        },
        {
          // Using alias (alias)
          // using Project = PC.MyCompany.Project;
          pattern: r(/(\busing\s+)<<0>>(?=\s*=)/.source, [m]),
          lookbehind: !0
        },
        {
          // Type declarations
          // class Foo<A, B>
          // interface Foo<out A, B>
          pattern: r(/(\b<<0>>\s+)<<1>>/.source, [o, v]),
          lookbehind: !0,
          inside: A
        },
        {
          // Single catch exception declaration
          // catch(Foo)
          // (things like catch(Foo e) is covered by variable declaration)
          pattern: r(/(\bcatch\s*\(\s*)<<0>>/.source, [S]),
          lookbehind: !0,
          inside: A
        },
        {
          // Name of the type parameter of generic constraints
          // where Foo : class
          pattern: r(/(\bwhere\s+)<<0>>/.source, [m]),
          lookbehind: !0
        },
        {
          // Casts and checks via as and is.
          // as Foo<A>, is Bar<B>
          // (things like if(a is Foo b) is covered by variable declaration)
          pattern: r(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [E]),
          lookbehind: !0,
          inside: A
        },
        {
          // Variable, field and parameter declaration
          // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)
          pattern: r(/\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source, [b, u, m]),
          inside: A
        }
      ],
      keyword: a,
      // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals
      number: /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
      operator: />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
      punctuation: /\?\.?|::|[{}[\];(),.:]/
    }), e.languages.insertBefore("csharp", "number", {
      range: {
        pattern: /\.\./,
        alias: "operator"
      }
    }), e.languages.insertBefore("csharp", "punctuation", {
      "named-parameter": {
        pattern: r(/([(,]\s*)<<0>>(?=\s*:)/.source, [m]),
        lookbehind: !0,
        alias: "punctuation"
      }
    }), e.languages.insertBefore("csharp", "class-name", {
      namespace: {
        // namespace Foo.Bar {}
        // using Foo.Bar;
        pattern: r(/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source, [m]),
        lookbehind: !0,
        inside: {
          punctuation: /\./
        }
      },
      "type-expression": {
        // default(Foo), typeof(Foo<Bar>), sizeof(int)
        pattern: r(/(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source, [d]),
        lookbehind: !0,
        alias: "class-name",
        inside: A
      },
      "return-type": {
        // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0
        // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];
        // int Foo => 0; int Foo { get; set } = 0;
        pattern: r(/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source, [b, S]),
        inside: A,
        alias: "class-name"
      },
      "constructor-invocation": {
        // new List<Foo<Bar[]>> { }
        pattern: r(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [b]),
        lookbehind: !0,
        inside: A,
        alias: "class-name"
      },
      /*'explicit-implementation': {
      	// int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();
      	pattern: replace(/\b<<0>>(?=\.<<1>>)/, className, methodOrPropertyDeclaration),
      	inside: classNameInside,
      	alias: 'class-name'
      },*/
      "generic-method": {
        // foo<Bar>()
        pattern: r(/<<0>>\s*<<1>>(?=\s*\()/.source, [m, f]),
        inside: {
          function: r(/^<<0>>/.source, [m]),
          generic: {
            pattern: RegExp(f),
            alias: "class-name",
            inside: A
          }
        }
      },
      "type-list": {
        // The list of types inherited or of generic constraints
        // class Foo<F> : Bar, IList<FooBar>
        // where F : Bar, IList<int>
        pattern: r(
          /\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source,
          [o, v, m, b, a.source, d, /\bnew\s*\(\s*\)/.source]
        ),
        lookbehind: !0,
        inside: {
          "record-arguments": {
            pattern: r(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [v, d]),
            lookbehind: !0,
            greedy: !0,
            inside: e.languages.csharp
          },
          keyword: a,
          "class-name": {
            pattern: RegExp(b),
            greedy: !0,
            inside: A
          },
          punctuation: /[,()]/
        }
      },
      preprocessor: {
        pattern: /(^[\t ]*)#.*/m,
        lookbehind: !0,
        alias: "property",
        inside: {
          // highlight preprocessor directives as keywords
          directive: {
            pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
            lookbehind: !0,
            alias: "keyword"
          }
        }
      }
    });
    var I = k + "|" + P, F = t(/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source, [I]), L = n(t(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [F]), 2), Q = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source, Y = t(/<<0>>(?:\s*\(<<1>>*\))?/.source, [S, L]);
    e.languages.insertBefore("csharp", "class-name", {
      attribute: {
        // Attributes
        // [Foo], [Foo(1), Bar(2, Prop = "foo")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]
        pattern: r(/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source, [Q, Y]),
        lookbehind: !0,
        greedy: !0,
        inside: {
          target: {
            pattern: r(/^<<0>>(?=\s*:)/.source, [Q]),
            alias: "keyword"
          },
          "attribute-arguments": {
            pattern: r(/\(<<0>>*\)/.source, [L]),
            inside: e.languages.csharp
          },
          "class-name": {
            pattern: RegExp(S),
            inside: {
              punctuation: /\./
            }
          },
          punctuation: /[:,]/
        }
      }
    });
    var ae = /:[^}\r\n]+/.source, le = n(t(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [F]), 2), ue = t(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [le, ae]), ce = n(t(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [I]), 2), be = t(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [ce, ae]);
    function G(ee, K) {
      return {
        interpolation: {
          pattern: r(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [ee]),
          lookbehind: !0,
          inside: {
            "format-string": {
              pattern: r(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [K, ae]),
              lookbehind: !0,
              inside: {
                punctuation: /^:/
              }
            },
            punctuation: /^\{|\}$/,
            expression: {
              pattern: /[\s\S]+/,
              alias: "language-csharp",
              inside: e.languages.csharp
            }
          }
        },
        string: /[\s\S]+/
      };
    }
    e.languages.insertBefore("csharp", "string", {
      "interpolation-string": [
        {
          pattern: r(/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source, [ue]),
          lookbehind: !0,
          greedy: !0,
          inside: G(ue, le)
        },
        {
          pattern: r(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [be]),
          lookbehind: !0,
          greedy: !0,
          inside: G(be, ce)
        }
      ],
      char: {
        pattern: RegExp(P),
        greedy: !0
      }
    }), e.languages.dotnet = e.languages.cs = e.languages.csharp;
  }(Prism)), BT;
}
var VT = {}, WT;
function fG() {
  return WT || (WT = 1, Prism.languages.go = Prism.languages.extend("clike", {
    string: {
      pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
      lookbehind: !0,
      greedy: !0
    },
    keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
    boolean: /\b(?:_|false|iota|nil|true)\b/,
    number: [
      // binary and octal integers
      /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
      // hexadecimal integers and floats
      /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
      // decimal integers and floats
      /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
    ],
    operator: /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
    builtin: /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
  }), Prism.languages.insertBefore("go", "string", {
    char: {
      pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
      greedy: !0
    }
  }), delete Prism.languages.go["class-name"]), VT;
}
var HT = {}, QT;
function dG() {
  return QT || (QT = 1, function(e) {
    function t(u) {
      return RegExp("(^(?:" + u + "):[ 	]*(?![ 	]))[^]+", "i");
    }
    e.languages.http = {
      "request-line": {
        pattern: /^(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PRI|PUT|SEARCH|TRACE)\s(?:https?:\/\/|\/)\S*\sHTTP\/[\d.]+/m,
        inside: {
          // HTTP Method
          method: {
            pattern: /^[A-Z]+\b/,
            alias: "property"
          },
          // Request Target e.g. http://example.com, /path/to/file
          "request-target": {
            pattern: /^(\s)(?:https?:\/\/|\/)\S*(?=\s)/,
            lookbehind: !0,
            alias: "url",
            inside: e.languages.uri
          },
          // HTTP Version
          "http-version": {
            pattern: /^(\s)HTTP\/[\d.]+/,
            lookbehind: !0,
            alias: "property"
          }
        }
      },
      "response-status": {
        pattern: /^HTTP\/[\d.]+ \d+ .+/m,
        inside: {
          // HTTP Version
          "http-version": {
            pattern: /^HTTP\/[\d.]+/,
            alias: "property"
          },
          // Status Code
          "status-code": {
            pattern: /^(\s)\d+(?=\s)/,
            lookbehind: !0,
            alias: "number"
          },
          // Reason Phrase
          "reason-phrase": {
            pattern: /^(\s).+/,
            lookbehind: !0,
            alias: "string"
          }
        }
      },
      header: {
        pattern: /^[\w-]+:.+(?:(?:\r\n?|\n)[ \t].+)*/m,
        inside: {
          "header-value": [
            {
              pattern: t(/Content-Security-Policy/.source),
              lookbehind: !0,
              alias: ["csp", "languages-csp"],
              inside: e.languages.csp
            },
            {
              pattern: t(/Public-Key-Pins(?:-Report-Only)?/.source),
              lookbehind: !0,
              alias: ["hpkp", "languages-hpkp"],
              inside: e.languages.hpkp
            },
            {
              pattern: t(/Strict-Transport-Security/.source),
              lookbehind: !0,
              alias: ["hsts", "languages-hsts"],
              inside: e.languages.hsts
            },
            {
              pattern: t(/[^:]+/.source),
              lookbehind: !0
            }
          ],
          "header-name": {
            pattern: /^[^:]+/,
            alias: "keyword"
          },
          punctuation: /^:/
        }
      }
    };
    var r = e.languages, n = {
      "application/javascript": r.javascript,
      "application/json": r.json || r.javascript,
      "application/xml": r.xml,
      "text/xml": r.xml,
      "text/html": r.html,
      "text/css": r.css,
      "text/plain": r.plain
    }, i = {
      "application/json": !0,
      "application/xml": !0
    };
    function s(u) {
      var f = u.replace(/^[a-z]+\//, ""), d = "\\w+/(?:[\\w.-]+\\+)+" + f + "(?![+\\w.-])";
      return "(?:" + u + "|" + d + ")";
    }
    var o;
    for (var a in n)
      if (n[a]) {
        o = o || {};
        var l = i[a] ? s(a) : a;
        o[a.replace(/\//g, "-")] = {
          pattern: RegExp(
            "(" + /content-type:\s*/.source + l + /(?:(?:\r\n?|\n)[\w-].*)*(?:\r(?:\n|(?!\n))|\n)/.source + ")" + // This is a little interesting:
            // The HTTP format spec required 1 empty line before the body to make everything unambiguous.
            // However, when writing code by hand (e.g. to display on a website) people can forget about this,
            // so we want to be liberal here. We will allow the empty line to be omitted if the first line of
            // the body does not start with a [\w-] character (as headers do).
            /[^ \t\w-][\s\S]*/.source,
            "i"
          ),
          lookbehind: !0,
          inside: n[a]
        };
      }
    o && e.languages.insertBefore("http", "header", o);
  }(Prism)), HT;
}
var YT = {}, GT;
function hG() {
  return GT || (GT = 1, function(e) {
    var t = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/, r = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source, n = {
      pattern: RegExp(/(^|[^\w.])/.source + r + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
      lookbehind: !0,
      inside: {
        namespace: {
          pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
          inside: {
            punctuation: /\./
          }
        },
        punctuation: /\./
      }
    };
    e.languages.java = e.languages.extend("clike", {
      string: {
        pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
        lookbehind: !0,
        greedy: !0
      },
      "class-name": [
        n,
        {
          // variables, parameters, and constructor references
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(/(^|[^\w.])/.source + r + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
          lookbehind: !0,
          inside: n.inside
        },
        {
          // class names based on keyword
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + r + /[A-Z]\w*\b/.source),
          lookbehind: !0,
          inside: n.inside
        }
      ],
      keyword: t,
      function: [
        e.languages.clike.function,
        {
          pattern: /(::\s*)[a-z_]\w*/,
          lookbehind: !0
        }
      ],
      number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
      operator: {
        pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
        lookbehind: !0
      },
      constant: /\b[A-Z][A-Z_\d]+\b/
    }), e.languages.insertBefore("java", "string", {
      "triple-quoted-string": {
        // http://openjdk.java.net/jeps/355#Description
        pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
        greedy: !0,
        alias: "string"
      },
      char: {
        pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
        greedy: !0
      }
    }), e.languages.insertBefore("java", "class-name", {
      annotation: {
        pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
        lookbehind: !0,
        alias: "punctuation"
      },
      generics: {
        pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
        inside: {
          "class-name": n,
          keyword: t,
          punctuation: /[<>(),.:]/,
          operator: /[?&|]/
        }
      },
      import: [
        {
          pattern: RegExp(/(\bimport\s+)/.source + r + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
          lookbehind: !0,
          inside: {
            namespace: n.inside.namespace,
            punctuation: /\./,
            operator: /\*/,
            "class-name": /\w+/
          }
        },
        {
          pattern: RegExp(/(\bimport\s+static\s+)/.source + r + /(?:\w+|\*)(?=\s*;)/.source),
          lookbehind: !0,
          alias: "static",
          inside: {
            namespace: n.inside.namespace,
            static: /\b\w+$/,
            punctuation: /\./,
            operator: /\*/,
            "class-name": /\w+/
          }
        }
      ],
      namespace: {
        pattern: RegExp(
          /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
            return t.source;
          })
        ),
        lookbehind: !0,
        inside: {
          punctuation: /\./
        }
      }
    });
  }(Prism)), YT;
}
var KT = {}, XT;
function mG() {
  return XT || (XT = 1, Prism.languages.lua = {
    comment: /^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,
    // \z may be used to skip the following space
    string: {
      pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,
      greedy: !0
    },
    number: /\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
    keyword: /\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,
    function: /(?!\d)\w+(?=\s*(?:[({]))/,
    operator: [
      /[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/,
      {
        // Match ".." but don't break "..."
        pattern: /(^|[^.])\.\.(?!\.)/,
        lookbehind: !0
      }
    ],
    punctuation: /[\[\](){},;]|\.+|:+/
  }), KT;
}
var JT = {}, ZT;
function gG() {
  return ZT || (ZT = 1, function(e) {
    function t(r, n) {
      return "___" + r.toUpperCase() + n + "___";
    }
    Object.defineProperties(e.languages["markup-templating"] = {}, {
      buildPlaceholders: {
        /**
         * Tokenize all inline templating expressions matching `placeholderPattern`.
         *
         * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns
         * `true` will be replaced.
         *
         * @param {object} env The environment of the `before-tokenize` hook.
         * @param {string} language The language id.
         * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.
         * @param {(match: string) => boolean} [replaceFilter]
         */
        value: function(r, n, i, s) {
          if (r.language === n) {
            var o = r.tokenStack = [];
            r.code = r.code.replace(i, function(a) {
              if (typeof s == "function" && !s(a))
                return a;
              for (var l = o.length, u; r.code.indexOf(u = t(n, l)) !== -1; )
                ++l;
              return o[l] = a, u;
            }), r.grammar = e.languages.markup;
          }
        }
      },
      tokenizePlaceholders: {
        /**
         * Replace placeholders with proper tokens after tokenizing.
         *
         * @param {object} env The environment of the `after-tokenize` hook.
         * @param {string} language The language id.
         */
        value: function(r, n) {
          if (r.language !== n || !r.tokenStack)
            return;
          r.grammar = e.languages[n];
          var i = 0, s = Object.keys(r.tokenStack);
          function o(a) {
            for (var l = 0; l < a.length && !(i >= s.length); l++) {
              var u = a[l];
              if (typeof u == "string" || u.content && typeof u.content == "string") {
                var f = s[i], d = r.tokenStack[f], m = typeof u == "string" ? u : u.content, v = t(n, f), S = m.indexOf(v);
                if (S > -1) {
                  ++i;
                  var y = m.substring(0, S), E = new e.Token(n, e.tokenize(d, r.grammar), "language-" + n, d), x = m.substring(S + v.length), g = [];
                  y && g.push.apply(g, o([y])), g.push(E), x && g.push.apply(g, o([x])), typeof u == "string" ? a.splice.apply(a, [l, 1].concat(g)) : u.content = g;
                }
              } else u.content && o(u.content);
            }
            return a;
          }
          o(r.tokens);
        }
      }
    });
  }(Prism)), JT;
}
var eC = {}, tC;
function yG() {
  return tC || (tC = 1, Prism.languages.markup = {
    comment: {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: !0
    },
    prolog: {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: !0
    },
    doctype: {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: !0,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: !0,
          greedy: !0,
          inside: null
          // see below
        },
        string: {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: !0
        },
        punctuation: /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        name: /[^\s<>'"]+/
      }
    },
    cdata: {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: !0
    },
    tag: {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: !0,
      inside: {
        tag: {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            punctuation: /^<\/?/,
            namespace: /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            punctuation: [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: !0
              }
            ]
          }
        },
        punctuation: /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            namespace: /^[^\s>\/:]+:/
          }
        }
      }
    },
    entity: [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
      },
      /&#x?[\da-f]{1,8};/i
    ]
  }, Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity, Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup, Prism.hooks.add("wrap", function(e) {
    e.type === "entity" && (e.attributes.title = e.content.replace(/&amp;/, "&"));
  }), Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
    /**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */
    value: function(t, r) {
      var n = {};
      n["language-" + r] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: !0,
        inside: Prism.languages[r]
      }, n.cdata = /^<!\[CDATA\[|\]\]>$/i;
      var i = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: n
        }
      };
      i["language-" + r] = {
        pattern: /[\s\S]+/,
        inside: Prism.languages[r]
      };
      var s = {};
      s[t] = {
        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
          return t;
        }), "i"),
        lookbehind: !0,
        greedy: !0,
        inside: i
      }, Prism.languages.insertBefore("markup", "cdata", s);
    }
  }), Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
    /**
     * Adds an pattern to highlight languages embedded in HTML attributes.
     *
     * An example of an inlined language is CSS with `style` attributes.
     *
     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addAttribute('style', 'css');
     */
    value: function(e, t) {
      Prism.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(
          /(^|["'\s])/.source + "(?:" + e + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
          "i"
        ),
        lookbehind: !0,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              value: {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: !0,
                alias: [t, "language-" + t],
                inside: Prism.languages[t]
              },
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          }
        }
      });
    }
  }), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.xml = Prism.languages.extend("markup", {}), Prism.languages.ssml = Prism.languages.xml, Prism.languages.atom = Prism.languages.xml, Prism.languages.rss = Prism.languages.xml), eC;
}
var rC = {}, nC;
function vG() {
  return nC || (nC = 1, Prism.languages.objectivec = Prism.languages.extend("c", {
    string: {
      pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: !0
    },
    keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
    operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
  }), delete Prism.languages.objectivec["class-name"], Prism.languages.objc = Prism.languages.objectivec), rC;
}
var iC = {}, oC;
function bG() {
  return oC || (oC = 1, function(e) {
    var t = /(?:\((?:[^()\\]|\\[\s\S])*\)|\{(?:[^{}\\]|\\[\s\S])*\}|\[(?:[^[\]\\]|\\[\s\S])*\]|<(?:[^<>\\]|\\[\s\S])*>)/.source;
    e.languages.perl = {
      comment: [
        {
          // POD
          pattern: /(^\s*)=\w[\s\S]*?=cut.*/m,
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: /(^|[^\\$])#.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      // TODO Could be nice to handle Heredoc too.
      string: [
        {
          pattern: RegExp(
            /\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
              // q/.../
              /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
              // q a...a
              // eslint-disable-next-line regexp/strict
              /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
              // q(...)
              // q{...}
              // q[...]
              // q<...>
              t
            ].join("|") + ")"
          ),
          greedy: !0
        },
        // "...", `...`
        {
          pattern: /("|`)(?:(?!\1)[^\\]|\\[\s\S])*\1/,
          greedy: !0
        },
        // '...'
        // FIXME Multi-line single-quoted strings are not supported as they would break variables containing '
        {
          pattern: /'(?:[^'\\\r\n]|\\.)*'/,
          greedy: !0
        }
      ],
      regex: [
        {
          pattern: RegExp(
            /\b(?:m|qr)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
              // m/.../
              /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
              // m a...a
              // eslint-disable-next-line regexp/strict
              /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
              // m(...)
              // m{...}
              // m[...]
              // m<...>
              t
            ].join("|") + ")" + /[msixpodualngc]*/.source
          ),
          greedy: !0
        },
        // The lookbehinds prevent -s from breaking
        {
          pattern: RegExp(
            /(^|[^-])\b(?:s|tr|y)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
              // s/.../.../
              // eslint-disable-next-line regexp/strict
              /([^a-zA-Z0-9\s{(\[<])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
              // s a...a...a
              // eslint-disable-next-line regexp/strict
              /([a-zA-Z0-9])(?:(?!\3)[^\\]|\\[\s\S])*\3(?:(?!\3)[^\\]|\\[\s\S])*\3/.source,
              // s(...)(...)
              // s{...}{...}
              // s[...][...]
              // s<...><...>
              // s(...)[...]
              t + /\s*/.source + t
            ].join("|") + ")" + /[msixpodualngcer]*/.source
          ),
          lookbehind: !0,
          greedy: !0
        },
        // /.../
        // The look-ahead tries to prevent two divisions on
        // the same line from being highlighted as regex.
        // This does not support multi-line regex.
        {
          pattern: /\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|x|xor)\b))/,
          greedy: !0
        }
      ],
      // FIXME Not sure about the handling of ::, ', and #
      variable: [
        // ${^POSTMATCH}
        /[&*$@%]\{\^[A-Z]+\}/,
        // $^V
        /[&*$@%]\^[A-Z_]/,
        // ${...}
        /[&*$@%]#?(?=\{)/,
        // $foo
        /[&*$@%]#?(?:(?:::)*'?(?!\d)[\w$]+(?![\w$]))+(?:::)*/,
        // $1
        /[&*$@%]\d+/,
        // $_, @_, %!
        // The negative lookahead prevents from breaking the %= operator
        /(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/
      ],
      filehandle: {
        // <>, <FOO>, _
        pattern: /<(?![<=])\S*?>|\b_\b/,
        alias: "symbol"
      },
      "v-string": {
        // v1.2, 1.2.3
        pattern: /v\d+(?:\.\d+)*|\d+(?:\.\d+){2,}/,
        alias: "string"
      },
      function: {
        pattern: /(\bsub[ \t]+)\w+/,
        lookbehind: !0
      },
      keyword: /\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\b/,
      number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)\b/,
      operator: /-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|xor)\b/,
      punctuation: /[{}[\];(),:]/
    };
  }(Prism)), iC;
}
var sC = {}, aC;
function wG() {
  return aC || (aC = 1, function(e) {
    var t = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/, r = [
      {
        pattern: /\b(?:false|true)\b/i,
        alias: "boolean"
      },
      {
        pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
        greedy: !0,
        lookbehind: !0
      },
      {
        pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
        greedy: !0,
        lookbehind: !0
      },
      /\b(?:null)\b/i,
      /\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/
    ], n = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i, i = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/, s = /[{}\[\](),:;]/;
    e.languages.php = {
      delimiter: {
        pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
        alias: "important"
      },
      comment: t,
      variable: /\$+(?:\w+\b|(?=\{))/,
      package: {
        pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
        lookbehind: !0,
        inside: {
          punctuation: /\\/
        }
      },
      "class-name-definition": {
        pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
        lookbehind: !0,
        alias: "class-name"
      },
      "function-definition": {
        pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
        lookbehind: !0,
        alias: "function"
      },
      keyword: [
        {
          pattern: /(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
          alias: "type-casting",
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
          alias: "type-hint",
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|never|object|self|static|string|void)\b/i,
          alias: "return-type",
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
          alias: "type-declaration",
          greedy: !0
        },
        {
          pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
          alias: "type-declaration",
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /\b(?:parent|self|static)(?=\s*::)/i,
          alias: "static-context",
          greedy: !0
        },
        {
          // yield from
          pattern: /(\byield\s+)from\b/i,
          lookbehind: !0
        },
        // `class` is always a keyword unlike other keywords
        /\bclass\b/i,
        {
          // https://www.php.net/manual/en/reserved.keywords.php
          //
          // keywords cannot be preceded by "->"
          // the complex lookbehind means `(?<!(?:->|::)\s*)`
          pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|never|new|or|parent|print|private|protected|public|readonly|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
          lookbehind: !0
        }
      ],
      "argument-name": {
        pattern: /([(,]\s*)\b[a-z_]\w*(?=\s*:(?!:))/i,
        lookbehind: !0
      },
      "class-name": [
        {
          pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
          greedy: !0
        },
        {
          pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
          alias: "class-name-fully-qualified",
          greedy: !0,
          lookbehind: !0,
          inside: {
            punctuation: /\\/
          }
        },
        {
          pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
          alias: "class-name-fully-qualified",
          greedy: !0,
          inside: {
            punctuation: /\\/
          }
        },
        {
          pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
          alias: "class-name-fully-qualified",
          greedy: !0,
          lookbehind: !0,
          inside: {
            punctuation: /\\/
          }
        },
        {
          pattern: /\b[a-z_]\w*(?=\s*\$)/i,
          alias: "type-declaration",
          greedy: !0
        },
        {
          pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
          alias: ["class-name-fully-qualified", "type-declaration"],
          greedy: !0,
          inside: {
            punctuation: /\\/
          }
        },
        {
          pattern: /\b[a-z_]\w*(?=\s*::)/i,
          alias: "static-context",
          greedy: !0
        },
        {
          pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
          alias: ["class-name-fully-qualified", "static-context"],
          greedy: !0,
          inside: {
            punctuation: /\\/
          }
        },
        {
          pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
          alias: "type-hint",
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
          alias: ["class-name-fully-qualified", "type-hint"],
          greedy: !0,
          lookbehind: !0,
          inside: {
            punctuation: /\\/
          }
        },
        {
          pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
          alias: "return-type",
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
          alias: ["class-name-fully-qualified", "return-type"],
          greedy: !0,
          lookbehind: !0,
          inside: {
            punctuation: /\\/
          }
        }
      ],
      constant: r,
      function: {
        pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
        lookbehind: !0,
        inside: {
          punctuation: /\\/
        }
      },
      property: {
        pattern: /(->\s*)\w+/,
        lookbehind: !0
      },
      number: n,
      operator: i,
      punctuation: s
    };
    var o = {
      pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
      lookbehind: !0,
      inside: e.languages.php
    }, a = [
      {
        pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
        alias: "nowdoc-string",
        greedy: !0,
        inside: {
          delimiter: {
            pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
            alias: "symbol",
            inside: {
              punctuation: /^<<<'?|[';]$/
            }
          }
        }
      },
      {
        pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
        alias: "heredoc-string",
        greedy: !0,
        inside: {
          delimiter: {
            pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
            alias: "symbol",
            inside: {
              punctuation: /^<<<"?|[";]$/
            }
          },
          interpolation: o
        }
      },
      {
        pattern: /`(?:\\[\s\S]|[^\\`])*`/,
        alias: "backtick-quoted-string",
        greedy: !0
      },
      {
        pattern: /'(?:\\[\s\S]|[^\\'])*'/,
        alias: "single-quoted-string",
        greedy: !0
      },
      {
        pattern: /"(?:\\[\s\S]|[^\\"])*"/,
        alias: "double-quoted-string",
        greedy: !0,
        inside: {
          interpolation: o
        }
      }
    ];
    e.languages.insertBefore("php", "variable", {
      string: a,
      attribute: {
        pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
        greedy: !0,
        inside: {
          "attribute-content": {
            pattern: /^(#\[)[\s\S]+(?=\]$)/,
            lookbehind: !0,
            // inside can appear subset of php
            inside: {
              comment: t,
              string: a,
              "attribute-class-name": [
                {
                  pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
                  alias: "class-name",
                  greedy: !0,
                  lookbehind: !0
                },
                {
                  pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
                  alias: [
                    "class-name",
                    "class-name-fully-qualified"
                  ],
                  greedy: !0,
                  lookbehind: !0,
                  inside: {
                    punctuation: /\\/
                  }
                }
              ],
              constant: r,
              number: n,
              operator: i,
              punctuation: s
            }
          },
          delimiter: {
            pattern: /^#\[|\]$/,
            alias: "punctuation"
          }
        }
      }
    }), e.hooks.add("before-tokenize", function(l) {
      if (/<\?/.test(l.code)) {
        var u = /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
        e.languages["markup-templating"].buildPlaceholders(l, "php", u);
      }
    }), e.hooks.add("after-tokenize", function(l) {
      e.languages["markup-templating"].tokenizePlaceholders(l, "php");
    });
  }(Prism)), sC;
}
var lC = {}, uC;
function SG() {
  return uC || (uC = 1, Prism.languages.python = {
    comment: {
      pattern: /(^|[^\\])#.*/,
      lookbehind: !0,
      greedy: !0
    },
    "string-interpolation": {
      pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
      greedy: !0,
      inside: {
        interpolation: {
          // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
          pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
          lookbehind: !0,
          inside: {
            "format-spec": {
              pattern: /(:)[^:(){}]+(?=\}$)/,
              lookbehind: !0
            },
            "conversion-option": {
              pattern: /![sra](?=[:}]$)/,
              alias: "punctuation"
            },
            rest: null
          }
        },
        string: /[\s\S]+/
      }
    },
    "triple-quoted-string": {
      pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
      greedy: !0,
      alias: "string"
    },
    string: {
      pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
      greedy: !0
    },
    function: {
      pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
      lookbehind: !0
    },
    "class-name": {
      pattern: /(\bclass\s+)\w+/i,
      lookbehind: !0
    },
    decorator: {
      pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
      lookbehind: !0,
      alias: ["annotation", "punctuation"],
      inside: {
        punctuation: /\./
      }
    },
    keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
    builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
    boolean: /\b(?:False|None|True)\b/,
    number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
    operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
    punctuation: /[{}[\];(),.:]/
  }, Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python, Prism.languages.py = Prism.languages.python), lC;
}
var cC = {}, pC;
function xG() {
  return pC || (pC = 1, Prism.languages.q = {
    string: /"(?:\\.|[^"\\\r\n])*"/,
    comment: [
      // From http://code.kx.com/wiki/Reference/Slash:
      // When / is following a space (or a right parenthesis, bracket, or brace), it is ignored with the rest of the line.
      {
        pattern: /([\t )\]}])\/.*/,
        lookbehind: !0,
        greedy: !0
      },
      // From http://code.kx.com/wiki/Reference/Slash:
      // A line which has / as its first character and contains at least one other non-whitespace character is a whole-line comment and is ignored entirely.
      // A / on a line by itself begins a multiline comment which is terminated by the next \ on a line by itself.
      // If a / is not matched by a \, the multiline comment is unterminated and continues to end of file.
      // The / and \ must be the first char on the line, but may be followed by any amount of whitespace.
      {
        pattern: /(^|\r?\n|\r)\/[\t ]*(?:(?:\r?\n|\r)(?:.*(?:\r?\n|\r(?!\n)))*?(?:\\(?=[\t ]*(?:\r?\n|\r))|$)|\S.*)/,
        lookbehind: !0,
        greedy: !0
      },
      // From http://code.kx.com/wiki/Reference/Slash:
      // A \ on a line by itself with no preceding matching / will comment to end of file.
      {
        pattern: /^\\[\t ]*(?:\r?\n|\r)[\s\S]+/m,
        greedy: !0
      },
      {
        pattern: /^#!.+/m,
        greedy: !0
      }
    ],
    symbol: /`(?::\S+|[\w.]*)/,
    datetime: {
      pattern: /0N[mdzuvt]|0W[dtz]|\d{4}\.\d\d(?:m|\.\d\d(?:T(?:\d\d(?::\d\d(?::\d\d(?:[.:]\d\d\d)?)?)?)?)?[dz]?)|\d\d:\d\d(?::\d\d(?:[.:]\d\d\d)?)?[uvt]?/,
      alias: "number"
    },
    // The negative look-ahead prevents bad highlighting
    // of verbs 0: and 1:
    number: /\b(?![01]:)(?:0N[hje]?|0W[hj]?|0[wn]|0x[\da-fA-F]+|\d+(?:\.\d*)?(?:e[+-]?\d+)?[hjfeb]?)/,
    keyword: /\\\w+\b|\b(?:abs|acos|aj0?|all|and|any|asc|asin|asof|atan|attr|avgs?|binr?|by|ceiling|cols|cor|cos|count|cov|cross|csv|cut|delete|deltas|desc|dev|differ|distinct|div|do|dsave|ej|enlist|eval|except|exec|exit|exp|fby|fills|first|fkeys|flip|floor|from|get|getenv|group|gtime|hclose|hcount|hdel|hopen|hsym|iasc|identity|idesc|if|ij|in|insert|inter|inv|keys?|last|like|list|ljf?|load|log|lower|lsq|ltime|ltrim|mavg|maxs?|mcount|md5|mdev|med|meta|mins?|mmax|mmin|mmu|mod|msum|neg|next|not|null|or|over|parse|peach|pj|plist|prds?|prev|prior|rand|rank|ratios|raze|read0|read1|reciprocal|reval|reverse|rload|rotate|rsave|rtrim|save|scan|scov|sdev|select|set|setenv|show|signum|sin|sqrt|ssr?|string|sublist|sums?|sv|svar|system|tables|tan|til|trim|txf|type|uj|ungroup|union|update|upper|upsert|value|var|views?|vs|wavg|where|while|within|wj1?|wsum|ww|xasc|xbar|xcols?|xdesc|xexp|xgroup|xkey|xlog|xprev|xrank)\b/,
    adverb: {
      pattern: /['\/\\]:?|\beach\b/,
      alias: "function"
    },
    verb: {
      pattern: /(?:\B\.\B|\b[01]:|<[=>]?|>=?|[:+\-*%,!?~=|$&#@^]):?|\b_\b:?/,
      alias: "operator"
    },
    punctuation: /[(){}\[\];.]/
  }), cC;
}
var fC = {}, dC;
function EG() {
  return dC || (dC = 1, function(e) {
    e.languages.ruby = e.languages.extend("clike", {
      comment: {
        pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
        greedy: !0
      },
      "class-name": {
        pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
        lookbehind: !0,
        inside: {
          punctuation: /[.\\]/
        }
      },
      keyword: /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
      operator: /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
      punctuation: /[(){}[\].,;]/
    }), e.languages.insertBefore("ruby", "operator", {
      "double-colon": {
        pattern: /::/,
        alias: "punctuation"
      }
    });
    var t = {
      pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
      lookbehind: !0,
      inside: {
        content: {
          pattern: /^(#\{)[\s\S]+(?=\}$)/,
          lookbehind: !0,
          inside: e.languages.ruby
        },
        delimiter: {
          pattern: /^#\{|\}$/,
          alias: "punctuation"
        }
      }
    };
    delete e.languages.ruby.function;
    var r = "(?:" + [
      /([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
      /\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source,
      /\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source,
      /\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source,
      /<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source
    ].join("|") + ")", n = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/.source;
    e.languages.insertBefore("ruby", "keyword", {
      "regex-literal": [
        {
          pattern: RegExp(/%r/.source + r + /[egimnosux]{0,6}/.source),
          greedy: !0,
          inside: {
            interpolation: t,
            regex: /[\s\S]+/
          }
        },
        {
          pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
          lookbehind: !0,
          greedy: !0,
          inside: {
            interpolation: t,
            regex: /[\s\S]+/
          }
        }
      ],
      variable: /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
      symbol: [
        {
          pattern: RegExp(/(^|[^:]):/.source + n),
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: RegExp(/([\r\n{(,][ \t]*)/.source + n + /(?=:(?!:))/.source),
          lookbehind: !0,
          greedy: !0
        }
      ],
      "method-definition": {
        pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
        lookbehind: !0,
        inside: {
          function: /\b\w+$/,
          keyword: /^self\b/,
          "class-name": /^\w+/,
          punctuation: /\./
        }
      }
    }), e.languages.insertBefore("ruby", "string", {
      "string-literal": [
        {
          pattern: RegExp(/%[qQiIwWs]?/.source + r),
          greedy: !0,
          inside: {
            interpolation: t,
            string: /[\s\S]+/
          }
        },
        {
          pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
          greedy: !0,
          inside: {
            interpolation: t,
            string: /[\s\S]+/
          }
        },
        {
          pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
          alias: "heredoc-string",
          greedy: !0,
          inside: {
            delimiter: {
              pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
              inside: {
                symbol: /\b\w+/,
                punctuation: /^<<[-~]?/
              }
            },
            interpolation: t,
            string: /[\s\S]+/
          }
        },
        {
          pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
          alias: "heredoc-string",
          greedy: !0,
          inside: {
            delimiter: {
              pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
              inside: {
                symbol: /\b\w+/,
                punctuation: /^<<[-~]?'|'$/
              }
            },
            string: /[\s\S]+/
          }
        }
      ],
      "command-literal": [
        {
          pattern: RegExp(/%x/.source + r),
          greedy: !0,
          inside: {
            interpolation: t,
            command: {
              pattern: /[\s\S]+/,
              alias: "string"
            }
          }
        },
        {
          pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
          greedy: !0,
          inside: {
            interpolation: t,
            command: {
              pattern: /[\s\S]+/,
              alias: "string"
            }
          }
        }
      ]
    }), delete e.languages.ruby.string, e.languages.insertBefore("ruby", "number", {
      builtin: /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
      constant: /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
    }), e.languages.rb = e.languages.ruby;
  }(Prism)), fC;
}
var hC = {}, mC;
function _G() {
  return mC || (mC = 1, Prism.languages.scala = Prism.languages.extend("java", {
    "triple-quoted-string": {
      pattern: /"""[\s\S]*?"""/,
      greedy: !0,
      alias: "string"
    },
    string: {
      pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    keyword: /<-|=>|\b(?:abstract|case|catch|class|def|derives|do|else|enum|extends|extension|final|finally|for|forSome|given|if|implicit|import|infix|inline|lazy|match|new|null|object|opaque|open|override|package|private|protected|return|sealed|self|super|this|throw|trait|transparent|try|type|using|val|var|while|with|yield)\b/,
    number: /\b0x(?:[\da-f]*\.)?[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e\d+)?[dfl]?/i,
    builtin: /\b(?:Any|AnyRef|AnyVal|Boolean|Byte|Char|Double|Float|Int|Long|Nothing|Short|String|Unit)\b/,
    symbol: /'[^\d\s\\]\w*/
  }), Prism.languages.insertBefore("scala", "triple-quoted-string", {
    "string-interpolation": {
      pattern: /\b[a-z]\w*(?:"""(?:[^$]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*?"""|"(?:[^$"\r\n]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*")/i,
      greedy: !0,
      inside: {
        id: {
          pattern: /^\w+/,
          greedy: !0,
          alias: "function"
        },
        escape: {
          pattern: /\\\$"|\$[$"]/,
          greedy: !0,
          alias: "symbol"
        },
        interpolation: {
          pattern: /\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
          greedy: !0,
          inside: {
            punctuation: /^\$\{?|\}$/,
            expression: {
              pattern: /[\s\S]+/,
              inside: Prism.languages.scala
            }
          }
        },
        string: /[\s\S]+/
      }
    }
  }), delete Prism.languages.scala["class-name"], delete Prism.languages.scala.function, delete Prism.languages.scala.constant), hC;
}
var gC = {}, yC;
function OG() {
  return yC || (yC = 1, Prism.languages.sql = {
    comment: {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
      lookbehind: !0
    },
    variable: [
      {
        pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
        greedy: !0
      },
      /@[\w.$]+/
    ],
    string: {
      pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
      greedy: !0,
      lookbehind: !0
    },
    identifier: {
      pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
      greedy: !0,
      lookbehind: !0,
      inside: {
        punctuation: /^`|`$/
      }
    },
    function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
    // Should we highlight user defined functions too?
    keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
    boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
    number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
    operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
    punctuation: /[;[\]()`,.]/
  }), gC;
}
var vC = {}, bC;
function kG() {
  return bC || (bC = 1, Prism.languages.swift = {
    comment: {
      // Nested comments are supported up to 2 levels
      pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
      lookbehind: !0,
      greedy: !0
    },
    "string-literal": [
      // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
      {
        pattern: RegExp(
          /(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
            lookbehind: !0,
            inside: null
            // see below
          },
          "interpolation-punctuation": {
            pattern: /^\)|\\\($/,
            alias: "punctuation"
          },
          punctuation: /\\(?=[\r\n])/,
          string: /[\s\S]+/
        }
      },
      {
        pattern: RegExp(
          /(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
            lookbehind: !0,
            inside: null
            // see below
          },
          "interpolation-punctuation": {
            pattern: /^\)|\\#+\($/,
            alias: "punctuation"
          },
          string: /[\s\S]+/
        }
      }
    ],
    directive: {
      // directives with conditions
      pattern: RegExp(
        /#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"
      ),
      alias: "property",
      inside: {
        "directive-name": /^#\w+/,
        boolean: /\b(?:false|true)\b/,
        number: /\b\d+(?:\.\d+)*\b/,
        operator: /!|&&|\|\||[<>]=?/,
        punctuation: /[(),]/
      }
    },
    literal: {
      pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
      alias: "constant"
    },
    "other-directive": {
      pattern: /#\w+\b/,
      alias: "property"
    },
    attribute: {
      pattern: /@\w+/,
      alias: "atrule"
    },
    "function-definition": {
      pattern: /(\bfunc\s+)\w+/,
      lookbehind: !0,
      alias: "function"
    },
    label: {
      // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
      pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
      lookbehind: !0,
      alias: "important"
    },
    keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
    boolean: /\b(?:false|true)\b/,
    nil: {
      pattern: /\bnil\b/,
      alias: "constant"
    },
    "short-argument": /\$\d+\b/,
    omit: {
      pattern: /\b_\b/,
      alias: "keyword"
    },
    number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
    // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
    "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
    // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
    // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
    // This regex only supports ASCII operators.
    operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
    punctuation: /[{}[\]();,.:\\]/
  }, Prism.languages.swift["string-literal"].forEach(function(e) {
    e.inside.interpolation.inside = Prism.languages.swift;
  })), vC;
}
var wC = {}, SC;
function AG() {
  return SC || (SC = 1, function(e) {
    var t = /[*&][^\s[\]{},]+/, r = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/, n = "(?:" + r.source + "(?:[ 	]+" + t.source + ")?|" + t.source + "(?:[ 	]+" + r.source + ")?)", i = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
      return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
    }), s = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
    function o(a, l) {
      l = (l || "").replace(/m/g, "") + "m";
      var u = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
        return n;
      }).replace(/<<value>>/g, function() {
        return a;
      });
      return RegExp(u, l);
    }
    e.languages.yaml = {
      scalar: {
        pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
          return n;
        })),
        lookbehind: !0,
        alias: "string"
      },
      comment: /#.*/,
      key: {
        pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
          return n;
        }).replace(/<<key>>/g, function() {
          return "(?:" + i + "|" + s + ")";
        })),
        lookbehind: !0,
        greedy: !0,
        alias: "atrule"
      },
      directive: {
        pattern: /(^[ \t]*)%.+/m,
        lookbehind: !0,
        alias: "important"
      },
      datetime: {
        pattern: o(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
        lookbehind: !0,
        alias: "number"
      },
      boolean: {
        pattern: o(/false|true/.source, "i"),
        lookbehind: !0,
        alias: "important"
      },
      null: {
        pattern: o(/null|~/.source, "i"),
        lookbehind: !0,
        alias: "important"
      },
      string: {
        pattern: o(s),
        lookbehind: !0,
        greedy: !0
      },
      number: {
        pattern: o(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"),
        lookbehind: !0
      },
      tag: r,
      important: t,
      punctuation: /---|[:[\]{}\-,|>?]|\.\.\./
    }, e.languages.yml = e.languages.yaml;
  }(Prism)), wC;
}
var xC = {}, EC;
function PG() {
  return EC || (EC = 1, Prism.languages.csv = {
    value: /[^\r\n,"]+|"(?:[^"]|"")*"(?!")/,
    punctuation: /,/
  }), xC;
}
var Ub = { exports: {} };
/*!***************************************************
* mark.js v8.11.1
* https://markjs.io/
* Copyright (c) 20142018, Julian Khnel
* Released under the MIT license https://git.io/vwTVl
*****************************************************/
var _C;
function TG() {
  return _C || (_C = 1, function(e, t) {
    (function(r, n) {
      e.exports = n();
    })(ft, function() {
      var r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(u) {
        return typeof u;
      } : function(u) {
        return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u;
      }, n = function(u, f) {
        if (!(u instanceof f))
          throw new TypeError("Cannot call a class as a function");
      }, i = /* @__PURE__ */ function() {
        function u(f, d) {
          for (var m = 0; m < d.length; m++) {
            var v = d[m];
            v.enumerable = v.enumerable || !1, v.configurable = !0, "value" in v && (v.writable = !0), Object.defineProperty(f, v.key, v);
          }
        }
        return function(f, d, m) {
          return d && u(f.prototype, d), m && u(f, m), f;
        };
      }(), s = Object.assign || function(u) {
        for (var f = 1; f < arguments.length; f++) {
          var d = arguments[f];
          for (var m in d)
            Object.prototype.hasOwnProperty.call(d, m) && (u[m] = d[m]);
        }
        return u;
      }, o = function() {
        function u(f) {
          var d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, m = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5e3;
          n(this, u), this.ctx = f, this.iframes = d, this.exclude = m, this.iframesTimeout = v;
        }
        return i(u, [{
          key: "getContexts",
          value: function() {
            var d = void 0, m = [];
            return typeof this.ctx > "u" || !this.ctx ? d = [] : NodeList.prototype.isPrototypeOf(this.ctx) ? d = Array.prototype.slice.call(this.ctx) : Array.isArray(this.ctx) ? d = this.ctx : typeof this.ctx == "string" ? d = Array.prototype.slice.call(document.querySelectorAll(this.ctx)) : d = [this.ctx], d.forEach(function(v) {
              var S = m.filter(function(y) {
                return y.contains(v);
              }).length > 0;
              m.indexOf(v) === -1 && !S && m.push(v);
            }), m;
          }
        }, {
          key: "getIframeContents",
          value: function(d, m) {
            var v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
            }, S = void 0;
            try {
              var y = d.contentWindow;
              if (S = y.document, !y || !S)
                throw new Error("iframe inaccessible");
            } catch {
              v();
            }
            S && m(S);
          }
        }, {
          key: "isIframeBlank",
          value: function(d) {
            var m = "about:blank", v = d.getAttribute("src").trim(), S = d.contentWindow.location.href;
            return S === m && v !== m && v;
          }
        }, {
          key: "observeIframeLoad",
          value: function(d, m, v) {
            var S = this, y = !1, E = null, x = function g() {
              if (!y) {
                y = !0, clearTimeout(E);
                try {
                  S.isIframeBlank(d) || (d.removeEventListener("load", g), S.getIframeContents(d, m, v));
                } catch {
                  v();
                }
              }
            };
            d.addEventListener("load", x), E = setTimeout(x, this.iframesTimeout);
          }
        }, {
          key: "onIframeReady",
          value: function(d, m, v) {
            try {
              d.contentWindow.document.readyState === "complete" ? this.isIframeBlank(d) ? this.observeIframeLoad(d, m, v) : this.getIframeContents(d, m, v) : this.observeIframeLoad(d, m, v);
            } catch {
              v();
            }
          }
        }, {
          key: "waitForIframes",
          value: function(d, m) {
            var v = this, S = 0;
            this.forEachIframe(d, function() {
              return !0;
            }, function(y) {
              S++, v.waitForIframes(y.querySelector("html"), function() {
                --S || m();
              });
            }, function(y) {
              y || m();
            });
          }
        }, {
          key: "forEachIframe",
          value: function(d, m, v) {
            var S = this, y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function() {
            }, E = d.querySelectorAll("iframe"), x = E.length, g = 0;
            E = Array.prototype.slice.call(E);
            var b = function() {
              --x <= 0 && y(g);
            };
            x || b(), E.forEach(function(A) {
              u.matches(A, S.exclude) ? b() : S.onIframeReady(A, function(P) {
                m(A) && (g++, v(P)), b();
              }, b);
            });
          }
        }, {
          key: "createIterator",
          value: function(d, m, v) {
            return document.createNodeIterator(d, m, v, !1);
          }
        }, {
          key: "createInstanceOnIframe",
          value: function(d) {
            return new u(d.querySelector("html"), this.iframes);
          }
        }, {
          key: "compareNodeIframe",
          value: function(d, m, v) {
            var S = d.compareDocumentPosition(v), y = Node.DOCUMENT_POSITION_PRECEDING;
            if (S & y)
              if (m !== null) {
                var E = m.compareDocumentPosition(v), x = Node.DOCUMENT_POSITION_FOLLOWING;
                if (E & x)
                  return !0;
              } else
                return !0;
            return !1;
          }
        }, {
          key: "getIteratorNode",
          value: function(d) {
            var m = d.previousNode(), v = void 0;
            return m === null ? v = d.nextNode() : v = d.nextNode() && d.nextNode(), {
              prevNode: m,
              node: v
            };
          }
        }, {
          key: "checkIframeFilter",
          value: function(d, m, v, S) {
            var y = !1, E = !1;
            return S.forEach(function(x, g) {
              x.val === v && (y = g, E = x.handled);
            }), this.compareNodeIframe(d, m, v) ? (y === !1 && !E ? S.push({
              val: v,
              handled: !0
            }) : y !== !1 && !E && (S[y].handled = !0), !0) : (y === !1 && S.push({
              val: v,
              handled: !1
            }), !1);
          }
        }, {
          key: "handleOpenIframes",
          value: function(d, m, v, S) {
            var y = this;
            d.forEach(function(E) {
              E.handled || y.getIframeContents(E.val, function(x) {
                y.createInstanceOnIframe(x).forEachNode(m, v, S);
              });
            });
          }
        }, {
          key: "iterateThroughNodes",
          value: function(d, m, v, S, y) {
            for (var E = this, x = this.createIterator(m, d, S), g = [], b = [], A = void 0, P = void 0, k = function() {
              var I = E.getIteratorNode(x);
              return P = I.prevNode, A = I.node, A;
            }; k(); )
              this.iframes && this.forEachIframe(m, function($) {
                return E.checkIframeFilter(A, P, $, g);
              }, function($) {
                E.createInstanceOnIframe($).forEachNode(d, function(I) {
                  return b.push(I);
                }, S);
              }), b.push(A);
            b.forEach(function($) {
              v($);
            }), this.iframes && this.handleOpenIframes(g, d, v, S), y();
          }
        }, {
          key: "forEachNode",
          value: function(d, m, v) {
            var S = this, y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function() {
            }, E = this.getContexts(), x = E.length;
            x || y(), E.forEach(function(g) {
              var b = function() {
                S.iterateThroughNodes(d, g, m, v, function() {
                  --x <= 0 && y();
                });
              };
              S.iframes ? S.waitForIframes(g, b) : b();
            });
          }
        }], [{
          key: "matches",
          value: function(d, m) {
            var v = typeof m == "string" ? [m] : m, S = d.matches || d.matchesSelector || d.msMatchesSelector || d.mozMatchesSelector || d.oMatchesSelector || d.webkitMatchesSelector;
            if (S) {
              var y = !1;
              return v.every(function(E) {
                return S.call(d, E) ? (y = !0, !1) : !0;
              }), y;
            } else
              return !1;
          }
        }]), u;
      }(), a = function() {
        function u(f) {
          n(this, u), this.ctx = f, this.ie = !1;
          var d = window.navigator.userAgent;
          (d.indexOf("MSIE") > -1 || d.indexOf("Trident") > -1) && (this.ie = !0);
        }
        return i(u, [{
          key: "log",
          value: function(d) {
            var m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "debug", v = this.opt.log;
            this.opt.debug && (typeof v > "u" ? "undefined" : r(v)) === "object" && typeof v[m] == "function" && v[m]("mark.js: " + d);
          }
        }, {
          key: "escapeStr",
          value: function(d) {
            return d.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
          }
        }, {
          key: "createRegExp",
          value: function(d) {
            return this.opt.wildcards !== "disabled" && (d = this.setupWildcardsRegExp(d)), d = this.escapeStr(d), Object.keys(this.opt.synonyms).length && (d = this.createSynonymsRegExp(d)), (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) && (d = this.setupIgnoreJoinersRegExp(d)), this.opt.diacritics && (d = this.createDiacriticsRegExp(d)), d = this.createMergedBlanksRegExp(d), (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) && (d = this.createJoinersRegExp(d)), this.opt.wildcards !== "disabled" && (d = this.createWildcardsRegExp(d)), d = this.createAccuracyRegExp(d), d;
          }
        }, {
          key: "createSynonymsRegExp",
          value: function(d) {
            var m = this.opt.synonyms, v = this.opt.caseSensitive ? "" : "i", S = this.opt.ignoreJoiners || this.opt.ignorePunctuation.length ? "\0" : "";
            for (var y in m)
              if (m.hasOwnProperty(y)) {
                var E = m[y], x = this.opt.wildcards !== "disabled" ? this.setupWildcardsRegExp(y) : this.escapeStr(y), g = this.opt.wildcards !== "disabled" ? this.setupWildcardsRegExp(E) : this.escapeStr(E);
                x !== "" && g !== "" && (d = d.replace(new RegExp("(" + this.escapeStr(x) + "|" + this.escapeStr(g) + ")", "gm" + v), S + ("(" + this.processSynomyms(x) + "|") + (this.processSynomyms(g) + ")") + S));
              }
            return d;
          }
        }, {
          key: "processSynomyms",
          value: function(d) {
            return (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) && (d = this.setupIgnoreJoinersRegExp(d)), d;
          }
        }, {
          key: "setupWildcardsRegExp",
          value: function(d) {
            return d = d.replace(/(?:\\)*\?/g, function(m) {
              return m.charAt(0) === "\\" ? "?" : "";
            }), d.replace(/(?:\\)*\*/g, function(m) {
              return m.charAt(0) === "\\" ? "*" : "";
            });
          }
        }, {
          key: "createWildcardsRegExp",
          value: function(d) {
            var m = this.opt.wildcards === "withSpaces";
            return d.replace(/\u0001/g, m ? "[\\S\\s]?" : "\\S?").replace(/\u0002/g, m ? "[\\S\\s]*?" : "\\S*");
          }
        }, {
          key: "setupIgnoreJoinersRegExp",
          value: function(d) {
            return d.replace(/[^(|)\\]/g, function(m, v, S) {
              var y = S.charAt(v + 1);
              return /[(|)\\]/.test(y) || y === "" ? m : m + "\0";
            });
          }
        }, {
          key: "createJoinersRegExp",
          value: function(d) {
            var m = [], v = this.opt.ignorePunctuation;
            return Array.isArray(v) && v.length && m.push(this.escapeStr(v.join(""))), this.opt.ignoreJoiners && m.push("\\u00ad\\u200b\\u200c\\u200d"), m.length ? d.split(/\u0000+/).join("[" + m.join("") + "]*") : d;
          }
        }, {
          key: "createDiacriticsRegExp",
          value: function(d) {
            var m = this.opt.caseSensitive ? "" : "i", v = this.opt.caseSensitive ? ["a", "A", "c", "C", "d", "D", "e", "E", "i", "I", "l", "L", "n", "N", "o", "O", "r", "R", "s", "S", "t", "T", "u", "U", "y", "Y", "z", "Z"] : ["aA", "cC", "dD", "eE", "iI", "lL", "nN", "oO", "rR", "sS", "tT", "uU", "yY", "zZ"], S = [];
            return d.split("").forEach(function(y) {
              v.every(function(E) {
                if (E.indexOf(y) !== -1) {
                  if (S.indexOf(E) > -1)
                    return !1;
                  d = d.replace(new RegExp("[" + E + "]", "gm" + m), "[" + E + "]"), S.push(E);
                }
                return !0;
              });
            }), d;
          }
        }, {
          key: "createMergedBlanksRegExp",
          value: function(d) {
            return d.replace(/[\s]+/gmi, "[\\s]+");
          }
        }, {
          key: "createAccuracyRegExp",
          value: function(d) {
            var m = this, v = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~", S = this.opt.accuracy, y = typeof S == "string" ? S : S.value, E = typeof S == "string" ? [] : S.limiters, x = "";
            switch (E.forEach(function(g) {
              x += "|" + m.escapeStr(g);
            }), y) {
              case "partially":
              default:
                return "()(" + d + ")";
              case "complementary":
                return x = "\\s" + (x || this.escapeStr(v)), "()([^" + x + "]*" + d + "[^" + x + "]*)";
              case "exactly":
                return "(^|\\s" + x + ")(" + d + ")(?=$|\\s" + x + ")";
            }
          }
        }, {
          key: "getSeparatedKeywords",
          value: function(d) {
            var m = this, v = [];
            return d.forEach(function(S) {
              m.opt.separateWordSearch ? S.split(" ").forEach(function(y) {
                y.trim() && v.indexOf(y) === -1 && v.push(y);
              }) : S.trim() && v.indexOf(S) === -1 && v.push(S);
            }), {
              keywords: v.sort(function(S, y) {
                return y.length - S.length;
              }),
              length: v.length
            };
          }
        }, {
          key: "isNumeric",
          value: function(d) {
            return Number(parseFloat(d)) == d;
          }
        }, {
          key: "checkRanges",
          value: function(d) {
            var m = this;
            if (!Array.isArray(d) || Object.prototype.toString.call(d[0]) !== "[object Object]")
              return this.log("markRanges() will only accept an array of objects"), this.opt.noMatch(d), [];
            var v = [], S = 0;
            return d.sort(function(y, E) {
              return y.start - E.start;
            }).forEach(function(y) {
              var E = m.callNoMatchOnInvalidRanges(y, S), x = E.start, g = E.end, b = E.valid;
              b && (y.start = x, y.length = g - x, v.push(y), S = g);
            }), v;
          }
        }, {
          key: "callNoMatchOnInvalidRanges",
          value: function(d, m) {
            var v = void 0, S = void 0, y = !1;
            return d && typeof d.start < "u" ? (v = parseInt(d.start, 10), S = v + parseInt(d.length, 10), this.isNumeric(d.start) && this.isNumeric(d.length) && S - m > 0 && S - v > 0 ? y = !0 : (this.log("Ignoring invalid or overlapping range: " + ("" + JSON.stringify(d))), this.opt.noMatch(d))) : (this.log("Ignoring invalid range: " + JSON.stringify(d)), this.opt.noMatch(d)), {
              start: v,
              end: S,
              valid: y
            };
          }
        }, {
          key: "checkWhitespaceRanges",
          value: function(d, m, v) {
            var S = void 0, y = !0, E = v.length, x = m - E, g = parseInt(d.start, 10) - x;
            return g = g > E ? E : g, S = g + parseInt(d.length, 10), S > E && (S = E, this.log("End range automatically set to the max value of " + E)), g < 0 || S - g < 0 || g > E || S > E ? (y = !1, this.log("Invalid range: " + JSON.stringify(d)), this.opt.noMatch(d)) : v.substring(g, S).replace(/\s+/g, "") === "" && (y = !1, this.log("Skipping whitespace only range: " + JSON.stringify(d)), this.opt.noMatch(d)), {
              start: g,
              end: S,
              valid: y
            };
          }
        }, {
          key: "getTextNodes",
          value: function(d) {
            var m = this, v = "", S = [];
            this.iterator.forEachNode(NodeFilter.SHOW_TEXT, function(y) {
              S.push({
                start: v.length,
                end: (v += y.textContent).length,
                node: y
              });
            }, function(y) {
              return m.matchesExclude(y.parentNode) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
            }, function() {
              d({
                value: v,
                nodes: S
              });
            });
          }
        }, {
          key: "matchesExclude",
          value: function(d) {
            return o.matches(d, this.opt.exclude.concat(["script", "style", "title", "head", "html"]));
          }
        }, {
          key: "wrapRangeInTextNode",
          value: function(d, m, v) {
            var S = this.opt.element ? this.opt.element : "mark", y = d.splitText(m), E = y.splitText(v - m), x = document.createElement(S);
            return x.setAttribute("data-markjs", "true"), this.opt.className && x.setAttribute("class", this.opt.className), x.textContent = y.textContent, y.parentNode.replaceChild(x, y), E;
          }
        }, {
          key: "wrapRangeInMappedTextNode",
          value: function(d, m, v, S, y) {
            var E = this;
            d.nodes.every(function(x, g) {
              var b = d.nodes[g + 1];
              if (typeof b > "u" || b.start > m) {
                if (!S(x.node))
                  return !1;
                var A = m - x.start, P = (v > x.end ? x.end : v) - x.start, k = d.value.substr(0, x.start), $ = d.value.substr(P + x.start);
                if (x.node = E.wrapRangeInTextNode(x.node, A, P), d.value = k + $, d.nodes.forEach(function(I, F) {
                  F >= g && (d.nodes[F].start > 0 && F !== g && (d.nodes[F].start -= P), d.nodes[F].end -= P);
                }), v -= P, y(x.node.previousSibling, x.start), v > x.end)
                  m = x.end;
                else
                  return !1;
              }
              return !0;
            });
          }
        }, {
          key: "wrapMatches",
          value: function(d, m, v, S, y) {
            var E = this, x = m === 0 ? 0 : m + 1;
            this.getTextNodes(function(g) {
              g.nodes.forEach(function(b) {
                b = b.node;
                for (var A = void 0; (A = d.exec(b.textContent)) !== null && A[x] !== ""; )
                  if (v(A[x], b)) {
                    var P = A.index;
                    if (x !== 0)
                      for (var k = 1; k < x; k++)
                        P += A[k].length;
                    b = E.wrapRangeInTextNode(b, P, P + A[x].length), S(b.previousSibling), d.lastIndex = 0;
                  }
              }), y();
            });
          }
        }, {
          key: "wrapMatchesAcrossElements",
          value: function(d, m, v, S, y) {
            var E = this, x = m === 0 ? 0 : m + 1;
            this.getTextNodes(function(g) {
              for (var b = void 0; (b = d.exec(g.value)) !== null && b[x] !== ""; ) {
                var A = b.index;
                if (x !== 0)
                  for (var P = 1; P < x; P++)
                    A += b[P].length;
                var k = A + b[x].length;
                E.wrapRangeInMappedTextNode(g, A, k, function($) {
                  return v(b[x], $);
                }, function($, I) {
                  d.lastIndex = I, S($);
                });
              }
              y();
            });
          }
        }, {
          key: "wrapRangeFromIndex",
          value: function(d, m, v, S) {
            var y = this;
            this.getTextNodes(function(E) {
              var x = E.value.length;
              d.forEach(function(g, b) {
                var A = y.checkWhitespaceRanges(g, x, E.value), P = A.start, k = A.end, $ = A.valid;
                $ && y.wrapRangeInMappedTextNode(E, P, k, function(I) {
                  return m(I, g, E.value.substring(P, k), b);
                }, function(I) {
                  v(I, g);
                });
              }), S();
            });
          }
        }, {
          key: "unwrapMatches",
          value: function(d) {
            for (var m = d.parentNode, v = document.createDocumentFragment(); d.firstChild; )
              v.appendChild(d.removeChild(d.firstChild));
            m.replaceChild(v, d), this.ie ? this.normalizeTextNode(m) : m.normalize();
          }
        }, {
          key: "normalizeTextNode",
          value: function(d) {
            if (d) {
              if (d.nodeType === 3)
                for (; d.nextSibling && d.nextSibling.nodeType === 3; )
                  d.nodeValue += d.nextSibling.nodeValue, d.parentNode.removeChild(d.nextSibling);
              else
                this.normalizeTextNode(d.firstChild);
              this.normalizeTextNode(d.nextSibling);
            }
          }
        }, {
          key: "markRegExp",
          value: function(d, m) {
            var v = this;
            this.opt = m, this.log('Searching with expression "' + d + '"');
            var S = 0, y = "wrapMatches", E = function(g) {
              S++, v.opt.each(g);
            };
            this.opt.acrossElements && (y = "wrapMatchesAcrossElements"), this[y](d, this.opt.ignoreGroups, function(x, g) {
              return v.opt.filter(g, x, S);
            }, E, function() {
              S === 0 && v.opt.noMatch(d), v.opt.done(S);
            });
          }
        }, {
          key: "mark",
          value: function(d, m) {
            var v = this;
            this.opt = m;
            var S = 0, y = "wrapMatches", E = this.getSeparatedKeywords(typeof d == "string" ? [d] : d), x = E.keywords, g = E.length, b = this.opt.caseSensitive ? "" : "i", A = function P(k) {
              var $ = new RegExp(v.createRegExp(k), "gm" + b), I = 0;
              v.log('Searching with expression "' + $ + '"'), v[y]($, 1, function(F, L) {
                return v.opt.filter(L, k, S, I);
              }, function(F) {
                I++, S++, v.opt.each(F);
              }, function() {
                I === 0 && v.opt.noMatch(k), x[g - 1] === k ? v.opt.done(S) : P(x[x.indexOf(k) + 1]);
              });
            };
            this.opt.acrossElements && (y = "wrapMatchesAcrossElements"), g === 0 ? this.opt.done(S) : A(x[0]);
          }
        }, {
          key: "markRanges",
          value: function(d, m) {
            var v = this;
            this.opt = m;
            var S = 0, y = this.checkRanges(d);
            y && y.length ? (this.log("Starting to mark with the following ranges: " + JSON.stringify(y)), this.wrapRangeFromIndex(y, function(E, x, g, b) {
              return v.opt.filter(E, x, g, b);
            }, function(E, x) {
              S++, v.opt.each(E, x);
            }, function() {
              v.opt.done(S);
            })) : this.opt.done(S);
          }
        }, {
          key: "unmark",
          value: function(d) {
            var m = this;
            this.opt = d;
            var v = this.opt.element ? this.opt.element : "*";
            v += "[data-markjs]", this.opt.className && (v += "." + this.opt.className), this.log('Removal selector "' + v + '"'), this.iterator.forEachNode(NodeFilter.SHOW_ELEMENT, function(S) {
              m.unwrapMatches(S);
            }, function(S) {
              var y = o.matches(S, v), E = m.matchesExclude(S);
              return !y || E ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
            }, this.opt.done);
          }
        }, {
          key: "opt",
          set: function(d) {
            this._opt = s({}, {
              element: "",
              className: "",
              exclude: [],
              iframes: !1,
              iframesTimeout: 5e3,
              separateWordSearch: !0,
              diacritics: !0,
              synonyms: {},
              accuracy: "partially",
              acrossElements: !1,
              caseSensitive: !1,
              ignoreJoiners: !1,
              ignoreGroups: 0,
              ignorePunctuation: [],
              wildcards: "disabled",
              each: function() {
              },
              noMatch: function() {
              },
              filter: function() {
                return !0;
              },
              done: function() {
              },
              debug: !1,
              log: window.console
            }, d);
          },
          get: function() {
            return this._opt;
          }
        }, {
          key: "iterator",
          get: function() {
            return new o(this.ctx, this.opt.iframes, this.opt.exclude, this.opt.iframesTimeout);
          }
        }]), u;
      }();
      function l(u) {
        var f = this, d = new a(u);
        return this.mark = function(m, v) {
          return d.mark(m, v), f;
        }, this.markRegExp = function(m, v) {
          return d.markRegExp(m, v), f;
        }, this.markRanges = function(m, v) {
          return d.markRanges(m, v), f;
        }, this.unmark = function(m) {
          return d.unmark(m), f;
        }, this;
      }
      return l;
    });
  }(Ub)), Ub.exports;
}
function fc(e) {
  return e < 10 ? "0" + e : e;
}
function CG(e, t, r, n) {
  var i = r ? "" : e.getUTCFullYear() + "-" + fc(e.getUTCMonth() + 1) + "-" + fc(e.getUTCDate());
  return t || (i += "T" + fc(e.getUTCHours()) + ":" + fc(e.getUTCMinutes()) + ":" + fc(e.getUTCSeconds()) + "Z"), i;
}
function BL(e, t) {
  return t > e.length ? e.repeat(Math.trunc(t / e.length) + 1).substring(0, t) : e;
}
function Qm(...e) {
  const t = (r) => r && typeof r == "object";
  return e.reduce((r, n) => (Object.keys(n || {}).forEach((i) => {
    const s = r[i], o = n[i];
    t(s) && t(o) ? r[i] = Qm(s, o) : r[i] = o;
  }), r), Array.isArray(e[e.length - 1]) ? [] : {});
}
function $G(e) {
  var t = IG(e), r = NG(t, t, t, t), n = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (i) => {
    var s = r() * 16 % 16 | 0;
    return (i == "x" ? s : s & 3 | 8).toString(16);
  });
  return n;
}
function Vb(e) {
  return {
    value: e === "object" ? {} : e === "array" ? [] : void 0
  };
}
function Do(e, t) {
  t && e.pop();
}
function RG(e) {
  var t, r, n, i, s;
  return {
    name: ((t = e == null ? void 0 : e.xml) == null ? void 0 : t.name) || "",
    prefix: ((r = e == null ? void 0 : e.xml) == null ? void 0 : r.prefix) || "",
    namespace: ((n = e == null ? void 0 : e.xml) == null ? void 0 : n.namespace) || null,
    attribute: ((i = e == null ? void 0 : e.xml) == null ? void 0 : i.attribute) ?? !1,
    wrapped: ((s = e == null ? void 0 : e.xml) == null ? void 0 : s.wrapped) ?? !1
  };
}
function Ym(e, t = {}, r = {}) {
  var m, v;
  const { value: n } = e, { propertyName: i } = r, { name: s, prefix: o, namespace: a, attribute: l, wrapped: u } = RG(t);
  let f = s || i ? `${o ? o + ":" : ""}${s || i}` : null, d = typeof n == "object" ? Array.isArray(n) ? [...n] : { ...n } : n;
  return l && f && (f = `$${f}`), a && (typeof d == "object" ? d[`$xmlns${o ? ":" + o : ""}`] = a : d = { [`$xmlns${o ? ":" + o : ""}`]: a, "#text": d }), t.type === "array" && (u && Array.isArray(d) && (d = { [f]: [...d] }), u || (f = null), t.example !== void 0 && !u && (f = ((v = (m = t.items) == null ? void 0 : m.xml) == null ? void 0 : v.name) || f)), (t.oneOf || t.anyOf || t.allOf || t.$ref) && (f = null), {
    propertyName: f,
    value: d
  };
}
function IG(e) {
  var t = 0;
  if (e.length == 0) return t;
  for (var r = 0; r < e.length; r++) {
    var n = e.charCodeAt(r);
    t = (t << 5) - t + n, t = t & t;
  }
  return t;
}
function NG(e, t, r, n) {
  return function() {
    e |= 0, t |= 0, r |= 0, n |= 0;
    var i = e - (t << 27 | t >>> 5) | 0;
    return e = t ^ (r << 17 | r >>> 15), t = r + n | 0, r = n + i | 0, n = e + i | 0, (n >>> 0) / 4294967296;
  };
}
function jG(e, t, r, n, i) {
  let s = Zn(e, r, n);
  const o = [];
  for (let a of t) {
    const { type: l, readOnly: u, writeOnly: f, value: d } = Zn({ type: s.type, ...a }, r, n, i);
    s.type && l && l !== s.type && (console.warn("allOf: schemas with different types can't be merged"), s.type = l), s.type = s.type || l, s.readOnly = s.readOnly || u, s.writeOnly = s.writeOnly || f, d != null && o.push(d);
  }
  if (s.type === "object")
    return s.value = Qm(s.value || {}, ...o.filter((a) => typeof a == "object")), s;
  {
    s.type === "array" && (r.quiet || console.warn('OpenAPI Sampler: found allOf with "array" type. Result may be incorrect'));
    const a = o[o.length - 1];
    return s.value = a ?? s.value, s;
  }
}
const OC = {
  multipleOf: "number",
  maximum: "number",
  exclusiveMaximum: "number",
  minimum: "number",
  exclusiveMinimum: "number",
  maxLength: "string",
  minLength: "string",
  pattern: "string",
  items: "array",
  maxItems: "array",
  minItems: "array",
  uniqueItems: "array",
  additionalItems: "array",
  maxProperties: "object",
  minProperties: "object",
  required: "object",
  additionalProperties: "object",
  properties: "object",
  patternProperties: "object",
  dependencies: "object"
};
function xc(e) {
  if (e.type !== void 0)
    return Array.isArray(e.type) ? e.type.length === 0 ? null : e.type[0] : e.type;
  const t = Object.keys(OC);
  for (var r = 0; r < t.length; r++) {
    let n = t[r], i = OC[n];
    if (e[n] !== void 0)
      return i;
  }
  return null;
}
var LG = qL();
const MG = /* @__PURE__ */ og(LG);
let Jh = {}, Yn = [];
function DG() {
  Jh = {}, Yn = [];
}
function UL(e) {
  let t;
  return e.const !== void 0 ? t = e.const : e.examples !== void 0 && e.examples.length ? t = e.examples[0] : e.enum !== void 0 && e.enum.length ? t = e.enum[0] : e.default !== void 0 && (t = e.default), t;
}
function kC(e) {
  const t = UL(e);
  if (t !== void 0)
    return {
      value: t,
      readOnly: e.readOnly,
      writeOnly: e.writeOnly,
      type: null
    };
}
function Zn(e, t, r, n) {
  if (n) {
    if (Yn.includes(e)) return Vb(xc(e));
    Yn.push(e);
  }
  if (n && n.depth > t.maxSampleDepth)
    return Do(Yn, n), Vb(xc(e));
  if (e.$ref) {
    if (!r)
      throw new Error("Your schema contains $ref. You must provide full specification in the third parameter.");
    let a = decodeURIComponent(e.$ref);
    a.startsWith("#") && (a = a.substring(1));
    const l = MG.get(r, a);
    let u;
    if (Jh[a] !== !0) {
      Jh[a] = !0;
      const f = Zn(l, t, r, n);
      if (t.format === "xml") {
        const { propertyName: d, value: m } = Ym(f, l, n);
        u = { ...f, value: { [d || "root"]: m } };
      } else
        u = f;
      Jh[a] = !1;
    } else {
      const f = xc(l);
      u = Vb(f);
    }
    return Do(Yn, n), u;
  }
  if (e.example !== void 0)
    return Do(Yn, n), {
      value: e.example,
      readOnly: e.readOnly,
      writeOnly: e.writeOnly,
      type: e.type
    };
  if (e.allOf !== void 0)
    return Do(Yn, n), kC(e) || jG(
      { ...e, allOf: void 0 },
      e.allOf,
      t,
      r,
      n
    );
  if (e.oneOf && e.oneOf.length) {
    e.anyOf && (t.quiet || console.warn("oneOf and anyOf are not supported on the same level. Skipping anyOf")), Do(Yn, n);
    const a = Object.assign({
      readOnly: e.readOnly,
      writeOnly: e.writeOnly
    }, e.oneOf[0]);
    return o(e, a);
  }
  if (e.anyOf && e.anyOf.length) {
    Do(Yn, n);
    const a = Object.assign({
      readOnly: e.readOnly,
      writeOnly: e.writeOnly
    }, e.anyOf[0]);
    return o(e, a);
  }
  if (e.if && e.then) {
    Do(Yn, n);
    const { if: a, then: l, ...u } = e;
    return Zn(Qm(u, a, l), t, r, n);
  }
  let i = UL(e), s = null;
  if (i === void 0) {
    i = null, s = e.type, Array.isArray(s) && e.type.length > 0 && (s = e.type[0]), s || (s = xc(e));
    let a = k1[s];
    a && (i = a(e, t, r, n));
  }
  return Do(Yn, n), {
    value: i,
    readOnly: e.readOnly,
    writeOnly: e.writeOnly,
    type: s
  };
  function o(a, l) {
    const u = kC(a);
    if (u !== void 0)
      return u;
    const f = Zn({ ...a, oneOf: void 0, anyOf: void 0 }, t, r, n), d = Zn(l, t, r, n);
    if (typeof f.value == "object" && typeof d.value == "object") {
      const m = Qm(f.value, d.value);
      return { ...d, value: m };
    }
    return d;
  }
}
function FG(e, t = {}, r, n) {
  const i = n && n.depth || 1;
  let s = Math.min(e.maxItems != null ? e.maxItems : 1 / 0, e.minItems || 1);
  const o = e.prefixItems || e.items || e.contains;
  Array.isArray(o) && (s = Math.max(s, o.length));
  let a = (u) => Array.isArray(o) ? o[u] || {} : o || {}, l = [];
  if (!o) return l;
  for (let u = 0; u < s; u++) {
    let f = a(u), { value: d } = Zn(f, t, r, { depth: i + 1 });
    if ((t == null ? void 0 : t.format) === "xml") {
      const { value: m, propertyName: v } = Ym({ value: d }, f, n);
      v ? (l != null && l[v] || (l = { ...l, [v]: [] }), l[v].push(m)) : l = { ...l, ...m };
    } else
      l.push(d);
  }
  if ((t == null ? void 0 : t.format) === "xml" && i === 1) {
    const { value: u, propertyName: f } = Ym({ value: null }, e, n);
    f && (u ? l = Array.isArray(l) ? { [f]: { ...u, ...l.map((d) => ({ "#text": { ...d } })) } } : { [f]: { ...l, ...u } } : l = { [f]: l });
  }
  return l;
}
function zG(e) {
  return !0;
}
function VL(e) {
  let t = 0;
  if (e.type === "number" && (e.format === "float" || e.format === "double") && (t = 0.1), typeof e.exclusiveMinimum == "boolean" || typeof e.exclusiveMaximum == "boolean") {
    if (e.maximum && e.minimum)
      return t = e.exclusiveMinimum ? Math.floor(e.minimum) + 1 : e.minimum, (e.exclusiveMaximum && t >= e.maximum || !e.exclusiveMaximum && t > e.maximum) && (t = (e.maximum + e.minimum) / 2), t;
    if (e.minimum)
      return e.exclusiveMinimum ? Math.floor(e.minimum) + 1 : e.minimum;
    if (e.maximum)
      return e.exclusiveMaximum ? e.maximum > 0 ? 0 : Math.floor(e.maximum) - 1 : e.maximum > 0 ? 0 : e.maximum;
  } else {
    if (e.minimum)
      return e.minimum;
    e.exclusiveMinimum ? (t = Math.floor(e.exclusiveMinimum) + 1, t === e.exclusiveMaximum && (t = (t + Math.floor(e.exclusiveMaximum) - 1) / 2)) : e.exclusiveMaximum ? t = Math.floor(e.exclusiveMaximum) - 1 : e.maximum && (t = e.maximum);
  }
  return t;
}
function qG(e, t = {}, r, n) {
  let i = {};
  const s = n && n.depth || 1;
  if (e && typeof e.properties == "object") {
    const o = Array.isArray(e.required) ? e.required : [], a = {};
    for (const l of o)
      a[l] = !0;
    Object.keys(e.properties).forEach((l) => {
      if (t.skipNonRequired && !a.hasOwnProperty(l))
        return;
      const u = Zn(e.properties[l], t, r, { propertyName: l, depth: s + 1 });
      if (!(t.skipReadOnly && u.readOnly) && !(t.skipWriteOnly && u.writeOnly))
        if ((t == null ? void 0 : t.format) === "xml") {
          const { propertyName: f, value: d } = Ym(u, e.properties[l], { propertyName: l });
          f ? i[f] = d : i = { ...i, ...d };
        } else
          i[l] = u.value;
    });
  }
  if (e && typeof e.additionalProperties == "object") {
    const o = e.additionalProperties["x-additionalPropertiesName"] || "property";
    i[`${String(o)}1`] = Zn(e.additionalProperties, t, r, { depth: s + 1 }).value, i[`${String(o)}2`] = Zn(e.additionalProperties, t, r, { depth: s + 1 }).value;
  }
  if (e && typeof e.properties == "object" && e.maxProperties !== void 0 && Object.keys(i).length > e.maxProperties) {
    const o = {};
    let a = 0;
    (Array.isArray(e.required) ? e.required : []).forEach((u) => {
      i[u] !== void 0 && (o[u] = i[u], a++);
    }), Object.keys(i).forEach((u) => {
      a < e.maxProperties && !o.hasOwnProperty(u) && (o[u] = i[u], a++);
    }), i = o;
  }
  return i;
}
function Fc(e, t) {
  return e;
}
function AC(e, t, r) {
  let n = 1;
  if (e)
    switch (e) {
      case "?": {
        n = 0;
        break;
      }
      case "*": {
        n = Fc(0);
        break;
      }
      case "+": {
        n = Fc(1);
        break;
      }
      default:
        throw new Error("Unknown quantifier symbol provided.");
    }
  else t != null && r != null ? n = Fc(parseInt(t)) : t != null && r == null && (n = parseInt(t));
  return n;
}
function BG(e) {
  var d;
  let t = !1;
  e instanceof RegExp && (t = e.flags.includes("i"), e = e.toString(), e = ((d = e.match(/\/(.+?)\//)) == null ? void 0 : d[1]) ?? "");
  let r, n, i;
  const s = /([.A-Za-z0-9])(?:\{(\d+)(?:\,(\d+)|)\}|(\?|\*|\+))(?![^[]*]|[^{]*})/;
  let o = e.match(s);
  for (; o != null; ) {
    const m = o[2], v = o[3], S = o[4];
    i = AC(
      S,
      m,
      v
    ), e = e.slice(0, o.index) + o[1].repeat(i) + e.slice(o.index + o[0].length), o = e.match(s);
  }
  const a = /(\d-\d|\w-\w|\d|\w|[-!@#$&()`.+,/"])/, l = /\[(\^|)(-|)(.+?)\](?:\{(\d+)(?:\,(\d+)|)\}|(\?|\*|\+)|)/;
  for (o = e.match(l); o != null; ) {
    const m = o[1] === "^", v = o[2] === "-", S = o[4], y = o[5], E = o[6], x = [];
    let g = o[3], b = g.match(a);
    for (v && x.push(45); b != null; ) {
      if (b[0].indexOf("-") === -1)
        t && isNaN(Number(b[0])) ? (x.push(b[0].toUpperCase().charCodeAt(0)), x.push(b[0].toLowerCase().charCodeAt(0))) : x.push(b[0].charCodeAt(0));
      else {
        const P = b[0].split("-").map((k) => k.charCodeAt(0));
        if (r = P[0], n = P[1], r > n)
          throw new Error("Character range provided is out of order.");
        for (let k = r; k <= n; k++)
          if (t && isNaN(Number(String.fromCharCode(k)))) {
            const $ = String.fromCharCode(k);
            x.push($.toUpperCase().charCodeAt(0)), x.push($.toLowerCase().charCodeAt(0));
          } else
            x.push(k);
      }
      g = g.substring(b[0].length), b = g.match(a);
    }
    if (i = AC(
      E,
      S,
      y
    ), m) {
      let P = -1;
      for (let k = 48; k <= 57; k++) {
        if (P = x.indexOf(k), P > -1) {
          x.splice(P, 1);
          continue;
        }
        x.push(k);
      }
      for (let k = 65; k <= 90; k++) {
        if (P = x.indexOf(k), P > -1) {
          x.splice(P, 1);
          continue;
        }
        x.push(k);
      }
      for (let k = 97; k <= 122; k++) {
        if (P = x.indexOf(k), P > -1) {
          x.splice(P, 1);
          continue;
        }
        x.push(k);
      }
    }
    const A = Array.from(
      { length: i },
      () => String.fromCharCode(x[Fc(0)])
    ).join("");
    e = e.slice(0, o.index) + A + e.slice(o.index + o[0].length), o = e.match(l);
  }
  const u = /(.)\{(\d+)\,(\d+)\}/;
  for (o = e.match(u); o != null; ) {
    if (r = parseInt(o[2]), n = parseInt(o[3]), r > n)
      throw new Error("Numbers out of order in {} quantifier.");
    i = Fc(r), e = e.slice(0, o.index) + o[1].repeat(i) + e.slice(o.index + o[0].length), o = e.match(u);
  }
  const f = /(.)\{(\d+)\}/;
  for (o = e.match(f); o != null; )
    i = parseInt(o[2]), e = e.slice(0, o.index) + o[1].repeat(i) + e.slice(o.index + o[0].length), o = e.match(f);
  return e;
}
const UG = "qwerty!@#$%^123456";
function VG() {
  return "user@example.com";
}
function WG() {
  return "@.";
}
function HG(e, t) {
  let r = "pa$$word";
  return e > r.length && (r += "_", r += BL(UG, e - r.length).substring(0, e - r.length)), r;
}
function x1({ min: e, max: t, omitTime: r, omitDate: n }) {
  let i = CG(/* @__PURE__ */ new Date("2019-08-24T14:15:22.123Z"), r, n);
  return i.length < e && console.warn(`Using minLength = ${e} is incorrect with format "date-time"`), t && i.length > t && console.warn(`Using maxLength = ${t} is incorrect with format "date-time"`), i;
}
function QG(e, t) {
  return x1({ min: e, max: t, omitTime: !1, omitDate: !1 });
}
function YG(e, t) {
  return x1({ min: e, max: t, omitTime: !0, omitDate: !1 });
}
function GG(e, t) {
  return x1({ min: e, max: t, omitTime: !1, omitDate: !0 }).slice(1);
}
function WL(e, t, r, n, i = !1) {
  if (n && i)
    return BG(n);
  let s = BL("string", e);
  return t && s.length > t && (s = s.substring(0, t)), s;
}
function KG() {
  return "192.168.0.1";
}
function XG() {
  return "2001:0db8:85a3:0000:0000:8a2e:0370:7334";
}
function JG() {
  return "example.com";
}
function ZG() {
  return ".";
}
function eK() {
  return "http://example.com";
}
function tK() {
  return "../dictionary";
}
function rK() {
  return "http://example.com/{endpoint}";
}
function nK() {
  return "http://example.com/entity/1";
}
function iK() {
  return "/entity/1";
}
function oK(e, t, r) {
  return $G(r || "id");
}
function sK() {
  return "/json/pointer";
}
function aK() {
  return "1/relative/json/pointer";
}
function lK() {
  return "/regex/";
}
const uK = {
  email: VG,
  "idn-email": WG,
  // https://tools.ietf.org/html/rfc6531#section-3.3
  password: HG,
  "date-time": QG,
  date: YG,
  time: GG,
  // full-time in https://tools.ietf.org/html/rfc3339#section-5.6
  ipv4: KG,
  ipv6: XG,
  hostname: JG,
  "idn-hostname": ZG,
  // https://tools.ietf.org/html/rfc5890#section-2.3.2.3
  iri: nK,
  // https://tools.ietf.org/html/rfc3987
  "iri-reference": iK,
  uri: eK,
  "uri-reference": tK,
  // either a URI or relative-reference https://tools.ietf.org/html/rfc3986#section-4.1
  "uri-template": rK,
  uuid: oK,
  default: WL,
  "json-pointer": sK,
  "relative-json-pointer": aK,
  // https://tools.ietf.org/html/draft-handrews-relative-json-pointer-01
  regex: lK
};
function cK(e, t, r, n) {
  let i = e.format || "default", s = uK[i] || WL, o = n && n.propertyName;
  return s(
    e.minLength || 0,
    e.maxLength,
    o,
    e.pattern,
    t == null ? void 0 : t.enablePatterns
  );
}
var E1 = {}, Zg = {};
(function(e) {
  const t = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", r = t + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040", n = "[" + t + "][" + r + "]*", i = new RegExp("^" + n + "$"), s = function(a, l) {
    const u = [];
    let f = l.exec(a);
    for (; f; ) {
      const d = [];
      d.startIndex = l.lastIndex - f[0].length;
      const m = f.length;
      for (let v = 0; v < m; v++)
        d.push(f[v]);
      u.push(d), f = l.exec(a);
    }
    return u;
  }, o = function(a) {
    const l = i.exec(a);
    return !(l === null || typeof l > "u");
  };
  e.isExist = function(a) {
    return typeof a < "u";
  }, e.isEmptyObject = function(a) {
    return Object.keys(a).length === 0;
  }, e.merge = function(a, l, u) {
    if (l) {
      const f = Object.keys(l), d = f.length;
      for (let m = 0; m < d; m++)
        u === "strict" ? a[f[m]] = [l[f[m]]] : a[f[m]] = l[f[m]];
    }
  }, e.getValue = function(a) {
    return e.isExist(a) ? a : "";
  }, e.isName = o, e.getAllMatches = s, e.nameRegexp = n;
})(Zg);
const _1 = Zg, pK = {
  allowBooleanAttributes: !1,
  //A tag can have attributes without any value
  unpairedTags: []
};
E1.validate = function(e, t) {
  t = Object.assign({}, pK, t);
  const r = [];
  let n = !1, i = !1;
  e[0] === "\uFEFF" && (e = e.substr(1));
  for (let s = 0; s < e.length; s++)
    if (e[s] === "<" && e[s + 1] === "?") {
      if (s += 2, s = TC(e, s), s.err) return s;
    } else if (e[s] === "<") {
      let o = s;
      if (s++, e[s] === "!") {
        s = CC(e, s);
        continue;
      } else {
        let a = !1;
        e[s] === "/" && (a = !0, s++);
        let l = "";
        for (; s < e.length && e[s] !== ">" && e[s] !== " " && e[s] !== "	" && e[s] !== `
` && e[s] !== "\r"; s++)
          l += e[s];
        if (l = l.trim(), l[l.length - 1] === "/" && (l = l.substring(0, l.length - 1), s--), !bK(l)) {
          let d;
          return l.trim().length === 0 ? d = "Invalid space after '<'." : d = "Tag '" + l + "' is an invalid name.", Zt("InvalidTag", d, zr(e, s));
        }
        const u = hK(e, s);
        if (u === !1)
          return Zt("InvalidAttr", "Attributes for '" + l + "' have open quote.", zr(e, s));
        let f = u.value;
        if (s = u.index, f[f.length - 1] === "/") {
          const d = s - f.length;
          f = f.substring(0, f.length - 1);
          const m = $C(f, t);
          if (m === !0)
            n = !0;
          else
            return Zt(m.err.code, m.err.msg, zr(e, d + m.err.line));
        } else if (a)
          if (u.tagClosed) {
            if (f.trim().length > 0)
              return Zt("InvalidTag", "Closing tag '" + l + "' can't have attributes or invalid starting.", zr(e, o));
            if (r.length === 0)
              return Zt("InvalidTag", "Closing tag '" + l + "' has not been opened.", zr(e, o));
            {
              const d = r.pop();
              if (l !== d.tagName) {
                let m = zr(e, d.tagStartPos);
                return Zt(
                  "InvalidTag",
                  "Expected closing tag '" + d.tagName + "' (opened in line " + m.line + ", col " + m.col + ") instead of closing tag '" + l + "'.",
                  zr(e, o)
                );
              }
              r.length == 0 && (i = !0);
            }
          } else return Zt("InvalidTag", "Closing tag '" + l + "' doesn't have proper closing.", zr(e, s));
        else {
          const d = $C(f, t);
          if (d !== !0)
            return Zt(d.err.code, d.err.msg, zr(e, s - f.length + d.err.line));
          if (i === !0)
            return Zt("InvalidXml", "Multiple possible root nodes found.", zr(e, s));
          t.unpairedTags.indexOf(l) !== -1 || r.push({ tagName: l, tagStartPos: o }), n = !0;
        }
        for (s++; s < e.length; s++)
          if (e[s] === "<")
            if (e[s + 1] === "!") {
              s++, s = CC(e, s);
              continue;
            } else if (e[s + 1] === "?") {
              if (s = TC(e, ++s), s.err) return s;
            } else
              break;
          else if (e[s] === "&") {
            const d = yK(e, s);
            if (d == -1)
              return Zt("InvalidChar", "char '&' is not expected.", zr(e, s));
            s = d;
          } else if (i === !0 && !PC(e[s]))
            return Zt("InvalidXml", "Extra text at the end", zr(e, s));
        e[s] === "<" && s--;
      }
    } else {
      if (PC(e[s]))
        continue;
      return Zt("InvalidChar", "char '" + e[s] + "' is not expected.", zr(e, s));
    }
  if (n) {
    if (r.length == 1)
      return Zt("InvalidTag", "Unclosed tag '" + r[0].tagName + "'.", zr(e, r[0].tagStartPos));
    if (r.length > 0)
      return Zt("InvalidXml", "Invalid '" + JSON.stringify(r.map((s) => s.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
  } else return Zt("InvalidXml", "Start tag expected.", 1);
  return !0;
};
function PC(e) {
  return e === " " || e === "	" || e === `
` || e === "\r";
}
function TC(e, t) {
  const r = t;
  for (; t < e.length; t++)
    if (e[t] == "?" || e[t] == " ") {
      const n = e.substr(r, t - r);
      if (t > 5 && n === "xml")
        return Zt("InvalidXml", "XML declaration allowed only at the start of the document.", zr(e, t));
      if (e[t] == "?" && e[t + 1] == ">") {
        t++;
        break;
      } else
        continue;
    }
  return t;
}
function CC(e, t) {
  if (e.length > t + 5 && e[t + 1] === "-" && e[t + 2] === "-") {
    for (t += 3; t < e.length; t++)
      if (e[t] === "-" && e[t + 1] === "-" && e[t + 2] === ">") {
        t += 2;
        break;
      }
  } else if (e.length > t + 8 && e[t + 1] === "D" && e[t + 2] === "O" && e[t + 3] === "C" && e[t + 4] === "T" && e[t + 5] === "Y" && e[t + 6] === "P" && e[t + 7] === "E") {
    let r = 1;
    for (t += 8; t < e.length; t++)
      if (e[t] === "<")
        r++;
      else if (e[t] === ">" && (r--, r === 0))
        break;
  } else if (e.length > t + 9 && e[t + 1] === "[" && e[t + 2] === "C" && e[t + 3] === "D" && e[t + 4] === "A" && e[t + 5] === "T" && e[t + 6] === "A" && e[t + 7] === "[") {
    for (t += 8; t < e.length; t++)
      if (e[t] === "]" && e[t + 1] === "]" && e[t + 2] === ">") {
        t += 2;
        break;
      }
  }
  return t;
}
const fK = '"', dK = "'";
function hK(e, t) {
  let r = "", n = "", i = !1;
  for (; t < e.length; t++) {
    if (e[t] === fK || e[t] === dK)
      n === "" ? n = e[t] : n !== e[t] || (n = "");
    else if (e[t] === ">" && n === "") {
      i = !0;
      break;
    }
    r += e[t];
  }
  return n !== "" ? !1 : {
    value: r,
    index: t,
    tagClosed: i
  };
}
const mK = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
function $C(e, t) {
  const r = _1.getAllMatches(e, mK), n = {};
  for (let i = 0; i < r.length; i++) {
    if (r[i][1].length === 0)
      return Zt("InvalidAttr", "Attribute '" + r[i][2] + "' has no space in starting.", dc(r[i]));
    if (r[i][3] !== void 0 && r[i][4] === void 0)
      return Zt("InvalidAttr", "Attribute '" + r[i][2] + "' is without value.", dc(r[i]));
    if (r[i][3] === void 0 && !t.allowBooleanAttributes)
      return Zt("InvalidAttr", "boolean attribute '" + r[i][2] + "' is not allowed.", dc(r[i]));
    const s = r[i][2];
    if (!vK(s))
      return Zt("InvalidAttr", "Attribute '" + s + "' is an invalid name.", dc(r[i]));
    if (!n.hasOwnProperty(s))
      n[s] = 1;
    else
      return Zt("InvalidAttr", "Attribute '" + s + "' is repeated.", dc(r[i]));
  }
  return !0;
}
function gK(e, t) {
  let r = /\d/;
  for (e[t] === "x" && (t++, r = /[\da-fA-F]/); t < e.length; t++) {
    if (e[t] === ";")
      return t;
    if (!e[t].match(r))
      break;
  }
  return -1;
}
function yK(e, t) {
  if (t++, e[t] === ";")
    return -1;
  if (e[t] === "#")
    return t++, gK(e, t);
  let r = 0;
  for (; t < e.length; t++, r++)
    if (!(e[t].match(/\w/) && r < 20)) {
      if (e[t] === ";")
        break;
      return -1;
    }
  return t;
}
function Zt(e, t, r) {
  return {
    err: {
      code: e,
      msg: t,
      line: r.line || r,
      col: r.col
    }
  };
}
function vK(e) {
  return _1.isName(e);
}
function bK(e) {
  return _1.isName(e);
}
function zr(e, t) {
  const r = e.substring(0, t).split(/\r?\n/);
  return {
    line: r.length,
    // column number is last line's length + 1, because column numbering starts at 1:
    col: r[r.length - 1].length + 1
  };
}
function dc(e) {
  return e.startIndex + e[1].length;
}
var O1 = {};
const HL = {
  preserveOrder: !1,
  attributeNamePrefix: "@_",
  attributesGroupName: !1,
  textNodeName: "#text",
  ignoreAttributes: !0,
  removeNSPrefix: !1,
  // remove NS from tag name or attribute name if true
  allowBooleanAttributes: !1,
  //a tag can have attributes without any value
  //ignoreRootElement : false,
  parseTagValue: !0,
  parseAttributeValue: !1,
  trimValues: !0,
  //Trim string values of tag and attributes
  cdataPropName: !1,
  numberParseOptions: {
    hex: !0,
    leadingZeros: !0,
    eNotation: !0
  },
  tagValueProcessor: function(e, t) {
    return t;
  },
  attributeValueProcessor: function(e, t) {
    return t;
  },
  stopNodes: [],
  //nested tags will not be parsed even for errors
  alwaysCreateTextNode: !1,
  isArray: () => !1,
  commentPropName: !1,
  unpairedTags: [],
  processEntities: !0,
  htmlEntities: !1,
  ignoreDeclaration: !1,
  ignorePiTags: !1,
  transformTagName: !1,
  transformAttributeName: !1,
  updateTag: function(e, t, r) {
    return e;
  }
  // skipEmptyListItem: false
}, wK = function(e) {
  return Object.assign({}, HL, e);
};
O1.buildOptions = wK;
O1.defaultOptions = HL;
class SK {
  constructor(t) {
    this.tagname = t, this.child = [], this[":@"] = {};
  }
  add(t, r) {
    t === "__proto__" && (t = "#__proto__"), this.child.push({ [t]: r });
  }
  addChild(t) {
    t.tagname === "__proto__" && (t.tagname = "#__proto__"), t[":@"] && Object.keys(t[":@"]).length > 0 ? this.child.push({ [t.tagname]: t.child, ":@": t[":@"] }) : this.child.push({ [t.tagname]: t.child });
  }
}
var xK = SK;
const EK = Zg;
function _K(e, t) {
  const r = {};
  if (e[t + 3] === "O" && e[t + 4] === "C" && e[t + 5] === "T" && e[t + 6] === "Y" && e[t + 7] === "P" && e[t + 8] === "E") {
    t = t + 9;
    let n = 1, i = !1, s = !1, o = "";
    for (; t < e.length; t++)
      if (e[t] === "<" && !s) {
        if (i && AK(e, t)) {
          t += 7;
          let a, l;
          [a, l, t] = OK(e, t + 1), l.indexOf("&") === -1 && (r[$K(a)] = {
            regx: RegExp(`&${a};`, "g"),
            val: l
          });
        } else if (i && PK(e, t)) t += 8;
        else if (i && TK(e, t)) t += 8;
        else if (i && CK(e, t)) t += 9;
        else if (kK) s = !0;
        else throw new Error("Invalid DOCTYPE");
        n++, o = "";
      } else if (e[t] === ">") {
        if (s ? e[t - 1] === "-" && e[t - 2] === "-" && (s = !1, n--) : n--, n === 0)
          break;
      } else e[t] === "[" ? i = !0 : o += e[t];
    if (n !== 0)
      throw new Error("Unclosed DOCTYPE");
  } else
    throw new Error("Invalid Tag instead of DOCTYPE");
  return { entities: r, i: t };
}
function OK(e, t) {
  let r = "";
  for (; t < e.length && e[t] !== "'" && e[t] !== '"'; t++)
    r += e[t];
  if (r = r.trim(), r.indexOf(" ") !== -1) throw new Error("External entites are not supported");
  const n = e[t++];
  let i = "";
  for (; t < e.length && e[t] !== n; t++)
    i += e[t];
  return [r, i, t];
}
function kK(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "-" && e[t + 3] === "-";
}
function AK(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "E" && e[t + 3] === "N" && e[t + 4] === "T" && e[t + 5] === "I" && e[t + 6] === "T" && e[t + 7] === "Y";
}
function PK(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "E" && e[t + 3] === "L" && e[t + 4] === "E" && e[t + 5] === "M" && e[t + 6] === "E" && e[t + 7] === "N" && e[t + 8] === "T";
}
function TK(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "A" && e[t + 3] === "T" && e[t + 4] === "T" && e[t + 5] === "L" && e[t + 6] === "I" && e[t + 7] === "S" && e[t + 8] === "T";
}
function CK(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "N" && e[t + 3] === "O" && e[t + 4] === "T" && e[t + 5] === "A" && e[t + 6] === "T" && e[t + 7] === "I" && e[t + 8] === "O" && e[t + 9] === "N";
}
function $K(e) {
  if (EK.isName(e))
    return e;
  throw new Error(`Invalid entity name ${e}`);
}
var RK = _K;
const IK = /^[-+]?0x[a-fA-F0-9]+$/, NK = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/, jK = {
  hex: !0,
  // oct: false,
  leadingZeros: !0,
  decimalPoint: ".",
  eNotation: !0
  //skipLike: /regex/
};
function LK(e, t = {}) {
  if (t = Object.assign({}, jK, t), !e || typeof e != "string") return e;
  let r = e.trim();
  if (t.skipLike !== void 0 && t.skipLike.test(r)) return e;
  if (e === "0") return 0;
  if (t.hex && IK.test(r))
    return DK(r, 16);
  if (r.search(/[eE]/) !== -1) {
    const n = r.match(/^([-\+])?(0*)([0-9]*(\.[0-9]*)?[eE][-\+]?[0-9]+)$/);
    if (n) {
      if (t.leadingZeros)
        r = (n[1] || "") + n[3];
      else if (!(n[2] === "0" && n[3][0] === ".")) return e;
      return t.eNotation ? Number(r) : e;
    } else
      return e;
  } else {
    const n = NK.exec(r);
    if (n) {
      const i = n[1], s = n[2];
      let o = MK(n[3]);
      if (!t.leadingZeros && s.length > 0 && i && r[2] !== ".") return e;
      if (!t.leadingZeros && s.length > 0 && !i && r[1] !== ".") return e;
      if (t.leadingZeros && s === e) return 0;
      {
        const a = Number(r), l = "" + a;
        return l.search(/[eE]/) !== -1 ? t.eNotation ? a : e : r.indexOf(".") !== -1 ? l === "0" && o === "" || l === o || i && l === "-" + o ? a : e : s ? o === l || i + o === l ? a : e : r === l || r === i + l ? a : e;
      }
    } else
      return e;
  }
}
function MK(e) {
  return e && e.indexOf(".") !== -1 && (e = e.replace(/0+$/, ""), e === "." ? e = "0" : e[0] === "." ? e = "0" + e : e[e.length - 1] === "." && (e = e.substr(0, e.length - 1))), e;
}
function DK(e, t) {
  if (parseInt) return parseInt(e, t);
  if (Number.parseInt) return Number.parseInt(e, t);
  if (window && window.parseInt) return window.parseInt(e, t);
  throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
}
var FK = LK;
function zK(e) {
  return typeof e == "function" ? e : Array.isArray(e) ? (t) => {
    for (const r of e)
      if (typeof r == "string" && t === r || r instanceof RegExp && r.test(t))
        return !0;
  } : () => !1;
}
var QL = zK;
const YL = Zg, hc = xK, qK = RK, BK = FK, UK = QL;
let VK = class {
  constructor(t) {
    this.options = t, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = {
      apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
      gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
      lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
      quot: { regex: /&(quot|#34|#x22);/g, val: '"' }
    }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = {
      space: { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      cent: { regex: /&(cent|#162);/g, val: "" },
      pound: { regex: /&(pound|#163);/g, val: "" },
      yen: { regex: /&(yen|#165);/g, val: "" },
      euro: { regex: /&(euro|#8364);/g, val: "" },
      copyright: { regex: /&(copy|#169);/g, val: "" },
      reg: { regex: /&(reg|#174);/g, val: "" },
      inr: { regex: /&(inr|#8377);/g, val: "" },
      num_dec: { regex: /&#([0-9]{1,7});/g, val: (r, n) => String.fromCharCode(Number.parseInt(n, 10)) },
      num_hex: { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (r, n) => String.fromCharCode(Number.parseInt(n, 16)) }
    }, this.addExternalEntities = WK, this.parseXml = KK, this.parseTextData = HK, this.resolveNameSpace = QK, this.buildAttributesMap = GK, this.isItStopNode = eX, this.replaceEntitiesValue = JK, this.readStopNodeData = rX, this.saveTextToParentTag = ZK, this.addChild = XK, this.ignoreAttributesFn = UK(this.options.ignoreAttributes);
  }
};
function WK(e) {
  const t = Object.keys(e);
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    this.lastEntities[n] = {
      regex: new RegExp("&" + n + ";", "g"),
      val: e[n]
    };
  }
}
function HK(e, t, r, n, i, s, o) {
  if (e !== void 0 && (this.options.trimValues && !n && (e = e.trim()), e.length > 0)) {
    o || (e = this.replaceEntitiesValue(e));
    const a = this.options.tagValueProcessor(t, e, r, i, s);
    return a == null ? e : typeof a != typeof e || a !== e ? a : this.options.trimValues ? Rw(e, this.options.parseTagValue, this.options.numberParseOptions) : e.trim() === e ? Rw(e, this.options.parseTagValue, this.options.numberParseOptions) : e;
  }
}
function QK(e) {
  if (this.options.removeNSPrefix) {
    const t = e.split(":"), r = e.charAt(0) === "/" ? "/" : "";
    if (t[0] === "xmlns")
      return "";
    t.length === 2 && (e = r + t[1]);
  }
  return e;
}
const YK = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
function GK(e, t, r) {
  if (this.options.ignoreAttributes !== !0 && typeof e == "string") {
    const n = YL.getAllMatches(e, YK), i = n.length, s = {};
    for (let o = 0; o < i; o++) {
      const a = this.resolveNameSpace(n[o][1]);
      if (this.ignoreAttributesFn(a, t))
        continue;
      let l = n[o][4], u = this.options.attributeNamePrefix + a;
      if (a.length)
        if (this.options.transformAttributeName && (u = this.options.transformAttributeName(u)), u === "__proto__" && (u = "#__proto__"), l !== void 0) {
          this.options.trimValues && (l = l.trim()), l = this.replaceEntitiesValue(l);
          const f = this.options.attributeValueProcessor(a, l, t);
          f == null ? s[u] = l : typeof f != typeof l || f !== l ? s[u] = f : s[u] = Rw(
            l,
            this.options.parseAttributeValue,
            this.options.numberParseOptions
          );
        } else this.options.allowBooleanAttributes && (s[u] = !0);
    }
    if (!Object.keys(s).length)
      return;
    if (this.options.attributesGroupName) {
      const o = {};
      return o[this.options.attributesGroupName] = s, o;
    }
    return s;
  }
}
const KK = function(e) {
  e = e.replace(/\r\n?/g, `
`);
  const t = new hc("!xml");
  let r = t, n = "", i = "";
  for (let s = 0; s < e.length; s++)
    if (e[s] === "<")
      if (e[s + 1] === "/") {
        const a = ra(e, ">", s, "Closing Tag is not closed.");
        let l = e.substring(s + 2, a).trim();
        if (this.options.removeNSPrefix) {
          const d = l.indexOf(":");
          d !== -1 && (l = l.substr(d + 1));
        }
        this.options.transformTagName && (l = this.options.transformTagName(l)), r && (n = this.saveTextToParentTag(n, r, i));
        const u = i.substring(i.lastIndexOf(".") + 1);
        if (l && this.options.unpairedTags.indexOf(l) !== -1)
          throw new Error(`Unpaired tag can not be used as closing tag: </${l}>`);
        let f = 0;
        u && this.options.unpairedTags.indexOf(u) !== -1 ? (f = i.lastIndexOf(".", i.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : f = i.lastIndexOf("."), i = i.substring(0, f), r = this.tagsNodeStack.pop(), n = "", s = a;
      } else if (e[s + 1] === "?") {
        let a = $w(e, s, !1, "?>");
        if (!a) throw new Error("Pi Tag is not closed.");
        if (n = this.saveTextToParentTag(n, r, i), !(this.options.ignoreDeclaration && a.tagName === "?xml" || this.options.ignorePiTags)) {
          const l = new hc(a.tagName);
          l.add(this.options.textNodeName, ""), a.tagName !== a.tagExp && a.attrExpPresent && (l[":@"] = this.buildAttributesMap(a.tagExp, i, a.tagName)), this.addChild(r, l, i);
        }
        s = a.closeIndex + 1;
      } else if (e.substr(s + 1, 3) === "!--") {
        const a = ra(e, "-->", s + 4, "Comment is not closed.");
        if (this.options.commentPropName) {
          const l = e.substring(s + 4, a - 2);
          n = this.saveTextToParentTag(n, r, i), r.add(this.options.commentPropName, [{ [this.options.textNodeName]: l }]);
        }
        s = a;
      } else if (e.substr(s + 1, 2) === "!D") {
        const a = qK(e, s);
        this.docTypeEntities = a.entities, s = a.i;
      } else if (e.substr(s + 1, 2) === "![") {
        const a = ra(e, "]]>", s, "CDATA is not closed.") - 2, l = e.substring(s + 9, a);
        n = this.saveTextToParentTag(n, r, i);
        let u = this.parseTextData(l, r.tagname, i, !0, !1, !0, !0);
        u == null && (u = ""), this.options.cdataPropName ? r.add(this.options.cdataPropName, [{ [this.options.textNodeName]: l }]) : r.add(this.options.textNodeName, u), s = a + 2;
      } else {
        let a = $w(e, s, this.options.removeNSPrefix), l = a.tagName;
        const u = a.rawTagName;
        let f = a.tagExp, d = a.attrExpPresent, m = a.closeIndex;
        this.options.transformTagName && (l = this.options.transformTagName(l)), r && n && r.tagname !== "!xml" && (n = this.saveTextToParentTag(n, r, i, !1));
        const v = r;
        if (v && this.options.unpairedTags.indexOf(v.tagname) !== -1 && (r = this.tagsNodeStack.pop(), i = i.substring(0, i.lastIndexOf("."))), l !== t.tagname && (i += i ? "." + l : l), this.isItStopNode(this.options.stopNodes, i, l)) {
          let S = "";
          if (f.length > 0 && f.lastIndexOf("/") === f.length - 1)
            l[l.length - 1] === "/" ? (l = l.substr(0, l.length - 1), i = i.substr(0, i.length - 1), f = l) : f = f.substr(0, f.length - 1), s = a.closeIndex;
          else if (this.options.unpairedTags.indexOf(l) !== -1)
            s = a.closeIndex;
          else {
            const E = this.readStopNodeData(e, u, m + 1);
            if (!E) throw new Error(`Unexpected end of ${u}`);
            s = E.i, S = E.tagContent;
          }
          const y = new hc(l);
          l !== f && d && (y[":@"] = this.buildAttributesMap(f, i, l)), S && (S = this.parseTextData(S, l, i, !0, d, !0, !0)), i = i.substr(0, i.lastIndexOf(".")), y.add(this.options.textNodeName, S), this.addChild(r, y, i);
        } else {
          if (f.length > 0 && f.lastIndexOf("/") === f.length - 1) {
            l[l.length - 1] === "/" ? (l = l.substr(0, l.length - 1), i = i.substr(0, i.length - 1), f = l) : f = f.substr(0, f.length - 1), this.options.transformTagName && (l = this.options.transformTagName(l));
            const S = new hc(l);
            l !== f && d && (S[":@"] = this.buildAttributesMap(f, i, l)), this.addChild(r, S, i), i = i.substr(0, i.lastIndexOf("."));
          } else {
            const S = new hc(l);
            this.tagsNodeStack.push(r), l !== f && d && (S[":@"] = this.buildAttributesMap(f, i, l)), this.addChild(r, S, i), r = S;
          }
          n = "", s = m;
        }
      }
    else
      n += e[s];
  return t.child;
};
function XK(e, t, r) {
  const n = this.options.updateTag(t.tagname, r, t[":@"]);
  n === !1 || (typeof n == "string" && (t.tagname = n), e.addChild(t));
}
const JK = function(e) {
  if (this.options.processEntities) {
    for (let t in this.docTypeEntities) {
      const r = this.docTypeEntities[t];
      e = e.replace(r.regx, r.val);
    }
    for (let t in this.lastEntities) {
      const r = this.lastEntities[t];
      e = e.replace(r.regex, r.val);
    }
    if (this.options.htmlEntities)
      for (let t in this.htmlEntities) {
        const r = this.htmlEntities[t];
        e = e.replace(r.regex, r.val);
      }
    e = e.replace(this.ampEntity.regex, this.ampEntity.val);
  }
  return e;
};
function ZK(e, t, r, n) {
  return e && (n === void 0 && (n = t.child.length === 0), e = this.parseTextData(
    e,
    t.tagname,
    r,
    !1,
    t[":@"] ? Object.keys(t[":@"]).length !== 0 : !1,
    n
  ), e !== void 0 && e !== "" && t.add(this.options.textNodeName, e), e = ""), e;
}
function eX(e, t, r) {
  const n = "*." + r;
  for (const i in e) {
    const s = e[i];
    if (n === s || t === s) return !0;
  }
  return !1;
}
function tX(e, t, r = ">") {
  let n, i = "";
  for (let s = t; s < e.length; s++) {
    let o = e[s];
    if (n)
      o === n && (n = "");
    else if (o === '"' || o === "'")
      n = o;
    else if (o === r[0])
      if (r[1]) {
        if (e[s + 1] === r[1])
          return {
            data: i,
            index: s
          };
      } else
        return {
          data: i,
          index: s
        };
    else o === "	" && (o = " ");
    i += o;
  }
}
function ra(e, t, r, n) {
  const i = e.indexOf(t, r);
  if (i === -1)
    throw new Error(n);
  return i + t.length - 1;
}
function $w(e, t, r, n = ">") {
  const i = tX(e, t + 1, n);
  if (!i) return;
  let s = i.data;
  const o = i.index, a = s.search(/\s/);
  let l = s, u = !0;
  a !== -1 && (l = s.substring(0, a), s = s.substring(a + 1).trimStart());
  const f = l;
  if (r) {
    const d = l.indexOf(":");
    d !== -1 && (l = l.substr(d + 1), u = l !== i.data.substr(d + 1));
  }
  return {
    tagName: l,
    tagExp: s,
    closeIndex: o,
    attrExpPresent: u,
    rawTagName: f
  };
}
function rX(e, t, r) {
  const n = r;
  let i = 1;
  for (; r < e.length; r++)
    if (e[r] === "<")
      if (e[r + 1] === "/") {
        const s = ra(e, ">", r, `${t} is not closed`);
        if (e.substring(r + 2, s).trim() === t && (i--, i === 0))
          return {
            tagContent: e.substring(n, r),
            i: s
          };
        r = s;
      } else if (e[r + 1] === "?")
        r = ra(e, "?>", r + 1, "StopNode is not closed.");
      else if (e.substr(r + 1, 3) === "!--")
        r = ra(e, "-->", r + 3, "StopNode is not closed.");
      else if (e.substr(r + 1, 2) === "![")
        r = ra(e, "]]>", r, "StopNode is not closed.") - 2;
      else {
        const s = $w(e, r, ">");
        s && ((s && s.tagName) === t && s.tagExp[s.tagExp.length - 1] !== "/" && i++, r = s.closeIndex);
      }
}
function Rw(e, t, r) {
  if (t && typeof e == "string") {
    const n = e.trim();
    return n === "true" ? !0 : n === "false" ? !1 : BK(e, r);
  } else
    return YL.isExist(e) ? e : "";
}
var nX = VK, GL = {};
function iX(e, t) {
  return KL(e, t);
}
function KL(e, t, r) {
  let n;
  const i = {};
  for (let s = 0; s < e.length; s++) {
    const o = e[s], a = oX(o);
    let l = "";
    if (r === void 0 ? l = a : l = r + "." + a, a === t.textNodeName)
      n === void 0 ? n = o[a] : n += "" + o[a];
    else {
      if (a === void 0)
        continue;
      if (o[a]) {
        let u = KL(o[a], t, l);
        const f = aX(u, t);
        o[":@"] ? sX(u, o[":@"], l, t) : Object.keys(u).length === 1 && u[t.textNodeName] !== void 0 && !t.alwaysCreateTextNode ? u = u[t.textNodeName] : Object.keys(u).length === 0 && (t.alwaysCreateTextNode ? u[t.textNodeName] = "" : u = ""), i[a] !== void 0 && i.hasOwnProperty(a) ? (Array.isArray(i[a]) || (i[a] = [i[a]]), i[a].push(u)) : t.isArray(a, l, f) ? i[a] = [u] : i[a] = u;
      }
    }
  }
  return typeof n == "string" ? n.length > 0 && (i[t.textNodeName] = n) : n !== void 0 && (i[t.textNodeName] = n), i;
}
function oX(e) {
  const t = Object.keys(e);
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    if (n !== ":@") return n;
  }
}
function sX(e, t, r, n) {
  if (t) {
    const i = Object.keys(t), s = i.length;
    for (let o = 0; o < s; o++) {
      const a = i[o];
      n.isArray(a, r + "." + a, !0, !0) ? e[a] = [t[a]] : e[a] = t[a];
    }
  }
}
function aX(e, t) {
  const { textNodeName: r } = t, n = Object.keys(e).length;
  return !!(n === 0 || n === 1 && (e[r] || typeof e[r] == "boolean" || e[r] === 0));
}
GL.prettify = iX;
const { buildOptions: lX } = O1, uX = nX, { prettify: cX } = GL, pX = E1;
let fX = class {
  constructor(t) {
    this.externalEntities = {}, this.options = lX(t);
  }
  /**
   * Parse XML dats to JS object 
   * @param {string|Buffer} xmlData 
   * @param {boolean|Object} validationOption 
   */
  parse(t, r) {
    if (typeof t != "string") if (t.toString)
      t = t.toString();
    else
      throw new Error("XML data is accepted in String or Bytes[] form.");
    if (r) {
      r === !0 && (r = {});
      const s = pX.validate(t, r);
      if (s !== !0)
        throw Error(`${s.err.msg}:${s.err.line}:${s.err.col}`);
    }
    const n = new uX(this.options);
    n.addExternalEntities(this.externalEntities);
    const i = n.parseXml(t);
    return this.options.preserveOrder || i === void 0 ? i : cX(i, this.options);
  }
  /**
   * Add Entity which is not by default supported by this library
   * @param {string} key 
   * @param {string} value 
   */
  addEntity(t, r) {
    if (r.indexOf("&") !== -1)
      throw new Error("Entity value can't have '&'");
    if (t.indexOf("&") !== -1 || t.indexOf(";") !== -1)
      throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
    if (r === "&")
      throw new Error("An entity with value '&' is not permitted");
    this.externalEntities[t] = r;
  }
};
var dX = fX;
const hX = `
`;
function mX(e, t) {
  let r = "";
  return t.format && t.indentBy.length > 0 && (r = hX), XL(e, t, "", r);
}
function XL(e, t, r, n) {
  let i = "", s = !1;
  for (let o = 0; o < e.length; o++) {
    const a = e[o], l = gX(a);
    if (l === void 0) continue;
    let u = "";
    if (r.length === 0 ? u = l : u = `${r}.${l}`, l === t.textNodeName) {
      let S = a[l];
      yX(u, t) || (S = t.tagValueProcessor(l, S), S = JL(S, t)), s && (i += n), i += S, s = !1;
      continue;
    } else if (l === t.cdataPropName) {
      s && (i += n), i += `<![CDATA[${a[l][0][t.textNodeName]}]]>`, s = !1;
      continue;
    } else if (l === t.commentPropName) {
      i += n + `<!--${a[l][0][t.textNodeName]}-->`, s = !0;
      continue;
    } else if (l[0] === "?") {
      const S = RC(a[":@"], t), y = l === "?xml" ? "" : n;
      let E = a[l][0][t.textNodeName];
      E = E.length !== 0 ? " " + E : "", i += y + `<${l}${E}${S}?>`, s = !0;
      continue;
    }
    let f = n;
    f !== "" && (f += t.indentBy);
    const d = RC(a[":@"], t), m = n + `<${l}${d}`, v = XL(a[l], t, u, f);
    t.unpairedTags.indexOf(l) !== -1 ? t.suppressUnpairedNode ? i += m + ">" : i += m + "/>" : (!v || v.length === 0) && t.suppressEmptyNode ? i += m + "/>" : v && v.endsWith(">") ? i += m + `>${v}${n}</${l}>` : (i += m + ">", v && n !== "" && (v.includes("/>") || v.includes("</")) ? i += n + t.indentBy + v + n : i += v, i += `</${l}>`), s = !0;
  }
  return i;
}
function gX(e) {
  const t = Object.keys(e);
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    if (e.hasOwnProperty(n) && n !== ":@")
      return n;
  }
}
function RC(e, t) {
  let r = "";
  if (e && !t.ignoreAttributes)
    for (let n in e) {
      if (!e.hasOwnProperty(n)) continue;
      let i = t.attributeValueProcessor(n, e[n]);
      i = JL(i, t), i === !0 && t.suppressBooleanAttributes ? r += ` ${n.substr(t.attributeNamePrefix.length)}` : r += ` ${n.substr(t.attributeNamePrefix.length)}="${i}"`;
    }
  return r;
}
function yX(e, t) {
  e = e.substr(0, e.length - t.textNodeName.length - 1);
  let r = e.substr(e.lastIndexOf(".") + 1);
  for (let n in t.stopNodes)
    if (t.stopNodes[n] === e || t.stopNodes[n] === "*." + r) return !0;
  return !1;
}
function JL(e, t) {
  if (e && e.length > 0 && t.processEntities)
    for (let r = 0; r < t.entities.length; r++) {
      const n = t.entities[r];
      e = e.replace(n.regex, n.val);
    }
  return e;
}
var vX = mX;
const bX = vX, wX = QL, SX = {
  attributeNamePrefix: "@_",
  attributesGroupName: !1,
  textNodeName: "#text",
  ignoreAttributes: !0,
  cdataPropName: !1,
  format: !1,
  indentBy: "  ",
  suppressEmptyNode: !1,
  suppressUnpairedNode: !0,
  suppressBooleanAttributes: !0,
  tagValueProcessor: function(e, t) {
    return t;
  },
  attributeValueProcessor: function(e, t) {
    return t;
  },
  preserveOrder: !1,
  commentPropName: !1,
  unpairedTags: [],
  entities: [
    { regex: new RegExp("&", "g"), val: "&amp;" },
    //it must be on top
    { regex: new RegExp(">", "g"), val: "&gt;" },
    { regex: new RegExp("<", "g"), val: "&lt;" },
    { regex: new RegExp("'", "g"), val: "&apos;" },
    { regex: new RegExp('"', "g"), val: "&quot;" }
  ],
  processEntities: !0,
  stopNodes: [],
  // transformTagName: false,
  // transformAttributeName: false,
  oneListGroup: !1
};
function Es(e) {
  this.options = Object.assign({}, SX, e), this.options.ignoreAttributes === !0 || this.options.attributesGroupName ? this.isAttribute = function() {
    return !1;
  } : (this.ignoreAttributesFn = wX(this.options.ignoreAttributes), this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = _X), this.processTextOrObjNode = xX, this.options.format ? (this.indentate = EX, this.tagEndChar = `>
`, this.newLine = `
`) : (this.indentate = function() {
    return "";
  }, this.tagEndChar = ">", this.newLine = "");
}
Es.prototype.build = function(e) {
  return this.options.preserveOrder ? bX(e, this.options) : (Array.isArray(e) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (e = {
    [this.options.arrayNodeName]: e
  }), this.j2x(e, 0, []).val);
};
Es.prototype.j2x = function(e, t, r) {
  let n = "", i = "";
  const s = r.join(".");
  for (let o in e)
    if (Object.prototype.hasOwnProperty.call(e, o))
      if (typeof e[o] > "u")
        this.isAttribute(o) && (i += "");
      else if (e[o] === null)
        this.isAttribute(o) || o === this.options.cdataPropName ? i += "" : o[0] === "?" ? i += this.indentate(t) + "<" + o + "?" + this.tagEndChar : i += this.indentate(t) + "<" + o + "/" + this.tagEndChar;
      else if (e[o] instanceof Date)
        i += this.buildTextValNode(e[o], o, "", t);
      else if (typeof e[o] != "object") {
        const a = this.isAttribute(o);
        if (a && !this.ignoreAttributesFn(a, s))
          n += this.buildAttrPairStr(a, "" + e[o]);
        else if (!a)
          if (o === this.options.textNodeName) {
            let l = this.options.tagValueProcessor(o, "" + e[o]);
            i += this.replaceEntitiesValue(l);
          } else
            i += this.buildTextValNode(e[o], o, "", t);
      } else if (Array.isArray(e[o])) {
        const a = e[o].length;
        let l = "", u = "";
        for (let f = 0; f < a; f++) {
          const d = e[o][f];
          if (!(typeof d > "u")) if (d === null)
            o[0] === "?" ? i += this.indentate(t) + "<" + o + "?" + this.tagEndChar : i += this.indentate(t) + "<" + o + "/" + this.tagEndChar;
          else if (typeof d == "object")
            if (this.options.oneListGroup) {
              const m = this.j2x(d, t + 1, r.concat(o));
              l += m.val, this.options.attributesGroupName && d.hasOwnProperty(this.options.attributesGroupName) && (u += m.attrStr);
            } else
              l += this.processTextOrObjNode(d, o, t, r);
          else if (this.options.oneListGroup) {
            let m = this.options.tagValueProcessor(o, d);
            m = this.replaceEntitiesValue(m), l += m;
          } else
            l += this.buildTextValNode(d, o, "", t);
        }
        this.options.oneListGroup && (l = this.buildObjectNode(l, o, u, t)), i += l;
      } else if (this.options.attributesGroupName && o === this.options.attributesGroupName) {
        const a = Object.keys(e[o]), l = a.length;
        for (let u = 0; u < l; u++)
          n += this.buildAttrPairStr(a[u], "" + e[o][a[u]]);
      } else
        i += this.processTextOrObjNode(e[o], o, t, r);
  return { attrStr: n, val: i };
};
Es.prototype.buildAttrPairStr = function(e, t) {
  return t = this.options.attributeValueProcessor(e, "" + t), t = this.replaceEntitiesValue(t), this.options.suppressBooleanAttributes && t === "true" ? " " + e : " " + e + '="' + t + '"';
};
function xX(e, t, r, n) {
  const i = this.j2x(e, r + 1, n.concat(t));
  return e[this.options.textNodeName] !== void 0 && Object.keys(e).length === 1 ? this.buildTextValNode(e[this.options.textNodeName], t, i.attrStr, r) : this.buildObjectNode(i.val, t, i.attrStr, r);
}
Es.prototype.buildObjectNode = function(e, t, r, n) {
  if (e === "")
    return t[0] === "?" ? this.indentate(n) + "<" + t + r + "?" + this.tagEndChar : this.indentate(n) + "<" + t + r + this.closeTag(t) + this.tagEndChar;
  {
    let i = "</" + t + this.tagEndChar, s = "";
    return t[0] === "?" && (s = "?", i = ""), (r || r === "") && e.indexOf("<") === -1 ? this.indentate(n) + "<" + t + r + s + ">" + e + i : this.options.commentPropName !== !1 && t === this.options.commentPropName && s.length === 0 ? this.indentate(n) + `<!--${e}-->` + this.newLine : this.indentate(n) + "<" + t + r + s + this.tagEndChar + e + this.indentate(n) + i;
  }
};
Es.prototype.closeTag = function(e) {
  let t = "";
  return this.options.unpairedTags.indexOf(e) !== -1 ? this.options.suppressUnpairedNode || (t = "/") : this.options.suppressEmptyNode ? t = "/" : t = `></${e}`, t;
};
Es.prototype.buildTextValNode = function(e, t, r, n) {
  if (this.options.cdataPropName !== !1 && t === this.options.cdataPropName)
    return this.indentate(n) + `<![CDATA[${e}]]>` + this.newLine;
  if (this.options.commentPropName !== !1 && t === this.options.commentPropName)
    return this.indentate(n) + `<!--${e}-->` + this.newLine;
  if (t[0] === "?")
    return this.indentate(n) + "<" + t + r + "?" + this.tagEndChar;
  {
    let i = this.options.tagValueProcessor(t, e);
    return i = this.replaceEntitiesValue(i), i === "" ? this.indentate(n) + "<" + t + r + this.closeTag(t) + this.tagEndChar : this.indentate(n) + "<" + t + r + ">" + i + "</" + t + this.tagEndChar;
  }
};
Es.prototype.replaceEntitiesValue = function(e) {
  if (e && e.length > 0 && this.options.processEntities)
    for (let t = 0; t < this.options.entities.length; t++) {
      const r = this.options.entities[t];
      e = e.replace(r.regex, r.val);
    }
  return e;
};
function EX(e) {
  return this.options.indentBy.repeat(e);
}
function _X(e) {
  return e.startsWith(this.options.attributeNamePrefix) && e !== this.options.textNodeName ? e.substr(this.attrPrefixLen) : !1;
}
var OX = Es;
const kX = E1, AX = dX, PX = OX;
var TX = {
  XMLParser: AX,
  XMLValidator: kX,
  XMLBuilder: PX
}, k1 = {};
const CX = {
  skipReadOnly: !1,
  maxSampleDepth: 15
};
function $X(e, t) {
  var n;
  if (!e)
    throw new Error("Unknown format output for building XML.");
  return (Array.isArray(e) || Object.keys(e).length > 1) && (e = { [((n = t == null ? void 0 : t.xml) == null ? void 0 : n.name) || "root"]: e }), new TX.XMLBuilder({
    ignoreAttributes: !1,
    format: !0,
    attributeNamePrefix: "$",
    textNodeName: "#text"
  }).build(e);
}
function RX(e, t, r) {
  let n = Object.assign({}, CX, t);
  DG();
  let i = Zn(e, n, r).value;
  return (n == null ? void 0 : n.format) === "xml" ? $X(i, e) : i;
}
function _a(e, t) {
  k1[e] = t;
}
_a("array", FG);
_a("boolean", zG);
_a("integer", VL);
_a("number", VL);
_a("object", qG);
_a("string", cK);
const IX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _registerSampler: _a,
  _samplers: k1,
  inferType: xc,
  sample: RX
}, Symbol.toStringTag, { value: "Module" })), NX = /* @__PURE__ */ Di(IX);
var ZL = zN();
function A1(e) {
  return (t) => !!t.type && t.type.tabsRole === e;
}
const Lp = A1("Tab"), ey = A1("TabList"), ty = A1("TabPanel");
function jX(e) {
  return Lp(e) || ey(e) || ty(e);
}
function Iw(e, t) {
  return et.Children.map(e, (r) => r === null ? null : jX(r) ? t(r) : r.props && r.props.children && typeof r.props.children == "object" ? et.cloneElement(r, Object.assign({}, r.props, { children: Iw(r.props.children, t) })) : r);
}
function Gm(e, t) {
  return et.Children.forEach(e, (r) => {
    r !== null && (Lp(r) || ty(r) ? t(r) : r.props && r.props.children && typeof r.props.children == "object" && (ey(r) && t(r), Gm(r.props.children, t)));
  });
}
function eM(e, t, r) {
  let n, i = 0, s = 0, o = !1;
  const a = [], l = e[t];
  return Gm(l, (u) => {
    ey(u) && (u.props && u.props.children && typeof u.props.children == "object" && Gm(u.props.children, (f) => a.push(f)), o && (n = new Error("Found multiple 'TabList' components inside 'Tabs'. Only one is allowed.")), o = !0), Lp(u) ? ((!o || a.indexOf(u) === -1) && (n = new Error("Found a 'Tab' component outside of the 'TabList' component. 'Tab' components have to be inside the 'TabList' component.")), i++) : ty(u) && s++;
  }), !n && i !== s && (n = new Error(`There should be an equal number of 'Tab' and 'TabPanel' in \`${r}\`. Received ${i} 'Tab' and ${s} 'TabPanel'.`)), n;
}
function LX(e, t, r, n, i) {
  const s = e[t], o = i || t;
  let a = null;
  return s && typeof s != "function" ? a = new Error(`Invalid ${n} \`${o}\` of type \`${typeof s}\` supplied to \`${r}\`, expected \`function\`.`) : e.selectedIndex != null && s == null && (a = new Error(`The ${n} \`${o}\` is marked as required in \`${r}\`, but its value is \`undefined\` or \`null\`.
\`onSelect\` is required when \`selectedIndex\` is also set. Not doing so will make the tabs not do anything, as \`selectedIndex\` indicates that you want to handle the selected tab yourself.
If you only want to set the inital tab replace \`selectedIndex\` with \`defaultIndex\`.`)), a;
}
function MX(e, t, r, n, i) {
  const s = e[t], o = i || t;
  let a = null;
  if (s != null && typeof s != "number")
    a = new Error(`Invalid ${n} \`${o}\` of type \`${typeof s}\` supplied to \`${r}\`, expected \`number\`.`);
  else if (e.defaultIndex != null && s != null)
    return new Error(`The ${n} \`${o}\` cannot be used together with \`defaultIndex\` in \`${r}\`.
Either remove \`${o}\` to let \`${r}\` handle the selected tab internally or remove \`defaultIndex\` to handle it yourself.`);
  return a;
}
function tM(e) {
  var t, r, n = "";
  if (typeof e == "string" || typeof e == "number") n += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (r = tM(e[t])) && (n && (n += " "), n += r);
  } else for (r in e) e[r] && (n && (n += " "), n += r);
  return n;
}
function ry() {
  for (var e, t, r = 0, n = "", i = arguments.length; r < i; r++) (e = arguments[r]) && (t = tM(e)) && (n && (n += " "), n += t);
  return n;
}
function rM(e) {
  let t = 0;
  return Gm(e, (r) => {
    Lp(r) && t++;
  }), t;
}
const DX = ["children", "className", "disabledTabClassName", "domRef", "focus", "forceRenderTabPanel", "onSelect", "selectedIndex", "selectedTabClassName", "selectedTabPanelClassName", "environment", "disableUpDownKeys", "disableLeftRightKeys"];
function FX(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e) if ({}.hasOwnProperty.call(e, n)) {
    if (t.includes(n)) continue;
    r[n] = e[n];
  }
  return r;
}
function nM(e) {
  return e && "getAttribute" in e;
}
function IC(e) {
  return nM(e) && e.getAttribute("data-rttab");
}
function Hs(e) {
  return nM(e) && e.getAttribute("aria-disabled") === "true";
}
let Km;
function zX(e) {
  const t = e || (typeof window < "u" ? window : void 0);
  try {
    Km = !!(typeof t < "u" && t.document && t.document.activeElement);
  } catch {
    Km = !1;
  }
}
const qX = { className: "react-tabs", focus: !1 }, BX = { children: eM }, UX = (e) => {
  ZL.checkPropTypes(BX, e, "prop", "UncontrolledTabs");
  let t = et.useRef([]), r = et.useRef([]);
  const n = et.useRef();
  function i(b, A) {
    if (b < 0 || b >= u()) return;
    const { onSelect: P, selectedIndex: k } = e;
    P(b, k, A);
  }
  function s(b) {
    const A = u();
    for (let P = b + 1; P < A; P++)
      if (!Hs(f(P)))
        return P;
    for (let P = 0; P < b; P++)
      if (!Hs(f(P)))
        return P;
    return b;
  }
  function o(b) {
    let A = b;
    for (; A--; )
      if (!Hs(f(A)))
        return A;
    for (A = u(); A-- > b; )
      if (!Hs(f(A)))
        return A;
    return b;
  }
  function a() {
    const b = u();
    for (let A = 0; A < b; A++)
      if (!Hs(f(A)))
        return A;
    return null;
  }
  function l() {
    let b = u();
    for (; b--; )
      if (!Hs(f(b)))
        return b;
    return null;
  }
  function u() {
    const { children: b } = e;
    return rM(b);
  }
  function f(b) {
    return t.current[`tabs-${b}`];
  }
  function d() {
    let b = 0;
    const { children: A, disabledTabClassName: P, focus: k, forceRenderTabPanel: $, selectedIndex: I, selectedTabClassName: F, selectedTabPanelClassName: L, environment: Q } = e;
    r.current = r.current || [];
    let Y = r.current.length - u();
    const ae = et.useId();
    for (; Y++ < 0; )
      r.current.push(`${ae}${r.current.length}`);
    return Iw(A, (le) => {
      let ue = le;
      if (ey(le)) {
        let ce = 0, be = !1;
        Km == null && zX(Q);
        const G = Q || (typeof window < "u" ? window : void 0);
        Km && G && (be = at.Children.toArray(le.props.children).filter(Lp).some((ee, K) => G.document.activeElement === f(K))), ue = et.cloneElement(le, { children: Iw(le.props.children, (ee) => {
          const K = `tabs-${ce}`, z = I === ce, te = { tabRef: (q) => {
            t.current[K] = q;
          }, id: r.current[ce], selected: z, focus: z && (k || be) };
          return F && (te.selectedClassName = F), P && (te.disabledClassName = P), ce++, et.cloneElement(ee, te);
        }) });
      } else if (ty(le)) {
        const ce = { id: r.current[b], selected: I === b };
        $ && (ce.forceRender = $), L && (ce.selectedClassName = L), b++, ue = et.cloneElement(le, ce);
      }
      return ue;
    });
  }
  function m(b) {
    const { direction: A, disableUpDownKeys: P, disableLeftRightKeys: k } = e;
    if (S(b.target)) {
      let { selectedIndex: $ } = e, I = !1, F = !1;
      (b.code === "Space" || b.keyCode === 32 || b.code === "Enter" || b.keyCode === 13) && (I = !0, F = !1, v(b)), !k && (b.keyCode === 37 || b.code === "ArrowLeft") || !P && (b.keyCode === 38 || b.code === "ArrowUp") ? (A === "rtl" ? $ = s($) : $ = o($), I = !0, F = !0) : !k && (b.keyCode === 39 || b.code === "ArrowRight") || !P && (b.keyCode === 40 || b.code === "ArrowDown") ? (A === "rtl" ? $ = o($) : $ = s($), I = !0, F = !0) : b.keyCode === 35 || b.code === "End" ? ($ = l(), I = !0, F = !0) : (b.keyCode === 36 || b.code === "Home") && ($ = a(), I = !0, F = !0), I && b.preventDefault(), F && i($, b);
    }
  }
  function v(b) {
    let A = b.target;
    do
      if (S(A)) {
        if (Hs(A))
          return;
        const P = [].slice.call(A.parentNode.children).filter(IC).indexOf(A);
        i(P, b);
        return;
      }
    while ((A = A.parentNode) != null);
  }
  function S(b) {
    if (!IC(b))
      return !1;
    let A = b.parentElement;
    do {
      if (A === n.current) return !0;
      if (A.getAttribute("data-rttabs")) break;
      A = A.parentElement;
    } while (A);
    return !1;
  }
  const y = Object.assign({}, qX, e), { className: E, domRef: x } = y, g = FX(y, DX);
  return at.createElement("div", Object.assign({}, g, { className: ry(E), onClick: v, onKeyDown: m, ref: (b) => {
    n.current = b, x && x(b);
  }, "data-rttabs": !0 }), d());
}, VX = ["children", "defaultFocus", "defaultIndex", "focusTabOnClick", "onSelect"];
function WX(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e) if ({}.hasOwnProperty.call(e, n)) {
    if (t.includes(n)) continue;
    r[n] = e[n];
  }
  return r;
}
const HX = 0, Zh = 1, QX = { children: eM, onSelect: LX, selectedIndex: MX }, YX = { defaultFocus: !1, focusTabOnClick: !0, forceRenderTabPanel: !1, selectedIndex: null, defaultIndex: null, environment: null, disableUpDownKeys: !1, disableLeftRightKeys: !1 }, GX = (e) => e.selectedIndex === null ? Zh : HX, iM = (e) => {
  ZL.checkPropTypes(QX, e, "prop", "Tabs");
  const t = Object.assign({}, YX, e), { children: r, defaultFocus: n, defaultIndex: i, focusTabOnClick: s, onSelect: o } = t, a = WX(t, VX), [l, u] = et.useState(n), [f] = et.useState(GX(a)), [d, m] = et.useState(f === Zh ? i || 0 : null);
  if (et.useEffect(() => {
    u(!1);
  }, []), f === Zh) {
    const y = rM(r);
    et.useEffect(() => {
      if (d != null) {
        const E = Math.max(0, y - 1);
        m(Math.min(d, E));
      }
    }, [y]);
  }
  const v = (y, E, x) => {
    typeof o == "function" && o(y, E, x) === !1 || (s && u(!0), f === Zh && m(y));
  };
  let S = Object.assign({}, e, a);
  return S.focus = l, S.onSelect = v, d != null && (S.selectedIndex = d), delete S.defaultFocus, delete S.defaultIndex, delete S.focusTabOnClick, at.createElement(UX, S, r);
};
iM.tabsRole = "Tabs";
const KX = ["children", "className"];
function XX(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e) if ({}.hasOwnProperty.call(e, n)) {
    if (t.includes(n)) continue;
    r[n] = e[n];
  }
  return r;
}
const JX = { className: "react-tabs__tab-list" }, oM = (e) => {
  const t = Object.assign({}, JX, e), { children: r, className: n } = t, i = XX(t, KX);
  return at.createElement("ul", Object.assign({}, i, { className: ry(n), role: "tablist" }), r);
};
oM.tabsRole = "TabList";
const ZX = ["children", "className", "disabled", "disabledClassName", "focus", "id", "selected", "selectedClassName", "tabIndex", "tabRef"];
function eJ(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e) if ({}.hasOwnProperty.call(e, n)) {
    if (t.includes(n)) continue;
    r[n] = e[n];
  }
  return r;
}
const Wb = "react-tabs__tab", tJ = { className: Wb, disabledClassName: `${Wb}--disabled`, focus: !1, id: null, selected: !1, selectedClassName: `${Wb}--selected` }, sM = (e) => {
  let t = et.useRef();
  const r = Object.assign({}, tJ, e), { children: n, className: i, disabled: s, disabledClassName: o, focus: a, id: l, selected: u, selectedClassName: f, tabIndex: d, tabRef: m } = r, v = eJ(r, ZX);
  return et.useEffect(() => {
    u && a && t.current.focus();
  }, [u, a]), at.createElement("li", Object.assign({}, v, { className: ry(i, { [f]: u, [o]: s }), ref: (S) => {
    t.current = S, m && m(S);
  }, role: "tab", id: `tab${l}`, "aria-selected": u ? "true" : "false", "aria-disabled": s ? "true" : "false", "aria-controls": `panel${l}`, tabIndex: d || (u ? "0" : null), "data-rttab": !0 }), n);
};
sM.tabsRole = "Tab";
const rJ = ["children", "className", "forceRender", "id", "selected", "selectedClassName"];
function nJ(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e) if ({}.hasOwnProperty.call(e, n)) {
    if (t.includes(n)) continue;
    r[n] = e[n];
  }
  return r;
}
const NC = "react-tabs__tab-panel", iJ = { className: NC, forceRender: !1, selectedClassName: `${NC}--selected` }, aM = (e) => {
  const t = Object.assign({}, iJ, e), { children: r, className: n, forceRender: i, id: s, selected: o, selectedClassName: a } = t, l = nJ(t, rJ);
  return at.createElement("div", Object.assign({}, l, { className: ry(n, { [a]: o }), role: "tabpanel", id: `panel${s}`, "aria-labelledby": `tab${s}` }), i || o ? r : null);
};
aM.tabsRole = "TabPanel";
const oJ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Tab: sM,
  TabList: oM,
  TabPanel: aM,
  Tabs: iM
}, Symbol.toStringTag, { value: "Module" })), sJ = /* @__PURE__ */ Di(oJ);
/*!
 * perfect-scrollbar v1.5.6
 * Copyright 2024 Hyunje Jun, MDBootstrap and Contributors
 * Licensed under MIT
 */
function Ti(e) {
  return getComputedStyle(e);
}
function Xr(e, t) {
  for (var r in t) {
    var n = t[r];
    typeof n == "number" && (n = n + "px"), e.style[r] = n;
  }
  return e;
}
function kh(e) {
  var t = document.createElement("div");
  return t.className = e, t;
}
var jC = typeof Element < "u" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
function Ko(e, t) {
  if (!jC)
    throw new Error("No element matching method supported");
  return jC.call(e, t);
}
function El(e) {
  e.remove ? e.remove() : e.parentNode && e.parentNode.removeChild(e);
}
function LC(e, t) {
  return Array.prototype.filter.call(
    e.children,
    function(r) {
      return Ko(r, t);
    }
  );
}
var ir = {
  main: "ps",
  rtl: "ps__rtl",
  element: {
    thumb: function(e) {
      return "ps__thumb-" + e;
    },
    rail: function(e) {
      return "ps__rail-" + e;
    },
    consuming: "ps__child--consume"
  },
  state: {
    focus: "ps--focus",
    clicking: "ps--clicking",
    active: function(e) {
      return "ps--active-" + e;
    },
    scrolling: function(e) {
      return "ps--scrolling-" + e;
    }
  }
}, lM = { x: null, y: null };
function uM(e, t) {
  var r = e.element.classList, n = ir.state.scrolling(t);
  r.contains(n) ? clearTimeout(lM[t]) : r.add(n);
}
function cM(e, t) {
  lM[t] = setTimeout(
    function() {
      return e.isAlive && e.element.classList.remove(ir.state.scrolling(t));
    },
    e.settings.scrollingThreshold
  );
}
function aJ(e, t) {
  uM(e, t), cM(e, t);
}
var Mp = function(t) {
  this.element = t, this.handlers = {};
}, pM = { isEmpty: { configurable: !0 } };
Mp.prototype.bind = function(t, r) {
  typeof this.handlers[t] > "u" && (this.handlers[t] = []), this.handlers[t].push(r), this.element.addEventListener(t, r, !1);
};
Mp.prototype.unbind = function(t, r) {
  var n = this;
  this.handlers[t] = this.handlers[t].filter(function(i) {
    return r && i !== r ? !0 : (n.element.removeEventListener(t, i, !1), !1);
  });
};
Mp.prototype.unbindAll = function() {
  for (var t in this.handlers)
    this.unbind(t);
};
pM.isEmpty.get = function() {
  var e = this;
  return Object.keys(this.handlers).every(
    function(t) {
      return e.handlers[t].length === 0;
    }
  );
};
Object.defineProperties(Mp.prototype, pM);
var cu = function() {
  this.eventElements = [];
};
cu.prototype.eventElement = function(t) {
  var r = this.eventElements.filter(function(n) {
    return n.element === t;
  })[0];
  return r || (r = new Mp(t), this.eventElements.push(r)), r;
};
cu.prototype.bind = function(t, r, n) {
  this.eventElement(t).bind(r, n);
};
cu.prototype.unbind = function(t, r, n) {
  var i = this.eventElement(t);
  i.unbind(r, n), i.isEmpty && this.eventElements.splice(this.eventElements.indexOf(i), 1);
};
cu.prototype.unbindAll = function() {
  this.eventElements.forEach(function(t) {
    return t.unbindAll();
  }), this.eventElements = [];
};
cu.prototype.once = function(t, r, n) {
  var i = this.eventElement(t), s = function(o) {
    i.unbind(r, s), n(o);
  };
  i.bind(r, s);
};
function Ah(e) {
  if (typeof window.CustomEvent == "function")
    return new CustomEvent(e);
  var t = document.createEvent("CustomEvent");
  return t.initCustomEvent(e, !1, !1, void 0), t;
}
function Xm(e, t, r, n, i) {
  n === void 0 && (n = !0), i === void 0 && (i = !1);
  var s;
  if (t === "top")
    s = ["contentHeight", "containerHeight", "scrollTop", "y", "up", "down"];
  else if (t === "left")
    s = ["contentWidth", "containerWidth", "scrollLeft", "x", "left", "right"];
  else
    throw new Error("A proper axis should be provided");
  lJ(e, r, s, n, i);
}
function lJ(e, t, r, n, i) {
  var s = r[0], o = r[1], a = r[2], l = r[3], u = r[4], f = r[5];
  n === void 0 && (n = !0), i === void 0 && (i = !1);
  var d = e.element;
  e.reach[l] = null, d[a] < 1 && (e.reach[l] = "start"), d[a] > e[s] - e[o] - 1 && (e.reach[l] = "end"), t && (d.dispatchEvent(Ah("ps-scroll-" + l)), t < 0 ? d.dispatchEvent(Ah("ps-scroll-" + u)) : t > 0 && d.dispatchEvent(Ah("ps-scroll-" + f)), n && aJ(e, l)), e.reach[l] && (t || i) && d.dispatchEvent(Ah("ps-" + l + "-reach-" + e.reach[l]));
}
function Ut(e) {
  return parseInt(e, 10) || 0;
}
function uJ(e) {
  return Ko(e, "input,[contenteditable]") || Ko(e, "select,[contenteditable]") || Ko(e, "textarea,[contenteditable]") || Ko(e, "button,[contenteditable]");
}
function cJ(e) {
  var t = Ti(e);
  return Ut(t.width) + Ut(t.paddingLeft) + Ut(t.paddingRight) + Ut(t.borderLeftWidth) + Ut(t.borderRightWidth);
}
var sl = {
  isWebKit: typeof document < "u" && "WebkitAppearance" in document.documentElement.style,
  supportsTouch: typeof window < "u" && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
  supportsIePointer: typeof navigator < "u" && navigator.msMaxTouchPoints,
  isChrome: typeof navigator < "u" && /Chrome/i.test(navigator && navigator.userAgent)
};
function _o(e) {
  var t = e.element, r = Math.floor(t.scrollTop), n = t.getBoundingClientRect();
  e.containerWidth = Math.floor(n.width), e.containerHeight = Math.floor(n.height), e.contentWidth = t.scrollWidth, e.contentHeight = t.scrollHeight, t.contains(e.scrollbarXRail) || (LC(t, ir.element.rail("x")).forEach(function(i) {
    return El(i);
  }), t.appendChild(e.scrollbarXRail)), t.contains(e.scrollbarYRail) || (LC(t, ir.element.rail("y")).forEach(function(i) {
    return El(i);
  }), t.appendChild(e.scrollbarYRail)), !e.settings.suppressScrollX && e.containerWidth + e.settings.scrollXMarginOffset < e.contentWidth ? (e.scrollbarXActive = !0, e.railXWidth = e.containerWidth - e.railXMarginWidth, e.railXRatio = e.containerWidth / e.railXWidth, e.scrollbarXWidth = MC(e, Ut(e.railXWidth * e.containerWidth / e.contentWidth)), e.scrollbarXLeft = Ut(
    (e.negativeScrollAdjustment + t.scrollLeft) * (e.railXWidth - e.scrollbarXWidth) / (e.contentWidth - e.containerWidth)
  )) : e.scrollbarXActive = !1, !e.settings.suppressScrollY && e.containerHeight + e.settings.scrollYMarginOffset < e.contentHeight ? (e.scrollbarYActive = !0, e.railYHeight = e.containerHeight - e.railYMarginHeight, e.railYRatio = e.containerHeight / e.railYHeight, e.scrollbarYHeight = MC(
    e,
    Ut(e.railYHeight * e.containerHeight / e.contentHeight)
  ), e.scrollbarYTop = Ut(
    r * (e.railYHeight - e.scrollbarYHeight) / (e.contentHeight - e.containerHeight)
  )) : e.scrollbarYActive = !1, e.scrollbarXLeft >= e.railXWidth - e.scrollbarXWidth && (e.scrollbarXLeft = e.railXWidth - e.scrollbarXWidth), e.scrollbarYTop >= e.railYHeight - e.scrollbarYHeight && (e.scrollbarYTop = e.railYHeight - e.scrollbarYHeight), pJ(t, e), e.scrollbarXActive ? t.classList.add(ir.state.active("x")) : (t.classList.remove(ir.state.active("x")), e.scrollbarXWidth = 0, e.scrollbarXLeft = 0, t.scrollLeft = e.isRtl === !0 ? e.contentWidth : 0), e.scrollbarYActive ? t.classList.add(ir.state.active("y")) : (t.classList.remove(ir.state.active("y")), e.scrollbarYHeight = 0, e.scrollbarYTop = 0, t.scrollTop = 0);
}
function MC(e, t) {
  return e.settings.minScrollbarLength && (t = Math.max(t, e.settings.minScrollbarLength)), e.settings.maxScrollbarLength && (t = Math.min(t, e.settings.maxScrollbarLength)), t;
}
function pJ(e, t) {
  var r = { width: t.railXWidth }, n = Math.floor(e.scrollTop);
  t.isRtl ? r.left = t.negativeScrollAdjustment + e.scrollLeft + t.containerWidth - t.contentWidth : r.left = e.scrollLeft, t.isScrollbarXUsingBottom ? r.bottom = t.scrollbarXBottom - n : r.top = t.scrollbarXTop + n, Xr(t.scrollbarXRail, r);
  var i = { top: n, height: t.railYHeight };
  t.isScrollbarYUsingRight ? t.isRtl ? i.right = t.contentWidth - (t.negativeScrollAdjustment + e.scrollLeft) - t.scrollbarYRight - t.scrollbarYOuterWidth - 9 : i.right = t.scrollbarYRight - e.scrollLeft : t.isRtl ? i.left = t.negativeScrollAdjustment + e.scrollLeft + t.containerWidth * 2 - t.contentWidth - t.scrollbarYLeft - t.scrollbarYOuterWidth : i.left = t.scrollbarYLeft + e.scrollLeft, Xr(t.scrollbarYRail, i), Xr(t.scrollbarX, {
    left: t.scrollbarXLeft,
    width: t.scrollbarXWidth - t.railBorderXWidth
  }), Xr(t.scrollbarY, {
    top: t.scrollbarYTop,
    height: t.scrollbarYHeight - t.railBorderYWidth
  });
}
function fJ(e) {
  e.event.bind(e.scrollbarY, "mousedown", function(t) {
    return t.stopPropagation();
  }), e.event.bind(e.scrollbarYRail, "mousedown", function(t) {
    var r = t.pageY - window.pageYOffset - e.scrollbarYRail.getBoundingClientRect().top, n = r > e.scrollbarYTop ? 1 : -1;
    e.element.scrollTop += n * e.containerHeight, _o(e), t.stopPropagation();
  }), e.event.bind(e.scrollbarX, "mousedown", function(t) {
    return t.stopPropagation();
  }), e.event.bind(e.scrollbarXRail, "mousedown", function(t) {
    var r = t.pageX - window.pageXOffset - e.scrollbarXRail.getBoundingClientRect().left, n = r > e.scrollbarXLeft ? 1 : -1;
    e.element.scrollLeft += n * e.containerWidth, _o(e), t.stopPropagation();
  });
}
var Ph = null;
function dJ(e) {
  DC(e, [
    "containerHeight",
    "contentHeight",
    "pageY",
    "railYHeight",
    "scrollbarY",
    "scrollbarYHeight",
    "scrollTop",
    "y",
    "scrollbarYRail"
  ]), DC(e, [
    "containerWidth",
    "contentWidth",
    "pageX",
    "railXWidth",
    "scrollbarX",
    "scrollbarXWidth",
    "scrollLeft",
    "x",
    "scrollbarXRail"
  ]);
}
function DC(e, t) {
  var r = t[0], n = t[1], i = t[2], s = t[3], o = t[4], a = t[5], l = t[6], u = t[7], f = t[8], d = e.element, m = null, v = null, S = null;
  function y(g) {
    g.touches && g.touches[0] && (g[i] = g.touches[0]["page" + u.toUpperCase()]), Ph === o && (d[l] = m + S * (g[i] - v), uM(e, u), _o(e), g.stopPropagation(), g.preventDefault());
  }
  function E() {
    cM(e, u), e[f].classList.remove(ir.state.clicking), document.removeEventListener("mousemove", y), document.removeEventListener("mouseup", E), document.removeEventListener("touchmove", y), document.removeEventListener("touchend", E), Ph = null;
  }
  function x(g) {
    Ph === null && (Ph = o, m = d[l], g.touches && (g[i] = g.touches[0]["page" + u.toUpperCase()]), v = g[i], S = (e[n] - e[r]) / (e[s] - e[a]), g.touches ? (document.addEventListener("touchmove", y, { passive: !1 }), document.addEventListener("touchend", E)) : (document.addEventListener("mousemove", y), document.addEventListener("mouseup", E)), e[f].classList.add(ir.state.clicking)), g.stopPropagation(), g.cancelable && g.preventDefault();
  }
  e[o].addEventListener("mousedown", x), e[o].addEventListener("touchstart", x);
}
function hJ(e) {
  var t = e.element, r = function() {
    return Ko(t, ":hover");
  }, n = function() {
    return Ko(e.scrollbarX, ":focus") || Ko(e.scrollbarY, ":focus");
  };
  function i(s, o) {
    var a = Math.floor(t.scrollTop);
    if (s === 0) {
      if (!e.scrollbarYActive)
        return !1;
      if (a === 0 && o > 0 || a >= e.contentHeight - e.containerHeight && o < 0)
        return !e.settings.wheelPropagation;
    }
    var l = t.scrollLeft;
    if (o === 0) {
      if (!e.scrollbarXActive)
        return !1;
      if (l === 0 && s < 0 || l >= e.contentWidth - e.containerWidth && s > 0)
        return !e.settings.wheelPropagation;
    }
    return !0;
  }
  e.event.bind(e.ownerDocument, "keydown", function(s) {
    if (!(s.isDefaultPrevented && s.isDefaultPrevented() || s.defaultPrevented) && !(!r() && !n())) {
      var o = document.activeElement ? document.activeElement : e.ownerDocument.activeElement;
      if (o) {
        if (o.tagName === "IFRAME")
          o = o.contentDocument.activeElement;
        else
          for (; o.shadowRoot; )
            o = o.shadowRoot.activeElement;
        if (uJ(o))
          return;
      }
      var a = 0, l = 0;
      switch (s.which) {
        case 37:
          s.metaKey ? a = -e.contentWidth : s.altKey ? a = -e.containerWidth : a = -30;
          break;
        case 38:
          s.metaKey ? l = e.contentHeight : s.altKey ? l = e.containerHeight : l = 30;
          break;
        case 39:
          s.metaKey ? a = e.contentWidth : s.altKey ? a = e.containerWidth : a = 30;
          break;
        case 40:
          s.metaKey ? l = -e.contentHeight : s.altKey ? l = -e.containerHeight : l = -30;
          break;
        case 32:
          s.shiftKey ? l = e.containerHeight : l = -e.containerHeight;
          break;
        case 33:
          l = e.containerHeight;
          break;
        case 34:
          l = -e.containerHeight;
          break;
        case 36:
          l = e.contentHeight;
          break;
        case 35:
          l = -e.contentHeight;
          break;
        default:
          return;
      }
      e.settings.suppressScrollX && a !== 0 || e.settings.suppressScrollY && l !== 0 || (t.scrollTop -= l, t.scrollLeft += a, _o(e), i(a, l) && s.preventDefault());
    }
  });
}
function mJ(e) {
  var t = e.element;
  function r(o, a) {
    var l = Math.floor(t.scrollTop), u = t.scrollTop === 0, f = l + t.offsetHeight === t.scrollHeight, d = t.scrollLeft === 0, m = t.scrollLeft + t.offsetWidth === t.scrollWidth, v;
    return Math.abs(a) > Math.abs(o) ? v = u || f : v = d || m, v ? !e.settings.wheelPropagation : !0;
  }
  function n(o) {
    var a = o.deltaX, l = -1 * o.deltaY;
    return (typeof a > "u" || typeof l > "u") && (a = -1 * o.wheelDeltaX / 6, l = o.wheelDeltaY / 6), o.deltaMode && o.deltaMode === 1 && (a *= 10, l *= 10), a !== a && l !== l && (a = 0, l = o.wheelDelta), o.shiftKey ? [-l, -a] : [a, l];
  }
  function i(o, a, l) {
    if (!sl.isWebKit && t.querySelector("select:focus"))
      return !0;
    if (!t.contains(o))
      return !1;
    for (var u = o; u && u !== t; ) {
      if (u.classList.contains(ir.element.consuming))
        return !0;
      var f = Ti(u);
      if (l && f.overflowY.match(/(scroll|auto)/)) {
        var d = u.scrollHeight - u.clientHeight;
        if (d > 0 && (u.scrollTop > 0 && l < 0 || u.scrollTop < d && l > 0))
          return !0;
      }
      if (a && f.overflowX.match(/(scroll|auto)/)) {
        var m = u.scrollWidth - u.clientWidth;
        if (m > 0 && (u.scrollLeft > 0 && a < 0 || u.scrollLeft < m && a > 0))
          return !0;
      }
      u = u.parentNode;
    }
    return !1;
  }
  function s(o) {
    var a = n(o), l = a[0], u = a[1];
    if (!i(o.target, l, u)) {
      var f = !1;
      e.settings.useBothWheelAxes ? e.scrollbarYActive && !e.scrollbarXActive ? (u ? t.scrollTop -= u * e.settings.wheelSpeed : t.scrollTop += l * e.settings.wheelSpeed, f = !0) : e.scrollbarXActive && !e.scrollbarYActive && (l ? t.scrollLeft += l * e.settings.wheelSpeed : t.scrollLeft -= u * e.settings.wheelSpeed, f = !0) : (t.scrollTop -= u * e.settings.wheelSpeed, t.scrollLeft += l * e.settings.wheelSpeed), _o(e), f = f || r(l, u), f && !o.ctrlKey && (o.stopPropagation(), o.preventDefault());
    }
  }
  typeof window.onwheel < "u" ? e.event.bind(t, "wheel", s) : typeof window.onmousewheel < "u" && e.event.bind(t, "mousewheel", s);
}
function gJ(e) {
  if (!sl.supportsTouch && !sl.supportsIePointer)
    return;
  var t = e.element, r = {
    startOffset: {},
    startTime: 0,
    speed: {},
    easingLoop: null
  };
  function n(d, m) {
    var v = Math.floor(t.scrollTop), S = t.scrollLeft, y = Math.abs(d), E = Math.abs(m);
    if (E > y) {
      if (m < 0 && v === e.contentHeight - e.containerHeight || m > 0 && v === 0)
        return window.scrollY === 0 && m > 0 && sl.isChrome;
    } else if (y > E && (d < 0 && S === e.contentWidth - e.containerWidth || d > 0 && S === 0))
      return !0;
    return !0;
  }
  function i(d, m) {
    t.scrollTop -= m, t.scrollLeft -= d, _o(e);
  }
  function s(d) {
    return d.targetTouches ? d.targetTouches[0] : d;
  }
  function o(d) {
    return d.target === e.scrollbarX || d.target === e.scrollbarY || d.pointerType && d.pointerType === "pen" && d.buttons === 0 ? !1 : !!(d.targetTouches && d.targetTouches.length === 1 || d.pointerType && d.pointerType !== "mouse" && d.pointerType !== d.MSPOINTER_TYPE_MOUSE);
  }
  function a(d) {
    if (o(d)) {
      var m = s(d);
      r.startOffset.pageX = m.pageX, r.startOffset.pageY = m.pageY, r.startTime = (/* @__PURE__ */ new Date()).getTime(), r.easingLoop !== null && clearInterval(r.easingLoop);
    }
  }
  function l(d, m, v) {
    if (!t.contains(d))
      return !1;
    for (var S = d; S && S !== t; ) {
      if (S.classList.contains(ir.element.consuming))
        return !0;
      var y = Ti(S);
      if (v && y.overflowY.match(/(scroll|auto)/)) {
        var E = S.scrollHeight - S.clientHeight;
        if (E > 0 && (S.scrollTop > 0 && v < 0 || S.scrollTop < E && v > 0))
          return !0;
      }
      if (m && y.overflowX.match(/(scroll|auto)/)) {
        var x = S.scrollWidth - S.clientWidth;
        if (x > 0 && (S.scrollLeft > 0 && m < 0 || S.scrollLeft < x && m > 0))
          return !0;
      }
      S = S.parentNode;
    }
    return !1;
  }
  function u(d) {
    if (o(d)) {
      var m = s(d), v = { pageX: m.pageX, pageY: m.pageY }, S = v.pageX - r.startOffset.pageX, y = v.pageY - r.startOffset.pageY;
      if (l(d.target, S, y))
        return;
      i(S, y), r.startOffset = v;
      var E = (/* @__PURE__ */ new Date()).getTime(), x = E - r.startTime;
      x > 0 && (r.speed.x = S / x, r.speed.y = y / x, r.startTime = E), n(S, y) && d.cancelable && d.preventDefault();
    }
  }
  function f() {
    e.settings.swipeEasing && (clearInterval(r.easingLoop), r.easingLoop = setInterval(function() {
      if (e.isInitialized) {
        clearInterval(r.easingLoop);
        return;
      }
      if (!r.speed.x && !r.speed.y) {
        clearInterval(r.easingLoop);
        return;
      }
      if (Math.abs(r.speed.x) < 0.01 && Math.abs(r.speed.y) < 0.01) {
        clearInterval(r.easingLoop);
        return;
      }
      i(r.speed.x * 30, r.speed.y * 30), r.speed.x *= 0.8, r.speed.y *= 0.8;
    }, 10));
  }
  sl.supportsTouch ? (e.event.bind(t, "touchstart", a), e.event.bind(t, "touchmove", u), e.event.bind(t, "touchend", f)) : sl.supportsIePointer && (window.PointerEvent ? (e.event.bind(t, "pointerdown", a), e.event.bind(t, "pointermove", u), e.event.bind(t, "pointerup", f)) : window.MSPointerEvent && (e.event.bind(t, "MSPointerDown", a), e.event.bind(t, "MSPointerMove", u), e.event.bind(t, "MSPointerUp", f)));
}
var yJ = function() {
  return {
    handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
    maxScrollbarLength: null,
    minScrollbarLength: null,
    scrollingThreshold: 1e3,
    scrollXMarginOffset: 0,
    scrollYMarginOffset: 0,
    suppressScrollX: !1,
    suppressScrollY: !1,
    swipeEasing: !0,
    useBothWheelAxes: !1,
    wheelPropagation: !0,
    wheelSpeed: 1
  };
}, vJ = {
  "click-rail": fJ,
  "drag-thumb": dJ,
  keyboard: hJ,
  wheel: mJ,
  touch: gJ
}, Dp = function(t, r) {
  var n = this;
  if (r === void 0 && (r = {}), typeof t == "string" && (t = document.querySelector(t)), !t || !t.nodeName)
    throw new Error("no element is specified to initialize PerfectScrollbar");
  this.element = t, t.classList.add(ir.main), this.settings = yJ();
  for (var i in r)
    this.settings[i] = r[i];
  this.containerWidth = null, this.containerHeight = null, this.contentWidth = null, this.contentHeight = null;
  var s = function() {
    return t.classList.add(ir.state.focus);
  }, o = function() {
    return t.classList.remove(ir.state.focus);
  };
  this.isRtl = Ti(t).direction === "rtl", this.isRtl === !0 && t.classList.add(ir.rtl), this.isNegativeScroll = function() {
    var u = t.scrollLeft, f = null;
    return t.scrollLeft = -1, f = t.scrollLeft < 0, t.scrollLeft = u, f;
  }(), this.negativeScrollAdjustment = this.isNegativeScroll ? t.scrollWidth - t.clientWidth : 0, this.event = new cu(), this.ownerDocument = t.ownerDocument || document, this.scrollbarXRail = kh(ir.element.rail("x")), t.appendChild(this.scrollbarXRail), this.scrollbarX = kh(ir.element.thumb("x")), this.scrollbarXRail.appendChild(this.scrollbarX), this.scrollbarX.setAttribute("tabindex", 0), this.event.bind(this.scrollbarX, "focus", s), this.event.bind(this.scrollbarX, "blur", o), this.scrollbarXActive = null, this.scrollbarXWidth = null, this.scrollbarXLeft = null;
  var a = Ti(this.scrollbarXRail);
  this.scrollbarXBottom = parseInt(a.bottom, 10), isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = !1, this.scrollbarXTop = Ut(a.top)) : this.isScrollbarXUsingBottom = !0, this.railBorderXWidth = Ut(a.borderLeftWidth) + Ut(a.borderRightWidth), Xr(this.scrollbarXRail, { display: "block" }), this.railXMarginWidth = Ut(a.marginLeft) + Ut(a.marginRight), Xr(this.scrollbarXRail, { display: "" }), this.railXWidth = null, this.railXRatio = null, this.scrollbarYRail = kh(ir.element.rail("y")), t.appendChild(this.scrollbarYRail), this.scrollbarY = kh(ir.element.thumb("y")), this.scrollbarYRail.appendChild(this.scrollbarY), this.scrollbarY.setAttribute("tabindex", 0), this.event.bind(this.scrollbarY, "focus", s), this.event.bind(this.scrollbarY, "blur", o), this.scrollbarYActive = null, this.scrollbarYHeight = null, this.scrollbarYTop = null;
  var l = Ti(this.scrollbarYRail);
  this.scrollbarYRight = parseInt(l.right, 10), isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = !1, this.scrollbarYLeft = Ut(l.left)) : this.isScrollbarYUsingRight = !0, this.scrollbarYOuterWidth = this.isRtl ? cJ(this.scrollbarY) : null, this.railBorderYWidth = Ut(l.borderTopWidth) + Ut(l.borderBottomWidth), Xr(this.scrollbarYRail, { display: "block" }), this.railYMarginHeight = Ut(l.marginTop) + Ut(l.marginBottom), Xr(this.scrollbarYRail, { display: "" }), this.railYHeight = null, this.railYRatio = null, this.reach = {
    x: t.scrollLeft <= 0 ? "start" : t.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
    y: t.scrollTop <= 0 ? "start" : t.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
  }, this.isAlive = !0, this.settings.handlers.forEach(function(u) {
    return vJ[u](n);
  }), this.lastScrollTop = Math.floor(t.scrollTop), this.lastScrollLeft = t.scrollLeft, this.event.bind(this.element, "scroll", function(u) {
    return n.onScroll(u);
  }), _o(this);
};
Dp.prototype.update = function() {
  this.isAlive && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0, Xr(this.scrollbarXRail, { display: "block" }), Xr(this.scrollbarYRail, { display: "block" }), this.railXMarginWidth = Ut(Ti(this.scrollbarXRail).marginLeft) + Ut(Ti(this.scrollbarXRail).marginRight), this.railYMarginHeight = Ut(Ti(this.scrollbarYRail).marginTop) + Ut(Ti(this.scrollbarYRail).marginBottom), Xr(this.scrollbarXRail, { display: "none" }), Xr(this.scrollbarYRail, { display: "none" }), _o(this), Xm(this, "top", 0, !1, !0), Xm(this, "left", 0, !1, !0), Xr(this.scrollbarXRail, { display: "" }), Xr(this.scrollbarYRail, { display: "" }));
};
Dp.prototype.onScroll = function(t) {
  this.isAlive && (_o(this), Xm(this, "top", this.element.scrollTop - this.lastScrollTop), Xm(this, "left", this.element.scrollLeft - this.lastScrollLeft), this.lastScrollTop = Math.floor(this.element.scrollTop), this.lastScrollLeft = this.element.scrollLeft);
};
Dp.prototype.destroy = function() {
  this.isAlive && (this.event.unbindAll(), El(this.scrollbarX), El(this.scrollbarY), El(this.scrollbarXRail), El(this.scrollbarYRail), this.removePsClasses(), this.element = null, this.scrollbarX = null, this.scrollbarY = null, this.scrollbarXRail = null, this.scrollbarYRail = null, this.isAlive = !1);
};
Dp.prototype.removePsClasses = function() {
  this.element.className = this.element.className.split(" ").filter(function(t) {
    return !t.match(/^ps([-_].+|)$/);
  }).join(" ");
};
const bJ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Dp
}, Symbol.toStringTag, { value: "Module" })), wJ = /* @__PURE__ */ Di(bJ);
/*! @license DOMPurify 3.2.4 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.4/LICENSE */
var Hb, FC;
function SJ() {
  if (FC) return Hb;
  FC = 1;
  const {
    entries: e,
    setPrototypeOf: t,
    isFrozen: r,
    getPrototypeOf: n,
    getOwnPropertyDescriptor: i
  } = Object;
  let {
    freeze: s,
    seal: o,
    create: a
  } = Object, {
    apply: l,
    construct: u
  } = typeof Reflect < "u" && Reflect;
  s || (s = function(se) {
    return se;
  }), o || (o = function(se) {
    return se;
  }), l || (l = function(se, ve, ge) {
    return se.apply(ve, ge);
  }), u || (u = function(se, ve) {
    return new se(...ve);
  });
  const f = I(Array.prototype.forEach), d = I(Array.prototype.lastIndexOf), m = I(Array.prototype.pop), v = I(Array.prototype.push), S = I(Array.prototype.splice), y = I(String.prototype.toLowerCase), E = I(String.prototype.toString), x = I(String.prototype.match), g = I(String.prototype.replace), b = I(String.prototype.indexOf), A = I(String.prototype.trim), P = I(Object.prototype.hasOwnProperty), k = I(RegExp.prototype.test), $ = F(TypeError);
  function I(M) {
    return function(se) {
      for (var ve = arguments.length, ge = new Array(ve > 1 ? ve - 1 : 0), Oe = 1; Oe < ve; Oe++)
        ge[Oe - 1] = arguments[Oe];
      return l(M, se, ge);
    };
  }
  function F(M) {
    return function() {
      for (var se = arguments.length, ve = new Array(se), ge = 0; ge < se; ge++)
        ve[ge] = arguments[ge];
      return u(M, ve);
    };
  }
  function L(M, se) {
    let ve = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : y;
    t && t(M, null);
    let ge = se.length;
    for (; ge--; ) {
      let Oe = se[ge];
      if (typeof Oe == "string") {
        const ke = ve(Oe);
        ke !== Oe && (r(se) || (se[ge] = ke), Oe = ke);
      }
      M[Oe] = !0;
    }
    return M;
  }
  function Q(M) {
    for (let se = 0; se < M.length; se++)
      P(M, se) || (M[se] = null);
    return M;
  }
  function Y(M) {
    const se = a(null);
    for (const [ve, ge] of e(M))
      P(M, ve) && (Array.isArray(ge) ? se[ve] = Q(ge) : ge && typeof ge == "object" && ge.constructor === Object ? se[ve] = Y(ge) : se[ve] = ge);
    return se;
  }
  function ae(M, se) {
    for (; M !== null; ) {
      const ge = i(M, se);
      if (ge) {
        if (ge.get)
          return I(ge.get);
        if (typeof ge.value == "function")
          return I(ge.value);
      }
      M = n(M);
    }
    function ve() {
      return null;
    }
    return ve;
  }
  const le = s(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), ue = s(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), ce = s(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), be = s(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), G = s(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), ee = s(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), K = s(["#text"]), z = s(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), te = s(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), q = s(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), j = s(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), H = o(/\{\{[\w\W]*|[\w\W]*\}\}/gm), B = o(/<%[\w\W]*|[\w\W]*%>/gm), pe = o(/\$\{[\w\W]*/gm), he = o(/^data-[\-\w.\u00B7-\uFFFF]+$/), Ae = o(/^aria-[\-\w]+$/), C = o(
    /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
    // eslint-disable-line no-useless-escape
  ), N = o(/^(?:\w+script|data):/i), J = o(
    /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
    // eslint-disable-line no-control-regex
  ), X = o(/^html$/i), oe = o(/^[a-z][.\w]*(-[.\w]+)+$/i);
  var U = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ARIA_ATTR: Ae,
    ATTR_WHITESPACE: J,
    CUSTOM_ELEMENT: oe,
    DATA_ATTR: he,
    DOCTYPE_NAME: X,
    ERB_EXPR: B,
    IS_ALLOWED_URI: C,
    IS_SCRIPT_OR_DATA: N,
    MUSTACHE_EXPR: H,
    TMPLIT_EXPR: pe
  });
  const V = {
    element: 1,
    text: 3,
    // Deprecated
    progressingInstruction: 7,
    comment: 8,
    document: 9
  }, ye = function() {
    return typeof window > "u" ? null : window;
  }, de = function(se, ve) {
    if (typeof se != "object" || typeof se.createPolicy != "function")
      return null;
    let ge = null;
    const Oe = "data-tt-policy-suffix";
    ve && ve.hasAttribute(Oe) && (ge = ve.getAttribute(Oe));
    const ke = "dompurify" + (ge ? "#" + ge : "");
    try {
      return se.createPolicy(ke, {
        createHTML(Me) {
          return Me;
        },
        createScriptURL(Me) {
          return Me;
        }
      });
    } catch {
      return console.warn("TrustedTypes policy " + ke + " could not be created."), null;
    }
  }, Ce = function() {
    return {
      afterSanitizeAttributes: [],
      afterSanitizeElements: [],
      afterSanitizeShadowDOM: [],
      beforeSanitizeAttributes: [],
      beforeSanitizeElements: [],
      beforeSanitizeShadowDOM: [],
      uponSanitizeAttribute: [],
      uponSanitizeElement: [],
      uponSanitizeShadowNode: []
    };
  };
  function Se() {
    let M = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ye();
    const se = (Ge) => Se(Ge);
    if (se.version = "3.2.4", se.removed = [], !M || !M.document || M.document.nodeType !== V.document || !M.Element)
      return se.isSupported = !1, se;
    let {
      document: ve
    } = M;
    const ge = ve, Oe = ge.currentScript, {
      DocumentFragment: ke,
      HTMLTemplateElement: Me,
      Node: Ve,
      Element: Je,
      NodeFilter: He,
      NamedNodeMap: Ue = M.NamedNodeMap || M.MozNamedAttrMap,
      HTMLFormElement: Ot,
      DOMParser: D,
      trustedTypes: we
    } = M, Ee = Je.prototype, _e = ae(Ee, "cloneNode"), Te = ae(Ee, "remove"), $e = ae(Ee, "nextSibling"), Be = ae(Ee, "childNodes"), Pe = ae(Ee, "parentNode");
    if (typeof Me == "function") {
      const Ge = ve.createElement("template");
      Ge.content && Ge.content.ownerDocument && (ve = Ge.content.ownerDocument);
    }
    let Re, Qe = "";
    const {
      implementation: ht,
      createNodeIterator: rt,
      createDocumentFragment: ut,
      getElementsByTagName: yt
    } = ve, {
      importNode: zn
    } = ge;
    let qt = Ce();
    se.isSupported = typeof e == "function" && typeof Pe == "function" && ht && ht.createHTMLDocument !== void 0;
    const {
      MUSTACHE_EXPR: du,
      ERB_EXPR: Oa,
      TMPLIT_EXPR: hu,
      DATA_ATTR: py,
      ARIA_ATTR: Fp,
      IS_SCRIPT_OR_DATA: Fi,
      ATTR_WHITESPACE: ka,
      CUSTOM_ELEMENT: zp
    } = U;
    let {
      IS_ALLOWED_URI: mu
    } = U, Qt = null;
    const qp = L({}, [...le, ...ue, ...ce, ...G, ...K]);
    let Yt = null;
    const gu = L({}, [...z, ...te, ...q, ...j]);
    let Dt = Object.seal(a(null, {
      tagNameCheck: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: null
      },
      attributeNameCheck: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: !1
      }
    })), Ao = null, _s = null, Po = !0, Aa = !0, yu = !1, vu = !0, En = !1, Pa = !0, qn = !1, Ta = !1, zi = !1, qi = !1, Os = !1, To = !1, Ca = !0, $a = !1;
    const Bp = "user-content-";
    let ks = !0, Bi = !1, di = {}, Ui = null;
    const bu = L({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
    let wu = null;
    const Ra = L({}, ["audio", "video", "img", "source", "image", "track"]);
    let Ia = null;
    const Su = L({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), As = "http://www.w3.org/1998/Math/MathML", hi = "http://www.w3.org/2000/svg", Bn = "http://www.w3.org/1999/xhtml";
    let mi = Bn, Na = !1, Vi = null;
    const Up = L({}, [As, hi, Bn], E);
    let Ps = L({}, ["mi", "mo", "mn", "ms", "mtext"]), gi = L({}, ["annotation-xml"]);
    const Vp = L({}, ["title", "style", "font", "a", "script"]);
    let Co = null;
    const xu = ["application/xhtml+xml", "text/html"], Wp = "text/html";
    let tr = null, $o = null;
    const fy = ve.createElement("form"), Hp = function(fe) {
      return fe instanceof RegExp || fe instanceof Function;
    }, Eu = function() {
      let fe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!($o && $o === fe)) {
        if ((!fe || typeof fe != "object") && (fe = {}), fe = Y(fe), Co = // eslint-disable-next-line unicorn/prefer-includes
        xu.indexOf(fe.PARSER_MEDIA_TYPE) === -1 ? Wp : fe.PARSER_MEDIA_TYPE, tr = Co === "application/xhtml+xml" ? E : y, Qt = P(fe, "ALLOWED_TAGS") ? L({}, fe.ALLOWED_TAGS, tr) : qp, Yt = P(fe, "ALLOWED_ATTR") ? L({}, fe.ALLOWED_ATTR, tr) : gu, Vi = P(fe, "ALLOWED_NAMESPACES") ? L({}, fe.ALLOWED_NAMESPACES, E) : Up, Ia = P(fe, "ADD_URI_SAFE_ATTR") ? L(Y(Su), fe.ADD_URI_SAFE_ATTR, tr) : Su, wu = P(fe, "ADD_DATA_URI_TAGS") ? L(Y(Ra), fe.ADD_DATA_URI_TAGS, tr) : Ra, Ui = P(fe, "FORBID_CONTENTS") ? L({}, fe.FORBID_CONTENTS, tr) : bu, Ao = P(fe, "FORBID_TAGS") ? L({}, fe.FORBID_TAGS, tr) : {}, _s = P(fe, "FORBID_ATTR") ? L({}, fe.FORBID_ATTR, tr) : {}, di = P(fe, "USE_PROFILES") ? fe.USE_PROFILES : !1, Po = fe.ALLOW_ARIA_ATTR !== !1, Aa = fe.ALLOW_DATA_ATTR !== !1, yu = fe.ALLOW_UNKNOWN_PROTOCOLS || !1, vu = fe.ALLOW_SELF_CLOSE_IN_ATTR !== !1, En = fe.SAFE_FOR_TEMPLATES || !1, Pa = fe.SAFE_FOR_XML !== !1, qn = fe.WHOLE_DOCUMENT || !1, qi = fe.RETURN_DOM || !1, Os = fe.RETURN_DOM_FRAGMENT || !1, To = fe.RETURN_TRUSTED_TYPE || !1, zi = fe.FORCE_BODY || !1, Ca = fe.SANITIZE_DOM !== !1, $a = fe.SANITIZE_NAMED_PROPS || !1, ks = fe.KEEP_CONTENT !== !1, Bi = fe.IN_PLACE || !1, mu = fe.ALLOWED_URI_REGEXP || C, mi = fe.NAMESPACE || Bn, Ps = fe.MATHML_TEXT_INTEGRATION_POINTS || Ps, gi = fe.HTML_INTEGRATION_POINTS || gi, Dt = fe.CUSTOM_ELEMENT_HANDLING || {}, fe.CUSTOM_ELEMENT_HANDLING && Hp(fe.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Dt.tagNameCheck = fe.CUSTOM_ELEMENT_HANDLING.tagNameCheck), fe.CUSTOM_ELEMENT_HANDLING && Hp(fe.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Dt.attributeNameCheck = fe.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), fe.CUSTOM_ELEMENT_HANDLING && typeof fe.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Dt.allowCustomizedBuiltInElements = fe.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), En && (Aa = !1), Os && (qi = !0), di && (Qt = L({}, K), Yt = [], di.html === !0 && (L(Qt, le), L(Yt, z)), di.svg === !0 && (L(Qt, ue), L(Yt, te), L(Yt, j)), di.svgFilters === !0 && (L(Qt, ce), L(Yt, te), L(Yt, j)), di.mathMl === !0 && (L(Qt, G), L(Yt, q), L(Yt, j))), fe.ADD_TAGS && (Qt === qp && (Qt = Y(Qt)), L(Qt, fe.ADD_TAGS, tr)), fe.ADD_ATTR && (Yt === gu && (Yt = Y(Yt)), L(Yt, fe.ADD_ATTR, tr)), fe.ADD_URI_SAFE_ATTR && L(Ia, fe.ADD_URI_SAFE_ATTR, tr), fe.FORBID_CONTENTS && (Ui === bu && (Ui = Y(Ui)), L(Ui, fe.FORBID_CONTENTS, tr)), ks && (Qt["#text"] = !0), qn && L(Qt, ["html", "head", "body"]), Qt.table && (L(Qt, ["tbody"]), delete Ao.tbody), fe.TRUSTED_TYPES_POLICY) {
          if (typeof fe.TRUSTED_TYPES_POLICY.createHTML != "function")
            throw $('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
          if (typeof fe.TRUSTED_TYPES_POLICY.createScriptURL != "function")
            throw $('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
          Re = fe.TRUSTED_TYPES_POLICY, Qe = Re.createHTML("");
        } else
          Re === void 0 && (Re = de(we, Oe)), Re !== null && typeof Qe == "string" && (Qe = Re.createHTML(""));
        s && s(fe), $o = fe;
      }
    }, _u = L({}, [...ue, ...ce, ...be]), Qp = L({}, [...G, ...ee]), dy = function(fe) {
      let je = Pe(fe);
      (!je || !je.tagName) && (je = {
        namespaceURI: mi,
        tagName: "template"
      });
      const We = y(fe.tagName), kt = y(je.tagName);
      return Vi[fe.namespaceURI] ? fe.namespaceURI === hi ? je.namespaceURI === Bn ? We === "svg" : je.namespaceURI === As ? We === "svg" && (kt === "annotation-xml" || Ps[kt]) : !!_u[We] : fe.namespaceURI === As ? je.namespaceURI === Bn ? We === "math" : je.namespaceURI === hi ? We === "math" && gi[kt] : !!Qp[We] : fe.namespaceURI === Bn ? je.namespaceURI === hi && !gi[kt] || je.namespaceURI === As && !Ps[kt] ? !1 : !Qp[We] && (Vp[We] || !_u[We]) : !!(Co === "application/xhtml+xml" && Vi[fe.namespaceURI]) : !1;
    }, an = function(fe) {
      v(se.removed, {
        element: fe
      });
      try {
        Pe(fe).removeChild(fe);
      } catch {
        Te(fe);
      }
    }, Ts = function(fe, je) {
      try {
        v(se.removed, {
          attribute: je.getAttributeNode(fe),
          from: je
        });
      } catch {
        v(se.removed, {
          attribute: null,
          from: je
        });
      }
      if (je.removeAttribute(fe), fe === "is")
        if (qi || Os)
          try {
            an(je);
          } catch {
          }
        else
          try {
            je.setAttribute(fe, "");
          } catch {
          }
    }, Ou = function(fe) {
      let je = null, We = null;
      if (zi)
        fe = "<remove></remove>" + fe;
      else {
        const lr = x(fe, /^[\r\n\t ]+/);
        We = lr && lr[0];
      }
      Co === "application/xhtml+xml" && mi === Bn && (fe = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + fe + "</body></html>");
      const kt = Re ? Re.createHTML(fe) : fe;
      if (mi === Bn)
        try {
          je = new D().parseFromString(kt, Co);
        } catch {
        }
      if (!je || !je.documentElement) {
        je = ht.createDocument(mi, "template", null);
        try {
          je.documentElement.innerHTML = Na ? Qe : kt;
        } catch {
        }
      }
      const fr = je.body || je.documentElement;
      return fe && We && fr.insertBefore(ve.createTextNode(We), fr.childNodes[0] || null), mi === Bn ? yt.call(je, qn ? "html" : "body")[0] : qn ? je.documentElement : fr;
    }, Cs = function(fe) {
      return rt.call(
        fe.ownerDocument || fe,
        fe,
        // eslint-disable-next-line no-bitwise
        He.SHOW_ELEMENT | He.SHOW_COMMENT | He.SHOW_TEXT | He.SHOW_PROCESSING_INSTRUCTION | He.SHOW_CDATA_SECTION,
        null
      );
    }, yi = function(fe) {
      return fe instanceof Ot && (typeof fe.nodeName != "string" || typeof fe.textContent != "string" || typeof fe.removeChild != "function" || !(fe.attributes instanceof Ue) || typeof fe.removeAttribute != "function" || typeof fe.setAttribute != "function" || typeof fe.namespaceURI != "string" || typeof fe.insertBefore != "function" || typeof fe.hasChildNodes != "function");
    }, ja = function(fe) {
      return typeof Ve == "function" && fe instanceof Ve;
    };
    function Un(Ge, fe, je) {
      f(Ge, (We) => {
        We.call(se, fe, je, $o);
      });
    }
    const Yp = function(fe) {
      let je = null;
      if (Un(qt.beforeSanitizeElements, fe, null), yi(fe))
        return an(fe), !0;
      const We = tr(fe.nodeName);
      if (Un(qt.uponSanitizeElement, fe, {
        tagName: We,
        allowedTags: Qt
      }), fe.hasChildNodes() && !ja(fe.firstElementChild) && k(/<[/\w]/g, fe.innerHTML) && k(/<[/\w]/g, fe.textContent) || fe.nodeType === V.progressingInstruction || Pa && fe.nodeType === V.comment && k(/<[/\w]/g, fe.data))
        return an(fe), !0;
      if (!Qt[We] || Ao[We]) {
        if (!Ao[We] && Ma(We) && (Dt.tagNameCheck instanceof RegExp && k(Dt.tagNameCheck, We) || Dt.tagNameCheck instanceof Function && Dt.tagNameCheck(We)))
          return !1;
        if (ks && !Ui[We]) {
          const kt = Pe(fe) || fe.parentNode, fr = Be(fe) || fe.childNodes;
          if (fr && kt) {
            const lr = fr.length;
            for (let br = lr - 1; br >= 0; --br) {
              const At = _e(fr[br], !0);
              At.__removalCount = (fe.__removalCount || 0) + 1, kt.insertBefore(At, $e(fe));
            }
          }
        }
        return an(fe), !0;
      }
      return fe instanceof Je && !dy(fe) || (We === "noscript" || We === "noembed" || We === "noframes") && k(/<\/no(script|embed|frames)/i, fe.innerHTML) ? (an(fe), !0) : (En && fe.nodeType === V.text && (je = fe.textContent, f([du, Oa, hu], (kt) => {
        je = g(je, kt, " ");
      }), fe.textContent !== je && (v(se.removed, {
        element: fe.cloneNode()
      }), fe.textContent = je)), Un(qt.afterSanitizeElements, fe, null), !1);
    }, La = function(fe, je, We) {
      if (Ca && (je === "id" || je === "name") && (We in ve || We in fy))
        return !1;
      if (!(Aa && !_s[je] && k(py, je))) {
        if (!(Po && k(Fp, je))) {
          if (!Yt[je] || _s[je]) {
            if (
              // First condition does a very basic check if a) it's basically a valid custom element tagname AND
              // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
              !(Ma(fe) && (Dt.tagNameCheck instanceof RegExp && k(Dt.tagNameCheck, fe) || Dt.tagNameCheck instanceof Function && Dt.tagNameCheck(fe)) && (Dt.attributeNameCheck instanceof RegExp && k(Dt.attributeNameCheck, je) || Dt.attributeNameCheck instanceof Function && Dt.attributeNameCheck(je)) || // Alternative, second condition checks if it's an `is`-attribute, AND
              // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              je === "is" && Dt.allowCustomizedBuiltInElements && (Dt.tagNameCheck instanceof RegExp && k(Dt.tagNameCheck, We) || Dt.tagNameCheck instanceof Function && Dt.tagNameCheck(We)))
            ) return !1;
          } else if (!Ia[je]) {
            if (!k(mu, g(We, ka, ""))) {
              if (!((je === "src" || je === "xlink:href" || je === "href") && fe !== "script" && b(We, "data:") === 0 && wu[fe])) {
                if (!(yu && !k(Fi, g(We, ka, "")))) {
                  if (We)
                    return !1;
                }
              }
            }
          }
        }
      }
      return !0;
    }, Ma = function(fe) {
      return fe !== "annotation-xml" && x(fe, zp);
    }, $s = function(fe) {
      Un(qt.beforeSanitizeAttributes, fe, null);
      const {
        attributes: je
      } = fe;
      if (!je || yi(fe))
        return;
      const We = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: Yt,
        forceKeepAttr: void 0
      };
      let kt = je.length;
      for (; kt--; ) {
        const fr = je[kt], {
          name: lr,
          namespaceURI: br,
          value: At
        } = fr, Rs = tr(lr);
        let dr = lr === "value" ? At : A(At);
        if (We.attrName = Rs, We.attrValue = dr, We.keepAttr = !0, We.forceKeepAttr = void 0, Un(qt.uponSanitizeAttribute, fe, We), dr = We.attrValue, $a && (Rs === "id" || Rs === "name") && (Ts(lr, fe), dr = Bp + dr), Pa && k(/((--!?|])>)|<\/(style|title)/i, dr)) {
          Ts(lr, fe);
          continue;
        }
        if (We.forceKeepAttr || (Ts(lr, fe), !We.keepAttr))
          continue;
        if (!vu && k(/\/>/i, dr)) {
          Ts(lr, fe);
          continue;
        }
        En && f([du, Oa, hu], (bt) => {
          dr = g(dr, bt, " ");
        });
        const Kp = tr(fe.nodeName);
        if (La(Kp, Rs, dr)) {
          if (Re && typeof we == "object" && typeof we.getAttributeType == "function" && !br)
            switch (we.getAttributeType(Kp, Rs)) {
              case "TrustedHTML": {
                dr = Re.createHTML(dr);
                break;
              }
              case "TrustedScriptURL": {
                dr = Re.createScriptURL(dr);
                break;
              }
            }
          try {
            br ? fe.setAttributeNS(br, lr, dr) : fe.setAttribute(lr, dr), yi(fe) ? an(fe) : m(se.removed);
          } catch {
          }
        }
      }
      Un(qt.afterSanitizeAttributes, fe, null);
    }, Gp = function Ge(fe) {
      let je = null;
      const We = Cs(fe);
      for (Un(qt.beforeSanitizeShadowDOM, fe, null); je = We.nextNode(); )
        Un(qt.uponSanitizeShadowNode, je, null), Yp(je), $s(je), je.content instanceof ke && Ge(je.content);
      Un(qt.afterSanitizeShadowDOM, fe, null);
    };
    return se.sanitize = function(Ge) {
      let fe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, je = null, We = null, kt = null, fr = null;
      if (Na = !Ge, Na && (Ge = "<!-->"), typeof Ge != "string" && !ja(Ge))
        if (typeof Ge.toString == "function") {
          if (Ge = Ge.toString(), typeof Ge != "string")
            throw $("dirty is not a string, aborting");
        } else
          throw $("toString is not a function");
      if (!se.isSupported)
        return Ge;
      if (Ta || Eu(fe), se.removed = [], typeof Ge == "string" && (Bi = !1), Bi) {
        if (Ge.nodeName) {
          const At = tr(Ge.nodeName);
          if (!Qt[At] || Ao[At])
            throw $("root node is forbidden and cannot be sanitized in-place");
        }
      } else if (Ge instanceof Ve)
        je = Ou("<!---->"), We = je.ownerDocument.importNode(Ge, !0), We.nodeType === V.element && We.nodeName === "BODY" || We.nodeName === "HTML" ? je = We : je.appendChild(We);
      else {
        if (!qi && !En && !qn && // eslint-disable-next-line unicorn/prefer-includes
        Ge.indexOf("<") === -1)
          return Re && To ? Re.createHTML(Ge) : Ge;
        if (je = Ou(Ge), !je)
          return qi ? null : To ? Qe : "";
      }
      je && zi && an(je.firstChild);
      const lr = Cs(Bi ? Ge : je);
      for (; kt = lr.nextNode(); )
        Yp(kt), $s(kt), kt.content instanceof ke && Gp(kt.content);
      if (Bi)
        return Ge;
      if (qi) {
        if (Os)
          for (fr = ut.call(je.ownerDocument); je.firstChild; )
            fr.appendChild(je.firstChild);
        else
          fr = je;
        return (Yt.shadowroot || Yt.shadowrootmode) && (fr = zn.call(ge, fr, !0)), fr;
      }
      let br = qn ? je.outerHTML : je.innerHTML;
      return qn && Qt["!doctype"] && je.ownerDocument && je.ownerDocument.doctype && je.ownerDocument.doctype.name && k(X, je.ownerDocument.doctype.name) && (br = "<!DOCTYPE " + je.ownerDocument.doctype.name + `>
` + br), En && f([du, Oa, hu], (At) => {
        br = g(br, At, " ");
      }), Re && To ? Re.createHTML(br) : br;
    }, se.setConfig = function() {
      let Ge = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      Eu(Ge), Ta = !0;
    }, se.clearConfig = function() {
      $o = null, Ta = !1;
    }, se.isValidAttribute = function(Ge, fe, je) {
      $o || Eu({});
      const We = tr(Ge), kt = tr(fe);
      return La(We, kt, je);
    }, se.addHook = function(Ge, fe) {
      typeof fe == "function" && v(qt[Ge], fe);
    }, se.removeHook = function(Ge, fe) {
      if (fe !== void 0) {
        const je = d(qt[Ge], fe);
        return je === -1 ? void 0 : S(qt[Ge], je, 1)[0];
      }
      return m(qt[Ge]);
    }, se.removeHooks = function(Ge) {
      qt[Ge] = [];
    }, se.removeAllHooks = function() {
      qt = Ce();
    }, se;
  }
  var O = Se();
  return Hb = O, Hb;
}
if (!et.useState)
  throw new Error("mobx-react-lite requires React with Hooks support");
if (!Ij)
  throw new Error("mobx-react-lite@3 requires mobx at least version 6 to be available");
function xJ(e) {
  e();
}
function fM(e) {
  e || (e = xJ), Ej({ reactionScheduler: e });
}
function EJ(e) {
  return _j(e);
}
var dM = !1;
function hM(e) {
  dM = e;
}
function Kl() {
  return dM;
}
var _J = 1e4, OJ = 1e4, kJ = (
  /** @class */
  function() {
    function e(t) {
      var r = this;
      Object.defineProperty(this, "finalize", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
      }), Object.defineProperty(this, "registrations", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /* @__PURE__ */ new Map()
      }), Object.defineProperty(this, "sweepTimeout", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "sweep", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: function(n) {
          n === void 0 && (n = _J), clearTimeout(r.sweepTimeout), r.sweepTimeout = void 0;
          var i = Date.now();
          r.registrations.forEach(function(s, o) {
            i - s.registeredAt >= n && (r.finalize(s.value), r.registrations.delete(o));
          }), r.registrations.size > 0 && r.scheduleSweep();
        }
      }), Object.defineProperty(this, "finalizeAllImmediately", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: function() {
          r.sweep(0);
        }
      });
    }
    return Object.defineProperty(e.prototype, "register", {
      enumerable: !1,
      configurable: !0,
      writable: !0,
      value: function(t, r, n) {
        this.registrations.set(n, {
          value: r,
          registeredAt: Date.now()
        }), this.scheduleSweep();
      }
    }), Object.defineProperty(e.prototype, "unregister", {
      enumerable: !1,
      configurable: !0,
      writable: !0,
      value: function(t) {
        this.registrations.delete(t);
      }
    }), Object.defineProperty(e.prototype, "scheduleSweep", {
      enumerable: !1,
      configurable: !0,
      writable: !0,
      value: function() {
        this.sweepTimeout === void 0 && (this.sweepTimeout = setTimeout(this.sweep, OJ));
      }
    }), e;
  }()
), AJ = typeof FinalizationRegistry < "u" ? FinalizationRegistry : kJ, yp = new AJ(function(e) {
  var t;
  (t = e.reaction) === null || t === void 0 || t.dispose(), e.reaction = null;
}), mM = { exports: {} }, gM = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Xl = et;
function PJ(e, t) {
  return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t;
}
var TJ = typeof Object.is == "function" ? Object.is : PJ, CJ = Xl.useState, $J = Xl.useEffect, RJ = Xl.useLayoutEffect, IJ = Xl.useDebugValue;
function NJ(e, t) {
  var r = t(), n = CJ({ inst: { value: r, getSnapshot: t } }), i = n[0].inst, s = n[1];
  return RJ(
    function() {
      i.value = r, i.getSnapshot = t, Qb(i) && s({ inst: i });
    },
    [e, r, t]
  ), $J(
    function() {
      return Qb(i) && s({ inst: i }), e(function() {
        Qb(i) && s({ inst: i });
      });
    },
    [e]
  ), IJ(r), r;
}
function Qb(e) {
  var t = e.getSnapshot;
  e = e.value;
  try {
    var r = t();
    return !TJ(e, r);
  } catch {
    return !0;
  }
}
function jJ(e, t) {
  return t();
}
var LJ = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? jJ : NJ;
gM.useSyncExternalStore = Xl.useSyncExternalStore !== void 0 ? Xl.useSyncExternalStore : LJ;
mM.exports = gM;
var MJ = mM.exports;
function zC(e) {
  e.reaction = new Mn("observer".concat(e.name), function() {
    var t;
    e.stateVersion = Symbol(), (t = e.onStoreChange) === null || t === void 0 || t.call(e);
  });
}
function P1(e, t) {
  if (t === void 0 && (t = "observed"), Kl())
    return e();
  var r = at.useRef(null);
  if (!r.current) {
    var n = {
      reaction: null,
      onStoreChange: null,
      stateVersion: Symbol(),
      name: t,
      subscribe: function(a) {
        return yp.unregister(n), n.onStoreChange = a, n.reaction || (zC(n), n.stateVersion = Symbol()), function() {
          var l;
          n.onStoreChange = null, (l = n.reaction) === null || l === void 0 || l.dispose(), n.reaction = null;
        };
      },
      getSnapshot: function() {
        return n.stateVersion;
      }
    };
    r.current = n;
  }
  var i = r.current;
  i.reaction || (zC(i), yp.register(r, i, i)), at.useDebugValue(i.reaction, EJ), MJ.useSyncExternalStore(
    // Both of these must be stable, otherwise it would keep resubscribing every render.
    i.subscribe,
    i.getSnapshot,
    i.getSnapshot
  );
  var s, o;
  if (i.reaction.track(function() {
    try {
      s = e();
    } catch (a) {
      o = a;
    }
  }), o)
    throw o;
  return s;
}
var Yb, Gb, yM = typeof Symbol == "function" && Symbol.for, DJ = (Gb = (Yb = Object.getOwnPropertyDescriptor(function() {
}, "name")) === null || Yb === void 0 ? void 0 : Yb.configurable) !== null && Gb !== void 0 ? Gb : !1, qC = yM ? Symbol.for("react.forward_ref") : typeof et.forwardRef == "function" && et.forwardRef(function(e) {
  return null;
}).$$typeof, BC = yM ? Symbol.for("react.memo") : typeof et.memo == "function" && et.memo(function(e) {
  return null;
}).$$typeof;
function FJ(e, t) {
  var r;
  if (BC && e.$$typeof === BC)
    throw new Error("[mobx-react-lite] You are trying to use `observer` on a function component wrapped in either another `observer` or `React.memo`. The observer already applies 'React.memo' for you.");
  if (Kl())
    return e;
  var n = (r = void 0) !== null && r !== void 0 ? r : !1, i = e, s = e.displayName || e.name;
  if (qC && e.$$typeof === qC && (n = !0, i = e.render, typeof i != "function"))
    throw new Error("[mobx-react-lite] `render` property of ForwardRef was not a function");
  var o = function(a, l) {
    return P1(function() {
      return i(a, l);
    }, s);
  };
  return o.displayName = e.displayName, DJ && Object.defineProperty(o, "name", {
    value: e.name,
    writable: !0,
    configurable: !0
  }), e.contextTypes && (o.contextTypes = e.contextTypes), n && (o = et.forwardRef(o)), o = et.memo(o), qJ(e, o), o;
}
var zJ = {
  $$typeof: !0,
  render: !0,
  compare: !0,
  type: !0,
  // Don't redefine `displayName`,
  // it's defined as getter-setter pair on `memo` (see #3192).
  displayName: !0
};
function qJ(e, t) {
  Object.keys(e).forEach(function(r) {
    zJ[r] || Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(e, r));
  });
}
function vM(e) {
  var t = e.children, r = e.render;
  t && r && console.error("MobX Observer: Do not use children and render in the same time in `Observer`");
  var n = t || r;
  return typeof n != "function" ? null : P1(n);
}
vM.displayName = "Observer";
function BJ(e, t) {
  return et.useState(function() {
    return Xt(e(), t, { autoBind: !0 });
  })[0];
}
function bM(e) {
  var t = et.useState(function() {
    return Xt(e, {}, { deep: !1 });
  })[0];
  return ww(function() {
    Object.assign(t, e);
  }), t;
}
function UJ(e, t) {
  var r = t && bM(t);
  return et.useState(function() {
    return Xt(e(r), void 0, { autoBind: !0 });
  })[0];
}
var Kb;
fM(gI.unstable_batchedUpdates);
Kb = yp.finalizeAllImmediately;
function VJ(e, t) {
  return t === void 0 && (t = "observed"), P1(e, t);
}
function WJ(e) {
  hM(e);
}
function HJ(e, t) {
  if (UC(e, t))
    return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  var r = Object.keys(e), n = Object.keys(t);
  if (r.length !== n.length)
    return !1;
  for (var i = 0; i < r.length; i++)
    if (!Object.hasOwnProperty.call(t, r[i]) || !UC(e[r[i]], t[r[i]]))
      return !1;
  return !0;
}
function UC(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
var QJ = {
  $$typeof: 1,
  render: 1,
  compare: 1,
  type: 1,
  childContextTypes: 1,
  contextType: 1,
  contextTypes: 1,
  defaultProps: 1,
  getDefaultProps: 1,
  getDerivedStateFromError: 1,
  getDerivedStateFromProps: 1,
  mixins: 1,
  displayName: 1,
  propTypes: 1
};
function YJ(e, t) {
  var r = Object.getOwnPropertyNames(Object.getPrototypeOf(e));
  Object.getOwnPropertyNames(e).forEach(function(n) {
    !QJ[n] && r.indexOf(n) === -1 && Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(e, n));
  });
}
var VC = /* @__PURE__ */ Symbol("patchMixins"), wM = /* @__PURE__ */ Symbol("patchedDefinition");
function GJ(e, t) {
  var r = e[VC] = e[VC] || {}, n = r[t] = r[t] || {};
  return n.locks = n.locks || 0, n.methods = n.methods || [], n;
}
function WC(e, t) {
  for (var r = this, n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), s = 2; s < n; s++)
    i[s - 2] = arguments[s];
  t.locks++;
  try {
    var o;
    return e != null && (o = e.apply(this, i)), o;
  } finally {
    t.locks--, t.locks === 0 && t.methods.forEach(function(a) {
      a.apply(r, i);
    });
  }
}
function HC(e, t) {
  var r = function() {
    for (var i = arguments.length, s = new Array(i), o = 0; o < i; o++)
      s[o] = arguments[o];
    WC.call.apply(WC, [this, e, t].concat(s));
  };
  return r;
}
function SM(e, t, r) {
  var n = GJ(e, t);
  n.methods.indexOf(r) < 0 && n.methods.push(r);
  var i = Object.getOwnPropertyDescriptor(e, t);
  if (!(i && i[wM])) {
    var s = e[t], o = xM(e, t, i ? i.enumerable : void 0, n, s);
    Object.defineProperty(e, t, o);
  }
}
function xM(e, t, r, n, i) {
  var s, o = HC(i, n);
  return s = {}, s[wM] = !0, s.get = function() {
    return o;
  }, s.set = function(l) {
    if (this === e)
      o = HC(l, n);
    else {
      var u = xM(this, t, r, n, l);
      Object.defineProperty(this, t, u);
    }
  }, s.configurable = !0, s.enumerable = r, s;
}
var QC = /* @__PURE__ */ Symbol("ObserverAdministration"), YC = /* @__PURE__ */ Symbol("isMobXReactObserver");
function Nw(e) {
  var t;
  return (t = e[QC]) != null ? t : e[QC] = {
    reaction: null,
    mounted: !1,
    reactionInvalidatedBeforeMount: !1,
    forceUpdate: null,
    name: jw(e.constructor),
    state: void 0,
    props: void 0,
    context: void 0
  };
}
function KJ(e) {
  var t = e.prototype;
  if (e[YC]) {
    var r = jw(e);
    throw new Error("The provided component class (" + r + ") has already been declared as an observer component.");
  } else
    e[YC] = !0;
  if (t.componentWillReact)
    throw new Error("The componentWillReact life-cycle event is no longer supported");
  if (e.__proto__ !== et.PureComponent) {
    if (!t.shouldComponentUpdate)
      t.shouldComponentUpdate = GC;
    else if (t.shouldComponentUpdate !== GC)
      throw new Error("It is not allowed to use shouldComponentUpdate in observer based components.");
  }
  var n = t.render;
  if (typeof n != "function") {
    var i = jw(e);
    throw new Error("[mobx-react] class component (" + i + ") is missing `render` method.\n`observer` requires `render` being a function defined on prototype.\n`render = () => {}` or `render = function() {}` is not supported.");
  }
  t.render = function() {
    return Object.defineProperty(this, "render", {
      // There is no safe way to replace render, therefore it's forbidden.
      configurable: !1,
      writable: !1,
      value: Kl() ? n : XJ.call(this, n)
    }), this.render();
  };
  var s = t.componentDidMount;
  return t.componentDidMount = function() {
    var o = this, a = Nw(this);
    return a.mounted = !0, yp.unregister(this), a.forceUpdate = function() {
      return o.forceUpdate();
    }, (!a.reaction || a.reactionInvalidatedBeforeMount) && a.forceUpdate(), s == null ? void 0 : s.apply(this, arguments);
  }, SM(t, "componentWillUnmount", function() {
    var o;
    if (!Kl()) {
      var a = Nw(this);
      (o = a.reaction) == null || o.dispose(), a.reaction = null, a.forceUpdate = null, a.mounted = !1, a.reactionInvalidatedBeforeMount = !1;
    }
  }), e;
}
function jw(e) {
  return e.displayName || e.name || "<component>";
}
function XJ(e) {
  var t = e.bind(this), r = Nw(this);
  function n() {
    r.reaction || (r.reaction = JJ(r), r.mounted || yp.register(this, r, this));
    var i = void 0, s = void 0;
    if (r.reaction.track(function() {
      try {
        s = qg(!1, t);
      } catch (o) {
        i = o;
      }
    }), i)
      throw i;
    return s;
  }
  return n;
}
function JJ(e) {
  return new Mn(e.name + ".render()", function() {
    if (!e.mounted) {
      e.reactionInvalidatedBeforeMount = !0;
      return;
    }
    try {
      e.forceUpdate == null || e.forceUpdate();
    } catch {
      var t;
      (t = e.reaction) == null || t.dispose(), e.reaction = null;
    }
  });
}
function GC(e, t) {
  return Kl() && console.warn("[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side."), this.state !== t ? !0 : !HJ(this.props, e);
}
function EM(e, t) {
  if (t && t.kind !== "class")
    throw new Error("The @observer decorator can be used on classes only");
  return e.isMobxInjector === !0 && console.warn("Mobx observer: You are trying to use `observer` on a component that already has `inject`. Please apply `observer` before applying `inject`"), Object.prototype.isPrototypeOf.call(et.Component, e) || Object.prototype.isPrototypeOf.call(et.PureComponent, e) ? KJ(e) : FJ(e);
}
function Jm() {
  return Jm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r) ({}).hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Jm.apply(null, arguments);
}
function ZJ(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e) if ({}.hasOwnProperty.call(e, n)) {
    if (t.indexOf(n) >= 0) continue;
    r[n] = e[n];
  }
  return r;
}
var eZ = ["children"], Zm = /* @__PURE__ */ at.createContext({});
function _M(e) {
  var t = e.children, r = ZJ(e, eZ), n = at.useContext(Zm), i = at.useRef(Jm({}, n, r)), s = i.current;
  return at.createElement(Zm.Provider, {
    value: s
  }, t);
}
_M.displayName = "MobXProvider";
function KC(e, t, r, n) {
  var i = at.forwardRef(function(s, o) {
    var a = Jm({}, s), l = at.useContext(Zm);
    return Object.assign(a, e(l || {}, a) || {}), o && (a.ref = o), at.createElement(t, a);
  });
  return n && (i = EM(i)), i.isMobxInjector = !0, YJ(t, i), i.wrappedComponent = t, i.displayName = tZ(t, r), i;
}
function tZ(e, t) {
  var r, n = e.displayName || e.name || e.constructor && e.constructor.name || "Component";
  return t ? r = "inject-with-" + t + "(" + n + ")" : r = "inject(" + n + ")", r;
}
function rZ(e) {
  return function(t, r) {
    return e.forEach(function(n) {
      if (!(n in r)) {
        if (!(n in t)) throw new Error("MobX injector: Store '" + n + "' is not available! Make sure it is provided by some Provider");
        r[n] = t[n];
      }
    }), r;
  };
}
function nZ() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  if (typeof arguments[0] == "function") {
    var n = arguments[0];
    return function(i) {
      return KC(n, i, n.name, !0);
    };
  } else
    return function(i) {
      return KC(rZ(t), i, t.join("-"), !1);
    };
}
var iZ = /* @__PURE__ */ Number.parseInt(at.version.split(".")[0]), XC = !1, em = /* @__PURE__ */ Symbol("disposeOnUnmountProto"), tm = /* @__PURE__ */ Symbol("disposeOnUnmountInst");
function oZ() {
  var e = this;
  [].concat(this[em] || [], this[tm] || []).forEach(function(t) {
    var r = typeof t == "string" ? e[t] : t;
    r != null && (Array.isArray(r) ? r.map(function(n) {
      return n();
    }) : r());
  });
}
function OM(e, t) {
  if (Array.isArray(t))
    return t.map(function(l) {
      return OM(e, l);
    });
  XC || (iZ >= 18 ? console.error("[mobx-react] disposeOnUnmount is not compatible with React 18 and higher. Don't use it.") : console.warn("[mobx-react] disposeOnUnmount is deprecated. It won't work correctly with React 18 and higher."), XC = !0);
  var r = Object.getPrototypeOf(e).constructor, n = Object.getPrototypeOf(e.constructor), i = Object.getPrototypeOf(Object.getPrototypeOf(e));
  if (!(r === at.Component || r === at.PureComponent || n === at.Component || n === at.PureComponent || i === at.Component || i === at.PureComponent))
    throw new Error("[mobx-react] disposeOnUnmount only supports direct subclasses of React.Component or React.PureComponent.");
  if (typeof t != "string" && typeof t != "function" && !Array.isArray(t))
    throw new Error("[mobx-react] disposeOnUnmount only works if the parameter is either a property key or a function.");
  var s = typeof t == "string", o = !!e[em] || !!e[tm], a = s ? (
    // decorators are added to the prototype store
    e[em] || (e[em] = [])
  ) : (
    // functions are added to the instance store
    e[tm] || (e[tm] = [])
  );
  if (a.push(t), o || SM(e, "componentWillUnmount", oZ), typeof t != "string")
    return t;
}
function kM(e) {
  function t(n, i, s, o, a, l) {
    for (var u = arguments.length, f = new Array(u > 6 ? u - 6 : 0), d = 6; d < u; d++)
      f[d - 6] = arguments[d];
    return au(function() {
      if (o = o || "<<anonymous>>", l = l || s, i[s] == null) {
        if (n) {
          var m = i[s] === null ? "null" : "undefined";
          return new Error("The " + a + " `" + l + "` is marked as required in `" + o + "`, but its value is `" + m + "`.");
        }
        return null;
      } else
        return e.apply(void 0, [i, s, o, a, l].concat(f));
    });
  }
  var r = t.bind(null, !1);
  return r.isRequired = t.bind(null, !0), r;
}
function sZ(e, t) {
  return e === "symbol" || t["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && t instanceof Symbol;
}
function AM(e) {
  var t = typeof e;
  return Array.isArray(e) ? "array" : e instanceof RegExp ? "object" : sZ(t, e) ? "symbol" : t;
}
function aZ(e) {
  var t = AM(e);
  if (t === "object") {
    if (e instanceof Date)
      return "date";
    if (e instanceof RegExp)
      return "regexp";
  }
  return t;
}
function pu(e, t) {
  return kM(function(r, n, i, s, o) {
    return au(function() {
      if (e && AM(r[n]) === t.toLowerCase())
        return null;
      var a;
      switch (t) {
        case "Array":
          a = Wr;
          break;
        case "Object":
          a = yr;
          break;
        case "Map":
          a = vr;
          break;
        default:
          throw new Error("Unexpected mobxType: " + t);
      }
      var l = r[n];
      if (!a(l)) {
        var u = aZ(l), f = e ? " or javascript `" + t.toLowerCase() + "`" : "";
        return new Error("Invalid prop `" + o + "` of type `" + u + "` supplied to `" + i + "`, expected `mobx.Observable" + t + "`" + f + ".");
      }
      return null;
    });
  });
}
function PM(e, t) {
  return kM(function(r, n, i, s, o) {
    for (var a = arguments.length, l = new Array(a > 5 ? a - 5 : 0), u = 5; u < a; u++)
      l[u - 5] = arguments[u];
    return au(function() {
      if (typeof t != "function")
        return new Error("Property `" + o + "` of component `" + i + "` has invalid PropType notation.");
      var f = pu(e, "Array")(r, n, i, s, o);
      if (f instanceof Error) return f;
      for (var d = r[n], m = 0; m < d.length; m++)
        if (f = t.apply(void 0, [d, m, i, s, o + "[" + m + "]"].concat(l)), f instanceof Error) return f;
      return null;
    });
  });
}
var lZ = /* @__PURE__ */ pu(!1, "Array"), uZ = /* @__PURE__ */ PM.bind(null, !1), cZ = /* @__PURE__ */ pu(!1, "Map"), pZ = /* @__PURE__ */ pu(!1, "Object"), fZ = /* @__PURE__ */ pu(!0, "Array"), dZ = /* @__PURE__ */ PM.bind(null, !0), hZ = /* @__PURE__ */ pu(!0, "Object"), mZ = {
  observableArray: lZ,
  observableArrayOf: uZ,
  observableMap: cZ,
  observableObject: pZ,
  arrayOrObservableArray: fZ,
  arrayOrObservableArrayOf: dZ,
  objectOrObservableObject: hZ
};
if (!et.Component)
  throw new Error("mobx-react requires React to be available");
if (!Xt)
  throw new Error("mobx-react requires mobx to be available");
const gZ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MobXProviderContext: Zm,
  Observer: vM,
  PropTypes: mZ,
  Provider: _M,
  disposeOnUnmount: OM,
  enableStaticRendering: hM,
  inject: nZ,
  isUsingStaticRendering: Kl,
  observer: EM,
  observerBatching: fM,
  useAsObservableSource: bM,
  useLocalObservable: BJ,
  useLocalStore: UJ,
  useObserver: VJ,
  useStaticRendering: WJ
}, Symbol.toStringTag, { value: "Module" })), yZ = /* @__PURE__ */ Di(gZ);
var Xb = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
var JC;
function vZ() {
  return JC || (JC = 1, function(e) {
    (function() {
      var t = {}.hasOwnProperty;
      function r() {
        for (var s = "", o = 0; o < arguments.length; o++) {
          var a = arguments[o];
          a && (s = i(s, n(a)));
        }
        return s;
      }
      function n(s) {
        if (typeof s == "string" || typeof s == "number")
          return s;
        if (typeof s != "object")
          return "";
        if (Array.isArray(s))
          return r.apply(null, s);
        if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]"))
          return s.toString();
        var o = "";
        for (var a in s)
          t.call(s, a) && s[a] && (o = i(o, a));
        return o;
      }
      function i(s, o) {
        return o ? s ? s + " " + o : s + o : s;
      }
      e.exports ? (r.default = r, e.exports = r) : window.classNames = r;
    })();
  }(Xb)), Xb.exports;
}
/*! For license information please see redoc.browser.lib.js.LICENSE.txt */
(function(e, t) {
  (function(r, n) {
    e.exports = n();
  })(ft, function() {
    return function() {
      var r = { 260: function(o, a, l) {
        var u = l(15), f = l.n(u), d = l(645), m = l.n(d)()(f());
        m.push([o.id, `.ps{overflow:hidden!important;overflow-anchor:none;-ms-overflow-style:none;touch-action:auto;-ms-touch-action:auto}.ps__rail-x{display:none;opacity:0;transition:background-color .2s linear,opacity .2s linear;-webkit-transition:background-color .2s linear,opacity .2s linear;height:15px;bottom:0;position:absolute}.ps__rail-y{display:none;opacity:0;transition:background-color .2s linear,opacity .2s linear;-webkit-transition:background-color .2s linear,opacity .2s linear;width:15px;right:0;position:absolute}.ps--active-x>.ps__rail-x,.ps--active-y>.ps__rail-y{display:block;background-color:transparent}.ps:hover>.ps__rail-x,.ps:hover>.ps__rail-y,.ps--focus>.ps__rail-x,.ps--focus>.ps__rail-y,.ps--scrolling-x>.ps__rail-x,.ps--scrolling-y>.ps__rail-y{opacity:.6}.ps .ps__rail-x:hover,.ps .ps__rail-y:hover,.ps .ps__rail-x:focus,.ps .ps__rail-y:focus,.ps .ps__rail-x.ps--clicking,.ps .ps__rail-y.ps--clicking{background-color:#eee;opacity:.9}.ps__thumb-x{background-color:#aaa;border-radius:6px;transition:background-color .2s linear,height .2s ease-in-out;-webkit-transition:background-color .2s linear,height .2s ease-in-out;height:6px;bottom:2px;position:absolute}.ps__thumb-y{background-color:#aaa;border-radius:6px;transition:background-color .2s linear,width .2s ease-in-out;-webkit-transition:background-color .2s linear,width .2s ease-in-out;width:6px;right:2px;position:absolute}.ps__rail-x:hover>.ps__thumb-x,.ps__rail-x:focus>.ps__thumb-x,.ps__rail-x.ps--clicking .ps__thumb-x{background-color:#999;height:11px}.ps__rail-y:hover>.ps__thumb-y,.ps__rail-y:focus>.ps__thumb-y,.ps__rail-y.ps--clicking .ps__thumb-y{background-color:#999;width:11px}@supports (-ms-overflow-style: none){.ps{overflow:auto!important}}@media screen and (-ms-high-contrast: active),(-ms-high-contrast: none){.ps{overflow:auto!important}}
`, "", { version: 3, sources: ["webpack://./node_modules/perfect-scrollbar/css/perfect-scrollbar.css"], names: [], mappings: "AAGA,IACE,yBAAA,CACA,oBAAA,CACA,uBAAA,CACA,iBAAA,CACA,qBAAA,CAMF,YACE,YAAA,CACA,SAAA,CACA,yDAAA,CACA,iEAAA,CACA,WAAA,CAEA,QAAA,CAEA,iBAAA,CAGF,YACE,YAAA,CACA,SAAA,CACA,yDAAA,CACA,iEAAA,CACA,UAAA,CAEA,OAAA,CAEA,iBAAA,CAGF,oDAEE,aAAA,CACA,4BAAA,CAGF,oJAME,UAAA,CAGF,kJAME,qBAAA,CACA,UAAA,CAMF,aACE,qBAAA,CAnEF,iBAAA,CAqEE,6DAAA,CACA,qEAAA,CACA,UAAA,CAEA,UAAA,CAEA,iBAAA,CAGF,aACE,qBAAA,CA/EF,iBAAA,CAiFE,4DAAA,CACA,oEAAA,CACA,SAAA,CAEA,SAAA,CAEA,iBAAA,CAGF,oGAGE,qBAAA,CACA,WAAA,CAGF,oGAGE,qBAAA,CACA,UAAA,CAIF,qCACE,IACE,uBAAA,CAAA,CAIJ,wEACE,IACE,uBAAA,CAAA", sourcesContent: [`/*
 * Container style
 */
.ps {
  overflow: hidden !important;
  overflow-anchor: none;
  -ms-overflow-style: none;
  touch-action: auto;
  -ms-touch-action: auto;
}

/*
 * Scrollbar rail styles
 */
.ps__rail-x {
  display: none;
  opacity: 0;
  transition: background-color .2s linear, opacity .2s linear;
  -webkit-transition: background-color .2s linear, opacity .2s linear;
  height: 15px;
  /* there must be 'bottom' or 'top' for ps__rail-x */
  bottom: 0px;
  /* please don't change 'position' */
  position: absolute;
}

.ps__rail-y {
  display: none;
  opacity: 0;
  transition: background-color .2s linear, opacity .2s linear;
  -webkit-transition: background-color .2s linear, opacity .2s linear;
  width: 15px;
  /* there must be 'right' or 'left' for ps__rail-y */
  right: 0;
  /* please don't change 'position' */
  position: absolute;
}

.ps--active-x > .ps__rail-x,
.ps--active-y > .ps__rail-y {
  display: block;
  background-color: transparent;
}

.ps:hover > .ps__rail-x,
.ps:hover > .ps__rail-y,
.ps--focus > .ps__rail-x,
.ps--focus > .ps__rail-y,
.ps--scrolling-x > .ps__rail-x,
.ps--scrolling-y > .ps__rail-y {
  opacity: 0.6;
}

.ps .ps__rail-x:hover,
.ps .ps__rail-y:hover,
.ps .ps__rail-x:focus,
.ps .ps__rail-y:focus,
.ps .ps__rail-x.ps--clicking,
.ps .ps__rail-y.ps--clicking {
  background-color: #eee;
  opacity: 0.9;
}

/*
 * Scrollbar thumb styles
 */
.ps__thumb-x {
  background-color: #aaa;
  border-radius: 6px;
  transition: background-color .2s linear, height .2s ease-in-out;
  -webkit-transition: background-color .2s linear, height .2s ease-in-out;
  height: 6px;
  /* there must be 'bottom' for ps__thumb-x */
  bottom: 2px;
  /* please don't change 'position' */
  position: absolute;
}

.ps__thumb-y {
  background-color: #aaa;
  border-radius: 6px;
  transition: background-color .2s linear, width .2s ease-in-out;
  -webkit-transition: background-color .2s linear, width .2s ease-in-out;
  width: 6px;
  /* there must be 'right' for ps__thumb-y */
  right: 2px;
  /* please don't change 'position' */
  position: absolute;
}

.ps__rail-x:hover > .ps__thumb-x,
.ps__rail-x:focus > .ps__thumb-x,
.ps__rail-x.ps--clicking .ps__thumb-x {
  background-color: #999;
  height: 11px;
}

.ps__rail-y:hover > .ps__thumb-y,
.ps__rail-y:focus > .ps__thumb-y,
.ps__rail-y.ps--clicking .ps__thumb-y {
  background-color: #999;
  width: 11px;
}

/* MS supports */
@supports (-ms-overflow-style: none) {
  .ps {
    overflow: auto !important;
  }
}

@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {
  .ps {
    overflow: auto !important;
  }
}
`], sourceRoot: "" }]), a.Z = m;
      }, 645: function(o) {
        o.exports = function(a) {
          var l = [];
          return l.toString = function() {
            return this.map(function(u) {
              var f = a(u);
              return u[2] ? "@media ".concat(u[2], " {").concat(f, "}") : f;
            }).join("");
          }, l.i = function(u, f, d) {
            typeof u == "string" && (u = [[null, u, ""]]);
            var m = {};
            if (d) for (var v = 0; v < this.length; v++) {
              var S = this[v][0];
              S != null && (m[S] = !0);
            }
            for (var y = 0; y < u.length; y++) {
              var E = [].concat(u[y]);
              d && m[E[0]] || (f && (E[2] ? E[2] = "".concat(f, " and ").concat(E[2]) : E[2] = f), l.push(E));
            }
          }, l;
        };
      }, 15: function(o) {
        function a(l, u) {
          (u == null || u > l.length) && (u = l.length);
          for (var f = 0, d = new Array(u); f < u; f++) d[f] = l[f];
          return d;
        }
        o.exports = function(l) {
          var u, f, d = (f = 4, function(g) {
            if (Array.isArray(g)) return g;
          }(u = l) || function(g, b) {
            var A = g && (typeof Symbol < "u" && g[Symbol.iterator] || g["@@iterator"]);
            if (A != null) {
              var P, k, $ = [], I = !0, F = !1;
              try {
                for (A = A.call(g); !(I = (P = A.next()).done) && ($.push(P.value), !b || $.length !== b); I = !0) ;
              } catch (L) {
                F = !0, k = L;
              } finally {
                try {
                  I || A.return == null || A.return();
                } finally {
                  if (F) throw k;
                }
              }
              return $;
            }
          }(u, f) || function(g, b) {
            if (g) {
              if (typeof g == "string") return a(g, b);
              var A = Object.prototype.toString.call(g).slice(8, -1);
              return A === "Object" && g.constructor && (A = g.constructor.name), A === "Map" || A === "Set" ? Array.from(g) : A === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(A) ? a(g, b) : void 0;
            }
          }(u, f) || function() {
            throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }()), m = d[1], v = d[3];
          if (typeof btoa == "function") {
            var S = btoa(unescape(encodeURIComponent(JSON.stringify(v)))), y = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(S), E = "/*# ".concat(y, " */"), x = v.sources.map(function(g) {
              return "/*# sourceURL=".concat(v.sourceRoot || "").concat(g, " */");
            });
            return [m].concat(x).concat([E]).join(`
`);
          }
          return [m].join(`
`);
        };
      }, 825: function(o) {
        o.exports = {};
      }, 388: function(o, a, l) {
        l.d(a, { ZP: function() {
          return d;
        } });
        var u = z3(), f = (F, L, Q) => new Promise((Y, ae) => {
          var le = (be) => {
            try {
              ce(Q.next(be));
            } catch (G) {
              ae(G);
            }
          }, ue = (be) => {
            try {
              ce(Q.throw(be));
            } catch (G) {
              ae(G);
            }
          }, ce = (be) => be.done ? Y(be.value) : Promise.resolve(be.value).then(le, ue);
          ce((Q = Q.apply(F, L)).next());
        });
        class d {
          constructor() {
            this.add = g, this.done = b, this.search = I, this.toJS = A, this.load = k, this.dispose = $, this.fromExternalJS = P;
          }
        }
        let m, v, S, y = [];
        function E() {
          m = new u.Builder(), m.field("title"), m.field("description"), m.ref("ref"), m.pipeline.add(u.trimmer, u.stopWordFilter, u.stemmer), S = new Promise((F) => {
            v = F;
          });
        }
        u.tokenizer.separator = /\s+/, E();
        const x = (F) => {
          const L = u.trimmer(new u.Token(F, {}));
          return "*" + u.stemmer(L) + "*";
        };
        function g(F, L, Q) {
          const Y = y.push(Q) - 1, ae = { title: F.toLowerCase(), description: L.toLowerCase(), ref: Y };
          m.add(ae);
        }
        function b() {
          return f(this, null, function* () {
            v(m.build());
          });
        }
        function A() {
          return f(this, null, function* () {
            return { store: y, index: (yield S).toJSON() };
          });
        }
        function P(F, L) {
          return f(this, null, function* () {
            try {
              if (importScripts(F), !self[L]) throw new Error("Broken index file format");
              k(self[L]);
            } catch (Q) {
              console.error("Failed to load search index: " + Q.message);
            }
          });
        }
        function k(F) {
          return f(this, null, function* () {
            y = F.store, v(u.Index.load(F.index));
          });
        }
        function $() {
          return f(this, null, function* () {
            y = [], E();
          });
        }
        function I(F, L = 0) {
          return f(this, null, function* () {
            if (F.trim().length === 0) return [];
            let Q = (yield S).query((Y) => {
              F.trim().toLowerCase().split(/\s+/).forEach((ae) => {
                if (ae.length === 1) return;
                const le = x(ae);
                Y.term(le, {});
              });
            });
            return L > 0 && (Q = Q.slice(0, L)), Q.map((Y) => ({ meta: y[Y.ref], score: Y.score }));
          });
        }
      }, 342: function(o, a, l) {
        const u = l(376), f = {}.NODE_DISABLE_COLORS ? { red: "", yellow: "", green: "", normal: "" } : { red: "\x1B[31m", yellow: "\x1B[33;1m", green: "\x1B[32m", normal: "\x1B[0m" };
        function d(v, S) {
          function y(E, x) {
            return u.stringify(E) === u.stringify(Object.assign({}, E, x));
          }
          return y(v, S) && y(S, v);
        }
        function m(v) {
          let S = (v = v.replace("[]", "Array")).split("/");
          return S[0] = S[0].replace(/[^A-Za-z0-9_\-\.]+|\s+/gm, "_"), S.join("/");
        }
        String.prototype.toCamelCase = function() {
          return this.toLowerCase().replace(/[-_ \/\.](.)/g, function(v, S) {
            return S.toUpperCase();
          });
        }, o.exports = { colour: f, uniqueOnly: function(v, S, y) {
          return y.indexOf(v) === S;
        }, hasDuplicates: function(v) {
          return new Set(v).size !== v.length;
        }, allSame: function(v) {
          return new Set(v).size <= 1;
        }, distinctArray: function(v) {
          return v.length === function(S) {
            let y = [];
            for (let E of S) y.find(function(x, g, b) {
              return d(x, E);
            }) || y.push(E);
            return y;
          }(v).length;
        }, firstDupe: function(v) {
          return v.find(function(S, y, E) {
            return v.indexOf(S) < y;
          });
        }, hash: function(v) {
          let S, y = 0;
          if (v.length === 0) return y;
          for (let E = 0; E < v.length; E++) S = v.charCodeAt(E), y = (y << 5) - y + S, y |= 0;
          return y;
        }, parameterTypeProperties: ["format", "minimum", "maximum", "exclusiveMinimum", "exclusiveMaximum", "minLength", "maxLength", "multipleOf", "minItems", "maxItems", "uniqueItems", "minProperties", "maxProperties", "additionalProperties", "pattern", "enum", "default"], arrayProperties: ["items", "minItems", "maxItems", "uniqueItems"], httpMethods: ["get", "post", "put", "delete", "patch", "head", "options", "trace"], sanitise: m, sanitiseAll: function(v) {
          return m(v.split("/").join("_"));
        } };
      }, 856: function(o, a, l) {
        const u = l(825), f = l(470), d = l(416), m = l(416), v = l(66), S = l(53).jptr, y = l(401).recurse, E = l(683).clone, x = l(593).dereference, g = l(592).isRef, b = l(342);
        function A(L, Q, Y, ae, le, ue) {
          let ce = ue.externalRefs[Y + ae].paths[0], be = d.parse(le), G = {}, ee = 1;
          for (; ee; ) ee = 0, y(L, { identityDetection: !0 }, function(K, z, te) {
            if (g(K, z)) {
              if (K[z].startsWith("#")) if (G[K[z]] || K.$fixed) {
                if (!K.$fixed) {
                  let q = (ce + "/" + G[K[z]]).split("/#/").join("/");
                  te.parent[te.pkey] = { $ref: q, "x-miro": K[z], $fixed: !0 }, ue.verbose > 1 && console.warn("Replacing with", q), ee++;
                }
              } else {
                let q = E(S(Q, K[z]));
                if (ue.verbose > 1 && console.warn((q === !1 ? b.colour.red : b.colour.green) + "Fragment resolution", K[z], b.colour.normal), q === !1) {
                  if (te.parent[te.pkey] = {}, ue.fatal) {
                    let j = new Error("Fragment $ref resolution failed " + K[z]);
                    if (!ue.promise) throw j;
                    ue.promise.reject(j);
                  }
                } else ee++, te.parent[te.pkey] = q, G[K[z]] = te.path.replace("/%24ref", "");
              }
              else if (be.protocol) {
                let q = d.resolve(le, K[z]).toString();
                ue.verbose > 1 && console.warn(b.colour.yellow + "Rewriting external url ref", K[z], "as", q, b.colour.normal), K["x-miro"] = K[z], ue.externalRefs[K[z]] && (ue.externalRefs[q] || (ue.externalRefs[q] = ue.externalRefs[K[z]]), ue.externalRefs[q].failed = ue.externalRefs[K[z]].failed), K[z] = q;
              } else if (!K["x-miro"]) {
                let q = d.resolve(le, K[z]).toString(), j = !1;
                ue.externalRefs[K[z]] && (j = ue.externalRefs[K[z]].failed), j || (ue.verbose > 1 && console.warn(b.colour.yellow + "Rewriting external ref", K[z], "as", q, b.colour.normal), K["x-miro"] = K[z], K[z] = q);
              }
            }
          });
          return y(L, {}, function(K, z, te) {
            g(K, z) && K.$fixed !== void 0 && delete K.$fixed;
          }), ue.verbose > 1 && console.warn("Finished fragment resolution"), L;
        }
        function P(L, Q) {
          if (!Q.filters || !Q.filters.length) return L;
          for (let Y of Q.filters) L = Y(L, Q);
          return L;
        }
        function k(L, Q, Y, ae) {
          var le = d.parse(Y.source), ue = Y.source.split("\\").join("/").split("/");
          ue.pop() || ue.pop();
          let ce = "", be = Q.split("#");
          be.length > 1 && (ce = "#" + be[1], Q = be[0]), ue = ue.join("/");
          let G = (ee = d.parse(Q).protocol, K = le.protocol, ee && ee.length > 2 ? ee : K && K.length > 2 ? K : "file:");
          var ee, K;
          let z;
          if (z = G === "file:" ? f.resolve(ue ? ue + "/" : "", Q) : d.resolve(ue ? ue + "/" : "", Q), Y.cache[z]) {
            Y.verbose && console.warn("CACHED", z, ce);
            let te = E(Y.cache[z]), q = Y.externalRef = te;
            if (ce && (q = S(q, ce), q === !1 && (q = {}, Y.fatal))) {
              let j = new Error("Cached $ref resolution failed " + z + ce);
              if (!Y.promise) throw j;
              Y.promise.reject(j);
            }
            return q = A(q, te, Q, ce, z, Y), q = P(q, Y), ae(E(q), z, Y), Promise.resolve(q);
          }
          if (Y.verbose && console.warn("GET", z, ce), Y.handlers && Y.handlers[G]) return Y.handlers[G](ue, Q, ce, Y).then(function(te) {
            return Y.externalRef = te, te = P(te, Y), Y.cache[z] = te, ae(te, z, Y), te;
          }).catch(function(te) {
            throw Y.verbose && console.warn(te), te;
          });
          if (G && G.startsWith("http")) {
            const te = Object.assign({}, Y.fetchOptions, { agent: Y.agent });
            return Y.fetch(z, te).then(function(q) {
              if (q.status !== 200) {
                if (Y.ignoreIOErrors) return Y.verbose && console.warn("FAILED", Q), Y.externalRefs[Q].failed = !0, '{"$ref":"' + Q + '"}';
                throw new Error(`Received status code ${q.status}: ${z}`);
              }
              return q.text();
            }).then(function(q) {
              try {
                let j = v.parse(q, { schema: "core", prettyErrors: !0 });
                if (q = Y.externalRef = j, Y.cache[z] = E(q), ce && (q = S(q, ce)) === !1 && (q = {}, Y.fatal)) {
                  let H = new Error("Remote $ref resolution failed " + z + ce);
                  if (!Y.promise) throw H;
                  Y.promise.reject(H);
                }
                q = P(q = A(q, j, Q, ce, z, Y), Y);
              } catch (j) {
                if (Y.verbose && console.warn(j), !Y.promise || !Y.fatal) throw j;
                Y.promise.reject(j);
              }
              return ae(q, z, Y), q;
            }).catch(function(q) {
              if (Y.verbose && console.warn(q), Y.cache[z] = {}, !Y.promise || !Y.fatal) throw q;
              Y.promise.reject(q);
            });
          }
          {
            const te = '{"$ref":"' + Q + '"}';
            return function(q, j, H, B, pe) {
              return new Promise(function(he, Ae) {
                u.readFile(q, j, function(C, N) {
                  C ? H.ignoreIOErrors && pe ? (H.verbose && console.warn("FAILED", B), H.externalRefs[B].failed = !0, he(pe)) : Ae(C) : he(N);
                });
              });
            }(z, Y.encoding || "utf8", Y, Q, te).then(function(q) {
              try {
                let j = v.parse(q, { schema: "core", prettyErrors: !0 });
                if (q = Y.externalRef = j, Y.cache[z] = E(q), ce && (q = S(q, ce)) === !1 && (q = {}, Y.fatal)) {
                  let H = new Error("File $ref resolution failed " + z + ce);
                  if (!Y.promise) throw H;
                  Y.promise.reject(H);
                }
                q = P(q = A(q, j, Q, ce, z, Y), Y);
              } catch (j) {
                if (Y.verbose && console.warn(j), !Y.promise || !Y.fatal) throw j;
                Y.promise.reject(j);
              }
              return ae(q, z, Y), q;
            }).catch(function(q) {
              if (Y.verbose && console.warn(q), !Y.promise || !Y.fatal) throw q;
              Y.promise.reject(q);
            });
          }
        }
        function $(L) {
          return new Promise(function(Q, Y) {
            (function(le) {
              return new Promise(function(ue, ce) {
                function be(ee, K, z) {
                  if (ee[K] && g(ee[K], "$ref")) {
                    let te = ee[K].$ref;
                    if (!te.startsWith("#")) {
                      let q = "";
                      if (!G[te]) {
                        let j = Object.keys(G).find(function(H, B, pe) {
                          return te.startsWith(H + "/");
                        });
                        j && (le.verbose && console.warn("Found potential subschema at", j), q = "/" + (te.split("#")[1] || "").replace(j.split("#")[1] || ""), q = q.split("/undefined").join(""), te = j);
                      }
                      if (G[te] || (G[te] = { resolved: !1, paths: [], extras: {}, description: ee[K].description }), G[te].resolved) {
                        if (!G[te].failed) if (le.rewriteRefs) {
                          let j = G[te].resolvedAt;
                          le.verbose > 1 && console.warn("Rewriting ref", te, j), ee[K]["x-miro"] = te, ee[K].$ref = j + q;
                        } else ee[K] = E(G[te].data);
                      } else G[te].paths.push(z.path), G[te].extras[z.path] = q;
                    }
                  }
                }
                let G = le.externalRefs;
                if (le.resolver.depth > 0 && le.source === le.resolver.base) return ue(G);
                y(le.openapi.definitions, { identityDetection: !0, path: "#/definitions" }, be), y(le.openapi.components, { identityDetection: !0, path: "#/components" }, be), y(le.openapi, { identityDetection: !0 }, be), ue(G);
              });
            })(L).then(function(le) {
              for (let ue in le) if (!le[ue].resolved) {
                let ce = L.resolver.depth;
                ce > 0 && ce++, L.resolver.actions[ce].push(function() {
                  return k(L.openapi, ue, L, function(be, G, ee) {
                    if (!le[ue].resolved) {
                      let q = {};
                      q.context = le[ue], q.$ref = ue, q.original = E(be), q.updated = be, q.source = G, ee.externals.push(q), le[ue].resolved = !0;
                    }
                    let K = Object.assign({}, ee, { source: "", resolver: { actions: ee.resolver.actions, depth: ee.resolver.actions.length - 1, base: ee.resolver.base } });
                    ee.patch && le[ue].description && !be.description && typeof be == "object" && (be.description = le[ue].description), le[ue].data = be;
                    let z = (te = le[ue].paths, [...new Set(te)]);
                    var te;
                    z = z.sort(function(q, j) {
                      const H = q.startsWith("#/components/") || q.startsWith("#/definitions/"), B = j.startsWith("#/components/") || j.startsWith("#/definitions/");
                      return H && !B ? -1 : B && !H ? 1 : 0;
                    });
                    for (let q of z) if (le[ue].resolvedAt && q !== le[ue].resolvedAt && q.indexOf("x-ms-examples/") < 0) ee.verbose > 1 && console.warn("Creating pointer to data at", q), S(ee.openapi, q, { $ref: le[ue].resolvedAt + le[ue].extras[q], "x-miro": ue + le[ue].extras[q] });
                    else {
                      le[ue].resolvedAt ? ee.verbose > 1 && console.warn("Avoiding circular reference") : (le[ue].resolvedAt = q, ee.verbose > 1 && console.warn("Creating initial clone of data at", q));
                      let j = E(be);
                      S(ee.openapi, q, j);
                    }
                    ee.resolver.actions[K.resolver.depth].length === 0 && ee.resolver.actions[K.resolver.depth].push(function() {
                      return $(K);
                    });
                  });
                });
              }
            }).catch(function(le) {
              L.verbose && console.warn(le), Y(le);
            });
            let ae = { options: L };
            ae.actions = L.resolver.actions[L.resolver.depth], Q(ae);
          });
        }
        function I(L, Q, Y) {
          L.resolver.actions.push([]), $(L).then(function(ae) {
            var le;
            (le = ae.actions, le.reduce((ue, ce) => ue.then((be) => ce().then(Array.prototype.concat.bind(be))), Promise.resolve([]))).then(function() {
              if (L.resolver.depth >= L.resolver.actions.length) return console.warn("Ran off the end of resolver actions"), Q(!0);
              L.resolver.depth++, L.resolver.actions[L.resolver.depth].length ? setTimeout(function() {
                I(ae.options, Q, Y);
              }, 0) : (L.verbose > 1 && console.warn(b.colour.yellow + "Finished external resolution!", b.colour.normal), L.resolveInternal && (L.verbose > 1 && console.warn(b.colour.yellow + "Starting internal resolution!", b.colour.normal), L.openapi = x(L.openapi, L.original, { verbose: L.verbose - 1 }), L.verbose > 1 && console.warn(b.colour.yellow + "Finished internal resolution!", b.colour.normal)), y(L.openapi, {}, function(ue, ce, be) {
                g(ue, ce) && (L.preserveMiro || delete ue["x-miro"]);
              }), Q(L));
            }).catch(function(ue) {
              L.verbose && console.warn(ue), Y(ue);
            });
          }).catch(function(ae) {
            L.verbose && console.warn(ae), Y(ae);
          });
        }
        function F(L) {
          if (L.cache || (L.cache = {}), L.fetch || (L.fetch = m), L.source) {
            let Q = d.parse(L.source);
            (!Q.protocol || Q.protocol.length <= 2) && (L.source = f.resolve(L.source));
          }
          L.externals = [], L.externalRefs = {}, L.rewriteRefs = !0, L.resolver = {}, L.resolver.depth = 0, L.resolver.base = L.source, L.resolver.actions = [[]];
        }
        o.exports = { optionalResolve: function(L) {
          return F(L), new Promise(function(Q, Y) {
            L.resolve ? I(L, Q, Y) : Q(L);
          });
        }, resolve: function(L, Q, Y) {
          return Y || (Y = {}), Y.openapi = L, Y.source = Q, Y.resolve = !0, F(Y), new Promise(function(ae, le) {
            I(Y, ae, le);
          });
        } };
      }, 804: function(o) {
        function a() {
          return { depth: 0, seen: /* @__PURE__ */ new WeakMap(), top: !0, combine: !1, allowRefSiblings: !1 };
        }
        o.exports = { getDefaultState: a, walkSchema: function l(u, f, d, m) {
          if (d.depth === void 0 && (d = a()), u == null) return u;
          if (u.$ref !== void 0) {
            let v = { $ref: u.$ref };
            return d.allowRefSiblings && u.description && (v.description = u.description), m(v, f, d), v;
          }
          if (d.combine && (u.allOf && Array.isArray(u.allOf) && u.allOf.length === 1 && delete (u = Object.assign({}, u.allOf[0], u)).allOf, u.anyOf && Array.isArray(u.anyOf) && u.anyOf.length === 1 && delete (u = Object.assign({}, u.anyOf[0], u)).anyOf, u.oneOf && Array.isArray(u.oneOf) && u.oneOf.length === 1 && delete (u = Object.assign({}, u.oneOf[0], u)).oneOf), m(u, f, d), d.seen.has(u)) return u;
          if (typeof u == "object" && u !== null && d.seen.set(u, !0), d.top = !1, d.depth++, u.items !== void 0 && (d.property = "items", l(u.items, u, d, m)), u.additionalItems && typeof u.additionalItems == "object" && (d.property = "additionalItems", l(u.additionalItems, u, d, m)), u.additionalProperties && typeof u.additionalProperties == "object" && (d.property = "additionalProperties", l(u.additionalProperties, u, d, m)), u.properties) for (let v in u.properties) {
            let S = u.properties[v];
            d.property = "properties/" + v, l(S, u, d, m);
          }
          if (u.patternProperties) for (let v in u.patternProperties) {
            let S = u.patternProperties[v];
            d.property = "patternProperties/" + v, l(S, u, d, m);
          }
          if (u.allOf) for (let v in u.allOf) {
            let S = u.allOf[v];
            d.property = "allOf/" + v, l(S, u, d, m);
          }
          if (u.anyOf) for (let v in u.anyOf) {
            let S = u.anyOf[v];
            d.property = "anyOf/" + v, l(S, u, d, m);
          }
          if (u.oneOf) for (let v in u.oneOf) {
            let S = u.oneOf[v];
            d.property = "oneOf/" + v, l(S, u, d, m);
          }
          return u.not && (d.property = "not", l(u.not, u, d, m)), d.depth--, u;
        } };
      }, 470: function(o) {
        function a(f) {
          if (typeof f != "string") throw new TypeError("Path must be a string. Received " + JSON.stringify(f));
        }
        function l(f, d) {
          for (var m, v = "", S = 0, y = -1, E = 0, x = 0; x <= f.length; ++x) {
            if (x < f.length) m = f.charCodeAt(x);
            else {
              if (m === 47) break;
              m = 47;
            }
            if (m === 47) {
              if (!(y === x - 1 || E === 1)) if (y !== x - 1 && E === 2) {
                if (v.length < 2 || S !== 2 || v.charCodeAt(v.length - 1) !== 46 || v.charCodeAt(v.length - 2) !== 46) {
                  if (v.length > 2) {
                    var g = v.lastIndexOf("/");
                    if (g !== v.length - 1) {
                      g === -1 ? (v = "", S = 0) : S = (v = v.slice(0, g)).length - 1 - v.lastIndexOf("/"), y = x, E = 0;
                      continue;
                    }
                  } else if (v.length === 2 || v.length === 1) {
                    v = "", S = 0, y = x, E = 0;
                    continue;
                  }
                }
                d && (v.length > 0 ? v += "/.." : v = "..", S = 2);
              } else v.length > 0 ? v += "/" + f.slice(y + 1, x) : v = f.slice(y + 1, x), S = x - y - 1;
              y = x, E = 0;
            } else m === 46 && E !== -1 ? ++E : E = -1;
          }
          return v;
        }
        var u = { resolve: function() {
          for (var f, d = "", m = !1, v = arguments.length - 1; v >= -1 && !m; v--) {
            var S;
            v >= 0 ? S = arguments[v] : (f === void 0 && (f = process.cwd()), S = f), a(S), S.length !== 0 && (d = S + "/" + d, m = S.charCodeAt(0) === 47);
          }
          return d = l(d, !m), m ? d.length > 0 ? "/" + d : "/" : d.length > 0 ? d : ".";
        }, normalize: function(f) {
          if (a(f), f.length === 0) return ".";
          var d = f.charCodeAt(0) === 47, m = f.charCodeAt(f.length - 1) === 47;
          return (f = l(f, !d)).length !== 0 || d || (f = "."), f.length > 0 && m && (f += "/"), d ? "/" + f : f;
        }, isAbsolute: function(f) {
          return a(f), f.length > 0 && f.charCodeAt(0) === 47;
        }, join: function() {
          if (arguments.length === 0) return ".";
          for (var f, d = 0; d < arguments.length; ++d) {
            var m = arguments[d];
            a(m), m.length > 0 && (f === void 0 ? f = m : f += "/" + m);
          }
          return f === void 0 ? "." : u.normalize(f);
        }, relative: function(f, d) {
          if (a(f), a(d), f === d || (f = u.resolve(f)) === (d = u.resolve(d))) return "";
          for (var m = 1; m < f.length && f.charCodeAt(m) === 47; ++m) ;
          for (var v = f.length, S = v - m, y = 1; y < d.length && d.charCodeAt(y) === 47; ++y) ;
          for (var E = d.length - y, x = S < E ? S : E, g = -1, b = 0; b <= x; ++b) {
            if (b === x) {
              if (E > x) {
                if (d.charCodeAt(y + b) === 47) return d.slice(y + b + 1);
                if (b === 0) return d.slice(y + b);
              } else S > x && (f.charCodeAt(m + b) === 47 ? g = b : b === 0 && (g = 0));
              break;
            }
            var A = f.charCodeAt(m + b);
            if (A !== d.charCodeAt(y + b)) break;
            A === 47 && (g = b);
          }
          var P = "";
          for (b = m + g + 1; b <= v; ++b) b !== v && f.charCodeAt(b) !== 47 || (P.length === 0 ? P += ".." : P += "/..");
          return P.length > 0 ? P + d.slice(y + g) : (y += g, d.charCodeAt(y) === 47 && ++y, d.slice(y));
        }, _makeLong: function(f) {
          return f;
        }, dirname: function(f) {
          if (a(f), f.length === 0) return ".";
          for (var d = f.charCodeAt(0), m = d === 47, v = -1, S = !0, y = f.length - 1; y >= 1; --y) if ((d = f.charCodeAt(y)) === 47) {
            if (!S) {
              v = y;
              break;
            }
          } else S = !1;
          return v === -1 ? m ? "/" : "." : m && v === 1 ? "//" : f.slice(0, v);
        }, basename: function(f, d) {
          if (d !== void 0 && typeof d != "string") throw new TypeError('"ext" argument must be a string');
          a(f);
          var m, v = 0, S = -1, y = !0;
          if (d !== void 0 && d.length > 0 && d.length <= f.length) {
            if (d.length === f.length && d === f) return "";
            var E = d.length - 1, x = -1;
            for (m = f.length - 1; m >= 0; --m) {
              var g = f.charCodeAt(m);
              if (g === 47) {
                if (!y) {
                  v = m + 1;
                  break;
                }
              } else x === -1 && (y = !1, x = m + 1), E >= 0 && (g === d.charCodeAt(E) ? --E == -1 && (S = m) : (E = -1, S = x));
            }
            return v === S ? S = x : S === -1 && (S = f.length), f.slice(v, S);
          }
          for (m = f.length - 1; m >= 0; --m) if (f.charCodeAt(m) === 47) {
            if (!y) {
              v = m + 1;
              break;
            }
          } else S === -1 && (y = !1, S = m + 1);
          return S === -1 ? "" : f.slice(v, S);
        }, extname: function(f) {
          a(f);
          for (var d = -1, m = 0, v = -1, S = !0, y = 0, E = f.length - 1; E >= 0; --E) {
            var x = f.charCodeAt(E);
            if (x !== 47) v === -1 && (S = !1, v = E + 1), x === 46 ? d === -1 ? d = E : y !== 1 && (y = 1) : d !== -1 && (y = -1);
            else if (!S) {
              m = E + 1;
              break;
            }
          }
          return d === -1 || v === -1 || y === 0 || y === 1 && d === v - 1 && d === m + 1 ? "" : f.slice(d, v);
        }, format: function(f) {
          if (f === null || typeof f != "object") throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof f);
          return function(d, m) {
            var v = m.dir || m.root, S = m.base || (m.name || "") + (m.ext || "");
            return v ? v === m.root ? v + S : v + "/" + S : S;
          }(0, f);
        }, parse: function(f) {
          a(f);
          var d = { root: "", dir: "", base: "", ext: "", name: "" };
          if (f.length === 0) return d;
          var m, v = f.charCodeAt(0), S = v === 47;
          S ? (d.root = "/", m = 1) : m = 0;
          for (var y = -1, E = 0, x = -1, g = !0, b = f.length - 1, A = 0; b >= m; --b) if ((v = f.charCodeAt(b)) !== 47) x === -1 && (g = !1, x = b + 1), v === 46 ? y === -1 ? y = b : A !== 1 && (A = 1) : y !== -1 && (A = -1);
          else if (!g) {
            E = b + 1;
            break;
          }
          return y === -1 || x === -1 || A === 0 || A === 1 && y === x - 1 && y === E + 1 ? x !== -1 && (d.base = d.name = E === 0 && S ? f.slice(1, x) : f.slice(E, x)) : (E === 0 && S ? (d.name = f.slice(1, y), d.base = f.slice(1, x)) : (d.name = f.slice(E, y), d.base = f.slice(E, x)), d.ext = f.slice(y, x)), E > 0 ? d.dir = f.slice(0, E - 1) : S && (d.dir = "/"), d;
        }, sep: "/", delimiter: ":", win32: null, posix: null };
        u.posix = u, o.exports = u;
      }, 683: function(o) {
        o.exports = { nop: function(a) {
          return a;
        }, clone: function(a) {
          return JSON.parse(JSON.stringify(a));
        }, shallowClone: function(a) {
          let l = {};
          for (let u in a) a.hasOwnProperty(u) && (l[u] = a[u]);
          return l;
        }, deepClone: function a(l) {
          let u = Array.isArray(l) ? [] : {};
          for (let f in l) (l.hasOwnProperty(f) || Array.isArray(l)) && (u[f] = typeof l[f] == "object" ? a(l[f]) : l[f]);
          return u;
        }, fastClone: function(a) {
          return Object.assign({}, a);
        }, circularClone: function a(l, u) {
          if (u || (u = /* @__PURE__ */ new WeakMap()), Object(l) !== l || l instanceof Function) return l;
          if (u.has(l)) return u.get(l);
          try {
            var f = new l.constructor();
          } catch {
            f = Object.create(Object.getPrototypeOf(l));
          }
          return u.set(l, f), Object.assign(f, ...Object.keys(l).map((d) => ({ [d]: a(l[d], u) })));
        } };
      }, 593: function(o, a, l) {
        const u = l(401).recurse, f = l(683).shallowClone, d = l(53).jptr, m = l(592).isRef;
        o.exports = { dereference: function v(S, y, E) {
          E || (E = {}), E.cache || (E.cache = {}), E.state || (E.state = {}), E.state.identityDetection = !0, E.depth = E.depth ? E.depth + 1 : 1;
          let x = E.depth > 1 ? S : f(S), g = { data: x }, b = E.depth > 1 ? y : f(y);
          E.master || (E.master = x);
          let A = function(k) {
            return k && k.verbose ? { warn: function() {
              var $ = Array.prototype.slice.call(arguments);
              console.warn.apply(console, $);
            } } : { warn: function() {
            } };
          }(E), P = 1;
          for (; P > 0; ) P = 0, u(g, E.state, function(k, $, I) {
            if (m(k, $)) {
              let F = k[$];
              if (P++, E.cache[F]) {
                let L = E.cache[F];
                if (L.resolved) A.warn("Patching %s for %s", F, L.path), I.parent[I.pkey] = L.data, E.$ref && typeof I.parent[I.pkey] == "object" && I.parent[I.pkey] !== null && (I.parent[I.pkey][E.$ref] = F);
                else {
                  if (F === L.path) throw new Error(`Tight circle at ${L.path}`);
                  A.warn("Unresolved ref"), I.parent[I.pkey] = d(L.source, L.path), I.parent[I.pkey] === !1 && (I.parent[I.pkey] = d(L.source, L.key)), E.$ref && typeof I.parent[I.pkey] == "object" && I.parent[I.pkey] !== null && (I.parent[E.$ref] = F);
                }
              } else {
                let L = {};
                L.path = I.path.split("/$ref")[0], L.key = F, A.warn("Dereffing %s at %s", F, L.path), L.source = b, L.data = d(L.source, L.key), L.data === !1 && (L.data = d(E.master, L.key), L.source = E.master), L.data === !1 && A.warn("Missing $ref target", L.key), E.cache[F] = L, L.data = I.parent[I.pkey] = v(d(L.source, L.key), L.source, E), E.$ref && typeof I.parent[I.pkey] == "object" && I.parent[I.pkey] !== null && (I.parent[I.pkey][E.$ref] = F), L.resolved = !0;
              }
            }
          });
          return g.data;
        } };
      }, 592: function(o) {
        o.exports = { isRef: function(a, l) {
          return l === "$ref" && !!a && typeof a[l] == "string";
        } };
      }, 53: function(o) {
        function a(l) {
          return l.replace(/\~1/g, "/").replace(/~0/g, "~");
        }
        o.exports = { jptr: function(l, u, f) {
          if (l === void 0) return !1;
          if (!u || typeof u != "string" || u === "#") return f !== void 0 ? f : l;
          if (u.indexOf("#") >= 0) {
            let m = u.split("#");
            if (m[0]) return !1;
            u = m[1], u = decodeURIComponent(u.slice(1).split("+").join(" "));
          }
          u.startsWith("/") && (u = u.slice(1));
          let d = u.split("/");
          for (let m = 0; m < d.length; m++) {
            d[m] = a(d[m]);
            let v = f !== void 0 && m == d.length - 1, S = parseInt(d[m], 10);
            if (!Array.isArray(l) || isNaN(S) || S.toString() !== d[m] ? S = Array.isArray(l) && d[m] === "-" ? -2 : -1 : d[m] = m > 0 ? d[m - 1] : "", S != -1 || l && l.hasOwnProperty(d[m])) if (S >= 0) v && (l[S] = f), l = l[S];
            else {
              if (S === -2) return v ? (Array.isArray(l) && l.push(f), f) : void 0;
              v && (l[d[m]] = f), l = l[d[m]];
            }
            else {
              if (f === void 0 || typeof l != "object" || Array.isArray(l)) return !1;
              l[d[m]] = v ? f : d[m + 1] === "0" || d[m + 1] === "-" ? [] : {}, l = l[d[m]];
            }
          }
          return l;
        }, jpescape: function(l) {
          return l.replace(/\~/g, "~0").replace(/\//g, "~1");
        }, jpunescape: a };
      }, 401: function(o, a, l) {
        const u = l(53).jpescape;
        o.exports = { recurse: function f(d, m, v) {
          if (m || (m = { depth: 0 }), m.depth || (m = Object.assign({}, { path: "#", depth: 0, pkey: "", parent: {}, payload: {}, seen: /* @__PURE__ */ new WeakMap(), identity: !1, identityDetection: !1 }, m)), typeof d != "object") return;
          let S = m.path;
          for (let y in d) {
            if (m.key = y, m.path = m.path + "/" + encodeURIComponent(u(y)), m.identityPath = m.seen.get(d[y]), m.identity = m.identityPath !== void 0, d.hasOwnProperty(y) && v(d, y, m), typeof d[y] == "object" && !m.identity) {
              m.identityDetection && !Array.isArray(d[y]) && d[y] !== null && m.seen.set(d[y], m.path);
              let E = {};
              E.parent = d, E.path = m.path, E.depth = m.depth ? m.depth + 1 : 1, E.pkey = y, E.payload = m.payload, E.seen = m.seen, E.identity = !1, E.identityDetection = m.identityDetection, f(d[y], E, v);
            }
            m.path = S;
          }
        } };
      }, 232: function(o, a, l) {
        l.r(a);
        var u = l(379), f = l.n(u), d = l(795), m = l.n(d), v = l(569), S = l.n(v), y = l(565), E = l.n(y), x = l(216), g = l.n(x), b = l(589), A = l.n(b), P = l(260), k = {};
        k.styleTagTransform = A(), k.setAttributes = E(), k.insert = S().bind(null, "head"), k.domAPI = m(), k.insertStyleElement = g(), f()(P.Z, k), a.default = P.Z && P.Z.locals ? P.Z.locals : void 0;
      }, 379: function(o) {
        var a = [];
        function l(d) {
          for (var m = -1, v = 0; v < a.length; v++) if (a[v].identifier === d) {
            m = v;
            break;
          }
          return m;
        }
        function u(d, m) {
          for (var v = {}, S = [], y = 0; y < d.length; y++) {
            var E = d[y], x = m.base ? E[0] + m.base : E[0], g = v[x] || 0, b = "".concat(x, " ").concat(g);
            v[x] = g + 1;
            var A = l(b), P = { css: E[1], media: E[2], sourceMap: E[3], supports: E[4], layer: E[5] };
            if (A !== -1) a[A].references++, a[A].updater(P);
            else {
              var k = f(P, m);
              m.byIndex = y, a.splice(y, 0, { identifier: b, updater: k, references: 1 });
            }
            S.push(b);
          }
          return S;
        }
        function f(d, m) {
          var v = m.domAPI(m);
          return v.update(d), function(S) {
            if (S) {
              if (S.css === d.css && S.media === d.media && S.sourceMap === d.sourceMap && S.supports === d.supports && S.layer === d.layer) return;
              v.update(d = S);
            } else v.remove();
          };
        }
        o.exports = function(d, m) {
          var v = u(d = d || [], m = m || {});
          return function(S) {
            S = S || [];
            for (var y = 0; y < v.length; y++) {
              var E = l(v[y]);
              a[E].references--;
            }
            for (var x = u(S, m), g = 0; g < v.length; g++) {
              var b = l(v[g]);
              a[b].references === 0 && (a[b].updater(), a.splice(b, 1));
            }
            v = x;
          };
        };
      }, 569: function(o) {
        var a = {};
        o.exports = function(l, u) {
          var f = function(d) {
            if (a[d] === void 0) {
              var m = document.querySelector(d);
              if (window.HTMLIFrameElement && m instanceof window.HTMLIFrameElement) try {
                m = m.contentDocument.head;
              } catch {
                m = null;
              }
              a[d] = m;
            }
            return a[d];
          }(l);
          if (!f) throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
          f.appendChild(u);
        };
      }, 216: function(o) {
        o.exports = function(a) {
          var l = document.createElement("style");
          return a.setAttributes(l, a.attributes), a.insert(l, a.options), l;
        };
      }, 565: function(o, a, l) {
        o.exports = function(u) {
          var f = l.nc;
          f && u.setAttribute("nonce", f);
        };
      }, 795: function(o) {
        o.exports = function(a) {
          var l = a.insertStyleElement(a);
          return { update: function(u) {
            (function(f, d, m) {
              var v = "";
              m.supports && (v += "@supports (".concat(m.supports, ") {")), m.media && (v += "@media ".concat(m.media, " {"));
              var S = m.layer !== void 0;
              S && (v += "@layer".concat(m.layer.length > 0 ? " ".concat(m.layer) : "", " {")), v += m.css, S && (v += "}"), m.media && (v += "}"), m.supports && (v += "}");
              var y = m.sourceMap;
              y && typeof btoa < "u" && (v += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(y)))), " */")), d.styleTagTransform(v, f, d.options);
            })(l, a, u);
          }, remove: function() {
            (function(u) {
              if (u.parentNode === null) return !1;
              u.parentNode.removeChild(u);
            })(l);
          } };
        };
      }, 589: function(o) {
        o.exports = function(a, l) {
          if (l.styleSheet) l.styleSheet.cssText = a;
          else {
            for (; l.firstChild; ) l.removeChild(l.firstChild);
            l.appendChild(document.createTextNode(a));
          }
        };
      }, 925: function(o, a, l) {
        const u = l(825), f = l(416), d = (l(470), l(766)), m = l(416), v = l(66), S = l(53), y = S.jptr, E = l(592).isRef, x = l(683).clone, g = l(683).circularClone, b = l(401).recurse, A = l(856), P = l(804), k = l(342), $ = l(711).statusCodes, I = l(109).i8, F = "3.0.0";
        let L;
        class Q extends Error {
          constructor(N) {
            super(N), this.name = "S2OError";
          }
        }
        function Y(C, N) {
          let J = new Q(C);
          if (J.options = N, !N.promise) throw J;
          N.promise.reject(J);
        }
        function ae(C, N, J) {
          J.warnOnly ? N[J.warnProperty || "x-s2o-warning"] = C : Y(C, J);
        }
        function le(C, N) {
          P.walkSchema(C, {}, {}, function(J, X, oe) {
            (function(U, V) {
              if (U["x-required"] && Array.isArray(U["x-required"]) && (U.required || (U.required = []), U.required = U.required.concat(U["x-required"]), delete U["x-required"]), U["x-anyOf"] && (U.anyOf = U["x-anyOf"], delete U["x-anyOf"]), U["x-oneOf"] && (U.oneOf = U["x-oneOf"], delete U["x-oneOf"]), U["x-not"] && (U.not = U["x-not"], delete U["x-not"]), typeof U["x-nullable"] == "boolean" && (U.nullable = U["x-nullable"], delete U["x-nullable"]), typeof U["x-discriminator"] == "object" && typeof U["x-discriminator"].propertyName == "string") {
                U.discriminator = U["x-discriminator"], delete U["x-discriminator"];
                for (let ye in U.discriminator.mapping) {
                  let de = U.discriminator.mapping[ye];
                  de.startsWith("#/definitions/") && (U.discriminator.mapping[ye] = de.replace("#/definitions/", "#/components/schemas/"));
                }
              }
            })(J), function(U, V, ye) {
              if (U.nullable && ye.patches++, U.discriminator && typeof U.discriminator == "string" && (U.discriminator = { propertyName: U.discriminator }), U.items && Array.isArray(U.items) && (U.items.length === 0 ? U.items = {} : U.items.length === 1 ? U.items = U.items[0] : U.items = { anyOf: U.items }), U.type && Array.isArray(U.type)) if (ye.patch) {
                if (ye.patches++, U.type.length === 0) delete U.type;
                else {
                  U.oneOf || (U.oneOf = []);
                  for (let de of U.type) {
                    let Ce = {};
                    if (de === "null") U.nullable = !0;
                    else {
                      Ce.type = de;
                      for (let Se of k.arrayProperties) U.prop !== void 0 && (Ce[Se] = U[Se], delete U[Se]);
                    }
                    Ce.type && U.oneOf.push(Ce);
                  }
                  delete U.type, U.oneOf.length === 0 ? delete U.oneOf : U.oneOf.length < 2 && (U.type = U.oneOf[0].type, Object.keys(U.oneOf[0]).length > 1 && ae("Lost properties from oneOf", U, ye), delete U.oneOf);
                }
                U.type && Array.isArray(U.type) && U.type.length === 1 && (U.type = U.type[0]);
              } else Y("(Patchable) schema type must not be an array", ye);
              U.type && U.type === "null" && (delete U.type, U.nullable = !0), U.type !== "array" || U.items || (U.items = {}), U.type === "file" && (U.type = "string", U.format = "binary"), typeof U.required == "boolean" && (U.required && U.name && (V.required === void 0 && (V.required = []), Array.isArray(V.required) && V.required.push(U.name)), delete U.required), U.xml && typeof U.xml.namespace == "string" && (U.xml.namespace || delete U.xml.namespace), U.allowEmptyValue !== void 0 && (ye.patches++, delete U.allowEmptyValue);
            }(J, X, N);
          });
        }
        function ue(C, N, J) {
          let X = J.payload.options;
          if (E(C, N)) {
            if (!C[N].startsWith("#/components/")) {
              if (C[N] === "#/consumes") delete C[N], J.parent[J.pkey] = x(X.openapi.consumes);
              else if (C[N] === "#/produces") delete C[N], J.parent[J.pkey] = x(X.openapi.produces);
              else if (C[N].startsWith("#/definitions/")) {
                let U = C[N].replace("#/definitions/", "").split("/");
                const V = S.jpunescape(U[0]);
                let ye = L.schemas[decodeURIComponent(V)];
                ye ? U[0] = ye : ae("Could not resolve reference " + C[N], C, X), C[N] = "#/components/schemas/" + U.join("/");
              } else if (C[N].startsWith("#/parameters/")) C[N] = "#/components/parameters/" + k.sanitise(C[N].replace("#/parameters/", ""));
              else if (C[N].startsWith("#/responses/")) C[N] = "#/components/responses/" + k.sanitise(C[N].replace("#/responses/", ""));
              else if (C[N].startsWith("#")) {
                let U = x(S.jptr(X.openapi, C[N]));
                if (U === !1) ae("direct $ref not found " + C[N], C, X);
                else if (X.refmap[C[N]]) C[N] = X.refmap[C[N]];
                else {
                  let V = C[N];
                  V = V.replace("/properties/headers/", ""), V = V.replace("/properties/responses/", ""), V = V.replace("/properties/parameters/", ""), V = V.replace("/properties/schemas/", "");
                  let ye = "schemas", de = V.lastIndexOf("/schema");
                  if (ye = V.indexOf("/headers/") > de ? "headers" : V.indexOf("/responses/") > de ? "responses" : V.indexOf("/example") > de ? "examples" : V.indexOf("/x-") > de ? "extensions" : V.indexOf("/parameters/") > de ? "parameters" : "schemas", ye === "schemas" && le(U, X), ye !== "responses" && ye !== "extensions") {
                    let Ce = ye.substr(0, ye.length - 1);
                    Ce === "parameter" && U.name && U.name === k.sanitise(U.name) && (Ce = encodeURIComponent(U.name));
                    let Se = 1;
                    for (C["x-miro"] && (oe = (oe = C["x-miro"]).indexOf("#") >= 0 ? oe.split("#")[1].split("/").pop() : oe.split("/").pop().split(".")[0], Ce = encodeURIComponent(k.sanitise(oe)), Se = ""); S.jptr(X.openapi, "#/components/" + ye + "/" + Ce + Se); ) Se = Se === "" ? 2 : ++Se;
                    let O = "#/components/" + ye + "/" + Ce + Se, M = "";
                    ye === "examples" && (U = { value: U }, M = "/value"), S.jptr(X.openapi, O, U), X.refmap[C[N]] = O + M, C[N] = O + M;
                  }
                }
              }
            }
            if (delete C["x-miro"], Object.keys(C).length > 1) {
              const U = C[N], V = J.path.indexOf("/schema") >= 0;
              X.refSiblings === "preserve" || (V && X.refSiblings === "allOf" ? (delete C.$ref, J.parent[J.pkey] = { allOf: [{ $ref: U }, C] }) : J.parent[J.pkey] = { $ref: U });
            }
          }
          var oe;
          if (N === "x-ms-odata" && typeof C[N] == "string" && C[N].startsWith("#/")) {
            let U = C[N].replace("#/definitions/", "").replace("#/components/schemas/", "").split("/"), V = L.schemas[decodeURIComponent(U[0])];
            V ? U[0] = V : ae("Could not resolve reference " + C[N], C, X), C[N] = "#/components/schemas/" + U.join("/");
          }
        }
        function ce(C) {
          for (let N in C) for (let J in C[N]) {
            let X = k.sanitise(J);
            J !== X && (C[N][X] = C[N][J], delete C[N][J]);
          }
        }
        function be(C, N) {
          if (C.type === "basic" && (C.type = "http", C.scheme = "basic"), C.type === "oauth2") {
            let J = {}, X = C.flow;
            C.flow === "application" && (X = "clientCredentials"), C.flow === "accessCode" && (X = "authorizationCode"), C.authorizationUrl !== void 0 && (J.authorizationUrl = C.authorizationUrl.split("?")[0].trim() || "/"), typeof C.tokenUrl == "string" && (J.tokenUrl = C.tokenUrl.split("?")[0].trim() || "/"), J.scopes = C.scopes || {}, C.flows = {}, C.flows[X] = J, delete C.flow, delete C.authorizationUrl, delete C.tokenUrl, delete C.scopes, C.name !== void 0 && (N.patch ? (N.patches++, delete C.name) : Y("(Patchable) oauth2 securitySchemes should not have name property", N));
          }
        }
        function G(C) {
          return C && !C["x-s2o-delete"];
        }
        function ee(C, N) {
          if (C.$ref) C.$ref = C.$ref.replace("#/responses/", "#/components/responses/");
          else {
            C.type && !C.schema && (C.schema = {}), C.type && (C.schema.type = C.type), C.items && C.items.type !== "array" && (C.items.collectionFormat !== C.collectionFormat && ae("Nested collectionFormats are not supported", C, N), delete C.items.collectionFormat), C.type === "array" ? (C.collectionFormat === "ssv" ? ae("collectionFormat:ssv is no longer supported for headers", C, N) : C.collectionFormat === "pipes" ? ae("collectionFormat:pipes is no longer supported for headers", C, N) : C.collectionFormat === "multi" ? C.explode = !0 : C.collectionFormat === "tsv" ? (ae("collectionFormat:tsv is no longer supported", C, N), C["x-collectionFormat"] = "tsv") : C.style = "simple", delete C.collectionFormat) : C.collectionFormat && (N.patch ? (N.patches++, delete C.collectionFormat) : Y("(Patchable) collectionFormat is only applicable to header.type array", N)), delete C.type;
            for (let J of k.parameterTypeProperties) C[J] !== void 0 && (C.schema[J] = C[J], delete C[J]);
            for (let J of k.arrayProperties) C[J] !== void 0 && (C.schema[J] = C[J], delete C[J]);
          }
        }
        function K(C, N) {
          if (C.$ref.indexOf("#/parameters/") >= 0) {
            let J = C.$ref.split("#/parameters/");
            C.$ref = J[0] + "#/components/parameters/" + k.sanitise(J[1]);
          }
          C.$ref.indexOf("#/definitions/") >= 0 && ae("Definition used as parameter", C, N);
        }
        function z(C, N, J, X, oe, U, V) {
          let ye, de = {}, Ce = !0;
          if (N && N.consumes && typeof N.consumes == "string") {
            if (!V.patch) return Y("(Patchable) operation.consumes must be an array", V);
            V.patches++, N.consumes = [N.consumes];
          }
          Array.isArray(U.consumes) || delete U.consumes;
          let Se = ((N ? N.consumes : null) || U.consumes || []).filter(k.uniqueOnly);
          if (C && C.$ref && typeof C.$ref == "string") {
            K(C, V);
            let O = decodeURIComponent(C.$ref.replace("#/components/parameters/", "")), M = !1, se = U.components.parameters[O];
            if (se && !se["x-s2o-delete"] || !C.$ref.startsWith("#/") || (C["x-s2o-delete"] = !0, M = !0), M) {
              let ve = C.$ref, ge = y(U, C.$ref);
              !ge && ve.startsWith("#/") ? ae("Could not resolve reference " + ve, C, V) : ge && (C = ge);
            }
          }
          if (C && (C.name || C.in)) {
            typeof C["x-deprecated"] == "boolean" && (C.deprecated = C["x-deprecated"], delete C["x-deprecated"]), C["x-example"] !== void 0 && (C.example = C["x-example"], delete C["x-example"]), C.in === "body" || C.type || (V.patch ? (V.patches++, C.type = "string") : Y("(Patchable) parameter.type is mandatory for non-body parameters", V)), C.type && typeof C.type == "object" && C.type.$ref && (C.type = y(U, C.type.$ref)), C.type === "file" && (C["x-s2o-originalType"] = C.type, ye = C.type), C.description && typeof C.description == "object" && C.description.$ref && (C.description = y(U, C.description.$ref)), C.description === null && delete C.description;
            let O = C.collectionFormat;
            if (C.type !== "array" || O || (O = "csv"), O && (C.type !== "array" && (V.patch ? (V.patches++, delete C.collectionFormat) : Y("(Patchable) collectionFormat is only applicable to param.type array", V)), O !== "csv" || C.in !== "query" && C.in !== "cookie" || (C.style = "form", C.explode = !1), O !== "csv" || C.in !== "path" && C.in !== "header" || (C.style = "simple"), O === "ssv" && (C.in === "query" ? C.style = "spaceDelimited" : ae("collectionFormat:ssv is no longer supported except for in:query parameters", C, V)), O === "pipes" && (C.in === "query" ? C.style = "pipeDelimited" : ae("collectionFormat:pipes is no longer supported except for in:query parameters", C, V)), O === "multi" && (C.explode = !0), O === "tsv" && (ae("collectionFormat:tsv is no longer supported", C, V), C["x-collectionFormat"] = "tsv"), delete C.collectionFormat), C.type && C.type !== "body" && C.in !== "formData") if (C.items && C.schema) ae("parameter has array,items and schema", C, V);
            else {
              C.schema && V.patches++, C.schema && typeof C.schema == "object" || (C.schema = {}), C.schema.type = C.type, C.items && (C.schema.items = C.items, delete C.items, b(C.schema.items, null, function(M, se, ve) {
                se === "collectionFormat" && typeof M[se] == "string" && (O && M[se] !== O && ae("Nested collectionFormats are not supported", C, V), delete M[se]);
              }));
              for (let M of k.parameterTypeProperties) C[M] !== void 0 && (C.schema[M] = C[M]), delete C[M];
            }
            C.schema && le(C.schema, V), C["x-ms-skip-url-encoding"] && C.in === "query" && (C.allowReserved = !0, delete C["x-ms-skip-url-encoding"]);
          }
          if (C && C.in === "formData") {
            Ce = !1, de.content = {};
            let O = "application/x-www-form-urlencoded";
            if (Se.length && Se.indexOf("multipart/form-data") >= 0 && (O = "multipart/form-data"), de.content[O] = {}, C.schema) de.content[O].schema = C.schema, C.schema.$ref && (de["x-s2o-name"] = decodeURIComponent(C.schema.$ref.replace("#/components/schemas/", "")));
            else {
              de.content[O].schema = {}, de.content[O].schema.type = "object", de.content[O].schema.properties = {}, de.content[O].schema.properties[C.name] = {};
              let M = de.content[O].schema, se = de.content[O].schema.properties[C.name];
              C.description && (se.description = C.description), C.example && (se.example = C.example), C.type && (se.type = C.type);
              for (let ve of k.parameterTypeProperties) C[ve] !== void 0 && (se[ve] = C[ve]);
              C.required === !0 && (M.required || (M.required = []), M.required.push(C.name), de.required = !0), C.default !== void 0 && (se.default = C.default), se.properties && (se.properties = C.properties), C.allOf && (se.allOf = C.allOf), C.type === "array" && C.items && (se.items = C.items, se.items.collectionFormat && delete se.items.collectionFormat), ye !== "file" && C["x-s2o-originalType"] !== "file" || (se.type = "string", se.format = "binary"), te(C, se);
            }
          } else C && C.type === "file" && (C.required && (de.required = C.required), de.content = {}, de.content["application/octet-stream"] = {}, de.content["application/octet-stream"].schema = {}, de.content["application/octet-stream"].schema.type = "string", de.content["application/octet-stream"].schema.format = "binary", te(C, de));
          if (C && C.in === "body") {
            de.content = {}, C.name && (de["x-s2o-name"] = (N && N.operationId ? k.sanitiseAll(N.operationId) : "") + ("_" + C.name).toCamelCase()), C.description && (de.description = C.description), C.required && (de.required = C.required), N && V.rbname && C.name && (N[V.rbname] = C.name), C.schema && C.schema.$ref ? de["x-s2o-name"] = decodeURIComponent(C.schema.$ref.replace("#/components/schemas/", "")) : C.schema && C.schema.type === "array" && C.schema.items && C.schema.items.$ref && (de["x-s2o-name"] = decodeURIComponent(C.schema.items.$ref.replace("#/components/schemas/", "")) + "Array"), Se.length || Se.push("application/json");
            for (let O of Se) de.content[O] = {}, de.content[O].schema = x(C.schema || {}), le(de.content[O].schema, V);
            te(C, de);
          }
          if (Object.keys(de).length > 0 && (C["x-s2o-delete"] = !0, N) && (N.requestBody && Ce ? (N.requestBody["x-s2o-overloaded"] = !0, ae("Operation " + (N.operationId || oe) + " has multiple requestBodies", N, V)) : (N.requestBody || (N = J[X] = function(O, M) {
            let se = {};
            for (let ve of Object.keys(O)) se[ve] = O[ve], ve === "parameters" && (se.requestBody = {}, M.rbname && (se[M.rbname] = ""));
            return se.requestBody = {}, se;
          }(N, V)), N.requestBody.content && N.requestBody.content["multipart/form-data"] && N.requestBody.content["multipart/form-data"].schema && N.requestBody.content["multipart/form-data"].schema.properties && de.content["multipart/form-data"] && de.content["multipart/form-data"].schema && de.content["multipart/form-data"].schema.properties ? (N.requestBody.content["multipart/form-data"].schema.properties = Object.assign(N.requestBody.content["multipart/form-data"].schema.properties, de.content["multipart/form-data"].schema.properties), N.requestBody.content["multipart/form-data"].schema.required = (N.requestBody.content["multipart/form-data"].schema.required || []).concat(de.content["multipart/form-data"].schema.required || []), N.requestBody.content["multipart/form-data"].schema.required.length || delete N.requestBody.content["multipart/form-data"].schema.required) : N.requestBody.content && N.requestBody.content["application/x-www-form-urlencoded"] && N.requestBody.content["application/x-www-form-urlencoded"].schema && N.requestBody.content["application/x-www-form-urlencoded"].schema.properties && de.content["application/x-www-form-urlencoded"] && de.content["application/x-www-form-urlencoded"].schema && de.content["application/x-www-form-urlencoded"].schema.properties ? (N.requestBody.content["application/x-www-form-urlencoded"].schema.properties = Object.assign(N.requestBody.content["application/x-www-form-urlencoded"].schema.properties, de.content["application/x-www-form-urlencoded"].schema.properties), N.requestBody.content["application/x-www-form-urlencoded"].schema.required = (N.requestBody.content["application/x-www-form-urlencoded"].schema.required || []).concat(de.content["application/x-www-form-urlencoded"].schema.required || []), N.requestBody.content["application/x-www-form-urlencoded"].schema.required.length || delete N.requestBody.content["application/x-www-form-urlencoded"].schema.required) : (N.requestBody = Object.assign(N.requestBody, de), N.requestBody["x-s2o-name"] || (N.requestBody.schema && N.requestBody.schema.$ref ? N.requestBody["x-s2o-name"] = decodeURIComponent(N.requestBody.schema.$ref.replace("#/components/schemas/", "")).split("/").join("") : N.operationId && (N.requestBody["x-s2o-name"] = k.sanitiseAll(N.operationId)))))), C && !C["x-s2o-delete"]) {
            delete C.type;
            for (let O of k.parameterTypeProperties) delete C[O];
            C.in !== "path" || C.required !== void 0 && C.required === !0 || (V.patch ? (V.patches++, C.required = !0) : Y("(Patchable) path parameters must be required:true [" + C.name + " in " + oe + "]", V));
          }
          return N;
        }
        function te(C, N) {
          for (let J in C) J.startsWith("x-") && !J.startsWith("x-s2o") && (N[J] = C[J]);
        }
        function q(C, N, J, X, oe) {
          if (!C) return !1;
          if (C.$ref && typeof C.$ref == "string") C.$ref.indexOf("#/definitions/") >= 0 ? ae("definition used as response: " + C.$ref, C, oe) : C.$ref.startsWith("#/responses/") && (C.$ref = "#/components/responses/" + k.sanitise(decodeURIComponent(C.$ref.replace("#/responses/", ""))));
          else {
            if ((C.description === void 0 || C.description === null || C.description === "" && oe.patch) && (oe.patch ? typeof C != "object" || Array.isArray(C) || (oe.patches++, C.description = $[C] || "") : Y("(Patchable) response.description is mandatory", oe)), C.schema !== void 0) {
              if (le(C.schema, oe), C.schema.$ref && typeof C.schema.$ref == "string" && C.schema.$ref.startsWith("#/responses/") && (C.schema.$ref = "#/components/responses/" + k.sanitise(decodeURIComponent(C.schema.$ref.replace("#/responses/", "")))), J && J.produces && typeof J.produces == "string") {
                if (!oe.patch) return Y("(Patchable) operation.produces must be an array", oe);
                oe.patches++, J.produces = [J.produces];
              }
              X.produces && !Array.isArray(X.produces) && delete X.produces;
              let U = ((J ? J.produces : null) || X.produces || []).filter(k.uniqueOnly);
              U.length || U.push("*/*"), C.content = {};
              for (let V of U) {
                if (C.content[V] = {}, C.content[V].schema = x(C.schema), C.examples && C.examples[V]) {
                  let ye = {};
                  ye.value = C.examples[V], C.content[V].examples = {}, C.content[V].examples.response = ye, delete C.examples[V];
                }
                C.content[V].schema.type === "file" && (C.content[V].schema = { type: "string", format: "binary" });
              }
              delete C.schema;
            }
            for (let U in C.examples) C.content || (C.content = {}), C.content[U] || (C.content[U] = {}), C.content[U].examples = {}, C.content[U].examples.response = {}, C.content[U].examples.response.value = C.examples[U];
            if (delete C.examples, C.headers) for (let U in C.headers) U.toLowerCase() === "status code" ? oe.patch ? (oe.patches++, delete C.headers[U]) : Y('(Patchable) "Status Code" is not a valid header', oe) : ee(C.headers[U], oe);
          }
        }
        function j(C, N, J, X, oe) {
          for (let U in C) {
            let V = C[U];
            V && V["x-trace"] && typeof V["x-trace"] == "object" && (V.trace = V["x-trace"], delete V["x-trace"]), V && V["x-summary"] && typeof V["x-summary"] == "string" && (V.summary = V["x-summary"], delete V["x-summary"]), V && V["x-description"] && typeof V["x-description"] == "string" && (V.description = V["x-description"], delete V["x-description"]), V && V["x-servers"] && Array.isArray(V["x-servers"]) && (V.servers = V["x-servers"], delete V["x-servers"]);
            for (let ye in V) if (k.httpMethods.indexOf(ye) >= 0 || ye === "x-amazon-apigateway-any-method") {
              let de = V[ye];
              if (de && de.parameters && Array.isArray(de.parameters)) {
                if (V.parameters) for (let Ce of V.parameters) typeof Ce.$ref == "string" && (K(Ce, J), Ce = y(oe, Ce.$ref)), de.parameters.find(function(Se, O, M) {
                  return Se.name === Ce.name && Se.in === Ce.in;
                }) || Ce.in !== "formData" && Ce.in !== "body" && Ce.type !== "file" || (de = z(Ce, de, V, ye, U, oe, J), J.rbname && de[J.rbname] === "" && delete de[J.rbname]);
                for (let Ce of de.parameters) de = z(Ce, de, V, ye, ye + ":" + U, oe, J);
                J.rbname && de[J.rbname] === "" && delete de[J.rbname], J.debug || de.parameters && (de.parameters = de.parameters.filter(G));
              }
              if (de && de.security && ce(de.security), typeof de == "object") {
                if (!de.responses) {
                  let Ce = { description: "Default response" };
                  de.responses = { default: Ce };
                }
                for (let Ce in de.responses) q(de.responses[Ce], 0, de, oe, J);
              }
              if (de && de["x-servers"] && Array.isArray(de["x-servers"])) de.servers = de["x-servers"], delete de["x-servers"];
              else if (de && de.schemes && de.schemes.length) {
                for (let Ce of de.schemes) if ((!oe.schemes || oe.schemes.indexOf(Ce) < 0) && (de.servers || (de.servers = []), Array.isArray(oe.servers))) for (let Se of oe.servers) {
                  let O = x(Se), M = f.parse(O.url);
                  M.protocol = Ce, O.url = M.format(), de.servers.push(O);
                }
              }
              if (J.debug && (de["x-s2o-consumes"] = de.consumes || [], de["x-s2o-produces"] = de.produces || []), de) {
                if (delete de.consumes, delete de.produces, delete de.schemes, de["x-ms-examples"]) {
                  for (let Ce in de["x-ms-examples"]) {
                    let Se = de["x-ms-examples"][Ce], O = k.sanitiseAll(Ce);
                    if (Se.parameters) for (let M in Se.parameters) {
                      let se = Se.parameters[M];
                      for (let ve of (de.parameters || []).concat(V.parameters || [])) ve.$ref && (ve = S.jptr(oe, ve.$ref)), ve.name !== M || ve.example || (ve.examples || (ve.examples = {}), ve.examples[Ce] = { value: se });
                    }
                    if (Se.responses) for (let M in Se.responses) {
                      if (Se.responses[M].headers) for (let se in Se.responses[M].headers) {
                        let ve = Se.responses[M].headers[se];
                        for (let ge in de.responses[M].headers) ge === se && (de.responses[M].headers[ge].example = ve);
                      }
                      if (Se.responses[M].body && (oe.components.examples[O] = { value: x(Se.responses[M].body) }, de.responses[M] && de.responses[M].content)) for (let se in de.responses[M].content) {
                        let ve = de.responses[M].content[se];
                        ve.examples || (ve.examples = {}), ve.examples[Ce] = { $ref: "#/components/examples/" + O };
                      }
                    }
                  }
                  delete de["x-ms-examples"];
                }
                if (de.parameters && de.parameters.length === 0 && delete de.parameters, de.requestBody) {
                  let Ce = de.operationId ? k.sanitiseAll(de.operationId) : k.sanitiseAll(ye + U).toCamelCase(), Se = k.sanitise(de.requestBody["x-s2o-name"] || Ce || "");
                  delete de.requestBody["x-s2o-name"];
                  let O = JSON.stringify(de.requestBody), M = k.hash(O);
                  if (!X[M]) {
                    let ve = {};
                    ve.name = Se, ve.body = de.requestBody, ve.refs = [], X[M] = ve;
                  }
                  let se = "#/" + N + "/" + encodeURIComponent(S.jpescape(U)) + "/" + ye + "/requestBody";
                  X[M].refs.push(se);
                }
              }
            }
            if (V && V.parameters) {
              for (let ye in V.parameters) z(V.parameters[ye], null, V, null, U, oe, J);
              !J.debug && Array.isArray(V.parameters) && (V.parameters = V.parameters.filter(G));
            }
          }
        }
        function H(C) {
          return C && C.url && typeof C.url == "string" && (C.url = C.url.split("{{").join("{"), C.url = C.url.split("}}").join("}"), C.url.replace(/\{(.+?)\}/g, function(N, J) {
            C.variables || (C.variables = {}), C.variables[J] = { default: "unknown" };
          })), C;
        }
        function B(C, N, J) {
          if (C.info === void 0 || C.info === null) {
            if (!N.patch) return J(new Q("(Patchable) info object is mandatory"));
            N.patches++, C.info = { version: "", title: "" };
          }
          if (typeof C.info != "object" || Array.isArray(C.info)) return J(new Q("info must be an object"));
          if (C.info.title === void 0 || C.info.title === null) {
            if (!N.patch) return J(new Q("(Patchable) info.title cannot be null"));
            N.patches++, C.info.title = "";
          }
          if (C.info.version === void 0 || C.info.version === null) {
            if (!N.patch) return J(new Q("(Patchable) info.version cannot be null"));
            N.patches++, C.info.version = "";
          }
          if (typeof C.info.version != "string") {
            if (!N.patch) return J(new Q("(Patchable) info.version must be a string"));
            N.patches++, C.info.version = C.info.version.toString();
          }
          if (C.info.logo !== void 0) {
            if (!N.patch) return J(new Q("(Patchable) info should not have logo property"));
            N.patches++, C.info["x-logo"] = C.info.logo, delete C.info.logo;
          }
          if (C.info.termsOfService !== void 0) {
            if (C.info.termsOfService === null) {
              if (!N.patch) return J(new Q("(Patchable) info.termsOfService cannot be null"));
              N.patches++, C.info.termsOfService = "";
            }
            try {
              new URL(C.info.termsOfService);
            } catch {
              if (!N.patch) return J(new Q("(Patchable) info.termsOfService must be a URL"));
              N.patches++, delete C.info.termsOfService;
            }
          }
        }
        function pe(C, N, J) {
          if (C.paths === void 0) {
            if (!N.patch) return J(new Q("(Patchable) paths object is mandatory"));
            N.patches++, C.paths = {};
          }
        }
        function he(C, N, J) {
          return d(J, new Promise(function(X, oe) {
            if (C || (C = {}), N.original = C, N.text || (N.text = v.stringify(C)), N.externals = [], N.externalRefs = {}, N.rewriteRefs = !0, N.preserveMiro = !0, N.promise = {}, N.promise.resolve = X, N.promise.reject = oe, N.patches = 0, N.cache || (N.cache = {}), N.source && (N.cache[N.source] = N.original), function(V, ye) {
              const de = /* @__PURE__ */ new WeakSet();
              b(V, { identityDetection: !0 }, function(Ce, Se, O) {
                typeof Ce[Se] == "object" && Ce[Se] !== null && (de.has(Ce[Se]) ? ye.anchors ? Ce[Se] = x(Ce[Se]) : Y("YAML anchor or merge key at " + O.path, ye) : de.add(Ce[Se]));
              });
            }(C, N), C.openapi && typeof C.openapi == "string" && C.openapi.startsWith("3.")) return N.openapi = g(C), B(N.openapi, N, oe), pe(N.openapi, N, oe), void A.optionalResolve(N).then(function() {
              return N.direct ? X(N.openapi) : X(N);
            }).catch(function(V) {
              console.warn(V), oe(V);
            });
            if (!C.swagger || C.swagger != "2.0") return oe(new Q("Unsupported swagger/OpenAPI version: " + (C.openapi ? C.openapi : C.swagger)));
            let U = N.openapi = {};
            if (U.openapi = typeof N.targetVersion == "string" && N.targetVersion.startsWith("3.") ? N.targetVersion : F, N.origin) {
              U["x-origin"] || (U["x-origin"] = []);
              let V = {};
              V.url = N.source || N.origin, V.format = "swagger", V.version = C.swagger, V.converter = {}, V.converter.url = "https://github.com/mermade/oas-kit", V.converter.version = I, U["x-origin"].push(V);
            }
            if (U = Object.assign(U, g(C)), delete U.swagger, b(U, {}, function(V, ye, de) {
              V[ye] === null && !ye.startsWith("x-") && ye !== "default" && de.path.indexOf("/example") < 0 && delete V[ye];
            }), C.host) for (let V of Array.isArray(C.schemes) ? C.schemes : [""]) {
              let ye = {}, de = (C.basePath || "").replace(/\/$/, "");
              ye.url = (V ? V + ":" : "") + "//" + C.host + de, H(ye), U.servers || (U.servers = []), U.servers.push(ye);
            }
            else if (C.basePath) {
              let V = {};
              V.url = C.basePath, H(V), U.servers || (U.servers = []), U.servers.push(V);
            }
            if (delete U.host, delete U.basePath, U["x-servers"] && Array.isArray(U["x-servers"]) && (U.servers = U["x-servers"], delete U["x-servers"]), C["x-ms-parameterized-host"]) {
              let V = C["x-ms-parameterized-host"], ye = {};
              ye.url = V.hostTemplate + (C.basePath ? C.basePath : ""), ye.variables = {};
              const de = ye.url.match(/\{\w+\}/g);
              for (let Ce in V.parameters) {
                let Se = V.parameters[Ce];
                Se.$ref && (Se = x(y(U, Se.$ref))), Ce.startsWith("x-") || (delete Se.required, delete Se.type, delete Se.in, Se.default === void 0 && (Se.enum ? Se.default = Se.enum[0] : Se.default = "none"), Se.name || (Se.name = de[Ce].replace("{", "").replace("}", "")), ye.variables[Se.name] = Se, delete Se.name);
              }
              U.servers || (U.servers = []), V.useSchemePrefix === !1 ? U.servers.push(ye) : C.schemes.forEach((Ce) => {
                U.servers.push(Object.assign({}, ye, { url: Ce + "://" + ye.url }));
              }), delete U["x-ms-parameterized-host"];
            }
            B(U, N, oe), pe(U, N, oe), typeof U.consumes == "string" && (U.consumes = [U.consumes]), typeof U.produces == "string" && (U.produces = [U.produces]), U.components = {}, U["x-callbacks"] && (U.components.callbacks = U["x-callbacks"], delete U["x-callbacks"]), U.components.examples = {}, U.components.headers = {}, U["x-links"] && (U.components.links = U["x-links"], delete U["x-links"]), U.components.parameters = U.parameters || {}, U.components.responses = U.responses || {}, U.components.requestBodies = {}, U.components.securitySchemes = U.securityDefinitions || {}, U.components.schemas = U.definitions || {}, delete U.definitions, delete U.responses, delete U.parameters, delete U.securityDefinitions, A.optionalResolve(N).then(function() {
              (function(V, ye) {
                let de = {};
                L = { schemas: {} }, V.security && ce(V.security);
                for (let Se in V.components.securitySchemes) {
                  let O = k.sanitise(Se);
                  Se !== O && (V.components.securitySchemes[O] && Y("Duplicate sanitised securityScheme name " + O, ye), V.components.securitySchemes[O] = V.components.securitySchemes[Se], delete V.components.securitySchemes[Se]), be(V.components.securitySchemes[O], ye);
                }
                for (let Se in V.components.schemas) {
                  let O = k.sanitiseAll(Se), M = "";
                  if (Se !== O) {
                    for (; V.components.schemas[O + M]; ) M = M ? ++M : 2;
                    V.components.schemas[O + M] = V.components.schemas[Se], delete V.components.schemas[Se];
                  }
                  L.schemas[Se] = O + M, le(V.components.schemas[O + M], ye);
                }
                ye.refmap = {}, b(V, { payload: { options: ye } }, ue), function(Se, O) {
                  for (let M in O.refmap) S.jptr(Se, M, { $ref: O.refmap[M] });
                }(V, ye);
                for (let Se in V.components.parameters) {
                  let O = k.sanitise(Se);
                  Se !== O && (V.components.parameters[O] && Y("Duplicate sanitised parameter name " + O, ye), V.components.parameters[O] = V.components.parameters[Se], delete V.components.parameters[Se]), z(V.components.parameters[O], null, null, null, O, V, ye);
                }
                for (let Se in V.components.responses) {
                  let O = k.sanitise(Se);
                  Se !== O && (V.components.responses[O] && Y("Duplicate sanitised response name " + O, ye), V.components.responses[O] = V.components.responses[Se], delete V.components.responses[Se]);
                  let M = V.components.responses[O];
                  if (q(M, 0, null, V, ye), M.headers) for (let se in M.headers) se.toLowerCase() === "status code" ? ye.patch ? (ye.patches++, delete M.headers[se]) : Y('(Patchable) "Status Code" is not a valid header', ye) : ee(M.headers[se], ye);
                }
                for (let Se in V.components.requestBodies) {
                  let O = V.components.requestBodies[Se], M = JSON.stringify(O), se = k.hash(M), ve = {};
                  ve.name = Se, ve.body = O, ve.refs = [], de[se] = ve;
                }
                if (j(V.paths, "paths", ye, de, V), V["x-ms-paths"] && j(V["x-ms-paths"], "x-ms-paths", ye, de, V), !ye.debug) for (let Se in V.components.parameters) V.components.parameters[Se]["x-s2o-delete"] && delete V.components.parameters[Se];
                ye.debug && (V["x-s2o-consumes"] = V.consumes || [], V["x-s2o-produces"] = V.produces || []), delete V.consumes, delete V.produces, delete V.schemes;
                let Ce = [];
                if (V.components.requestBodies = {}, !ye.resolveInternal) {
                  let Se = 1;
                  for (let O in de) {
                    let M = de[O];
                    if (M.refs.length > 1) {
                      let se = "";
                      for (M.name || (M.name = "requestBody", se = Se++); Ce.indexOf(M.name + se) >= 0; ) se = se ? ++se : 2;
                      M.name = M.name + se, Ce.push(M.name), V.components.requestBodies[M.name] = x(M.body);
                      for (let ve in M.refs) {
                        let ge = {};
                        ge.$ref = "#/components/requestBodies/" + M.name, S.jptr(V, M.refs[ve], ge);
                      }
                    }
                  }
                }
                V.components.responses && Object.keys(V.components.responses).length === 0 && delete V.components.responses, V.components.parameters && Object.keys(V.components.parameters).length === 0 && delete V.components.parameters, V.components.examples && Object.keys(V.components.examples).length === 0 && delete V.components.examples, V.components.requestBodies && Object.keys(V.components.requestBodies).length === 0 && delete V.components.requestBodies, V.components.securitySchemes && Object.keys(V.components.securitySchemes).length === 0 && delete V.components.securitySchemes, V.components.headers && Object.keys(V.components.headers).length === 0 && delete V.components.headers, V.components.schemas && Object.keys(V.components.schemas).length === 0 && delete V.components.schemas, V.components && Object.keys(V.components).length === 0 && delete V.components;
              })(N.openapi, N), N.direct ? X(N.openapi) : X(N);
            }).catch(function(V) {
              console.warn(V), oe(V);
            });
          }));
        }
        function Ae(C, N, J) {
          return d(J, new Promise(function(X, oe) {
            let U = null, V = null;
            try {
              U = JSON.parse(C), N.text = JSON.stringify(U, null, 2);
            } catch (ye) {
              V = ye;
              try {
                U = v.parse(C, { schema: "core", prettyErrors: !0 }), N.sourceYaml = !0, N.text = C;
              } catch (de) {
                V = de;
              }
            }
            U ? he(U, N).then((ye) => X(ye)).catch((ye) => oe(ye)) : oe(new Q(V ? V.message : "Could not parse string"));
          }));
        }
        o.exports = { S2OError: Q, targetVersion: F, convert: he, convertObj: he, convertUrl: function(C, N, J) {
          return d(J, new Promise(function(X, oe) {
            N.origin = !0, N.source || (N.source = C), N.verbose && console.warn("GET " + C), N.fetch || (N.fetch = m);
            const U = Object.assign({}, N.fetchOptions, { agent: N.agent });
            N.fetch(C, U).then(function(V) {
              if (V.status !== 200) throw new Q(`Received status code ${V.status}: ${C}`);
              return V.text();
            }).then(function(V) {
              Ae(V, N).then((ye) => X(ye)).catch((ye) => oe(ye));
            }).catch(function(V) {
              oe(V);
            });
          }));
        }, convertStr: Ae, convertFile: function(C, N, J) {
          return d(J, new Promise(function(X, oe) {
            u.readFile(C, N.encoding || "utf8", function(U, V) {
              U ? oe(U) : (N.sourceFile = C, Ae(V, N).then((ye) => X(ye)).catch((ye) => oe(ye)));
            });
          }));
        }, convertStream: function(C, N, J) {
          return d(J, new Promise(function(X, oe) {
            let U = "";
            C.on("data", function(V) {
              U += V;
            }).on("end", function() {
              Ae(U, N).then((V) => X(V)).catch((V) => oe(V));
            });
          }));
        } };
      }, 711: function(o, a, l) {
        const u = l(177);
        o.exports = { statusCodes: Object.assign({}, { default: "Default response", "1XX": "Informational", 103: "Early hints", "2XX": "Successful", "3XX": "Redirection", "4XX": "Client Error", "5XX": "Server Error", "7XX": "Developer Error" }, u.STATUS_CODES) };
      }, 595: function(o, a, l) {
        var u = l(314), f = ["add", "done", "toJS", "fromExternalJS", "load", "dispose", "search", "Worker"];
        o.exports = function() {
          var d = new Worker(URL.createObjectURL(new Blob([`/*! For license information please see 756674defce81e90acea.worker.js.LICENSE.txt */
!function(){var e={336:function(e,t,r){var n,i;!function(){var s,o,a,u,l,c,h,d,f,p,y,m,g,x,v,w,Q,k,S,E,L,P,b,T,O,I,R,F,C,N,j=function(e){var t=new j.Builder;return t.pipeline.add(j.trimmer,j.stopWordFilter,j.stemmer),t.searchPipeline.add(j.stemmer),e.call(t,t),t.build()};j.version="2.3.9",j.utils={},j.utils.warn=(s=this,function(e){s.console&&console.warn&&console.warn(e)}),j.utils.asString=function(e){return null==e?"":e.toString()},j.utils.clone=function(e){if(null==e)return e;for(var t=Object.create(null),r=Object.keys(e),n=0;n<r.length;n++){var i=r[n],s=e[i];if(Array.isArray(s))t[i]=s.slice();else{if("string"!=typeof s&&"number"!=typeof s&&"boolean"!=typeof s)throw new TypeError("clone is not deep and does not support nested objects");t[i]=s}}return t},j.FieldRef=function(e,t,r){this.docRef=e,this.fieldName=t,this._stringValue=r},j.FieldRef.joiner="/",j.FieldRef.fromString=function(e){var t=e.indexOf(j.FieldRef.joiner);if(-1===t)throw"malformed field ref string";var r=e.slice(0,t),n=e.slice(t+1);return new j.FieldRef(n,r,e)},j.FieldRef.prototype.toString=function(){return null==this._stringValue&&(this._stringValue=this.fieldName+j.FieldRef.joiner+this.docRef),this._stringValue},j.Set=function(e){if(this.elements=Object.create(null),e){this.length=e.length;for(var t=0;t<this.length;t++)this.elements[e[t]]=!0}else this.length=0},j.Set.complete={intersect:function(e){return e},union:function(){return this},contains:function(){return!0}},j.Set.empty={intersect:function(){return this},union:function(e){return e},contains:function(){return!1}},j.Set.prototype.contains=function(e){return!!this.elements[e]},j.Set.prototype.intersect=function(e){var t,r,n,i=[];if(e===j.Set.complete)return this;if(e===j.Set.empty)return e;this.length<e.length?(t=this,r=e):(t=e,r=this),n=Object.keys(t.elements);for(var s=0;s<n.length;s++){var o=n[s];o in r.elements&&i.push(o)}return new j.Set(i)},j.Set.prototype.union=function(e){return e===j.Set.complete?j.Set.complete:e===j.Set.empty?this:new j.Set(Object.keys(this.elements).concat(Object.keys(e.elements)))},j.idf=function(e,t){var r=0;for(var n in e)"_index"!=n&&(r+=Object.keys(e[n]).length);var i=(t-r+.5)/(r+.5);return Math.log(1+Math.abs(i))},j.Token=function(e,t){this.str=e||"",this.metadata=t||{}},j.Token.prototype.toString=function(){return this.str},j.Token.prototype.update=function(e){return this.str=e(this.str,this.metadata),this},j.Token.prototype.clone=function(e){return e=e||function(e){return e},new j.Token(e(this.str,this.metadata),this.metadata)},j.tokenizer=function(e,t){if(null==e||null==e)return[];if(Array.isArray(e))return e.map((function(e){return new j.Token(j.utils.asString(e).toLowerCase(),j.utils.clone(t))}));for(var r=e.toString().toLowerCase(),n=r.length,i=[],s=0,o=0;s<=n;s++){var a=s-o;if(r.charAt(s).match(j.tokenizer.separator)||s==n){if(a>0){var u=j.utils.clone(t)||{};u.position=[o,a],u.index=i.length,i.push(new j.Token(r.slice(o,s),u))}o=s+1}}return i},j.tokenizer.separator=/[\\s\\-]+/,j.Pipeline=function(){this._stack=[]},j.Pipeline.registeredFunctions=Object.create(null),j.Pipeline.registerFunction=function(e,t){t in this.registeredFunctions&&j.utils.warn("Overwriting existing registered function: "+t),e.label=t,j.Pipeline.registeredFunctions[e.label]=e},j.Pipeline.warnIfFunctionNotRegistered=function(e){e.label&&e.label in this.registeredFunctions||j.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\\n",e)},j.Pipeline.load=function(e){var t=new j.Pipeline;return e.forEach((function(e){var r=j.Pipeline.registeredFunctions[e];if(!r)throw new Error("Cannot load unregistered function: "+e);t.add(r)})),t},j.Pipeline.prototype.add=function(){Array.prototype.slice.call(arguments).forEach((function(e){j.Pipeline.warnIfFunctionNotRegistered(e),this._stack.push(e)}),this)},j.Pipeline.prototype.after=function(e,t){j.Pipeline.warnIfFunctionNotRegistered(t);var r=this._stack.indexOf(e);if(-1==r)throw new Error("Cannot find existingFn");r+=1,this._stack.splice(r,0,t)},j.Pipeline.prototype.before=function(e,t){j.Pipeline.warnIfFunctionNotRegistered(t);var r=this._stack.indexOf(e);if(-1==r)throw new Error("Cannot find existingFn");this._stack.splice(r,0,t)},j.Pipeline.prototype.remove=function(e){var t=this._stack.indexOf(e);-1!=t&&this._stack.splice(t,1)},j.Pipeline.prototype.run=function(e){for(var t=this._stack.length,r=0;r<t;r++){for(var n=this._stack[r],i=[],s=0;s<e.length;s++){var o=n(e[s],s,e);if(null!=o&&""!==o)if(Array.isArray(o))for(var a=0;a<o.length;a++)i.push(o[a]);else i.push(o)}e=i}return e},j.Pipeline.prototype.runString=function(e,t){var r=new j.Token(e,t);return this.run([r]).map((function(e){return e.toString()}))},j.Pipeline.prototype.reset=function(){this._stack=[]},j.Pipeline.prototype.toJSON=function(){return this._stack.map((function(e){return j.Pipeline.warnIfFunctionNotRegistered(e),e.label}))},j.Vector=function(e){this._magnitude=0,this.elements=e||[]},j.Vector.prototype.positionForIndex=function(e){if(0==this.elements.length)return 0;for(var t=0,r=this.elements.length/2,n=r-t,i=Math.floor(n/2),s=this.elements[2*i];n>1&&(s<e&&(t=i),s>e&&(r=i),s!=e);)n=r-t,i=t+Math.floor(n/2),s=this.elements[2*i];return s==e||s>e?2*i:s<e?2*(i+1):void 0},j.Vector.prototype.insert=function(e,t){this.upsert(e,t,(function(){throw"duplicate index"}))},j.Vector.prototype.upsert=function(e,t,r){this._magnitude=0;var n=this.positionForIndex(e);this.elements[n]==e?this.elements[n+1]=r(this.elements[n+1],t):this.elements.splice(n,0,e,t)},j.Vector.prototype.magnitude=function(){if(this._magnitude)return this._magnitude;for(var e=0,t=this.elements.length,r=1;r<t;r+=2){var n=this.elements[r];e+=n*n}return this._magnitude=Math.sqrt(e)},j.Vector.prototype.dot=function(e){for(var t=0,r=this.elements,n=e.elements,i=r.length,s=n.length,o=0,a=0,u=0,l=0;u<i&&l<s;)(o=r[u])<(a=n[l])?u+=2:o>a?l+=2:o==a&&(t+=r[u+1]*n[l+1],u+=2,l+=2);return t},j.Vector.prototype.similarity=function(e){return this.dot(e)/this.magnitude()||0},j.Vector.prototype.toArray=function(){for(var e=new Array(this.elements.length/2),t=1,r=0;t<this.elements.length;t+=2,r++)e[r]=this.elements[t];return e},j.Vector.prototype.toJSON=function(){return this.elements},j.stemmer=(o={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},a={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},h="^("+(l="[^aeiou][^aeiouy]*")+")?"+(c=(u="[aeiouy]")+"[aeiou]*")+l+"("+c+")?$",d="^("+l+")?"+c+l+c+l,f="^("+l+")?"+u,p=new RegExp("^("+l+")?"+c+l),y=new RegExp(d),m=new RegExp(h),g=new RegExp(f),x=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,w=/^(.+?)eed$/,Q=/^(.+?)(ed|ing)$/,k=/.$/,S=/(at|bl|iz)$/,E=new RegExp("([^aeiouylsz])\\\\1$"),L=new RegExp("^"+l+u+"[^aeiouwxy]$"),P=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,T=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,O=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,I=/^(.+?)(s|t)(ion)$/,R=/^(.+?)e$/,F=/ll$/,C=new RegExp("^"+l+u+"[^aeiouwxy]$"),N=function(e){var t,r,n,i,s,u,l;if(e.length<3)return e;if("y"==(n=e.substr(0,1))&&(e=n.toUpperCase()+e.substr(1)),s=v,(i=x).test(e)?e=e.replace(i,"$1$2"):s.test(e)&&(e=e.replace(s,"$1$2")),s=Q,(i=w).test(e)){var c=i.exec(e);(i=p).test(c[1])&&(i=k,e=e.replace(i,""))}else s.test(e)&&(t=(c=s.exec(e))[1],(s=g).test(t)&&(u=E,l=L,(s=S).test(e=t)?e+="e":u.test(e)?(i=k,e=e.replace(i,"")):l.test(e)&&(e+="e")));return(i=P).test(e)&&(e=(t=(c=i.exec(e))[1])+"i"),(i=b).test(e)&&(t=(c=i.exec(e))[1],r=c[2],(i=p).test(t)&&(e=t+o[r])),(i=T).test(e)&&(t=(c=i.exec(e))[1],r=c[2],(i=p).test(t)&&(e=t+a[r])),s=I,(i=O).test(e)?(t=(c=i.exec(e))[1],(i=y).test(t)&&(e=t)):s.test(e)&&(t=(c=s.exec(e))[1]+c[2],(s=y).test(t)&&(e=t)),(i=R).test(e)&&(t=(c=i.exec(e))[1],s=m,u=C,((i=y).test(t)||s.test(t)&&!u.test(t))&&(e=t)),s=y,(i=F).test(e)&&s.test(e)&&(i=k,e=e.replace(i,"")),"y"==n&&(e=n.toLowerCase()+e.substr(1)),e},function(e){return e.update(N)}),j.Pipeline.registerFunction(j.stemmer,"stemmer"),j.generateStopWordFilter=function(e){var t=e.reduce((function(e,t){return e[t]=t,e}),{});return function(e){if(e&&t[e.toString()]!==e.toString())return e}},j.stopWordFilter=j.generateStopWordFilter(["a","able","about","across","after","all","almost","also","am","among","an","and","any","are","as","at","be","because","been","but","by","can","cannot","could","dear","did","do","does","either","else","ever","every","for","from","get","got","had","has","have","he","her","hers","him","his","how","however","i","if","in","into","is","it","its","just","least","let","like","likely","may","me","might","most","must","my","neither","no","nor","not","of","off","often","on","only","or","other","our","own","rather","said","say","says","she","should","since","so","some","than","that","the","their","them","then","there","these","they","this","tis","to","too","twas","us","wants","was","we","were","what","when","where","which","while","who","whom","why","will","with","would","yet","you","your"]),j.Pipeline.registerFunction(j.stopWordFilter,"stopWordFilter"),j.trimmer=function(e){return e.update((function(e){return e.replace(/^\\W+/,"").replace(/\\W+$/,"")}))},j.Pipeline.registerFunction(j.trimmer,"trimmer"),j.TokenSet=function(){this.final=!1,this.edges={},this.id=j.TokenSet._nextId,j.TokenSet._nextId+=1},j.TokenSet._nextId=1,j.TokenSet.fromArray=function(e){for(var t=new j.TokenSet.Builder,r=0,n=e.length;r<n;r++)t.insert(e[r]);return t.finish(),t.root},j.TokenSet.fromClause=function(e){return"editDistance"in e?j.TokenSet.fromFuzzyString(e.term,e.editDistance):j.TokenSet.fromString(e.term)},j.TokenSet.fromFuzzyString=function(e,t){for(var r=new j.TokenSet,n=[{node:r,editsRemaining:t,str:e}];n.length;){var i=n.pop();if(i.str.length>0){var s,o=i.str.charAt(0);o in i.node.edges?s=i.node.edges[o]:(s=new j.TokenSet,i.node.edges[o]=s),1==i.str.length&&(s.final=!0),n.push({node:s,editsRemaining:i.editsRemaining,str:i.str.slice(1)})}if(0!=i.editsRemaining){if("*"in i.node.edges)var a=i.node.edges["*"];else a=new j.TokenSet,i.node.edges["*"]=a;if(0==i.str.length&&(a.final=!0),n.push({node:a,editsRemaining:i.editsRemaining-1,str:i.str}),i.str.length>1&&n.push({node:i.node,editsRemaining:i.editsRemaining-1,str:i.str.slice(1)}),1==i.str.length&&(i.node.final=!0),i.str.length>=1){if("*"in i.node.edges)var u=i.node.edges["*"];else u=new j.TokenSet,i.node.edges["*"]=u;1==i.str.length&&(u.final=!0),n.push({node:u,editsRemaining:i.editsRemaining-1,str:i.str.slice(1)})}if(i.str.length>1){var l,c=i.str.charAt(0),h=i.str.charAt(1);h in i.node.edges?l=i.node.edges[h]:(l=new j.TokenSet,i.node.edges[h]=l),1==i.str.length&&(l.final=!0),n.push({node:l,editsRemaining:i.editsRemaining-1,str:c+i.str.slice(2)})}}}return r},j.TokenSet.fromString=function(e){for(var t=new j.TokenSet,r=t,n=0,i=e.length;n<i;n++){var s=e[n],o=n==i-1;if("*"==s)t.edges[s]=t,t.final=o;else{var a=new j.TokenSet;a.final=o,t.edges[s]=a,t=a}}return r},j.TokenSet.prototype.toArray=function(){for(var e=[],t=[{prefix:"",node:this}];t.length;){var r=t.pop(),n=Object.keys(r.node.edges),i=n.length;r.node.final&&(r.prefix.charAt(0),e.push(r.prefix));for(var s=0;s<i;s++){var o=n[s];t.push({prefix:r.prefix.concat(o),node:r.node.edges[o]})}}return e},j.TokenSet.prototype.toString=function(){if(this._str)return this._str;for(var e=this.final?"1":"0",t=Object.keys(this.edges).sort(),r=t.length,n=0;n<r;n++){var i=t[n];e=e+i+this.edges[i].id}return e},j.TokenSet.prototype.intersect=function(e){for(var t=new j.TokenSet,r=void 0,n=[{qNode:e,output:t,node:this}];n.length;){r=n.pop();for(var i=Object.keys(r.qNode.edges),s=i.length,o=Object.keys(r.node.edges),a=o.length,u=0;u<s;u++)for(var l=i[u],c=0;c<a;c++){var h=o[c];if(h==l||"*"==l){var d=r.node.edges[h],f=r.qNode.edges[l],p=d.final&&f.final,y=void 0;h in r.output.edges?(y=r.output.edges[h]).final=y.final||p:((y=new j.TokenSet).final=p,r.output.edges[h]=y),n.push({qNode:f,output:y,node:d})}}}return t},j.TokenSet.Builder=function(){this.previousWord="",this.root=new j.TokenSet,this.uncheckedNodes=[],this.minimizedNodes={}},j.TokenSet.Builder.prototype.insert=function(e){var t,r=0;if(e<this.previousWord)throw new Error("Out of order word insertion");for(var n=0;n<e.length&&n<this.previousWord.length&&e[n]==this.previousWord[n];n++)r++;for(this.minimize(r),t=0==this.uncheckedNodes.length?this.root:this.uncheckedNodes[this.uncheckedNodes.length-1].child,n=r;n<e.length;n++){var i=new j.TokenSet,s=e[n];t.edges[s]=i,this.uncheckedNodes.push({parent:t,char:s,child:i}),t=i}t.final=!0,this.previousWord=e},j.TokenSet.Builder.prototype.finish=function(){this.minimize(0)},j.TokenSet.Builder.prototype.minimize=function(e){for(var t=this.uncheckedNodes.length-1;t>=e;t--){var r=this.uncheckedNodes[t],n=r.child.toString();n in this.minimizedNodes?r.parent.edges[r.char]=this.minimizedNodes[n]:(r.child._str=n,this.minimizedNodes[n]=r.child),this.uncheckedNodes.pop()}},j.Index=function(e){this.invertedIndex=e.invertedIndex,this.fieldVectors=e.fieldVectors,this.tokenSet=e.tokenSet,this.fields=e.fields,this.pipeline=e.pipeline},j.Index.prototype.search=function(e){return this.query((function(t){new j.QueryParser(e,t).parse()}))},j.Index.prototype.query=function(e){for(var t=new j.Query(this.fields),r=Object.create(null),n=Object.create(null),i=Object.create(null),s=Object.create(null),o=Object.create(null),a=0;a<this.fields.length;a++)n[this.fields[a]]=new j.Vector;for(e.call(t,t),a=0;a<t.clauses.length;a++){var u,l=t.clauses[a],c=j.Set.empty;u=l.usePipeline?this.pipeline.runString(l.term,{fields:l.fields}):[l.term];for(var h=0;h<u.length;h++){var d=u[h];l.term=d;var f=j.TokenSet.fromClause(l),p=this.tokenSet.intersect(f).toArray();if(0===p.length&&l.presence===j.Query.presence.REQUIRED){for(var y=0;y<l.fields.length;y++)s[R=l.fields[y]]=j.Set.empty;break}for(var m=0;m<p.length;m++){var g=p[m],x=this.invertedIndex[g],v=x._index;for(y=0;y<l.fields.length;y++){var w=x[R=l.fields[y]],Q=Object.keys(w),k=g+"/"+R,S=new j.Set(Q);if(l.presence==j.Query.presence.REQUIRED&&(c=c.union(S),void 0===s[R]&&(s[R]=j.Set.complete)),l.presence!=j.Query.presence.PROHIBITED){if(n[R].upsert(v,l.boost,(function(e,t){return e+t})),!i[k]){for(var E=0;E<Q.length;E++){var L,P=Q[E],b=new j.FieldRef(P,R),T=w[P];void 0===(L=r[b])?r[b]=new j.MatchData(g,R,T):L.add(g,R,T)}i[k]=!0}}else void 0===o[R]&&(o[R]=j.Set.empty),o[R]=o[R].union(S)}}}if(l.presence===j.Query.presence.REQUIRED)for(y=0;y<l.fields.length;y++)s[R=l.fields[y]]=s[R].intersect(c)}var O=j.Set.complete,I=j.Set.empty;for(a=0;a<this.fields.length;a++){var R;s[R=this.fields[a]]&&(O=O.intersect(s[R])),o[R]&&(I=I.union(o[R]))}var F=Object.keys(r),C=[],N=Object.create(null);if(t.isNegated())for(F=Object.keys(this.fieldVectors),a=0;a<F.length;a++){b=F[a];var _=j.FieldRef.fromString(b);r[b]=new j.MatchData}for(a=0;a<F.length;a++){var D=(_=j.FieldRef.fromString(F[a])).docRef;if(O.contains(D)&&!I.contains(D)){var A,B=this.fieldVectors[_],z=n[_.fieldName].similarity(B);if(void 0!==(A=N[D]))A.score+=z,A.matchData.combine(r[_]);else{var V={ref:D,score:z,matchData:r[_]};N[D]=V,C.push(V)}}}return C.sort((function(e,t){return t.score-e.score}))},j.Index.prototype.toJSON=function(){var e=Object.keys(this.invertedIndex).sort().map((function(e){return[e,this.invertedIndex[e]]}),this),t=Object.keys(this.fieldVectors).map((function(e){return[e,this.fieldVectors[e].toJSON()]}),this);return{version:j.version,fields:this.fields,fieldVectors:t,invertedIndex:e,pipeline:this.pipeline.toJSON()}},j.Index.load=function(e){var t={},r={},n=e.fieldVectors,i=Object.create(null),s=e.invertedIndex,o=new j.TokenSet.Builder,a=j.Pipeline.load(e.pipeline);e.version!=j.version&&j.utils.warn("Version mismatch when loading serialised index. Current version of lunr '"+j.version+"' does not match serialized index '"+e.version+"'");for(var u=0;u<n.length;u++){var l=(h=n[u])[0],c=h[1];r[l]=new j.Vector(c)}for(u=0;u<s.length;u++){var h,d=(h=s[u])[0],f=h[1];o.insert(d),i[d]=f}return o.finish(),t.fields=e.fields,t.fieldVectors=r,t.invertedIndex=i,t.tokenSet=o.root,t.pipeline=a,new j.Index(t)},j.Builder=function(){this._ref="id",this._fields=Object.create(null),this._documents=Object.create(null),this.invertedIndex=Object.create(null),this.fieldTermFrequencies={},this.fieldLengths={},this.tokenizer=j.tokenizer,this.pipeline=new j.Pipeline,this.searchPipeline=new j.Pipeline,this.documentCount=0,this._b=.75,this._k1=1.2,this.termIndex=0,this.metadataWhitelist=[]},j.Builder.prototype.ref=function(e){this._ref=e},j.Builder.prototype.field=function(e,t){if(/\\//.test(e))throw new RangeError("Field '"+e+"' contains illegal character '/'");this._fields[e]=t||{}},j.Builder.prototype.b=function(e){this._b=e<0?0:e>1?1:e},j.Builder.prototype.k1=function(e){this._k1=e},j.Builder.prototype.add=function(e,t){var r=e[this._ref],n=Object.keys(this._fields);this._documents[r]=t||{},this.documentCount+=1;for(var i=0;i<n.length;i++){var s=n[i],o=this._fields[s].extractor,a=o?o(e):e[s],u=this.tokenizer(a,{fields:[s]}),l=this.pipeline.run(u),c=new j.FieldRef(r,s),h=Object.create(null);this.fieldTermFrequencies[c]=h,this.fieldLengths[c]=0,this.fieldLengths[c]+=l.length;for(var d=0;d<l.length;d++){var f=l[d];if(null==h[f]&&(h[f]=0),h[f]+=1,null==this.invertedIndex[f]){var p=Object.create(null);p._index=this.termIndex,this.termIndex+=1;for(var y=0;y<n.length;y++)p[n[y]]=Object.create(null);this.invertedIndex[f]=p}null==this.invertedIndex[f][s][r]&&(this.invertedIndex[f][s][r]=Object.create(null));for(var m=0;m<this.metadataWhitelist.length;m++){var g=this.metadataWhitelist[m],x=f.metadata[g];null==this.invertedIndex[f][s][r][g]&&(this.invertedIndex[f][s][r][g]=[]),this.invertedIndex[f][s][r][g].push(x)}}}},j.Builder.prototype.calculateAverageFieldLengths=function(){for(var e=Object.keys(this.fieldLengths),t=e.length,r={},n={},i=0;i<t;i++){var s=j.FieldRef.fromString(e[i]),o=s.fieldName;n[o]||(n[o]=0),n[o]+=1,r[o]||(r[o]=0),r[o]+=this.fieldLengths[s]}var a=Object.keys(this._fields);for(i=0;i<a.length;i++){var u=a[i];r[u]=r[u]/n[u]}this.averageFieldLength=r},j.Builder.prototype.createFieldVectors=function(){for(var e={},t=Object.keys(this.fieldTermFrequencies),r=t.length,n=Object.create(null),i=0;i<r;i++){for(var s=j.FieldRef.fromString(t[i]),o=s.fieldName,a=this.fieldLengths[s],u=new j.Vector,l=this.fieldTermFrequencies[s],c=Object.keys(l),h=c.length,d=this._fields[o].boost||1,f=this._documents[s.docRef].boost||1,p=0;p<h;p++){var y,m,g,x=c[p],v=l[x],w=this.invertedIndex[x]._index;void 0===n[x]?(y=j.idf(this.invertedIndex[x],this.documentCount),n[x]=y):y=n[x],m=y*((this._k1+1)*v)/(this._k1*(1-this._b+this._b*(a/this.averageFieldLength[o]))+v),m*=d,m*=f,g=Math.round(1e3*m)/1e3,u.insert(w,g)}e[s]=u}this.fieldVectors=e},j.Builder.prototype.createTokenSet=function(){this.tokenSet=j.TokenSet.fromArray(Object.keys(this.invertedIndex).sort())},j.Builder.prototype.build=function(){return this.calculateAverageFieldLengths(),this.createFieldVectors(),this.createTokenSet(),new j.Index({invertedIndex:this.invertedIndex,fieldVectors:this.fieldVectors,tokenSet:this.tokenSet,fields:Object.keys(this._fields),pipeline:this.searchPipeline})},j.Builder.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},j.MatchData=function(e,t,r){for(var n=Object.create(null),i=Object.keys(r||{}),s=0;s<i.length;s++){var o=i[s];n[o]=r[o].slice()}this.metadata=Object.create(null),void 0!==e&&(this.metadata[e]=Object.create(null),this.metadata[e][t]=n)},j.MatchData.prototype.combine=function(e){for(var t=Object.keys(e.metadata),r=0;r<t.length;r++){var n=t[r],i=Object.keys(e.metadata[n]);null==this.metadata[n]&&(this.metadata[n]=Object.create(null));for(var s=0;s<i.length;s++){var o=i[s],a=Object.keys(e.metadata[n][o]);null==this.metadata[n][o]&&(this.metadata[n][o]=Object.create(null));for(var u=0;u<a.length;u++){var l=a[u];null==this.metadata[n][o][l]?this.metadata[n][o][l]=e.metadata[n][o][l]:this.metadata[n][o][l]=this.metadata[n][o][l].concat(e.metadata[n][o][l])}}}},j.MatchData.prototype.add=function(e,t,r){if(!(e in this.metadata))return this.metadata[e]=Object.create(null),void(this.metadata[e][t]=r);if(t in this.metadata[e])for(var n=Object.keys(r),i=0;i<n.length;i++){var s=n[i];s in this.metadata[e][t]?this.metadata[e][t][s]=this.metadata[e][t][s].concat(r[s]):this.metadata[e][t][s]=r[s]}else this.metadata[e][t]=r},j.Query=function(e){this.clauses=[],this.allFields=e},j.Query.wildcard=new String("*"),j.Query.wildcard.NONE=0,j.Query.wildcard.LEADING=1,j.Query.wildcard.TRAILING=2,j.Query.presence={OPTIONAL:1,REQUIRED:2,PROHIBITED:3},j.Query.prototype.clause=function(e){return"fields"in e||(e.fields=this.allFields),"boost"in e||(e.boost=1),"usePipeline"in e||(e.usePipeline=!0),"wildcard"in e||(e.wildcard=j.Query.wildcard.NONE),e.wildcard&j.Query.wildcard.LEADING&&e.term.charAt(0)!=j.Query.wildcard&&(e.term="*"+e.term),e.wildcard&j.Query.wildcard.TRAILING&&e.term.slice(-1)!=j.Query.wildcard&&(e.term=e.term+"*"),"presence"in e||(e.presence=j.Query.presence.OPTIONAL),this.clauses.push(e),this},j.Query.prototype.isNegated=function(){for(var e=0;e<this.clauses.length;e++)if(this.clauses[e].presence!=j.Query.presence.PROHIBITED)return!1;return!0},j.Query.prototype.term=function(e,t){if(Array.isArray(e))return e.forEach((function(e){this.term(e,j.utils.clone(t))}),this),this;var r=t||{};return r.term=e.toString(),this.clause(r),this},j.QueryParseError=function(e,t,r){this.name="QueryParseError",this.message=e,this.start=t,this.end=r},j.QueryParseError.prototype=new Error,j.QueryLexer=function(e){this.lexemes=[],this.str=e,this.length=e.length,this.pos=0,this.start=0,this.escapeCharPositions=[]},j.QueryLexer.prototype.run=function(){for(var e=j.QueryLexer.lexText;e;)e=e(this)},j.QueryLexer.prototype.sliceString=function(){for(var e=[],t=this.start,r=this.pos,n=0;n<this.escapeCharPositions.length;n++)r=this.escapeCharPositions[n],e.push(this.str.slice(t,r)),t=r+1;return e.push(this.str.slice(t,this.pos)),this.escapeCharPositions.length=0,e.join("")},j.QueryLexer.prototype.emit=function(e){this.lexemes.push({type:e,str:this.sliceString(),start:this.start,end:this.pos}),this.start=this.pos},j.QueryLexer.prototype.escapeCharacter=function(){this.escapeCharPositions.push(this.pos-1),this.pos+=1},j.QueryLexer.prototype.next=function(){if(this.pos>=this.length)return j.QueryLexer.EOS;var e=this.str.charAt(this.pos);return this.pos+=1,e},j.QueryLexer.prototype.width=function(){return this.pos-this.start},j.QueryLexer.prototype.ignore=function(){this.start==this.pos&&(this.pos+=1),this.start=this.pos},j.QueryLexer.prototype.backup=function(){this.pos-=1},j.QueryLexer.prototype.acceptDigitRun=function(){var e,t;do{t=(e=this.next()).charCodeAt(0)}while(t>47&&t<58);e!=j.QueryLexer.EOS&&this.backup()},j.QueryLexer.prototype.more=function(){return this.pos<this.length},j.QueryLexer.EOS="EOS",j.QueryLexer.FIELD="FIELD",j.QueryLexer.TERM="TERM",j.QueryLexer.EDIT_DISTANCE="EDIT_DISTANCE",j.QueryLexer.BOOST="BOOST",j.QueryLexer.PRESENCE="PRESENCE",j.QueryLexer.lexField=function(e){return e.backup(),e.emit(j.QueryLexer.FIELD),e.ignore(),j.QueryLexer.lexText},j.QueryLexer.lexTerm=function(e){if(e.width()>1&&(e.backup(),e.emit(j.QueryLexer.TERM)),e.ignore(),e.more())return j.QueryLexer.lexText},j.QueryLexer.lexEditDistance=function(e){return e.ignore(),e.acceptDigitRun(),e.emit(j.QueryLexer.EDIT_DISTANCE),j.QueryLexer.lexText},j.QueryLexer.lexBoost=function(e){return e.ignore(),e.acceptDigitRun(),e.emit(j.QueryLexer.BOOST),j.QueryLexer.lexText},j.QueryLexer.lexEOS=function(e){e.width()>0&&e.emit(j.QueryLexer.TERM)},j.QueryLexer.termSeparator=j.tokenizer.separator,j.QueryLexer.lexText=function(e){for(;;){var t=e.next();if(t==j.QueryLexer.EOS)return j.QueryLexer.lexEOS;if(92!=t.charCodeAt(0)){if(":"==t)return j.QueryLexer.lexField;if("~"==t)return e.backup(),e.width()>0&&e.emit(j.QueryLexer.TERM),j.QueryLexer.lexEditDistance;if("^"==t)return e.backup(),e.width()>0&&e.emit(j.QueryLexer.TERM),j.QueryLexer.lexBoost;if("+"==t&&1===e.width())return e.emit(j.QueryLexer.PRESENCE),j.QueryLexer.lexText;if("-"==t&&1===e.width())return e.emit(j.QueryLexer.PRESENCE),j.QueryLexer.lexText;if(t.match(j.QueryLexer.termSeparator))return j.QueryLexer.lexTerm}else e.escapeCharacter()}},j.QueryParser=function(e,t){this.lexer=new j.QueryLexer(e),this.query=t,this.currentClause={},this.lexemeIdx=0},j.QueryParser.prototype.parse=function(){this.lexer.run(),this.lexemes=this.lexer.lexemes;for(var e=j.QueryParser.parseClause;e;)e=e(this);return this.query},j.QueryParser.prototype.peekLexeme=function(){return this.lexemes[this.lexemeIdx]},j.QueryParser.prototype.consumeLexeme=function(){var e=this.peekLexeme();return this.lexemeIdx+=1,e},j.QueryParser.prototype.nextClause=function(){var e=this.currentClause;this.query.clause(e),this.currentClause={}},j.QueryParser.parseClause=function(e){var t=e.peekLexeme();if(null!=t)switch(t.type){case j.QueryLexer.PRESENCE:return j.QueryParser.parsePresence;case j.QueryLexer.FIELD:return j.QueryParser.parseField;case j.QueryLexer.TERM:return j.QueryParser.parseTerm;default:var r="expected either a field or a term, found "+t.type;throw t.str.length>=1&&(r+=" with value '"+t.str+"'"),new j.QueryParseError(r,t.start,t.end)}},j.QueryParser.parsePresence=function(e){var t=e.consumeLexeme();if(null!=t){switch(t.str){case"-":e.currentClause.presence=j.Query.presence.PROHIBITED;break;case"+":e.currentClause.presence=j.Query.presence.REQUIRED;break;default:var r="unrecognised presence operator'"+t.str+"'";throw new j.QueryParseError(r,t.start,t.end)}var n=e.peekLexeme();if(null==n)throw r="expecting term or field, found nothing",new j.QueryParseError(r,t.start,t.end);switch(n.type){case j.QueryLexer.FIELD:return j.QueryParser.parseField;case j.QueryLexer.TERM:return j.QueryParser.parseTerm;default:throw r="expecting term or field, found '"+n.type+"'",new j.QueryParseError(r,n.start,n.end)}}},j.QueryParser.parseField=function(e){var t=e.consumeLexeme();if(null!=t){if(-1==e.query.allFields.indexOf(t.str)){var r=e.query.allFields.map((function(e){return"'"+e+"'"})).join(", "),n="unrecognised field '"+t.str+"', possible fields: "+r;throw new j.QueryParseError(n,t.start,t.end)}e.currentClause.fields=[t.str];var i=e.peekLexeme();if(null==i)throw n="expecting term, found nothing",new j.QueryParseError(n,t.start,t.end);if(i.type===j.QueryLexer.TERM)return j.QueryParser.parseTerm;throw n="expecting term, found '"+i.type+"'",new j.QueryParseError(n,i.start,i.end)}},j.QueryParser.parseTerm=function(e){var t=e.consumeLexeme();if(null!=t){e.currentClause.term=t.str.toLowerCase(),-1!=t.str.indexOf("*")&&(e.currentClause.usePipeline=!1);var r=e.peekLexeme();if(null!=r)switch(r.type){case j.QueryLexer.TERM:return e.nextClause(),j.QueryParser.parseTerm;case j.QueryLexer.FIELD:return e.nextClause(),j.QueryParser.parseField;case j.QueryLexer.EDIT_DISTANCE:return j.QueryParser.parseEditDistance;case j.QueryLexer.BOOST:return j.QueryParser.parseBoost;case j.QueryLexer.PRESENCE:return e.nextClause(),j.QueryParser.parsePresence;default:var n="Unexpected lexeme type '"+r.type+"'";throw new j.QueryParseError(n,r.start,r.end)}else e.nextClause()}},j.QueryParser.parseEditDistance=function(e){var t=e.consumeLexeme();if(null!=t){var r=parseInt(t.str,10);if(isNaN(r)){var n="edit distance must be numeric";throw new j.QueryParseError(n,t.start,t.end)}e.currentClause.editDistance=r;var i=e.peekLexeme();if(null!=i)switch(i.type){case j.QueryLexer.TERM:return e.nextClause(),j.QueryParser.parseTerm;case j.QueryLexer.FIELD:return e.nextClause(),j.QueryParser.parseField;case j.QueryLexer.EDIT_DISTANCE:return j.QueryParser.parseEditDistance;case j.QueryLexer.BOOST:return j.QueryParser.parseBoost;case j.QueryLexer.PRESENCE:return e.nextClause(),j.QueryParser.parsePresence;default:throw n="Unexpected lexeme type '"+i.type+"'",new j.QueryParseError(n,i.start,i.end)}else e.nextClause()}},j.QueryParser.parseBoost=function(e){var t=e.consumeLexeme();if(null!=t){var r=parseInt(t.str,10);if(isNaN(r)){var n="boost must be numeric";throw new j.QueryParseError(n,t.start,t.end)}e.currentClause.boost=r;var i=e.peekLexeme();if(null!=i)switch(i.type){case j.QueryLexer.TERM:return e.nextClause(),j.QueryParser.parseTerm;case j.QueryLexer.FIELD:return e.nextClause(),j.QueryParser.parseField;case j.QueryLexer.EDIT_DISTANCE:return j.QueryParser.parseEditDistance;case j.QueryLexer.BOOST:return j.QueryParser.parseBoost;case j.QueryLexer.PRESENCE:return e.nextClause(),j.QueryParser.parsePresence;default:throw n="Unexpected lexeme type '"+i.type+"'",new j.QueryParseError(n,i.start,i.end)}else e.nextClause()}},void 0===(i="function"==typeof(n=function(){return j})?n.call(t,r,t,e):n)||(e.exports=i)}()}},t={};function r(n){var i=t[n];if(void 0!==i)return i.exports;var s=t[n]={exports:{}};return e[n](s,s.exports,r),s.exports}r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,{a:t}),t},r.d=function(e,t){for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)};var n={};!function(){"use strict";r.d(n,{add:function(){return c},dispose:function(){return y},done:function(){return h},fromExternalJS:function(){return f},load:function(){return p},search:function(){return m},toJS:function(){return d}});var e=r(336),t=(e,t,r)=>new Promise(((n,i)=>{var s=e=>{try{a(r.next(e))}catch(e){i(e)}},o=e=>{try{a(r.throw(e))}catch(e){i(e)}},a=e=>e.done?n(e.value):Promise.resolve(e.value).then(s,o);a((r=r.apply(e,t)).next())}));let i,s,o,a=[];function u(){i=new e.Builder,i.field("title"),i.field("description"),i.ref("ref"),i.pipeline.add(e.trimmer,e.stopWordFilter,e.stemmer),o=new Promise((e=>{s=e}))}e.tokenizer.separator=/\\s+/,u();const l=t=>{const r=e.trimmer(new e.Token(t,{}));return"*"+e.stemmer(r)+"*"};function c(e,t,r){const n=a.push(r)-1,s={title:e.toLowerCase(),description:t.toLowerCase(),ref:n};i.add(s)}function h(){return t(this,null,(function*(){s(i.build())}))}function d(){return t(this,null,(function*(){return{store:a,index:(yield o).toJSON()}}))}function f(e,r){return t(this,null,(function*(){try{if(importScripts(e),!self[r])throw new Error("Broken index file format");p(self[r])}catch(e){console.error("Failed to load search index: "+e.message)}}))}function p(r){return t(this,null,(function*(){a=r.store,s(e.Index.load(r.index))}))}function y(){return t(this,null,(function*(){a=[],u()}))}function m(e,r=0){return t(this,null,(function*(){if(0===e.trim().length)return[];let t=(yield o).query((t=>{e.trim().toLowerCase().split(/\\s+/).forEach((e=>{if(1===e.length)return;const r=l(e);t.term(r,{})}))}));return r>0&&(t=t.slice(0,r)),t.map((e=>({meta:a[e.ref],score:e.score})))}))}addEventListener("message",(function(e){var t,r=e.data,i=r.type,s=r.method,o=r.id,a=r.params;"RPC"===i&&s&&((t=n[s])?Promise.resolve().then((function(){return t.apply(n,a)})):Promise.reject("No such method")).then((function(e){postMessage({type:"RPC",id:o,result:e})})).catch((function(e){var t={message:e};e.stack&&(t.message=e.message,t.stack=e.stack,t.name=e.name),postMessage({type:"RPC",id:o,error:t})}))})),postMessage({type:"RPC",method:"ready"})}()}();
//# sourceMappingURL=756674defce81e90acea.worker.js.map`])), { name: "[fullhash].worker.js" });
          return u(d, f), d;
        };
      }, 314: function(o) {
        o.exports = function(a, l) {
          var u = 0, f = {};
          a.addEventListener("message", function(d) {
            var m = d.data;
            if (m.type === "RPC") if (m.id) {
              var v = f[m.id];
              v && (delete f[m.id], m.error ? v[1](Object.assign(Error(m.error.message), m.error)) : v[0](m.result));
            } else {
              var S = document.createEvent("Event");
              S.initEvent(m.method, !1, !1), S.data = m.params, a.dispatchEvent(S);
            }
          }), l.forEach(function(d) {
            a[d] = function() {
              var m = arguments;
              return new Promise(function(v, S) {
                var y = ++u;
                f[y] = [v, S], a.postMessage({ type: "RPC", id: y, method: d, params: [].slice.call(m) });
              });
            };
          });
        };
      }, 766: function(o) {
        o.exports = B3();
      }, 376: function(o) {
        o.exports = U3();
      }, 322: function(o) {
        o.exports = V3();
      }, 66: function(o) {
        o.exports = n5();
      }, 416: function(o) {
        o.exports = void 0;
      }, 177: function() {
      }, 109: function(o) {
        o.exports = { i8: "7.0.8" };
      } }, n = {};
      function i(o) {
        var a = n[o];
        if (a !== void 0) return a.exports;
        var l = n[o] = { id: o, exports: {} };
        return r[o](l, l.exports, i), l.exports;
      }
      i.n = function(o) {
        var a = o && o.__esModule ? function() {
          return o.default;
        } : function() {
          return o;
        };
        return i.d(a, { a }), a;
      }, i.d = function(o, a) {
        for (var l in a) i.o(a, l) && !i.o(o, l) && Object.defineProperty(o, l, { enumerable: !0, get: a[l] });
      }, i.g = function() {
        if (typeof globalThis == "object") return globalThis;
        try {
          return this || new Function("return this")();
        } catch {
          if (typeof window == "object") return window;
        }
      }(), i.o = function(o, a) {
        return Object.prototype.hasOwnProperty.call(o, a);
      }, i.r = function(o) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(o, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(o, "__esModule", { value: !0 });
      }, i.nc = void 0;
      var s = {};
      return function() {
        i.r(s), i.d(s, { AUTH_TYPES: function() {
          return $f;
        }, ApiContentWrap: function() {
          return w_;
        }, ApiInfo: function() {
          return If;
        }, ApiInfoModel: function() {
          return B1;
        }, ApiLogo: function() {
          return Nf;
        }, AppStore: function() {
          return Ha;
        }, ArraySchema: function() {
          return _E;
        }, BackgroundStub: function() {
          return S_;
        }, BodyContent: function() {
          return GE;
        }, COMPONENT_REGEXP: function() {
          return gy;
        }, CallbackModel: function() {
          return tf;
        }, ClipboardService: function() {
          return Gi;
        }, ContentItem: function() {
          return Bf;
        }, ContentItems: function() {
          return Lu;
        }, DiscriminatorDropdown: function() {
          return _f;
        }, Dropdown: function() {
          return mf;
        }, DropdownLabel: function() {
          return vf;
        }, DropdownOrLabel: function() {
          return Va;
        }, DropdownWrapper: function() {
          return bf;
        }, ErrorBoundary: function() {
          return ge;
        }, Example: function() {
          return Iy;
        }, ExampleModel: function() {
          return za;
        }, ExternalExample: function() {
          return nE;
        }, FieldModel: function() {
          return ln;
        }, GROUP_DEPTH: function() {
          return cf;
        }, GroupModel: function() {
          return Wn;
        }, HistoryService: function() {
          return Ma;
        }, IS_BROWSER: function() {
          return f;
        }, InvertedSimpleDropdown: function() {
          return wf;
        }, JsonPointer: function() {
          return rt;
        }, JsonViewer: function() {
          return eE;
        }, LEGACY_REGEXP: function() {
          return z1;
        }, Loading: function() {
          return Ve;
        }, MDX_COMPONENT_REGEXP: function() {
          return q1;
        }, Markdown: function() {
          return Dr;
        }, MarkdownRenderer: function() {
          return Da;
        }, MarkerService: function() {
          return Ge;
        }, MediaContentModel: function() {
          return qa;
        }, MediaTypeModel: function() {
          return wy;
        }, MediaTypesSwitch: function() {
          return Qa;
        }, MenuBuilder: function() {
          return vi;
        }, MenuItem: function() {
          return Mu;
        }, MenuItemLabel: function() {
          return Lf;
        }, MenuItemLi: function() {
          return qE;
        }, MenuItemTitle: function() {
          return By;
        }, MenuItemUl: function() {
          return zE;
        }, MenuItems: function() {
          return Du;
        }, MenuStore: function() {
          return Hi;
        }, MiddlePanel: function() {
          return No;
        }, MimeLabel: function() {
          return Ny;
        }, NoSampleLabel: function() {
          return iE;
        }, OLD_SECURITY_DEFINITIONS_JSX_NAME: function() {
          return Su;
        }, ObjectSchema: function() {
          return Of;
        }, OneOfButton: function() {
          return kf;
        }, OneOfSchema: function() {
          return Af;
        }, OpenAPIParser: function() {
          return Z1;
        }, Operation: function() {
          return c_;
        }, OperationBadge: function() {
          return ju;
        }, OperationItem: function() {
          return Vf;
        }, OperationMenuItemContent: function() {
          return m_;
        }, OperationModel: function() {
          return Mr;
        }, OptionsConsumer: function() {
          return Ot;
        }, OptionsContext: function() {
          return He;
        }, OptionsProvider: function() {
          return Ue;
        }, Parameters: function() {
          return Vy;
        }, PayloadSamples: function() {
          return Ya;
        }, Redoc: function() {
          return Ky;
        }, RedocAttribution: function() {
          return UE;
        }, RedocNormalizedOptions: function() {
          return X;
        }, RedocStandalone: function() {
          return pq;
        }, RedocWrap: function() {
          return b_;
        }, RequestBodyModel: function() {
          return ux;
        }, ResponseDetails: function() {
          return t_;
        }, ResponseHeaders: function() {
          return JE;
        }, ResponseModel: function() {
          return uf;
        }, ResponseSamples: function() {
          return zf;
        }, ResponseTitle: function() {
          return XE;
        }, ResponseView: function() {
          return r_;
        }, ResponsesList: function() {
          return Wy;
        }, RightPanel: function() {
          return Px;
        }, Row: function() {
          return Ns;
        }, SCHEMA_DEFINITION_JSX_NAME: function() {
          return As;
        }, SECTION_ATTR: function() {
          return Is;
        }, SECURITY_DEFINITIONS_JSX_NAME: function() {
          return Ia;
        }, SECURITY_SCHEMES_SECTION_PREFIX: function() {
          return hi;
        }, Schema: function() {
          return Xi;
        }, SchemaDefinition: function() {
          return Cf;
        }, SchemaModel: function() {
          return Au;
        }, ScrollService: function() {
          return Ey;
        }, SearchBox: function() {
          return Hf;
        }, SearchStore: function() {
          return Ax;
        }, Section: function() {
          return Pu;
        }, SectionItem: function() {
          return Uf;
        }, SecurityDefs: function() {
          return zy;
        }, SecuritySchemeModel: function() {
          return yx;
        }, SecuritySchemesModel: function() {
          return vx;
        }, SideMenu: function() {
          return Fu;
        }, SideNavStyleEnum: function() {
          return te;
        }, SimpleDropdown: function() {
          return Ux;
        }, SourceCode: function() {
          return tE;
        }, SourceCodeWithCopy: function() {
          return Ry;
        }, SpecStore: function() {
          return xx;
        }, StickyResponsiveSidebar: function() {
          return zu;
        }, StoreBuilder: function() {
          return Rx;
        }, StoreConsumer: function() {
          return $x;
        }, StoreContext: function() {
          return ff;
        }, StoreProvider: function() {
          return Cx;
        }, StyledMarkdownBlock: function() {
          return Wa;
        }, ThemeProvider: function() {
          return Se;
        }, Throttle: function() {
          return Wp;
        }, alphabeticallyByProp: function() {
          return ja;
        }, appendToMdHeading: function() {
          return P;
        }, argValueToBoolean: function() {
          return N;
        }, buildComponentComment: function() {
          return UM;
        }, concatRefStacks: function() {
          return sf;
        }, convertSwagger2OpenAPI: function() {
          return Be;
        }, createGlobalStyle: function() {
          return de;
        }, createStore: function() {
          return OF;
        }, css: function() {
          return ye;
        }, debugTime: function() {
          return tr;
        }, debugTimeEnd: function() {
          return $o;
        }, detectType: function() {
          return Ao;
        }, escapeHTMLAttrChars: function() {
          return ce;
        }, expandDefaultServerVariables: function() {
          return wu;
        }, extensionsHook: function() {
          return se;
        }, extractExtensions: function() {
          return Vi;
        }, flattenByProp: function() {
          return g;
        }, getBasePath: function() {
          return Y;
        }, getContentWithLegacyExamples: function() {
          return Ps;
        }, getDefinitionName: function() {
          return Ca;
        }, getOperationSummary: function() {
          return gu;
        }, getSerializedValue: function() {
          return zi;
        }, getStatusCodeType: function() {
          return Qt;
        }, highlight: function() {
          return xu;
        }, history: function() {
          return $s;
        }, html2Str: function() {
          return m;
        }, humanizeConstraints: function() {
          return ks;
        }, humanizeNumberRange: function() {
          return Bp;
        }, isAbsoluteUrl: function() {
          return L;
        }, isArray: function() {
          return G;
        }, isBoolean: function() {
          return ee;
        }, isFormUrlEncoded: function() {
          return Aa;
        }, isJsonLike: function() {
          return Po;
        }, isNamedDefinition: function() {
          return To;
        }, isNumeric: function() {
          return A;
        }, isObject: function() {
          return $;
        }, isOperationName: function() {
          return Yt;
        }, isPayloadSample: function() {
          return xy;
        }, isPrimitiveType: function() {
          return _s;
        }, isRedocExtension: function() {
          return Na;
        }, isStatusCode: function() {
          return mu;
        }, keyframes: function() {
          return Ce;
        }, langFromMime: function() {
          return qi;
        }, loadAndBundleSpec: function() {
          return $e;
        }, mapLang: function() {
          return Co;
        }, mapValues: function() {
          return x;
        }, mapWithLast: function() {
          return E;
        }, media: function() {
          return O;
        }, memoize: function() {
          return yi;
        }, menuItemDepth: function() {
          return BE;
        }, mergeObjects: function() {
          return k;
        }, mergeParams: function() {
          return Ui;
        }, mergeSimilarMediaTypes: function() {
          return bu;
        }, normalizeServers: function() {
          return Ra;
        }, pluralizeType: function() {
          return Up;
        }, pushRef: function() {
          return of;
        }, querySelector: function() {
          return d;
        }, removeQueryStringAndHash: function() {
          return le;
        }, resolveUrl: function() {
          return Q;
        }, safeSlugify: function() {
          return F;
        }, scrollIntoViewIfNeeded: function() {
          return v;
        }, serializeParameterValue: function() {
          return Ta;
        }, serializeParameterValueWithMime: function() {
          return qn;
        }, setSecuritySchemePrefix: function() {
          return Bn;
        }, shortenHTTPVerb: function() {
          return mi;
        }, sortByField: function() {
          return di;
        }, sortByRequired: function() {
          return Bi;
        }, stripTrailingSlash: function() {
          return b;
        }, styled: function() {
          return M;
        }, titleize: function() {
          return ae;
        }, unescapeHTMLChars: function() {
          return be;
        }, urlFormEncodePayload: function() {
          return Pa;
        }, useStore: function() {
          return Ix;
        } });
        var o = et, a = U6;
        const l = { spacing: { unit: 5, sectionHorizontal: ({ spacing: c }) => 8 * c.unit, sectionVertical: ({ spacing: c }) => 8 * c.unit }, breakpoints: { small: "50rem", medium: "75rem", large: "105rem" }, colors: { tonalOffset: 0.2, primary: { main: "#32329f", light: ({ colors: c }) => (0, a.lighten)(c.tonalOffset, c.primary.main), dark: ({ colors: c }) => (0, a.darken)(c.tonalOffset, c.primary.main), contrastText: ({ colors: c }) => (0, a.readableColor)(c.primary.main) }, success: { main: "#1d8127", light: ({ colors: c }) => (0, a.lighten)(2 * c.tonalOffset, c.success.main), dark: ({ colors: c }) => (0, a.darken)(c.tonalOffset, c.success.main), contrastText: ({ colors: c }) => (0, a.readableColor)(c.success.main) }, warning: { main: "#ffa500", light: ({ colors: c }) => (0, a.lighten)(c.tonalOffset, c.warning.main), dark: ({ colors: c }) => (0, a.darken)(c.tonalOffset, c.warning.main), contrastText: "#ffffff" }, error: { main: "#d41f1c", light: ({ colors: c }) => (0, a.lighten)(c.tonalOffset, c.error.main), dark: ({ colors: c }) => (0, a.darken)(c.tonalOffset, c.error.main), contrastText: ({ colors: c }) => (0, a.readableColor)(c.error.main) }, gray: { 50: "#FAFAFA", 100: "#F5F5F5" }, text: { primary: "#333333", secondary: ({ colors: c }) => (0, a.lighten)(c.tonalOffset, c.text.primary) }, border: { dark: "rgba(0,0,0, 0.1)", light: "#ffffff" }, responses: { success: { color: ({ colors: c }) => c.success.main, backgroundColor: ({ colors: c }) => (0, a.transparentize)(0.93, c.success.main), tabTextColor: ({ colors: c }) => c.responses.success.color }, error: { color: ({ colors: c }) => c.error.main, backgroundColor: ({ colors: c }) => (0, a.transparentize)(0.93, c.error.main), tabTextColor: ({ colors: c }) => c.responses.error.color }, redirect: { color: ({ colors: c }) => c.warning.main, backgroundColor: ({ colors: c }) => (0, a.transparentize)(0.9, c.responses.redirect.color), tabTextColor: ({ colors: c }) => c.responses.redirect.color }, info: { color: "#87ceeb", backgroundColor: ({ colors: c }) => (0, a.transparentize)(0.9, c.responses.info.color), tabTextColor: ({ colors: c }) => c.responses.info.color } }, http: { get: "#2F8132", post: "#186FAF", put: "#95507c", options: "#947014", patch: "#bf581d", delete: "#cc3333", basic: "#707070", link: "#07818F", head: "#A23DAD" } }, schema: { linesColor: (c) => (0, a.lighten)(c.colors.tonalOffset, (0, a.desaturate)(c.colors.tonalOffset, c.colors.primary.main)), defaultDetailsWidth: "75%", typeNameColor: (c) => c.colors.text.secondary, typeTitleColor: (c) => c.schema.typeNameColor, requireLabelColor: (c) => c.colors.error.main, labelsTextSize: "0.9em", nestingSpacing: "1em", nestedBackground: "#fafafa", arrow: { size: "1.1em", color: (c) => c.colors.text.secondary } }, typography: { fontSize: "14px", lineHeight: "1.5em", fontWeightRegular: "400", fontWeightBold: "600", fontWeightLight: "300", fontFamily: "Roboto, sans-serif", smoothing: "antialiased", optimizeSpeed: !0, headings: { fontFamily: "Montserrat, sans-serif", fontWeight: "400", lineHeight: "1.6em" }, code: { fontSize: "13px", fontFamily: "Courier, monospace", lineHeight: ({ typography: c }) => c.lineHeight, fontWeight: ({ typography: c }) => c.fontWeightRegular, color: "#e53935", backgroundColor: "rgba(38, 50, 56, 0.05)", wrap: !1 }, links: { color: ({ colors: c }) => c.primary.main, visited: ({ typography: c }) => c.links.color, hover: ({ typography: c }) => (0, a.lighten)(0.2, c.links.color), textDecoration: "auto", hoverTextDecoration: "auto" } }, sidebar: { width: "260px", backgroundColor: "#fafafa", textColor: "#333333", activeTextColor: (c) => c.sidebar.textColor !== l.sidebar.textColor ? c.sidebar.textColor : c.colors.primary.main, groupItems: { activeBackgroundColor: (c) => (0, a.darken)(0.1, c.sidebar.backgroundColor), activeTextColor: (c) => c.sidebar.activeTextColor, textTransform: "uppercase" }, level1Items: { activeBackgroundColor: (c) => (0, a.darken)(0.05, c.sidebar.backgroundColor), activeTextColor: (c) => c.sidebar.activeTextColor, textTransform: "none" }, arrow: { size: "1.5em", color: (c) => c.sidebar.textColor } }, logo: { maxHeight: ({ sidebar: c }) => c.width, maxWidth: ({ sidebar: c }) => c.width, gutter: "2px" }, rightPanel: { backgroundColor: "#263238", width: "40%", textColor: "#ffffff", servers: { overlay: { backgroundColor: "#fafafa", textColor: "#263238" }, url: { backgroundColor: "#fff" } } }, codeBlock: { backgroundColor: ({ rightPanel: c }) => (0, a.darken)(0.1, c.backgroundColor) }, fab: { backgroundColor: "#f2f2f2", color: "#0065FB" } };
        var u = l;
        const f = typeof window < "u" && "HTMLElement" in window;
        function d(c) {
          return typeof document < "u" ? document.querySelector(c) : null;
        }
        function m(c) {
          return c.split(/<[^>]+>/).map((p) => p.trim()).filter((p) => p.length > 0).join(" ");
        }
        function v(c, p = !0) {
          const h = c.parentNode;
          if (!h) return;
          const w = window.getComputedStyle(h, void 0), _ = parseInt(w.getPropertyValue("border-top-width"), 10), T = parseInt(w.getPropertyValue("border-left-width"), 10), R = c.offsetTop - h.offsetTop < h.scrollTop, W = c.offsetTop - h.offsetTop + c.clientHeight - _ > h.scrollTop + h.clientHeight, Z = c.offsetLeft - h.offsetLeft < h.scrollLeft, ne = c.offsetLeft - h.offsetLeft + c.clientWidth - T > h.scrollLeft + h.clientWidth, re = R && !W;
          (R || W) && p && (h.scrollTop = c.offsetTop - h.offsetTop - h.clientHeight / 2 - _ + c.clientHeight / 2), (Z || ne) && p && (h.scrollLeft = c.offsetLeft - h.offsetLeft - h.clientWidth / 2 - T + c.clientWidth / 2), (R || W || Z || ne) && !p && c.scrollIntoView(re);
        }
        var S = V6(), y = i.n(S);
        function E(c, p) {
          const h = [];
          for (let w = 0; w < c.length - 1; w++) h.push(p(c[w], !1));
          return c.length !== 0 && h.push(p(c[c.length - 1], !0)), h;
        }
        function x(c, p) {
          const h = {};
          for (const w in c) c.hasOwnProperty(w) && (h[w] = p(c[w], w, c));
          return h;
        }
        function g(c, p) {
          const h = [], w = (_) => {
            for (const T of _) h.push(T), T[p] && w(T[p]);
          };
          return w(c), h;
        }
        function b(c) {
          return c.endsWith("/") ? c.substring(0, c.length - 1) : c;
        }
        function A(c) {
          return !isNaN(parseFloat(c)) && isFinite(c);
        }
        function P(c, p, h) {
          const w = new RegExp(`(^|\\n)#\\s?${p}\\s*\\n`, "i"), _ = new RegExp(`((\\n|^)#\\s*${p}\\s*(\\n|$)(?:.|\\n)*?)(\\n#|$)`, "i");
          if (w.test(c)) return c.replace(_, `$1

${h}
$4`);
          {
            const T = c === "" || c.endsWith(`

`) ? "" : c.endsWith(`
`) ? `
` : `

`;
            return `${c}${T}# ${p}

${h}`;
          }
        }
        const k = (c, ...p) => {
          if (!p.length) return c;
          const h = p.shift();
          return h === void 0 ? c : (I(c) && I(h) && Object.keys(h).forEach((w) => {
            I(h[w]) ? (c[w] || (c[w] = {}), k(c[w], h[w])) : c[w] = h[w];
          }), k(c, ...p));
        }, $ = (c) => c !== null && typeof c == "object", I = (c) => $(c) && !G(c);
        function F(c) {
          return y()(c) || c.toString().toLowerCase().replace(/\s+/g, "-").replace(/&/g, "-and-").replace(/\--+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
        }
        function L(c) {
          return /(?:^[a-z][a-z0-9+.-]*:|\/\/)/i.test(c);
        }
        function Q(c, p) {
          let h;
          if (p.startsWith("//")) try {
            h = `${new URL(c).protocol || "https:"}${p}`;
          } catch {
            h = `https:${p}`;
          }
          else if (L(p)) h = p;
          else if (p.startsWith("/")) try {
            const w = new URL(c);
            w.pathname = p, h = w.href;
          } catch {
            h = p;
          }
          else h = b(c) + "/" + p;
          return b(h);
        }
        function Y(c) {
          try {
            return ue(c).pathname;
          } catch {
            return c;
          }
        }
        function ae(c) {
          return c.charAt(0).toUpperCase() + c.slice(1);
        }
        function le(c) {
          try {
            const p = ue(c);
            return p.search = "", p.hash = "", p.toString();
          } catch {
            return c;
          }
        }
        function ue(c) {
          return typeof URL > "u" ? new (i(416)).URL(c) : new URL(c);
        }
        function ce(c) {
          return c.replace(/["\\]/g, "\\$&");
        }
        function be(c) {
          return c.replace(/&#(\d+);/g, (p, h) => String.fromCharCode(parseInt(h, 10))).replace(/&amp;/g, "&").replace(/&quot;/g, '"');
        }
        function G(c) {
          return Array.isArray(c);
        }
        function ee(c) {
          return typeof c == "boolean";
        }
        const K = { enum: "Enum", enumSingleValue: "Value", enumArray: "Items", default: "Default", deprecated: "Deprecated", example: "Example", examples: "Examples", recursive: "Recursive", arrayOf: "Array of ", webhook: "Event", const: "Value", noResultsFound: "No results found", download: "Download", downloadSpecification: "Download OpenAPI specification", responses: "Responses", callbackResponses: "Callback responses", requestSamples: "Request samples", responseSamples: "Response samples" };
        function z(c, p) {
          return K[c];
        }
        var te = ((c) => (c.SummaryOnly = "summary-only", c.PathOnly = "path-only", c.IdOnly = "id-only", c))(te || {}), q = Object.defineProperty, j = Object.defineProperties, H = Object.getOwnPropertyDescriptors, B = Object.getOwnPropertySymbols, pe = Object.prototype.hasOwnProperty, he = Object.prototype.propertyIsEnumerable, Ae = (c, p, h) => p in c ? q(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h, C = (c, p) => {
          for (var h in p || (p = {})) pe.call(p, h) && Ae(c, h, p[h]);
          if (B) for (var h of B(p)) he.call(p, h) && Ae(c, h, p[h]);
          return c;
        };
        function N(c, p) {
          return c === void 0 ? p || !1 : typeof c == "string" ? c !== "false" : c;
        }
        function J(c) {
          return typeof c == "string" ? parseInt(c, 10) : typeof c == "number" ? c : void 0;
        }
        class X {
          static normalizeExpandResponses(p) {
            if (p === "all") return "all";
            if (typeof p == "string") {
              const h = {};
              return p.split(",").forEach((w) => {
                h[w.trim()] = !0;
              }), h;
            }
            return p !== void 0 && console.warn(`expandResponses must be a string but received value "${p}" of type ${typeof p}`), {};
          }
          static normalizeHideHostname(p) {
            return !!p;
          }
          static normalizeScrollYOffset(p) {
            if (typeof p == "string" && !A(p)) {
              const h = d(p);
              h || console.warn("scrollYOffset value is a selector to non-existing element. Using offset 0 by default");
              const w = h && h.getBoundingClientRect().bottom || 0;
              return () => w;
            }
            return typeof p == "number" || A(p) ? () => typeof p == "number" ? p : parseFloat(p) : typeof p == "function" ? () => {
              const h = p();
              return typeof h != "number" && console.warn(`scrollYOffset should return number but returned value "${h}" of type ${typeof h}`), h;
            } : (p !== void 0 && console.warn("Wrong value for scrollYOffset ReDoc option: should be string, number or function"), () => 0);
          }
          static normalizeShowExtensions(p) {
            if (p === void 0) return !1;
            if (p === "") return !0;
            if (typeof p != "string") return p;
            switch (p) {
              case "true":
                return !0;
              case "false":
                return !1;
              default:
                return p.split(",").map((h) => h.trim());
            }
          }
          static normalizeSideNavStyle(p) {
            const h = te.SummaryOnly;
            if (typeof p != "string") return h;
            switch (p) {
              case h:
                return p;
              case te.PathOnly:
                return te.PathOnly;
              case te.IdOnly:
                return te.IdOnly;
              default:
                return h;
            }
          }
          static normalizePayloadSampleIdx(p) {
            return typeof p == "number" ? Math.max(0, p) : typeof p == "string" && isFinite(p) ? parseInt(p, 10) : 0;
          }
          static normalizeJsonSampleExpandLevel(p) {
            return p === "all" ? 1 / 0 : isNaN(Number(p)) ? 2 : Math.ceil(Number(p));
          }
          static normalizeGeneratedPayloadSamplesMaxDepth(p) {
            return isNaN(Number(p)) ? 10 : Math.max(0, Number(p));
          }
          constructor(p, h = {}) {
            var w, _, T, R, W;
            const Z = (p = C(C({}, h), p)).theme && p.theme.extensionsHook;
            var ne, re;
            (w = p.theme) != null && w.menu && !((_ = p.theme) != null && _.sidebar) && (console.warn('Theme setting "menu" is deprecated. Rename to "sidebar"'), p.theme.sidebar = p.theme.menu), (T = p.theme) != null && T.codeSample && !((R = p.theme) != null && R.codeBlock) && (console.warn('Theme setting "codeSample" is deprecated. Rename to "codeBlock"'), p.theme.codeBlock = p.theme.codeSample), this.theme = function(me) {
              const Ie = {};
              let Fe = 0;
              const vt = (Pt, it) => {
                Object.keys(Pt).forEach((un) => {
                  const Qr = (it ? it + "." : "") + un, Jt = Pt[un];
                  typeof Jt == "function" ? Object.defineProperty(Pt, un, { get() {
                    if (!Ie[Qr]) {
                      if (Fe++, Fe > 1e3) throw new Error(`Theme probably contains circular dependency at ${Qr}: ${Jt.toString()}`);
                      Ie[Qr] = Jt(me);
                    }
                    return Ie[Qr];
                  }, enumerable: !0 }) : typeof Jt == "object" && vt(Jt, Qr);
                });
              };
              return vt(me, ""), JSON.parse(JSON.stringify(me));
            }(k({}, u, (ne = C({}, p.theme), j(ne, H({ extensionsHook: void 0 }))))), this.theme.extensionsHook = Z, re = p.labels, Object.assign(K, re), this.scrollYOffset = X.normalizeScrollYOffset(p.scrollYOffset), this.hideHostname = X.normalizeHideHostname(p.hideHostname), this.expandResponses = X.normalizeExpandResponses(p.expandResponses), this.requiredPropsFirst = N(p.requiredPropsFirst), this.sortPropsAlphabetically = N(p.sortPropsAlphabetically), this.sortEnumValuesAlphabetically = N(p.sortEnumValuesAlphabetically), this.sortOperationsAlphabetically = N(p.sortOperationsAlphabetically), this.sortTagsAlphabetically = N(p.sortTagsAlphabetically), this.nativeScrollbars = N(p.nativeScrollbars), this.pathInMiddlePanel = N(p.pathInMiddlePanel), this.untrustedSpec = N(p.untrustedSpec), this.hideDownloadButton = N(p.hideDownloadButton), this.downloadFileName = p.downloadFileName, this.downloadDefinitionUrl = p.downloadDefinitionUrl, this.disableSearch = N(p.disableSearch), this.onlyRequiredInSamples = N(p.onlyRequiredInSamples), this.showExtensions = X.normalizeShowExtensions(p.showExtensions), this.sideNavStyle = X.normalizeSideNavStyle(p.sideNavStyle), this.hideSingleRequestSampleTab = N(p.hideSingleRequestSampleTab), this.hideRequestPayloadSample = N(p.hideRequestPayloadSample), this.menuToggle = N(p.menuToggle, !0), this.jsonSampleExpandLevel = X.normalizeJsonSampleExpandLevel(p.jsonSampleExpandLevel), this.enumSkipQuotes = N(p.enumSkipQuotes), this.hideSchemaTitles = N(p.hideSchemaTitles), this.simpleOneOfTypeLabel = N(p.simpleOneOfTypeLabel), this.payloadSampleIdx = X.normalizePayloadSampleIdx(p.payloadSampleIdx), this.expandSingleSchemaField = N(p.expandSingleSchemaField), this.schemaExpansionLevel = function(me, Ie = 0) {
              return me === "all" ? 1 / 0 : J(me) || Ie;
            }(p.schemaExpansionLevel), this.showObjectSchemaExamples = N(p.showObjectSchemaExamples), this.showSecuritySchemeType = N(p.showSecuritySchemeType), this.hideSecuritySection = N(p.hideSecuritySection), this.unstable_ignoreMimeParameters = N(p.unstable_ignoreMimeParameters), this.allowedMdComponents = p.allowedMdComponents || {}, this.expandDefaultServerVariables = N(p.expandDefaultServerVariables), this.maxDisplayedEnumValues = J(p.maxDisplayedEnumValues);
            const ie = G(p.ignoreNamedSchemas) ? p.ignoreNamedSchemas : (W = p.ignoreNamedSchemas) == null ? void 0 : W.split(",").map((me) => me.trim());
            this.ignoreNamedSchemas = new Set(ie), this.hideSchemaPattern = N(p.hideSchemaPattern), this.generatedPayloadSamplesMaxDepth = X.normalizeGeneratedPayloadSamplesMaxDepth(p.generatedPayloadSamplesMaxDepth), this.nonce = p.nonce, this.hideFab = N(p.hideFab), this.minCharacterLengthToInitSearch = J(p.minCharacterLengthToInitSearch) || 3, this.showWebhookVerb = N(p.showWebhookVerb);
          }
        }
        var oe = ZV, U = i.n(oe);
        const { default: V, css: ye, createGlobalStyle: de, keyframes: Ce, ThemeProvider: Se } = oe, O = { lessThan(c, p, h) {
          return (...w) => ye`
      @media ${p ? "print, " : ""} screen and (max-width: ${(_) => _.theme.breakpoints[c]}) ${h || ""} {
        ${ye(...w)};
      }
    `;
        }, greaterThan(c) {
          return (...p) => ye`
      @media (min-width: ${(h) => h.theme.breakpoints[c]}) {
        ${ye(...p)};
      }
    `;
        }, between(c, p) {
          return (...h) => ye`
      @media (min-width: ${(w) => w.theme.breakpoints[c]}) and (max-width: ${(w) => w.theme.breakpoints[p]}) {
        ${ye(...h)};
      }
    `;
        } };
        var M = V;
        function se(c) {
          return (p) => {
            if (p.theme.extensionsHook) return p.theme.extensionsHook(c, p);
          };
        }
        const ve = M.div`
  padding: 20px;
  color: red;
`;
        class ge extends o.Component {
          constructor(p) {
            super(p), this.state = { error: void 0 };
          }
          componentDidCatch(p) {
            return this.setState({ error: p }), !1;
          }
          render() {
            return this.state.error ? o.createElement(ve, null, o.createElement("h1", null, "Something went wrong..."), o.createElement("small", null, " ", this.state.error.message, " "), o.createElement("p", null, o.createElement("details", null, o.createElement("summary", null, "Stack trace"), o.createElement("pre", null, this.state.error.stack))), o.createElement("small", null, " ReDoc Version: ", "2.1.5"), " ", o.createElement("br", null), o.createElement("small", null, " Commit: ", "3658b6d")) : o.createElement(o.Fragment, null, o.Children.only(this.props.children));
          }
        }
        const Oe = Ce`
  0% {
    transform: rotate(0deg); }
  100% {
    transform: rotate(360deg);
  }
`, ke = M((c) => o.createElement("svg", { className: c.className, version: "1.1", width: "512", height: "512", viewBox: "0 0 512 512" }, o.createElement("path", { d: "M275.682 147.999c0 10.864-8.837 19.661-19.682 19.661v0c-10.875 0-19.681-8.796-19.681-19.661v-96.635c0-10.885 8.806-19.661 19.681-19.661v0c10.844 0 19.682 8.776 19.682 19.661v96.635z" }), o.createElement("path", { d: "M275.682 460.615c0 10.865-8.837 19.682-19.682 19.682v0c-10.875 0-19.681-8.817-19.681-19.682v-96.604c0-10.885 8.806-19.681 19.681-19.681v0c10.844 0 19.682 8.796 19.682 19.682v96.604z" }), o.createElement("path", { d: "M147.978 236.339c10.885 0 19.681 8.755 19.681 19.641v0c0 10.885-8.796 19.702-19.681 19.702h-96.624c-10.864 0-19.661-8.817-19.661-19.702v0c0-10.885 8.796-19.641 19.661-19.641h96.624z" }), o.createElement("path", { d: "M460.615 236.339c10.865 0 19.682 8.755 19.682 19.641v0c0 10.885-8.817 19.702-19.682 19.702h-96.584c-10.885 0-19.722-8.817-19.722-19.702v0c0-10.885 8.837-19.641 19.722-19.641h96.584z" }), o.createElement("path", { d: "M193.546 165.703c7.69 7.66 7.68 20.142 0 27.822v0c-7.701 7.701-20.162 7.701-27.853 0.020l-68.311-68.322c-7.68-7.701-7.68-20.142 0-27.863v0c7.68-7.68 20.121-7.68 27.822 0l68.342 68.342z" }), o.createElement("path", { d: "M414.597 386.775c7.7 7.68 7.7 20.163 0.021 27.863v0c-7.7 7.659-20.142 7.659-27.843-0.062l-68.311-68.26c-7.68-7.7-7.68-20.204 0-27.863v0c7.68-7.7 20.163-7.7 27.842 0l68.291 68.322z" }), o.createElement("path", { d: "M165.694 318.464c7.69-7.7 20.153-7.7 27.853 0v0c7.68 7.659 7.69 20.163 0 27.863l-68.342 68.322c-7.67 7.659-20.142 7.659-27.822-0.062v0c-7.68-7.68-7.68-20.122 0-27.801l68.311-68.322z" }), o.createElement("path", { d: "M386.775 97.362c7.7-7.68 20.142-7.68 27.822 0v0c7.7 7.68 7.7 20.183 0.021 27.863l-68.322 68.311c-7.68 7.68-20.163 7.68-27.843-0.020v0c-7.68-7.68-7.68-20.162 0-27.822l68.322-68.332z" })))`
  animation: 2s ${Oe} linear infinite;
  width: 50px;
  height: 50px;
  content: '';
  display: inline-block;
  margin-left: -25px;

  path {
    fill: ${(c) => c.color};
  }
`, Me = M.div`
  font-family: helvetica, sans;
  width: 100%;
  text-align: center;
  font-size: 25px;
  margin: 30px 0 20px 0;
  color: ${(c) => c.color};
`;
        class Ve extends o.PureComponent {
          render() {
            return o.createElement("div", { style: { textAlign: "center" } }, o.createElement(Me, { color: this.props.color }, "Loading ..."), o.createElement(ke, { color: this.props.color }));
          }
        }
        var Je = zN();
        const He = o.createContext(new X({})), Ue = He.Provider, Ot = He.Consumer;
        var D = S9, we = ZY(), Ee = zL(), _e = i(925), Te = (c, p, h) => new Promise((w, _) => {
          var T = (Z) => {
            try {
              W(h.next(Z));
            } catch (ne) {
              _(ne);
            }
          }, R = (Z) => {
            try {
              W(h.throw(Z));
            } catch (ne) {
              _(ne);
            }
          }, W = (Z) => Z.done ? w(Z.value) : Promise.resolve(Z.value).then(T, R);
          W((h = h.apply(c, p)).next());
        });
        function $e(c) {
          return Te(this, null, function* () {
            const p = new Ee.Config({}), h = { config: p, base: f ? window.location.href : process.cwd() };
            f && (p.resolve.http.customFetch = i.g.fetch), typeof c == "object" && c !== null ? h.doc = { source: { absoluteRef: "" }, parsed: c } : h.ref = c;
            const { bundle: { parsed: w } } = yield (0, we.bundle)(h);
            return w.swagger !== void 0 ? Be(w) : w;
          });
        }
        function Be(c) {
          return console.warn("[ReDoc Compatibility mode]: Converting OpenAPI 2.0 to OpenAPI 3.0"), new Promise((p, h) => (0, _e.convertObj)(c, { patch: !0, warnOnly: !0, text: "{}", anchors: !0 }, (w, _) => {
            if (w) return h(w);
            p(_ && _.openapi);
          }));
        }
        var Pe = tG(), Re = rG(), Qe = qL();
        const ht = Qe.parse;
        class rt {
          static baseName(p, h = 1) {
            const w = rt.parse(p);
            return w[w.length - h];
          }
          static dirName(p, h = 1) {
            const w = rt.parse(p);
            return Qe.compile(w.slice(0, w.length - h));
          }
          static relative(p, h) {
            const w = rt.parse(p);
            return rt.parse(h).slice(w.length);
          }
          static parse(p) {
            let h = p;
            return h.charAt(0) === "#" && (h = h.substring(1)), ht(h);
          }
          static join(p, h) {
            const w = rt.parse(p).concat(h);
            return Qe.compile(w);
          }
          static get(p, h) {
            return Qe.get(p, h);
          }
          static compile(p) {
            return Qe.compile(p);
          }
          static escape(p) {
            return Qe.escape(p);
          }
        }
        Qe.parse = rt.parse, Object.assign(rt, Qe);
        var ut = i(470), yt = iG(), zn = Object.defineProperty, qt = Object.defineProperties, du = Object.getOwnPropertyDescriptors, Oa = Object.getOwnPropertySymbols, hu = Object.prototype.hasOwnProperty, py = Object.prototype.propertyIsEnumerable, Fp = (c, p, h) => p in c ? zn(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h, Fi = (c, p) => {
          for (var h in p || (p = {})) hu.call(p, h) && Fp(c, h, p[h]);
          if (Oa) for (var h of Oa(p)) py.call(p, h) && Fp(c, h, p[h]);
          return c;
        }, ka = (c, p) => qt(c, du(p));
        function zp(c) {
          return typeof c == "string" && /\dxx/i.test(c);
        }
        function mu(c) {
          return c === "default" || A(c) || zp(c);
        }
        function Qt(c, p = !1) {
          if (c === "default") return p ? "error" : "success";
          let h = typeof c == "string" ? parseInt(c, 10) : c;
          if (zp(c) && (h *= 100), h < 100 || h > 599) throw new Error("invalid HTTP code");
          let w = "success";
          return h >= 300 && h < 400 ? w = "redirect" : h >= 400 ? w = "error" : h < 200 && (w = "info"), w;
        }
        const qp = { get: !0, post: !0, put: !0, head: !0, patch: !0, delete: !0, options: !0, $ref: !0 };
        function Yt(c) {
          return c in qp;
        }
        function gu(c) {
          return c.summary || c.operationId || c.description && c.description.substring(0, 50) || c.pathName || "<no summary>";
        }
        const Dt = { multipleOf: "number", maximum: "number", exclusiveMaximum: "number", minimum: "number", exclusiveMinimum: "number", maxLength: "string", minLength: "string", pattern: "string", contentEncoding: "string", contentMediaType: "string", items: "array", maxItems: "array", minItems: "array", uniqueItems: "array", maxProperties: "object", minProperties: "object", required: "object", additionalProperties: "object", unevaluatedProperties: "object", properties: "object", patternProperties: "object" };
        function Ao(c) {
          if (c.type !== void 0 && !G(c.type)) return c.type;
          const p = Object.keys(Dt);
          for (const h of p) {
            const w = Dt[h];
            if (c[h] !== void 0) return w;
          }
          return "any";
        }
        function _s(c, p = c.type) {
          if (c["x-circular-ref"]) return !0;
          if (c.oneOf !== void 0 || c.anyOf !== void 0 || c.if && c.then || c.if && c.else) return !1;
          let h = !0;
          const w = G(p);
          return (p === "object" || w && (p != null && p.includes("object"))) && (h = c.properties !== void 0 ? Object.keys(c.properties).length === 0 : c.additionalProperties === void 0 && c.unevaluatedProperties === void 0 && c.patternProperties === void 0), !G(c.items) && !G(c.prefixItems) && (c.items !== void 0 && !ee(c.items) && (p === "array" || w && (p != null && p.includes("array"))) && (h = _s(c.items, c.items.type)), h);
        }
        function Po(c) {
          return c.search(/json/i) !== -1;
        }
        function Aa(c) {
          return c === "application/x-www-form-urlencoded";
        }
        function yu(c, p, h) {
          return G(c) ? c.map((w) => w.toString()).join(h) : typeof c == "object" ? Object.keys(c).map((w) => `${w}${h}${c[w]}`).join(h) : p + "=" + c.toString();
        }
        function vu(c, p) {
          return G(c) ? (console.warn("deepObject style cannot be used with array value:" + c.toString()), "") : typeof c == "object" ? Object.keys(c).map((h) => `${p}[${h}]=${c[h]}`).join("&") : (console.warn("deepObject style cannot be used with non-object value:" + c.toString()), "");
        }
        function En(c, p, h) {
          const w = "__redoc_param_name__", _ = p ? "*" : "";
          return yt.parse(`{?${w}${_}}`).expand({ [w]: h }).substring(1).replace(/__redoc_param_name__/g, c);
        }
        function Pa(c, p = {}) {
          if (G(c)) throw new Error("Payload must have fields: " + c.toString());
          return Object.keys(c).map((h) => {
            const w = c[h], { style: _ = "form", explode: T = !0 } = p[h] || {};
            switch (_) {
              case "form":
                return En(h, T, w);
              case "spaceDelimited":
                return yu(w, h, "%20");
              case "pipeDelimited":
                return yu(w, h, "|");
              case "deepObject":
                return vu(w, h);
              default:
                return console.warn("Incorrect or unsupported encoding style: " + _), "";
            }
          }).join("&");
        }
        function qn(c, p) {
          return Po(p) ? JSON.stringify(c) : (console.warn(`Parameter serialization as ${p} is not supported`), "");
        }
        function Ta(c, p) {
          const { name: h, style: w, explode: _ = !1, serializationMime: T } = c;
          if (T) switch (c.in) {
            case "path":
            case "header":
              return qn(p, T);
            case "cookie":
            case "query":
              return `${h}=${qn(p, T)}`;
            default:
              return console.warn("Unexpected parameter location: " + c.in), "";
          }
          if (!w) return console.warn(`Missing style attribute or content for parameter ${h}`), "";
          switch (c.in) {
            case "path":
              return function(R, W, Z, ne) {
                const re = Z ? "*" : "";
                let ie = "";
                W === "label" ? ie = "." : W === "matrix" && (ie = ";");
                const me = "__redoc_param_name__";
                return yt.parse(`{${ie}${me}${re}}`).expand({ [me]: ne }).replace(/__redoc_param_name__/g, R);
              }(h, w, _, p);
            case "query":
              return function(R, W, Z, ne) {
                switch (W) {
                  case "form":
                    return En(R, Z, ne);
                  case "spaceDelimited":
                    return G(ne) ? Z ? En(R, Z, ne) : `${R}=${ne.join("%20")}` : (console.warn("The style spaceDelimited is only applicable to arrays"), "");
                  case "pipeDelimited":
                    return G(ne) ? Z ? En(R, Z, ne) : `${R}=${ne.join("|")}` : (console.warn("The style pipeDelimited is only applicable to arrays"), "");
                  case "deepObject":
                    return !Z || G(ne) || typeof ne != "object" ? (console.warn("The style deepObject is only applicable for objects with explode=true"), "") : vu(ne, R);
                  default:
                    return console.warn("Unexpected style for query: " + W), "";
                }
              }(h, w, _, p);
            case "header":
              return function(R, W, Z) {
                if (R === "simple") {
                  const ne = W ? "*" : "", re = "__redoc_param_name__", ie = yt.parse(`{${re}${ne}}`);
                  return decodeURIComponent(ie.expand({ [re]: Z }));
                }
                return console.warn("Unexpected style for header: " + R), "";
              }(w, _, p);
            case "cookie":
              return function(R, W, Z, ne) {
                return W === "form" ? En(R, Z, ne) : (console.warn("Unexpected style for cookie: " + W), "");
              }(h, w, _, p);
            default:
              return console.warn("Unexpected parameter location: " + c.in), "";
          }
        }
        function zi(c, p) {
          return c.in ? decodeURIComponent(Ta(c, p)) : String(p);
        }
        function qi(c) {
          return c.search(/xml/i) !== -1 ? "xml" : c.search(/csv/i) !== -1 ? "csv" : c.search(/plain/i) !== -1 ? "tex" : "clike";
        }
        const Os = /^#\/components\/(schemas|pathItems)\/([^/]+)$/;
        function To(c) {
          return Os.test(c || "");
        }
        function Ca(c) {
          var p;
          const [h] = ((p = c == null ? void 0 : c.match(Os)) == null ? void 0 : p.reverse()) || [];
          return h;
        }
        function $a(c, p, h) {
          let w;
          return p !== void 0 && h !== void 0 ? w = p === h ? `= ${p} ${c}` : `[ ${p} .. ${h} ] ${c}` : h !== void 0 ? w = `<= ${h} ${c}` : p !== void 0 && (w = p === 1 ? "non-empty" : `>= ${p} ${c}`), w;
        }
        function Bp(c) {
          var p, h;
          const w = typeof c.exclusiveMinimum == "number" ? Math.min(c.exclusiveMinimum, (p = c.minimum) != null ? p : 1 / 0) : c.minimum, _ = typeof c.exclusiveMaximum == "number" ? Math.max(c.exclusiveMaximum, (h = c.maximum) != null ? h : -1 / 0) : c.maximum, T = typeof c.exclusiveMinimum == "number" || c.exclusiveMinimum, R = typeof c.exclusiveMaximum == "number" || c.exclusiveMaximum;
          return w !== void 0 && _ !== void 0 ? `${T ? "( " : "[ "}${w} .. ${_}${R ? " )" : " ]"}` : _ !== void 0 ? `${R ? "< " : "<= "}${_}` : w !== void 0 ? `${T ? "> " : ">= "}${w}` : void 0;
        }
        function ks(c) {
          const p = [], h = $a("characters", c.minLength, c.maxLength);
          h !== void 0 && p.push(h);
          const w = $a("items", c.minItems, c.maxItems);
          w !== void 0 && p.push(w);
          const _ = $a("properties", c.minProperties, c.maxProperties);
          _ !== void 0 && p.push(_);
          const T = function(W) {
            if (W === void 0) return;
            const Z = W.toString(10);
            return /^0\.0*1$/.test(Z) ? `decimal places <= ${Z.split(".")[1].length}` : `multiple of ${Z}`;
          }(c.multipleOf);
          T !== void 0 && p.push(T);
          const R = Bp(c);
          return R !== void 0 && p.push(R), c.uniqueItems && p.push("unique"), p;
        }
        function Bi(c, p = []) {
          const h = [], w = [], _ = [];
          return c.forEach((T) => {
            T.required ? p.includes(T.name) ? w.push(T) : _.push(T) : h.push(T);
          }), w.sort((T, R) => p.indexOf(T.name) - p.indexOf(R.name)), [...w, ..._, ...h];
        }
        function di(c, p) {
          return [...c].sort((h, w) => h[p].localeCompare(w[p]));
        }
        function Ui(c, p = [], h = []) {
          const w = {};
          return h.forEach((_) => {
            ({ resolved: _ } = c.deref(_)), w[_.name + "_" + _.in] = !0;
          }), (p = p.filter((_) => ({ resolved: _ } = c.deref(_), !w[_.name + "_" + _.in]))).concat(h);
        }
        function bu(c) {
          const p = {};
          return Object.keys(c).forEach((h) => {
            const w = c[h], _ = h.split(";")[0].trim();
            p[_] ? p[_] = Fi(Fi({}, p[_]), w) : p[_] = w;
          }), p;
        }
        function wu(c, p = {}) {
          return c.replace(/(?:{)([\w-.]+)(?:})/g, (h, w) => p[w] && p[w].default || h);
        }
        function Ra(c, p) {
          const h = c === void 0 ? le((() => {
            if (!f) return "";
            const w = window.location.href;
            return w.endsWith(".html") ? (0, ut.dirname)(w) : w;
          })()) : (0, ut.dirname)(c);
          return p.length === 0 && (p = [{ url: "/" }]), p.map((w) => {
            return ka(Fi({}, w), { url: (_ = w.url, Q(h, _)), description: w.description || "" });
            var _;
          });
        }
        const Ia = "SecurityDefinitions", Su = "security-definitions", As = "SchemaDefinition";
        let hi = "section/Authentication/";
        function Bn(c) {
          hi = c;
        }
        const mi = (c) => ({ delete: "del", options: "opts" })[c] || c;
        function Na(c) {
          return c in { "x-circular-ref": !0, "x-parentRefs": !0, "x-refsStack": !0, "x-code-samples": !0, "x-codeSamples": !0, "x-displayName": !0, "x-examples": !0, "x-ignoredHeaderParameters": !0, "x-logo": !0, "x-nullable": !0, "x-servers": !0, "x-tagGroups": !0, "x-traitTag": !0, "x-additionalPropertiesName": !0, "x-explicitMappingOnly": !0 };
        }
        function Vi(c, p) {
          return Object.keys(c).filter((h) => p === !0 ? h.startsWith("x-") && !Na(h) : h.startsWith("x-") && p.indexOf(h) > -1).reduce((h, w) => (h[w] = c[w], h), {});
        }
        function Up(c) {
          return c.split(" or ").map((p) => p.replace(/^(string|object|number|integer|array|boolean)s?( ?.*)/, "$1s$2")).join(" or ");
        }
        function Ps(c) {
          let p = c.content;
          const h = c["x-examples"], w = c["x-example"];
          if (h) {
            p = Fi({}, p);
            for (const _ of Object.keys(h)) {
              const T = h[_];
              p[_] = ka(Fi({}, p[_]), { examples: T });
            }
          } else if (w) {
            p = Fi({}, p);
            for (const _ of Object.keys(w)) {
              const T = w[_];
              p[_] = ka(Fi({}, p[_]), { example: T });
            }
          }
          return p;
        }
        var gi = oG();
        sG(), aG(), lG(), uG(), cG(), pG(), fG(), dG(), hG(), mG(), gG(), yG(), vG(), bG(), wG(), SG(), xG(), EG(), _G(), OG(), kG(), AG(), PG();
        const Vp = "clike";
        function Co(c) {
          return { json: "js", "c++": "cpp", "c#": "csharp", "objective-c": "objectivec", shell: "bash", viml: "vim" }[c] || Vp;
        }
        function xu(c, p = Vp) {
          p = p.toLowerCase();
          let h = gi.languages[p];
          return h || (h = gi.languages[Co(p)]), gi.highlight(c.toString(), h, p);
        }
        function Wp(c) {
          return (p, h, w) => {
            w.value = /* @__PURE__ */ function(_, T) {
              let R, W, Z, ne = null, re = 0;
              const ie = () => {
                re = (/* @__PURE__ */ new Date()).getTime(), ne = null, Z = _.apply(R, W), ne || (R = W = null);
              };
              return function() {
                const me = (/* @__PURE__ */ new Date()).getTime(), Ie = T - (me - re);
                return R = this, W = arguments, Ie <= 0 || Ie > T ? (ne && (clearTimeout(ne), ne = null), re = me, Z = _.apply(R, W), ne || (R = W = null)) : ne || (ne = setTimeout(ie, Ie)), Z;
              };
            }(w.value, c);
          };
        }
        function tr(c) {
        }
        function $o(c) {
        }
        gi.languages.insertBefore("javascript", "string", { "property string": { pattern: /([{,]\s*)"(?:\\.|[^\\"\r\n])*"(?=\s*:)/i, lookbehind: !0 } }, void 0), gi.languages.insertBefore("javascript", "punctuation", { property: { pattern: /([{,]\s*)[a-z]\w*(?=\s*:)/i, lookbehind: !0 } }, void 0);
        var fy = Object.defineProperty, Hp = Object.defineProperties, Eu = Object.getOwnPropertyDescriptors, _u = Object.getOwnPropertySymbols, Qp = Object.prototype.hasOwnProperty, dy = Object.prototype.propertyIsEnumerable, an = (c, p, h) => p in c ? fy(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h, Ts = (c, p) => {
          for (var h in p || (p = {})) Qp.call(p, h) && an(c, h, p[h]);
          if (_u) for (var h of _u(p)) dy.call(p, h) && an(c, h, p[h]);
          return c;
        }, Ou = (c, p) => Hp(c, Eu(p));
        const Cs = {};
        function yi(c, p, h) {
          if (typeof h.value == "function") return function(w, _, T) {
            if (!T.value || T.value.length > 0) throw new Error("@memoize decorator can only be applied to methods of zero arguments");
            const R = `_memoized_${_}`, W = T.value;
            return w[R] = Cs, Ou(Ts({}, T), { value() {
              return this[R] === Cs && (this[R] = W.call(this)), this[R];
            } });
          }(c, p, h);
          if (typeof h.get == "function") return function(w, _, T) {
            const R = `_memoized_${_}`, W = T.get;
            return w[R] = Cs, Ou(Ts({}, T), { get() {
              return this[R] === Cs && (this[R] = W.call(this)), this[R];
            } });
          }(c, p, h);
          throw new Error("@memoize decorator can be applied to methods or getters, got " + String(h.value) + " instead");
        }
        function ja(c) {
          let p = 1;
          return c[0] === "-" && (p = -1, c = c.substr(1)), (h, w) => p == -1 ? w[c].localeCompare(h[c]) : h[c].localeCompare(w[c]);
        }
        var Un = Object.defineProperty, Yp = Object.getOwnPropertyDescriptor;
        const La = "hashchange";
        class Ma {
          constructor() {
            this.emit = () => {
              this._emiter.emit(La, this.currentId);
            }, this._emiter = new Re.EventEmitter(), this.bind();
          }
          get currentId() {
            return f ? decodeURIComponent(window.location.hash.substring(1)) : "";
          }
          linkForId(p) {
            return p ? "#" + p : "";
          }
          subscribe(p) {
            const h = this._emiter.addListener(La, p);
            return () => h.removeListener(La, p);
          }
          bind() {
            f && window.addEventListener("hashchange", this.emit, !1);
          }
          dispose() {
            f && window.removeEventListener("hashchange", this.emit);
          }
          replace(p, h = !1) {
            f && p != null && p !== this.currentId && (h ? window.history.replaceState(null, "", window.location.href.split("#")[0] + this.linkForId(p)) : (window.history.pushState(null, "", window.location.href.split("#")[0] + this.linkForId(p)), this.emit()));
          }
        }
        ((c, p, h, w) => {
          for (var _, T = Yp(p, h), R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = _(p, h, T) || T);
          T && Un(p, h, T);
        })([Pe.bind, Pe.debounce], Ma.prototype, "replace");
        const $s = new Ma();
        var Gp = TG();
        class Ge {
          constructor() {
            this.map = /* @__PURE__ */ new Map(), this.prevTerm = "";
          }
          add(p) {
            this.map.set(p, new Gp(p));
          }
          delete(p) {
            this.map.delete(p);
          }
          addOnly(p) {
            this.map.forEach((h, w) => {
              p.indexOf(w) === -1 && (h.unmark(), this.map.delete(w));
            });
            for (const h of p) this.map.has(h) || this.map.set(h, new Gp(h));
          }
          clearAll() {
            this.unmark(), this.map.clear();
          }
          mark(p) {
            (p || this.prevTerm) && (this.map.forEach((h) => {
              h.unmark(), h.mark(p || this.prevTerm);
            }), this.prevTerm = p || this.prevTerm);
          }
          unmark() {
            this.map.forEach((p) => p.unmark()), this.prevTerm = "";
          }
        }
        let fe = { async: !1, baseUrl: null, breaks: !1, extensions: null, gfm: !0, headerIds: !0, headerPrefix: "", highlight: null, hooks: null, langPrefix: "language-", mangle: !0, pedantic: !1, renderer: null, sanitize: !1, sanitizer: null, silent: !1, smartypants: !1, tokenizer: null, walkTokens: null, xhtml: !1 };
        const je = /[&<>"']/, We = new RegExp(je.source, "g"), kt = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, fr = new RegExp(kt.source, "g"), lr = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, br = (c) => lr[c];
        function At(c, p) {
          if (p) {
            if (je.test(c)) return c.replace(We, br);
          } else if (kt.test(c)) return c.replace(fr, br);
          return c;
        }
        const Rs = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi;
        function dr(c) {
          return c.replace(Rs, (p, h) => (h = h.toLowerCase()) === "colon" ? ":" : h.charAt(0) === "#" ? h.charAt(1) === "x" ? String.fromCharCode(parseInt(h.substring(2), 16)) : String.fromCharCode(+h.substring(1)) : "");
        }
        const Kp = /(^|[^\[])\^/g;
        function bt(c, p) {
          c = typeof c == "string" ? c : c.source, p = p || "";
          const h = { replace: (w, _) => (_ = (_ = _.source || _).replace(Kp, "$1"), c = c.replace(w, _), h), getRegex: () => new RegExp(c, p) };
          return h;
        }
        const $M = /[^\w:]/g, RM = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
        function T1(c, p, h) {
          if (c) {
            let w;
            try {
              w = decodeURIComponent(dr(h)).replace($M, "").toLowerCase();
            } catch {
              return null;
            }
            if (w.indexOf("javascript:") === 0 || w.indexOf("vbscript:") === 0 || w.indexOf("data:") === 0) return null;
          }
          p && !RM.test(h) && (h = function(w, _) {
            Xp[" " + w] || (IM.test(w) ? Xp[" " + w] = w + "/" : Xp[" " + w] = Zp(w, "/", !0));
            const T = (w = Xp[" " + w]).indexOf(":") === -1;
            return _.substring(0, 2) === "//" ? T ? _ : w.replace(NM, "$1") + _ : _.charAt(0) === "/" ? T ? _ : w.replace(jM, "$1") + _ : w + _;
          }(p, h));
          try {
            h = encodeURI(h).replace(/%25/g, "%");
          } catch {
            return null;
          }
          return h;
        }
        const Xp = {}, IM = /^[^:]+:\/*[^/]*$/, NM = /^([^:]+:)[\s\S]*$/, jM = /^([^:]+:\/*[^/]*)[\s\S]*$/, Jp = { exec: function() {
        } };
        function C1(c, p) {
          const h = c.replace(/\|/g, (_, T, R) => {
            let W = !1, Z = T;
            for (; --Z >= 0 && R[Z] === "\\"; ) W = !W;
            return W ? "|" : " |";
          }).split(/ \|/);
          let w = 0;
          if (h[0].trim() || h.shift(), h.length > 0 && !h[h.length - 1].trim() && h.pop(), h.length > p) h.splice(p);
          else for (; h.length < p; ) h.push("");
          for (; w < h.length; w++) h[w] = h[w].trim().replace(/\\\|/g, "|");
          return h;
        }
        function Zp(c, p, h) {
          const w = c.length;
          if (w === 0) return "";
          let _ = 0;
          for (; _ < w; ) {
            const T = c.charAt(w - _ - 1);
            if (T !== p || h) {
              if (T === p || !h) break;
              _++;
            } else _++;
          }
          return c.slice(0, w - _);
        }
        function $1(c, p) {
          if (p < 1) return "";
          let h = "";
          for (; p > 1; ) 1 & p && (h += c), p >>= 1, c += c;
          return h + c;
        }
        function R1(c, p, h, w) {
          const _ = p.href, T = p.title ? At(p.title) : null, R = c[1].replace(/\\([\[\]])/g, "$1");
          if (c[0].charAt(0) !== "!") {
            w.state.inLink = !0;
            const W = { type: "link", raw: h, href: _, title: T, text: R, tokens: w.inlineTokens(R) };
            return w.state.inLink = !1, W;
          }
          return { type: "image", raw: h, href: _, title: T, text: At(R) };
        }
        class hy {
          constructor(p) {
            this.options = p || fe;
          }
          space(p) {
            const h = this.rules.block.newline.exec(p);
            if (h && h[0].length > 0) return { type: "space", raw: h[0] };
          }
          code(p) {
            const h = this.rules.block.code.exec(p);
            if (h) {
              const w = h[0].replace(/^ {1,4}/gm, "");
              return { type: "code", raw: h[0], codeBlockStyle: "indented", text: this.options.pedantic ? w : Zp(w, `
`) };
            }
          }
          fences(p) {
            const h = this.rules.block.fences.exec(p);
            if (h) {
              const w = h[0], _ = function(T, R) {
                const W = T.match(/^(\s+)(?:```)/);
                if (W === null) return R;
                const Z = W[1];
                return R.split(`
`).map((ne) => {
                  const re = ne.match(/^\s+/);
                  if (re === null) return ne;
                  const [ie] = re;
                  return ie.length >= Z.length ? ne.slice(Z.length) : ne;
                }).join(`
`);
              }(w, h[3] || "");
              return { type: "code", raw: w, lang: h[2] ? h[2].trim().replace(this.rules.inline._escapes, "$1") : h[2], text: _ };
            }
          }
          heading(p) {
            const h = this.rules.block.heading.exec(p);
            if (h) {
              let w = h[2].trim();
              if (/#$/.test(w)) {
                const _ = Zp(w, "#");
                this.options.pedantic ? w = _.trim() : _ && !/ $/.test(_) || (w = _.trim());
              }
              return { type: "heading", raw: h[0], depth: h[1].length, text: w, tokens: this.lexer.inline(w) };
            }
          }
          hr(p) {
            const h = this.rules.block.hr.exec(p);
            if (h) return { type: "hr", raw: h[0] };
          }
          blockquote(p) {
            const h = this.rules.block.blockquote.exec(p);
            if (h) {
              const w = h[0].replace(/^ *>[ \t]?/gm, ""), _ = this.lexer.state.top;
              this.lexer.state.top = !0;
              const T = this.lexer.blockTokens(w);
              return this.lexer.state.top = _, { type: "blockquote", raw: h[0], tokens: T, text: w };
            }
          }
          list(p) {
            let h = this.rules.block.list.exec(p);
            if (h) {
              let w, _, T, R, W, Z, ne, re, ie, me, Ie, Fe, vt = h[1].trim();
              const Pt = vt.length > 1, it = { type: "list", raw: "", ordered: Pt, start: Pt ? +vt.slice(0, -1) : "", loose: !1, items: [] };
              vt = Pt ? `\\d{1,9}\\${vt.slice(-1)}` : `\\${vt}`, this.options.pedantic && (vt = Pt ? vt : "[*+-]");
              const un = new RegExp(`^( {0,3}${vt})((?:[	 ][^\\n]*)?(?:\\n|$))`);
              for (; p && (Fe = !1, h = un.exec(p)) && !this.rules.block.hr.test(p); ) {
                if (w = h[0], p = p.substring(w.length), re = h[2].split(`
`, 1)[0].replace(/^\t+/, (Jt) => " ".repeat(3 * Jt.length)), ie = p.split(`
`, 1)[0], this.options.pedantic ? (R = 2, Ie = re.trimLeft()) : (R = h[2].search(/[^ ]/), R = R > 4 ? 1 : R, Ie = re.slice(R), R += h[1].length), Z = !1, !re && /^ *$/.test(ie) && (w += ie + `
`, p = p.substring(ie.length + 1), Fe = !0), !Fe) {
                  const Jt = new RegExp(`^ {0,${Math.min(3, R - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), On = new RegExp(`^ {0,${Math.min(3, R - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), rr = new RegExp(`^ {0,${Math.min(3, R - 1)}}(?:\`\`\`|~~~)`), Pr = new RegExp(`^ {0,${Math.min(3, R - 1)}}#`);
                  for (; p && (me = p.split(`
`, 1)[0], ie = me, this.options.pedantic && (ie = ie.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), !rr.test(ie)) && !Pr.test(ie) && !Jt.test(ie) && !On.test(p); ) {
                    if (ie.search(/[^ ]/) >= R || !ie.trim()) Ie += `
` + ie.slice(R);
                    else {
                      if (Z || re.search(/[^ ]/) >= 4 || rr.test(re) || Pr.test(re) || On.test(re)) break;
                      Ie += `
` + ie;
                    }
                    Z || ie.trim() || (Z = !0), w += me + `
`, p = p.substring(me.length + 1), re = ie.slice(R);
                  }
                }
                it.loose || (ne ? it.loose = !0 : /\n *\n *$/.test(w) && (ne = !0)), this.options.gfm && (_ = /^\[[ xX]\] /.exec(Ie), _ && (T = _[0] !== "[ ] ", Ie = Ie.replace(/^\[[ xX]\] +/, ""))), it.items.push({ type: "list_item", raw: w, task: !!_, checked: T, loose: !1, text: Ie }), it.raw += w;
              }
              it.items[it.items.length - 1].raw = w.trimRight(), it.items[it.items.length - 1].text = Ie.trimRight(), it.raw = it.raw.trimRight();
              const Qr = it.items.length;
              for (W = 0; W < Qr; W++) if (this.lexer.state.top = !1, it.items[W].tokens = this.lexer.blockTokens(it.items[W].text, []), !it.loose) {
                const Jt = it.items[W].tokens.filter((rr) => rr.type === "space"), On = Jt.length > 0 && Jt.some((rr) => /\n.*\n/.test(rr.raw));
                it.loose = On;
              }
              if (it.loose) for (W = 0; W < Qr; W++) it.items[W].loose = !0;
              return it;
            }
          }
          html(p) {
            const h = this.rules.block.html.exec(p);
            if (h) {
              const w = { type: "html", raw: h[0], pre: !this.options.sanitizer && (h[1] === "pre" || h[1] === "script" || h[1] === "style"), text: h[0] };
              if (this.options.sanitize) {
                const _ = this.options.sanitizer ? this.options.sanitizer(h[0]) : At(h[0]);
                w.type = "paragraph", w.text = _, w.tokens = this.lexer.inline(_);
              }
              return w;
            }
          }
          def(p) {
            const h = this.rules.block.def.exec(p);
            if (h) {
              const w = h[1].toLowerCase().replace(/\s+/g, " "), _ = h[2] ? h[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "", T = h[3] ? h[3].substring(1, h[3].length - 1).replace(this.rules.inline._escapes, "$1") : h[3];
              return { type: "def", tag: w, raw: h[0], href: _, title: T };
            }
          }
          table(p) {
            const h = this.rules.block.table.exec(p);
            if (h) {
              const w = { type: "table", header: C1(h[1]).map((_) => ({ text: _ })), align: h[2].replace(/^ *|\| *$/g, "").split(/ *\| */), rows: h[3] && h[3].trim() ? h[3].replace(/\n[ \t]*$/, "").split(`
`) : [] };
              if (w.header.length === w.align.length) {
                w.raw = h[0];
                let _, T, R, W, Z = w.align.length;
                for (_ = 0; _ < Z; _++) /^ *-+: *$/.test(w.align[_]) ? w.align[_] = "right" : /^ *:-+: *$/.test(w.align[_]) ? w.align[_] = "center" : /^ *:-+ *$/.test(w.align[_]) ? w.align[_] = "left" : w.align[_] = null;
                for (Z = w.rows.length, _ = 0; _ < Z; _++) w.rows[_] = C1(w.rows[_], w.header.length).map((ne) => ({ text: ne }));
                for (Z = w.header.length, T = 0; T < Z; T++) w.header[T].tokens = this.lexer.inline(w.header[T].text);
                for (Z = w.rows.length, T = 0; T < Z; T++) for (W = w.rows[T], R = 0; R < W.length; R++) W[R].tokens = this.lexer.inline(W[R].text);
                return w;
              }
            }
          }
          lheading(p) {
            const h = this.rules.block.lheading.exec(p);
            if (h) return { type: "heading", raw: h[0], depth: h[2].charAt(0) === "=" ? 1 : 2, text: h[1], tokens: this.lexer.inline(h[1]) };
          }
          paragraph(p) {
            const h = this.rules.block.paragraph.exec(p);
            if (h) {
              const w = h[1].charAt(h[1].length - 1) === `
` ? h[1].slice(0, -1) : h[1];
              return { type: "paragraph", raw: h[0], text: w, tokens: this.lexer.inline(w) };
            }
          }
          text(p) {
            const h = this.rules.block.text.exec(p);
            if (h) return { type: "text", raw: h[0], text: h[0], tokens: this.lexer.inline(h[0]) };
          }
          escape(p) {
            const h = this.rules.inline.escape.exec(p);
            if (h) return { type: "escape", raw: h[0], text: At(h[1]) };
          }
          tag(p) {
            const h = this.rules.inline.tag.exec(p);
            if (h) return !this.lexer.state.inLink && /^<a /i.test(h[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && /^<\/a>/i.test(h[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(h[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(h[0]) && (this.lexer.state.inRawBlock = !1), { type: this.options.sanitize ? "text" : "html", raw: h[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(h[0]) : At(h[0]) : h[0] };
          }
          link(p) {
            const h = this.rules.inline.link.exec(p);
            if (h) {
              const w = h[2].trim();
              if (!this.options.pedantic && /^</.test(w)) {
                if (!/>$/.test(w)) return;
                const R = Zp(w.slice(0, -1), "\\");
                if ((w.length - R.length) % 2 == 0) return;
              } else {
                const R = function(W, Z) {
                  if (W.indexOf(Z[1]) === -1) return -1;
                  const ne = W.length;
                  let re = 0, ie = 0;
                  for (; ie < ne; ie++) if (W[ie] === "\\") ie++;
                  else if (W[ie] === Z[0]) re++;
                  else if (W[ie] === Z[1] && (re--, re < 0)) return ie;
                  return -1;
                }(h[2], "()");
                if (R > -1) {
                  const W = (h[0].indexOf("!") === 0 ? 5 : 4) + h[1].length + R;
                  h[2] = h[2].substring(0, R), h[0] = h[0].substring(0, W).trim(), h[3] = "";
                }
              }
              let _ = h[2], T = "";
              if (this.options.pedantic) {
                const R = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(_);
                R && (_ = R[1], T = R[3]);
              } else T = h[3] ? h[3].slice(1, -1) : "";
              return _ = _.trim(), /^</.test(_) && (_ = this.options.pedantic && !/>$/.test(w) ? _.slice(1) : _.slice(1, -1)), R1(h, { href: _ && _.replace(this.rules.inline._escapes, "$1"), title: T && T.replace(this.rules.inline._escapes, "$1") }, h[0], this.lexer);
            }
          }
          reflink(p, h) {
            let w;
            if ((w = this.rules.inline.reflink.exec(p)) || (w = this.rules.inline.nolink.exec(p))) {
              let _ = (w[2] || w[1]).replace(/\s+/g, " ");
              if (_ = h[_.toLowerCase()], !_) {
                const T = w[0].charAt(0);
                return { type: "text", raw: T, text: T };
              }
              return R1(w, _, w[0], this.lexer);
            }
          }
          emStrong(p, h, w = "") {
            let _ = this.rules.inline.emStrong.lDelim.exec(p);
            if (!_ || _[3] && w.match(/[\p{L}\p{N}]/u)) return;
            const T = _[1] || _[2] || "";
            if (!T || T && (w === "" || this.rules.inline.punctuation.exec(w))) {
              const R = _[0].length - 1;
              let W, Z, ne = R, re = 0;
              const ie = _[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
              for (ie.lastIndex = 0, h = h.slice(-1 * p.length + R); (_ = ie.exec(h)) != null; ) {
                if (W = _[1] || _[2] || _[3] || _[4] || _[5] || _[6], !W) continue;
                if (Z = W.length, _[3] || _[4]) {
                  ne += Z;
                  continue;
                }
                if ((_[5] || _[6]) && R % 3 && !((R + Z) % 3)) {
                  re += Z;
                  continue;
                }
                if (ne -= Z, ne > 0) continue;
                Z = Math.min(Z, Z + ne + re);
                const me = p.slice(0, R + _.index + (_[0].length - W.length) + Z);
                if (Math.min(R, Z) % 2) {
                  const Fe = me.slice(1, -1);
                  return { type: "em", raw: me, text: Fe, tokens: this.lexer.inlineTokens(Fe) };
                }
                const Ie = me.slice(2, -2);
                return { type: "strong", raw: me, text: Ie, tokens: this.lexer.inlineTokens(Ie) };
              }
            }
          }
          codespan(p) {
            const h = this.rules.inline.code.exec(p);
            if (h) {
              let w = h[2].replace(/\n/g, " ");
              const _ = /[^ ]/.test(w), T = /^ /.test(w) && / $/.test(w);
              return _ && T && (w = w.substring(1, w.length - 1)), w = At(w, !0), { type: "codespan", raw: h[0], text: w };
            }
          }
          br(p) {
            const h = this.rules.inline.br.exec(p);
            if (h) return { type: "br", raw: h[0] };
          }
          del(p) {
            const h = this.rules.inline.del.exec(p);
            if (h) return { type: "del", raw: h[0], text: h[2], tokens: this.lexer.inlineTokens(h[2]) };
          }
          autolink(p, h) {
            const w = this.rules.inline.autolink.exec(p);
            if (w) {
              let _, T;
              return w[2] === "@" ? (_ = At(this.options.mangle ? h(w[1]) : w[1]), T = "mailto:" + _) : (_ = At(w[1]), T = _), { type: "link", raw: w[0], text: _, href: T, tokens: [{ type: "text", raw: _, text: _ }] };
            }
          }
          url(p, h) {
            let w;
            if (w = this.rules.inline.url.exec(p)) {
              let _, T;
              if (w[2] === "@") _ = At(this.options.mangle ? h(w[0]) : w[0]), T = "mailto:" + _;
              else {
                let R;
                do
                  R = w[0], w[0] = this.rules.inline._backpedal.exec(w[0])[0];
                while (R !== w[0]);
                _ = At(w[0]), T = w[1] === "www." ? "http://" + w[0] : w[0];
              }
              return { type: "link", raw: w[0], text: _, href: T, tokens: [{ type: "text", raw: _, text: _ }] };
            }
          }
          inlineText(p, h) {
            const w = this.rules.inline.text.exec(p);
            if (w) {
              let _;
              return _ = this.lexer.state.inRawBlock ? this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(w[0]) : At(w[0]) : w[0] : At(this.options.smartypants ? h(w[0]) : w[0]), { type: "text", raw: w[0], text: _ };
            }
          }
        }
        const Ze = { newline: /^(?: *(?:\n|$))+/, code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/, fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/, list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/, html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))", def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/, table: Jp, lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, text: /^[^\n]+/, _label: /(?!\s*\])(?:\\.|[^\[\]\\])+/, _title: /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/ };
        Ze.def = bt(Ze.def).replace("label", Ze._label).replace("title", Ze._title).getRegex(), Ze.bullet = /(?:[*+-]|\d{1,9}[.)])/, Ze.listItemStart = bt(/^( *)(bull) */).replace("bull", Ze.bullet).getRegex(), Ze.list = bt(Ze.list).replace(/bull/g, Ze.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + Ze.def.source + ")").getRegex(), Ze._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", Ze._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/, Ze.html = bt(Ze.html, "i").replace("comment", Ze._comment).replace("tag", Ze._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), Ze.paragraph = bt(Ze._paragraph).replace("hr", Ze.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Ze._tag).getRegex(), Ze.blockquote = bt(Ze.blockquote).replace("paragraph", Ze.paragraph).getRegex(), Ze.normal = { ...Ze }, Ze.gfm = { ...Ze.normal, table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)" }, Ze.gfm.table = bt(Ze.gfm.table).replace("hr", Ze.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Ze._tag).getRegex(), Ze.gfm.paragraph = bt(Ze._paragraph).replace("hr", Ze.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", Ze.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Ze._tag).getRegex(), Ze.pedantic = { ...Ze.normal, html: bt(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", Ze._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: Jp, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: bt(Ze.normal._paragraph).replace("hr", Ze.hr).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", Ze.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex() };
        const ze = { escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/, url: Jp, tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/, reflink: /^!?\[(label)\]\[(ref)\]/, nolink: /^!?\[(ref)\](?:\[\])?/, reflinkSearch: "reflink|nolink(?!\\()", emStrong: { lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/, rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/, rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/ }, code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, br: /^( {2,}|\\)\n(?!\s*$)/, del: Jp, text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, punctuation: /^([\spunctuation])/ };
        function LM(c) {
          return c.replace(/---/g, "").replace(/--/g, "").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1").replace(/'/g, "").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1").replace(/"/g, "").replace(/\.{3}/g, "");
        }
        function I1(c) {
          let p, h, w = "";
          const _ = c.length;
          for (p = 0; p < _; p++) h = c.charCodeAt(p), Math.random() > 0.5 && (h = "x" + h.toString(16)), w += "&#" + h + ";";
          return w;
        }
        ze._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~", ze.punctuation = bt(ze.punctuation).replace(/punctuation/g, ze._punctuation).getRegex(), ze.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g, ze.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g, ze._comment = bt(Ze._comment).replace("(?:-->|$)", "-->").getRegex(), ze.emStrong.lDelim = bt(ze.emStrong.lDelim).replace(/punct/g, ze._punctuation).getRegex(), ze.emStrong.rDelimAst = bt(ze.emStrong.rDelimAst, "g").replace(/punct/g, ze._punctuation).getRegex(), ze.emStrong.rDelimUnd = bt(ze.emStrong.rDelimUnd, "g").replace(/punct/g, ze._punctuation).getRegex(), ze._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g, ze._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/, ze._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/, ze.autolink = bt(ze.autolink).replace("scheme", ze._scheme).replace("email", ze._email).getRegex(), ze._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/, ze.tag = bt(ze.tag).replace("comment", ze._comment).replace("attribute", ze._attribute).getRegex(), ze._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, ze._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/, ze._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/, ze.link = bt(ze.link).replace("label", ze._label).replace("href", ze._href).replace("title", ze._title).getRegex(), ze.reflink = bt(ze.reflink).replace("label", ze._label).replace("ref", Ze._label).getRegex(), ze.nolink = bt(ze.nolink).replace("ref", Ze._label).getRegex(), ze.reflinkSearch = bt(ze.reflinkSearch, "g").replace("reflink", ze.reflink).replace("nolink", ze.nolink).getRegex(), ze.normal = { ...ze }, ze.pedantic = { ...ze.normal, strong: { start: /^__|\*\*/, middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/, endAst: /\*\*(?!\*)/g, endUnd: /__(?!_)/g }, em: { start: /^_|\*/, middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/, endAst: /\*(?!\*)/g, endUnd: /_(?!_)/g }, link: bt(/^!?\[(label)\]\((.*?)\)/).replace("label", ze._label).getRegex(), reflink: bt(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", ze._label).getRegex() }, ze.gfm = { ...ze.normal, escape: bt(ze.escape).replace("])", "~|])").getRegex(), _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/, url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/, text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/ }, ze.gfm.url = bt(ze.gfm.url, "i").replace("email", ze.gfm._extended_email).getRegex(), ze.breaks = { ...ze.gfm, br: bt(ze.br).replace("{2,}", "*").getRegex(), text: bt(ze.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() };
        class Ro {
          constructor(p) {
            this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = p || fe, this.options.tokenizer = this.options.tokenizer || new hy(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: !1, inRawBlock: !1, top: !0 };
            const h = { block: Ze.normal, inline: ze.normal };
            this.options.pedantic ? (h.block = Ze.pedantic, h.inline = ze.pedantic) : this.options.gfm && (h.block = Ze.gfm, this.options.breaks ? h.inline = ze.breaks : h.inline = ze.gfm), this.tokenizer.rules = h;
          }
          static get rules() {
            return { block: Ze, inline: ze };
          }
          static lex(p, h) {
            return new Ro(h).lex(p);
          }
          static lexInline(p, h) {
            return new Ro(h).inlineTokens(p);
          }
          lex(p) {
            let h;
            for (p = p.replace(/\r\n|\r/g, `
`), this.blockTokens(p, this.tokens); h = this.inlineQueue.shift(); ) this.inlineTokens(h.src, h.tokens);
            return this.tokens;
          }
          blockTokens(p, h = []) {
            let w, _, T, R;
            for (p = this.options.pedantic ? p.replace(/\t/g, "    ").replace(/^ +$/gm, "") : p.replace(/^( *)(\t+)/gm, (W, Z, ne) => Z + "    ".repeat(ne.length)); p; ) if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((W) => !!(w = W.call({ lexer: this }, p, h)) && (p = p.substring(w.raw.length), h.push(w), !0)))) if (w = this.tokenizer.space(p)) p = p.substring(w.raw.length), w.raw.length === 1 && h.length > 0 ? h[h.length - 1].raw += `
` : h.push(w);
            else if (w = this.tokenizer.code(p)) p = p.substring(w.raw.length), _ = h[h.length - 1], !_ || _.type !== "paragraph" && _.type !== "text" ? h.push(w) : (_.raw += `
` + w.raw, _.text += `
` + w.text, this.inlineQueue[this.inlineQueue.length - 1].src = _.text);
            else if (w = this.tokenizer.fences(p)) p = p.substring(w.raw.length), h.push(w);
            else if (w = this.tokenizer.heading(p)) p = p.substring(w.raw.length), h.push(w);
            else if (w = this.tokenizer.hr(p)) p = p.substring(w.raw.length), h.push(w);
            else if (w = this.tokenizer.blockquote(p)) p = p.substring(w.raw.length), h.push(w);
            else if (w = this.tokenizer.list(p)) p = p.substring(w.raw.length), h.push(w);
            else if (w = this.tokenizer.html(p)) p = p.substring(w.raw.length), h.push(w);
            else if (w = this.tokenizer.def(p)) p = p.substring(w.raw.length), _ = h[h.length - 1], !_ || _.type !== "paragraph" && _.type !== "text" ? this.tokens.links[w.tag] || (this.tokens.links[w.tag] = { href: w.href, title: w.title }) : (_.raw += `
` + w.raw, _.text += `
` + w.raw, this.inlineQueue[this.inlineQueue.length - 1].src = _.text);
            else if (w = this.tokenizer.table(p)) p = p.substring(w.raw.length), h.push(w);
            else if (w = this.tokenizer.lheading(p)) p = p.substring(w.raw.length), h.push(w);
            else {
              if (T = p, this.options.extensions && this.options.extensions.startBlock) {
                let W = 1 / 0;
                const Z = p.slice(1);
                let ne;
                this.options.extensions.startBlock.forEach(function(re) {
                  ne = re.call({ lexer: this }, Z), typeof ne == "number" && ne >= 0 && (W = Math.min(W, ne));
                }), W < 1 / 0 && W >= 0 && (T = p.substring(0, W + 1));
              }
              if (this.state.top && (w = this.tokenizer.paragraph(T))) _ = h[h.length - 1], R && _.type === "paragraph" ? (_.raw += `
` + w.raw, _.text += `
` + w.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = _.text) : h.push(w), R = T.length !== p.length, p = p.substring(w.raw.length);
              else if (w = this.tokenizer.text(p)) p = p.substring(w.raw.length), _ = h[h.length - 1], _ && _.type === "text" ? (_.raw += `
` + w.raw, _.text += `
` + w.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = _.text) : h.push(w);
              else if (p) {
                const W = "Infinite loop on byte: " + p.charCodeAt(0);
                if (this.options.silent) {
                  console.error(W);
                  break;
                }
                throw new Error(W);
              }
            }
            return this.state.top = !0, h;
          }
          inline(p, h = []) {
            return this.inlineQueue.push({ src: p, tokens: h }), h;
          }
          inlineTokens(p, h = []) {
            let w, _, T, R, W, Z, ne = p;
            if (this.tokens.links) {
              const re = Object.keys(this.tokens.links);
              if (re.length > 0) for (; (R = this.tokenizer.rules.inline.reflinkSearch.exec(ne)) != null; ) re.includes(R[0].slice(R[0].lastIndexOf("[") + 1, -1)) && (ne = ne.slice(0, R.index) + "[" + $1("a", R[0].length - 2) + "]" + ne.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
            }
            for (; (R = this.tokenizer.rules.inline.blockSkip.exec(ne)) != null; ) ne = ne.slice(0, R.index) + "[" + $1("a", R[0].length - 2) + "]" + ne.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
            for (; (R = this.tokenizer.rules.inline.escapedEmSt.exec(ne)) != null; ) ne = ne.slice(0, R.index + R[0].length - 2) + "++" + ne.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex), this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
            for (; p; ) if (W || (Z = ""), W = !1, !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((re) => !!(w = re.call({ lexer: this }, p, h)) && (p = p.substring(w.raw.length), h.push(w), !0)))) if (w = this.tokenizer.escape(p)) p = p.substring(w.raw.length), h.push(w);
            else if (w = this.tokenizer.tag(p)) p = p.substring(w.raw.length), _ = h[h.length - 1], _ && w.type === "text" && _.type === "text" ? (_.raw += w.raw, _.text += w.text) : h.push(w);
            else if (w = this.tokenizer.link(p)) p = p.substring(w.raw.length), h.push(w);
            else if (w = this.tokenizer.reflink(p, this.tokens.links)) p = p.substring(w.raw.length), _ = h[h.length - 1], _ && w.type === "text" && _.type === "text" ? (_.raw += w.raw, _.text += w.text) : h.push(w);
            else if (w = this.tokenizer.emStrong(p, ne, Z)) p = p.substring(w.raw.length), h.push(w);
            else if (w = this.tokenizer.codespan(p)) p = p.substring(w.raw.length), h.push(w);
            else if (w = this.tokenizer.br(p)) p = p.substring(w.raw.length), h.push(w);
            else if (w = this.tokenizer.del(p)) p = p.substring(w.raw.length), h.push(w);
            else if (w = this.tokenizer.autolink(p, I1)) p = p.substring(w.raw.length), h.push(w);
            else if (this.state.inLink || !(w = this.tokenizer.url(p, I1))) {
              if (T = p, this.options.extensions && this.options.extensions.startInline) {
                let re = 1 / 0;
                const ie = p.slice(1);
                let me;
                this.options.extensions.startInline.forEach(function(Ie) {
                  me = Ie.call({ lexer: this }, ie), typeof me == "number" && me >= 0 && (re = Math.min(re, me));
                }), re < 1 / 0 && re >= 0 && (T = p.substring(0, re + 1));
              }
              if (w = this.tokenizer.inlineText(T, LM)) p = p.substring(w.raw.length), w.raw.slice(-1) !== "_" && (Z = w.raw.slice(-1)), W = !0, _ = h[h.length - 1], _ && _.type === "text" ? (_.raw += w.raw, _.text += w.text) : h.push(w);
              else if (p) {
                const re = "Infinite loop on byte: " + p.charCodeAt(0);
                if (this.options.silent) {
                  console.error(re);
                  break;
                }
                throw new Error(re);
              }
            } else p = p.substring(w.raw.length), h.push(w);
            return h;
          }
        }
        class my {
          constructor(p) {
            this.options = p || fe;
          }
          code(p, h, w) {
            const _ = (h || "").match(/\S*/)[0];
            if (this.options.highlight) {
              const T = this.options.highlight(p, _);
              T != null && T !== p && (w = !0, p = T);
            }
            return p = p.replace(/\n$/, "") + `
`, _ ? '<pre><code class="' + this.options.langPrefix + At(_) + '">' + (w ? p : At(p, !0)) + `</code></pre>
` : "<pre><code>" + (w ? p : At(p, !0)) + `</code></pre>
`;
          }
          blockquote(p) {
            return `<blockquote>
${p}</blockquote>
`;
          }
          html(p) {
            return p;
          }
          heading(p, h, w, _) {
            return this.options.headerIds ? `<h${h} id="${this.options.headerPrefix + _.slug(w)}">${p}</h${h}>
` : `<h${h}>${p}</h${h}>
`;
          }
          hr() {
            return this.options.xhtml ? `<hr/>
` : `<hr>
`;
          }
          list(p, h, w) {
            const _ = h ? "ol" : "ul";
            return "<" + _ + (h && w !== 1 ? ' start="' + w + '"' : "") + `>
` + p + "</" + _ + `>
`;
          }
          listitem(p) {
            return `<li>${p}</li>
`;
          }
          checkbox(p) {
            return "<input " + (p ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
          }
          paragraph(p) {
            return `<p>${p}</p>
`;
          }
          table(p, h) {
            return h && (h = `<tbody>${h}</tbody>`), `<table>
<thead>
` + p + `</thead>
` + h + `</table>
`;
          }
          tablerow(p) {
            return `<tr>
${p}</tr>
`;
          }
          tablecell(p, h) {
            const w = h.header ? "th" : "td";
            return (h.align ? `<${w} align="${h.align}">` : `<${w}>`) + p + `</${w}>
`;
          }
          strong(p) {
            return `<strong>${p}</strong>`;
          }
          em(p) {
            return `<em>${p}</em>`;
          }
          codespan(p) {
            return `<code>${p}</code>`;
          }
          br() {
            return this.options.xhtml ? "<br/>" : "<br>";
          }
          del(p) {
            return `<del>${p}</del>`;
          }
          link(p, h, w) {
            if ((p = T1(this.options.sanitize, this.options.baseUrl, p)) === null) return w;
            let _ = '<a href="' + p + '"';
            return h && (_ += ' title="' + h + '"'), _ += ">" + w + "</a>", _;
          }
          image(p, h, w) {
            if ((p = T1(this.options.sanitize, this.options.baseUrl, p)) === null) return w;
            let _ = `<img src="${p}" alt="${w}"`;
            return h && (_ += ` title="${h}"`), _ += this.options.xhtml ? "/>" : ">", _;
          }
          text(p) {
            return p;
          }
        }
        class N1 {
          strong(p) {
            return p;
          }
          em(p) {
            return p;
          }
          codespan(p) {
            return p;
          }
          del(p) {
            return p;
          }
          html(p) {
            return p;
          }
          text(p) {
            return p;
          }
          link(p, h, w) {
            return "" + w;
          }
          image(p, h, w) {
            return "" + w;
          }
          br() {
            return "";
          }
        }
        class j1 {
          constructor() {
            this.seen = {};
          }
          serialize(p) {
            return p.toLowerCase().trim().replace(/<[!\/a-z].*?>/gi, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
          }
          getNextSafeSlug(p, h) {
            let w = p, _ = 0;
            if (this.seen.hasOwnProperty(w)) {
              _ = this.seen[p];
              do
                _++, w = p + "-" + _;
              while (this.seen.hasOwnProperty(w));
            }
            return h || (this.seen[p] = _, this.seen[w] = 0), w;
          }
          slug(p, h = {}) {
            const w = this.serialize(p);
            return this.getNextSafeSlug(w, h.dryrun);
          }
        }
        class Io {
          constructor(p) {
            this.options = p || fe, this.options.renderer = this.options.renderer || new my(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.textRenderer = new N1(), this.slugger = new j1();
          }
          static parse(p, h) {
            return new Io(h).parse(p);
          }
          static parseInline(p, h) {
            return new Io(h).parseInline(p);
          }
          parse(p, h = !0) {
            let w, _, T, R, W, Z, ne, re, ie, me, Ie, Fe, vt, Pt, it, un, Qr, Jt, On, rr = "";
            const Pr = p.length;
            for (w = 0; w < Pr; w++) if (me = p[w], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[me.type] && (On = this.options.extensions.renderers[me.type].call({ parser: this }, me), On !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(me.type))) rr += On || "";
            else switch (me.type) {
              case "space":
                continue;
              case "hr":
                rr += this.renderer.hr();
                continue;
              case "heading":
                rr += this.renderer.heading(this.parseInline(me.tokens), me.depth, dr(this.parseInline(me.tokens, this.textRenderer)), this.slugger);
                continue;
              case "code":
                rr += this.renderer.code(me.text, me.lang, me.escaped);
                continue;
              case "table":
                for (re = "", ne = "", R = me.header.length, _ = 0; _ < R; _++) ne += this.renderer.tablecell(this.parseInline(me.header[_].tokens), { header: !0, align: me.align[_] });
                for (re += this.renderer.tablerow(ne), ie = "", R = me.rows.length, _ = 0; _ < R; _++) {
                  for (Z = me.rows[_], ne = "", W = Z.length, T = 0; T < W; T++) ne += this.renderer.tablecell(this.parseInline(Z[T].tokens), { header: !1, align: me.align[T] });
                  ie += this.renderer.tablerow(ne);
                }
                rr += this.renderer.table(re, ie);
                continue;
              case "blockquote":
                ie = this.parse(me.tokens), rr += this.renderer.blockquote(ie);
                continue;
              case "list":
                for (Ie = me.ordered, Fe = me.start, vt = me.loose, R = me.items.length, ie = "", _ = 0; _ < R; _++) it = me.items[_], un = it.checked, Qr = it.task, Pt = "", it.task && (Jt = this.renderer.checkbox(un), vt ? it.tokens.length > 0 && it.tokens[0].type === "paragraph" ? (it.tokens[0].text = Jt + " " + it.tokens[0].text, it.tokens[0].tokens && it.tokens[0].tokens.length > 0 && it.tokens[0].tokens[0].type === "text" && (it.tokens[0].tokens[0].text = Jt + " " + it.tokens[0].tokens[0].text)) : it.tokens.unshift({ type: "text", text: Jt }) : Pt += Jt), Pt += this.parse(it.tokens, vt), ie += this.renderer.listitem(Pt, Qr, un);
                rr += this.renderer.list(ie, Ie, Fe);
                continue;
              case "html":
                rr += this.renderer.html(me.text);
                continue;
              case "paragraph":
                rr += this.renderer.paragraph(this.parseInline(me.tokens));
                continue;
              case "text":
                for (ie = me.tokens ? this.parseInline(me.tokens) : me.text; w + 1 < Pr && p[w + 1].type === "text"; ) me = p[++w], ie += `
` + (me.tokens ? this.parseInline(me.tokens) : me.text);
                rr += h ? this.renderer.paragraph(ie) : ie;
                continue;
              default: {
                const Ji = 'Token with "' + me.type + '" type was not found.';
                if (this.options.silent) return void console.error(Ji);
                throw new Error(Ji);
              }
            }
            return rr;
          }
          parseInline(p, h) {
            h = h || this.renderer;
            let w, _, T, R = "";
            const W = p.length;
            for (w = 0; w < W; w++) if (_ = p[w], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[_.type] && (T = this.options.extensions.renderers[_.type].call({ parser: this }, _), T !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(_.type))) R += T || "";
            else switch (_.type) {
              case "escape":
              case "text":
                R += h.text(_.text);
                break;
              case "html":
                R += h.html(_.text);
                break;
              case "link":
                R += h.link(_.href, _.title, this.parseInline(_.tokens, h));
                break;
              case "image":
                R += h.image(_.href, _.title, _.text);
                break;
              case "strong":
                R += h.strong(this.parseInline(_.tokens, h));
                break;
              case "em":
                R += h.em(this.parseInline(_.tokens, h));
                break;
              case "codespan":
                R += h.codespan(_.text);
                break;
              case "br":
                R += h.br();
                break;
              case "del":
                R += h.del(this.parseInline(_.tokens, h));
                break;
              default: {
                const Z = 'Token with "' + _.type + '" type was not found.';
                if (this.options.silent) return void console.error(Z);
                throw new Error(Z);
              }
            }
            return R;
          }
        }
        class ef {
          constructor(p) {
            this.options = p || fe;
          }
          preprocess(p) {
            return p;
          }
          postprocess(p) {
            return p;
          }
        }
        O_(ef, "passThroughHooks", /* @__PURE__ */ new Set(["preprocess", "postprocess"]));
        function L1(c, p) {
          return (h, w, _) => {
            typeof w == "function" && (_ = w, w = null);
            const T = { ...w }, R = /* @__PURE__ */ function(W, Z, ne) {
              return (re) => {
                if (re.message += `
Please report this to https://github.com/markedjs/marked.`, W) {
                  const ie = "<p>An error occurred:</p><pre>" + At(re.message + "", !0) + "</pre>";
                  return Z ? Promise.resolve(ie) : ne ? void ne(null, ie) : ie;
                }
                if (Z) return Promise.reject(re);
                if (!ne) throw re;
                ne(re);
              };
            }((w = { ...Ke.defaults, ...T }).silent, w.async, _);
            if (h == null) return R(new Error("marked(): input parameter is undefined or null"));
            if (typeof h != "string") return R(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(h) + ", string expected"));
            if (function(W) {
              W && W.sanitize && !W.silent && console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
            }(w), w.hooks && (w.hooks.options = w), _) {
              const W = w.highlight;
              let Z;
              try {
                w.hooks && (h = w.hooks.preprocess(h)), Z = c(h, w);
              } catch (ie) {
                return R(ie);
              }
              const ne = function(ie) {
                let me;
                if (!ie) try {
                  w.walkTokens && Ke.walkTokens(Z, w.walkTokens), me = p(Z, w), w.hooks && (me = w.hooks.postprocess(me));
                } catch (Ie) {
                  ie = Ie;
                }
                return w.highlight = W, ie ? R(ie) : _(null, me);
              };
              if (!W || W.length < 3 || (delete w.highlight, !Z.length)) return ne();
              let re = 0;
              return Ke.walkTokens(Z, function(ie) {
                ie.type === "code" && (re++, setTimeout(() => {
                  W(ie.text, ie.lang, function(me, Ie) {
                    if (me) return ne(me);
                    Ie != null && Ie !== ie.text && (ie.text = Ie, ie.escaped = !0), re--, re === 0 && ne();
                  });
                }, 0));
              }), void (re === 0 && ne());
            }
            if (w.async) return Promise.resolve(w.hooks ? w.hooks.preprocess(h) : h).then((W) => c(W, w)).then((W) => w.walkTokens ? Promise.all(Ke.walkTokens(W, w.walkTokens)).then(() => W) : W).then((W) => p(W, w)).then((W) => w.hooks ? w.hooks.postprocess(W) : W).catch(R);
            try {
              w.hooks && (h = w.hooks.preprocess(h));
              const W = c(h, w);
              w.walkTokens && Ke.walkTokens(W, w.walkTokens);
              let Z = p(W, w);
              return w.hooks && (Z = w.hooks.postprocess(Z)), Z;
            } catch (W) {
              return R(W);
            }
          };
        }
        function Ke(c, p, h) {
          return L1(Ro.lex, Io.parse)(c, p, h);
        }
        Ke.options = Ke.setOptions = function(c) {
          var p;
          return Ke.defaults = { ...Ke.defaults, ...c }, p = Ke.defaults, fe = p, Ke;
        }, Ke.getDefaults = function() {
          return { async: !1, baseUrl: null, breaks: !1, extensions: null, gfm: !0, headerIds: !0, headerPrefix: "", highlight: null, hooks: null, langPrefix: "language-", mangle: !0, pedantic: !1, renderer: null, sanitize: !1, sanitizer: null, silent: !1, smartypants: !1, tokenizer: null, walkTokens: null, xhtml: !1 };
        }, Ke.defaults = fe, Ke.use = function(...c) {
          const p = Ke.defaults.extensions || { renderers: {}, childTokens: {} };
          c.forEach((h) => {
            const w = { ...h };
            if (w.async = Ke.defaults.async || w.async || !1, h.extensions && (h.extensions.forEach((_) => {
              if (!_.name) throw new Error("extension name required");
              if (_.renderer) {
                const T = p.renderers[_.name];
                p.renderers[_.name] = T ? function(...R) {
                  let W = _.renderer.apply(this, R);
                  return W === !1 && (W = T.apply(this, R)), W;
                } : _.renderer;
              }
              if (_.tokenizer) {
                if (!_.level || _.level !== "block" && _.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
                p[_.level] ? p[_.level].unshift(_.tokenizer) : p[_.level] = [_.tokenizer], _.start && (_.level === "block" ? p.startBlock ? p.startBlock.push(_.start) : p.startBlock = [_.start] : _.level === "inline" && (p.startInline ? p.startInline.push(_.start) : p.startInline = [_.start]));
              }
              _.childTokens && (p.childTokens[_.name] = _.childTokens);
            }), w.extensions = p), h.renderer) {
              const _ = Ke.defaults.renderer || new my();
              for (const T in h.renderer) {
                const R = _[T];
                _[T] = (...W) => {
                  let Z = h.renderer[T].apply(_, W);
                  return Z === !1 && (Z = R.apply(_, W)), Z;
                };
              }
              w.renderer = _;
            }
            if (h.tokenizer) {
              const _ = Ke.defaults.tokenizer || new hy();
              for (const T in h.tokenizer) {
                const R = _[T];
                _[T] = (...W) => {
                  let Z = h.tokenizer[T].apply(_, W);
                  return Z === !1 && (Z = R.apply(_, W)), Z;
                };
              }
              w.tokenizer = _;
            }
            if (h.hooks) {
              const _ = Ke.defaults.hooks || new ef();
              for (const T in h.hooks) {
                const R = _[T];
                ef.passThroughHooks.has(T) ? _[T] = (W) => {
                  if (Ke.defaults.async) return Promise.resolve(h.hooks[T].call(_, W)).then((ne) => R.call(_, ne));
                  const Z = h.hooks[T].call(_, W);
                  return R.call(_, Z);
                } : _[T] = (...W) => {
                  let Z = h.hooks[T].apply(_, W);
                  return Z === !1 && (Z = R.apply(_, W)), Z;
                };
              }
              w.hooks = _;
            }
            if (h.walkTokens) {
              const _ = Ke.defaults.walkTokens;
              w.walkTokens = function(T) {
                let R = [];
                return R.push(h.walkTokens.call(this, T)), _ && (R = R.concat(_.call(this, T))), R;
              };
            }
            Ke.setOptions(w);
          });
        }, Ke.walkTokens = function(c, p) {
          let h = [];
          for (const w of c) switch (h = h.concat(p.call(Ke, w)), w.type) {
            case "table":
              for (const _ of w.header) h = h.concat(Ke.walkTokens(_.tokens, p));
              for (const _ of w.rows) for (const T of _) h = h.concat(Ke.walkTokens(T.tokens, p));
              break;
            case "list":
              h = h.concat(Ke.walkTokens(w.items, p));
              break;
            default:
              Ke.defaults.extensions && Ke.defaults.extensions.childTokens && Ke.defaults.extensions.childTokens[w.type] ? Ke.defaults.extensions.childTokens[w.type].forEach(function(_) {
                h = h.concat(Ke.walkTokens(w[_], p));
              }) : w.tokens && (h = h.concat(Ke.walkTokens(w.tokens, p)));
          }
          return h;
        }, Ke.parseInline = L1(Ro.lexInline, Io.parseInline), Ke.Parser = Io, Ke.parser = Io.parse, Ke.Renderer = my, Ke.TextRenderer = N1, Ke.Lexer = Ro, Ke.lexer = Ro.lex, Ke.Tokenizer = hy, Ke.Slugger = j1, Ke.Hooks = ef, Ke.parse = Ke, Ke.options, Ke.setOptions, Ke.use, Ke.walkTokens, Ke.parseInline, Io.parse, Ro.lex;
        var MM = Object.defineProperty, DM = Object.defineProperties, FM = Object.getOwnPropertyDescriptors, M1 = Object.getOwnPropertySymbols, zM = Object.prototype.hasOwnProperty, qM = Object.prototype.propertyIsEnumerable, D1 = (c, p, h) => p in c ? MM(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h, F1 = (c, p) => {
          for (var h in p || (p = {})) zM.call(p, h) && D1(c, h, p[h]);
          if (M1) for (var h of M1(p)) qM.call(p, h) && D1(c, h, p[h]);
          return c;
        };
        const BM = new Ke.Renderer();
        Ke.setOptions({ renderer: BM, highlight: (c, p) => xu(c, p) });
        const z1 = "^ {0,3}<!-- ReDoc-Inject:\\s+?<({component}).*?/?>\\s+?-->\\s*$", q1 = "(?:^ {0,3}<({component})([\\s\\S]*?)>([\\s\\S]*?)</\\2>|^ {0,3}<({component})([\\s\\S]*?)(?:/>|\\n{2,}))", gy = "(?:" + z1 + "|" + q1 + ")";
        function UM(c) {
          return `<!-- ReDoc-Inject: <${c}> -->`;
        }
        class Da {
          constructor(p, h) {
            this.options = p, this.parentId = h, this.headings = [], this.headingRule = (w, _, T, R) => (_ === 1 ? this.currentTopHeading = this.saveHeading(w, _) : _ === 2 && this.saveHeading(w, _, this.currentTopHeading && this.currentTopHeading.items, this.currentTopHeading && this.currentTopHeading.id), this.originalHeadingRule(w, _, T, R)), this.parentId = h, this.parser = new Ke.Parser(), this.headingEnhanceRenderer = new Ke.Renderer(), this.originalHeadingRule = this.headingEnhanceRenderer.heading.bind(this.headingEnhanceRenderer), this.headingEnhanceRenderer.heading = this.headingRule;
          }
          static containsComponent(p, h) {
            return new RegExp(gy.replace(/{component}/g, h), "gmi").test(p);
          }
          static getTextBeforeHading(p, h) {
            const w = p.search(new RegExp(`^##?\\s+${h}`, "m"));
            return w > -1 ? p.substring(0, w) : p;
          }
          saveHeading(p, h, w = this.headings, _) {
            p = be(p);
            const T = { id: _ ? `${_}/${F(p)}` : `${this.parentId || "section"}/${F(p)}`, name: p, level: h, items: [] };
            return w.push(T), T;
          }
          flattenHeadings(p) {
            if (p === void 0) return [];
            const h = [];
            for (const w of p) h.push(w), h.push(...this.flattenHeadings(w.items));
            return h;
          }
          attachHeadingsDescriptions(p) {
            const h = (W) => new RegExp(`##?\\s+${W.name.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")}s*(
|\r
|$|s*)`), w = this.flattenHeadings(this.headings);
            if (w.length < 1) return;
            let _ = w[0], T = h(_), R = p.search(T);
            for (let W = 1; W < w.length; W++) {
              const Z = w[W], ne = h(Z), re = p.substr(R + 1).search(ne) + R + 1;
              _.description = p.substring(R, re).replace(T, "").trim(), _ = Z, T = ne, R = re;
            }
            _.description = p.substring(R).replace(T, "").trim();
          }
          renderMd(p, h = !1) {
            const w = h ? { renderer: this.headingEnhanceRenderer } : void 0;
            return Ke(p.toString(), w);
          }
          extractHeadings(p) {
            this.renderMd(p, !0), this.attachHeadingsDescriptions(p);
            const h = this.headings;
            return this.headings = [], h;
          }
          renderMdWithComponents(p) {
            const h = this.options && this.options.allowedMdComponents;
            if (!h || Object.keys(h).length === 0) return [this.renderMd(p)];
            const w = Object.keys(h).join("|"), _ = new RegExp(gy.replace(/{component}/g, w), "mig"), T = [], R = [];
            let W = _.exec(p), Z = 0;
            for (; W; ) {
              T.push(p.substring(Z, W.index)), Z = _.lastIndex;
              const me = h[W[1] || W[2] || W[5]], Ie = W[3] || W[6], Fe = W[4];
              me && R.push({ component: me.component, propsSelector: me.propsSelector, props: (ne = F1(F1({}, VM(Ie)), me.props), re = { children: Fe }, DM(ne, FM(re))) }), W = _.exec(p);
            }
            var ne, re;
            T.push(p.substring(Z));
            const ie = [];
            for (let me = 0; me < T.length; me++) {
              const Ie = T[me];
              Ie && ie.push(this.renderMd(Ie)), R[me] && ie.push(R[me]);
            }
            return ie;
          }
        }
        function VM(c) {
          if (!c) return {};
          const p = /([\w-]+)\s*=\s*(?:{([^}]+?)}|"([^"]+?)")/gim, h = {};
          let w;
          for (; (w = p.exec(c)) !== null; ) if (w[3]) h[w[1]] = w[3];
          else if (w[2]) {
            let _;
            try {
              _ = JSON.parse(w[2]);
            } catch {
            }
            h[w[1]] = _;
          }
          return h;
        }
        class B1 {
          constructor(p, h = new X({})) {
            this.parser = p, this.options = h, Object.assign(this, p.spec.info), this.description = p.spec.info.description || "", this.summary = p.spec.info.summary || "";
            const w = this.description.search(/^\s*##?\s+/m);
            w > -1 && (this.description = this.description.substring(0, w)), this.downloadLink = this.getDownloadLink(), this.downloadFileName = this.getDownloadFileName();
          }
          getDownloadLink() {
            if (this.options.downloadDefinitionUrl) return this.options.downloadDefinitionUrl;
            if (this.parser.specUrl) return this.parser.specUrl;
            if (f && window.Blob && window.URL && window.URL.createObjectURL) {
              const p = new Blob([JSON.stringify(this.parser.spec, null, 2)], { type: "application/json" });
              return window.URL.createObjectURL(p);
            }
          }
          getDownloadFileName() {
            return this.parser.specUrl || this.options.downloadDefinitionUrl ? this.options.downloadFileName : this.options.downloadFileName || "openapi.json";
          }
        }
        var WM = Object.defineProperty, HM = Object.defineProperties, QM = Object.getOwnPropertyDescriptors, U1 = Object.getOwnPropertySymbols, YM = Object.prototype.hasOwnProperty, GM = Object.prototype.propertyIsEnumerable, V1 = (c, p, h) => p in c ? WM(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h;
        class W1 {
          constructor(p, h) {
            const w = h.spec.components && h.spec.components.securitySchemes || {};
            this.schemes = Object.keys(p || {}).map((_) => {
              const { resolved: T } = h.deref(w[_]), R = p[_] || [];
              if (!T) return void console.warn(`Non existing security scheme referenced: ${_}. Skipping`);
              const W = T["x-displayName"] || _;
              return Z = ((ne, re) => {
                for (var ie in re || (re = {})) YM.call(re, ie) && V1(ne, ie, re[ie]);
                if (U1) for (var ie of U1(re)) GM.call(re, ie) && V1(ne, ie, re[ie]);
                return ne;
              })({}, T), HM(Z, QM({ id: _, sectionId: _, displayName: W, scopes: R }));
              var Z;
            }).filter((_) => _ !== void 0);
          }
        }
        var H1 = Object.defineProperty, KM = Object.defineProperties, XM = Object.getOwnPropertyDescriptor, JM = Object.getOwnPropertyDescriptors, Q1 = Object.getOwnPropertySymbols, ZM = Object.prototype.hasOwnProperty, e2 = Object.prototype.propertyIsEnumerable, Y1 = (c, p, h) => p in c ? H1(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h, t2 = (c, p) => {
          for (var h in p || (p = {})) ZM.call(p, h) && Y1(c, h, p[h]);
          if (Q1) for (var h of Q1(p)) e2.call(p, h) && Y1(c, h, p[h]);
          return c;
        }, G1 = (c, p, h, w) => {
          for (var _, T = w > 1 ? void 0 : w ? XM(p, h) : p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = (w ? _(p, h, T) : _(T)) || T);
          return w && T && H1(p, h, T), T;
        };
        class tf {
          constructor(p, h, w, _, T) {
            this.expanded = !1, this.operations = [], (0, D.makeObservable)(this), this.name = h;
            const { resolved: R } = p.deref(w);
            for (const ne of Object.keys(R)) {
              const re = R[ne], ie = Object.keys(re).filter(Yt);
              for (const me of ie) {
                const Ie = re[me], Fe = new Mr(p, (W = t2({}, Ie), Z = { pathName: ne, pointer: rt.compile([_, h, ne, me]), httpVerb: me, pathParameters: re.parameters || [], pathServers: re.servers }, KM(W, JM(Z))), void 0, T, !0);
                this.operations.push(Fe);
              }
            }
            var W, Z;
          }
          toggle() {
            this.expanded = !this.expanded;
          }
        }
        G1([D.observable], tf.prototype, "expanded", 2), G1([D.action], tf.prototype, "toggle", 1);
        var r2 = Object.defineProperty, n2 = Object.defineProperties, i2 = Object.getOwnPropertyDescriptors, rf = Object.getOwnPropertySymbols, K1 = Object.prototype.hasOwnProperty, X1 = Object.prototype.propertyIsEnumerable, J1 = (c, p, h) => p in c ? r2(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h, Wi = (c, p) => {
          for (var h in p || (p = {})) K1.call(p, h) && J1(c, h, p[h]);
          if (rf) for (var h of rf(p)) X1.call(p, h) && J1(c, h, p[h]);
          return c;
        }, nf = (c, p) => n2(c, i2(p)), yy = (c, p) => {
          var h = {};
          for (var w in c) K1.call(c, w) && p.indexOf(w) < 0 && (h[w] = c[w]);
          if (c != null && rf) for (var w of rf(c)) p.indexOf(w) < 0 && X1.call(c, w) && (h[w] = c[w]);
          return h;
        };
        function of(c, p) {
          return p && c[c.length - 1] !== p ? [...c, p] : c;
        }
        function sf(c, p) {
          return p ? c.concat(p) : c;
        }
        class Z1 {
          constructor(p, h, w = new X({})) {
            this.options = w, this.allowMergeRefs = !1, this.byRef = (T) => {
              let R;
              if (this.spec) {
                T.charAt(0) !== "#" && (T = "#" + T), T = decodeURIComponent(T);
                try {
                  R = rt.get(this.spec, T);
                } catch {
                }
                return R || {};
              }
            }, this.validate(p), this.spec = p, this.allowMergeRefs = p.openapi.startsWith("3.1");
            const _ = f ? window.location.href : "";
            typeof h == "string" && (this.specUrl = _ ? new URL(h, _).href : h);
          }
          validate(p) {
            if (p.openapi === void 0) throw new Error("Document must be valid OpenAPI 3.0.0 definition");
          }
          isRef(p) {
            return !!p && p.$ref !== void 0 && p.$ref !== null;
          }
          deref(p, h = [], w = !1) {
            const _ = p == null ? void 0 : p["x-refsStack"];
            if (h = sf(h, _), this.isRef(p)) {
              const T = Ca(p.$ref);
              if (T && this.options.ignoreNamedSchemas.has(T)) return { resolved: { type: "object", title: T }, refsStack: h };
              let R = this.byRef(p.$ref);
              if (!R) throw new Error(`Failed to resolve $ref "${p.$ref}"`);
              let W = h;
              if (h.includes(p.$ref) || h.length > 999) R = Object.assign({}, R, { "x-circular-ref": !0 });
              else if (this.isRef(R)) {
                const Z = this.deref(R, h, w);
                W = Z.refsStack, R = Z.resolved;
              }
              return W = of(h, p.$ref), R = this.allowMergeRefs ? this.mergeRefs(p, R, w) : R, { resolved: R, refsStack: W };
            }
            return { resolved: p, refsStack: sf(h, _) };
          }
          mergeRefs(p, h, w) {
            const _ = p, { $ref: T } = _, R = yy(_, ["$ref"]), W = Object.keys(R);
            if (W.length === 0) return h;
            if (w && W.some((Z) => !["description", "title", "externalDocs", "x-refsStack", "x-parentRefs", "readOnly", "writeOnly"].includes(Z))) {
              const Z = R, { description: ne, title: re, readOnly: ie, writeOnly: me } = Z;
              return { allOf: [{ description: ne, title: re, readOnly: ie, writeOnly: me }, h, yy(Z, ["description", "title", "readOnly", "writeOnly"])] };
            }
            return Wi(Wi({}, h), R);
          }
          mergeAllOf(p, h, w) {
            var _;
            if (p["x-circular-ref"] || (p = this.hoistOneOfs(p, w)).allOf === void 0) return p;
            let T = nf(Wi({}, p), { "x-parentRefs": [], allOf: void 0, title: p.title || Ca(h) });
            T.properties !== void 0 && typeof T.properties == "object" && (T.properties = Wi({}, T.properties)), T.items !== void 0 && typeof T.items == "object" && (T.items = Wi({}, T.items));
            const R = function(W, Z) {
              const ne = /* @__PURE__ */ new Set();
              return W.filter((re) => {
                const ie = re.$ref;
                return !ie || ie && !ne.has(ie) && ne.add(ie);
              });
            }(p.allOf.map((W) => {
              var Z;
              const { resolved: ne, refsStack: re } = this.deref(W, w, !0), ie = W.$ref || void 0, me = this.mergeAllOf(ne, ie, re);
              if (!me["x-circular-ref"] || !me.allOf) return ie && ((Z = T["x-parentRefs"]) == null || Z.push(...me["x-parentRefs"] || [], ie)), { $ref: ie, refsStack: of(re, ie), schema: me };
            }).filter((W) => W !== void 0));
            for (const { schema: W, refsStack: Z } of R) {
              const ne = W, { type: re, enum: ie, properties: me, items: Ie, required: Fe, title: vt, description: Pt, readOnly: it, writeOnly: un, oneOf: Qr, anyOf: Jt, "x-circular-ref": On } = ne, rr = yy(ne, ["type", "enum", "properties", "items", "required", "title", "description", "readOnly", "writeOnly", "oneOf", "anyOf", "x-circular-ref"]);
              if (T.type !== re && T.type !== void 0 && re !== void 0 && console.warn(`Incompatible types in allOf at "${h}": "${T.type}" and "${re}"`), re !== void 0 && (Array.isArray(re) && Array.isArray(T.type) ? T.type = [...re, ...T.type] : T.type = re), ie !== void 0 && (Array.isArray(ie) && Array.isArray(T.enum) ? T.enum = Array.from(/* @__PURE__ */ new Set([...ie, ...T.enum])) : T.enum = ie), me !== void 0 && typeof me == "object") {
                T.properties = T.properties || {};
                for (const Pr in me) {
                  const Ji = sf(Z, (_ = me[Pr]) == null ? void 0 : _["x-refsStack"]);
                  if (T.properties[Pr]) {
                    if (!On) {
                      const fq = this.mergeAllOf({ allOf: [T.properties[Pr], nf(Wi({}, me[Pr]), { "x-refsStack": Ji })], "x-refsStack": Ji }, h + "/properties/" + Pr, Ji);
                      T.properties[Pr] = fq;
                    }
                  } else T.properties[Pr] = nf(Wi({}, me[Pr]), { "x-refsStack": Ji });
                }
              }
              if (Ie !== void 0 && !On) {
                const Pr = typeof T.items == "boolean" ? {} : Object.assign({}, T.items), Ji = typeof W.items == "boolean" ? {} : Object.assign({}, W.items);
                T.items = this.mergeAllOf({ allOf: [Pr, Ji] }, h + "/items", Z);
              }
              Qr !== void 0 && (T.oneOf = Qr), Jt !== void 0 && (T.anyOf = Jt), Fe !== void 0 && (T.required = [...T.required || [], ...Fe]), T = Wi(nf(Wi({}, T), { title: T.title || vt, description: T.description || Pt, readOnly: T.readOnly !== void 0 ? T.readOnly : it, writeOnly: T.writeOnly !== void 0 ? T.writeOnly : un, "x-circular-ref": T["x-circular-ref"] || On }), rr);
            }
            return T;
          }
          findDerived(p) {
            const h = {}, w = this.spec.components && this.spec.components.schemas || {};
            for (const _ in w) {
              const { resolved: T } = this.deref(w[_]);
              T.allOf !== void 0 && T.allOf.find((R) => R.$ref !== void 0 && p.indexOf(R.$ref) > -1) && (h["#/components/schemas/" + _] = [T["x-discriminator-value"] || _]);
            }
            return h;
          }
          hoistOneOfs(p, h) {
            if (p.allOf === void 0) return p;
            const w = p.allOf;
            for (let _ = 0; _ < w.length; _++) {
              const T = w[_];
              if (Array.isArray(T.oneOf)) {
                const R = w.slice(0, _), W = w.slice(_ + 1);
                return { oneOf: T.oneOf.map((Z) => ({ allOf: [...R, Z, ...W], "x-refsStack": h })) };
              }
            }
            return p;
          }
        }
        var ex = Object.defineProperty, o2 = Object.defineProperties, s2 = Object.getOwnPropertyDescriptor, a2 = Object.getOwnPropertyDescriptors, af = Object.getOwnPropertySymbols, tx = Object.prototype.hasOwnProperty, rx = Object.prototype.propertyIsEnumerable, nx = (c, p, h) => p in c ? ex(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h, Fa = (c, p) => {
          for (var h in p || (p = {})) tx.call(p, h) && nx(c, h, p[h]);
          if (af) for (var h of af(p)) rx.call(p, h) && nx(c, h, p[h]);
          return c;
        }, vy = (c, p) => o2(c, a2(p)), ix = (c, p, h, w) => {
          for (var _, T = w > 1 ? void 0 : w ? s2(p, h) : p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = (w ? _(p, h, T) : _(T)) || T);
          return w && T && ex(p, h, T), T;
        };
        const ku = class {
          constructor(c, p, h, w, _ = !1, T = []) {
            this.options = w, this.refsStack = T, this.typePrefix = "", this.isCircular = !1, this.activeOneOf = 0, (0, D.makeObservable)(this), this.pointer = p.$ref || h || "";
            const { resolved: R, refsStack: W } = c.deref(p, T, !0);
            this.refsStack = of(W, this.pointer), this.rawSchema = R, this.schema = c.mergeAllOf(this.rawSchema, this.pointer, this.refsStack), this.init(c, _), w.showExtensions && (this.extensions = Vi(this.schema, w.showExtensions));
          }
          activateOneOf(c) {
            this.activeOneOf = c;
          }
          hasType(c) {
            return this.type === c || G(this.type) && this.type.includes(c);
          }
          init(c, p) {
            var h, w, _, T, R, W, Z, ne;
            const re = this.schema;
            if (this.isCircular = !!re["x-circular-ref"], this.title = re.title || To(this.pointer) && rt.baseName(this.pointer) || "", this.description = re.description || "", this.type = re.type || Ao(re), this.format = re.format, this.enum = re.enum || [], this.example = re.example, this.examples = re.examples, this.deprecated = !!re.deprecated, this.pattern = re.pattern, this.externalDocs = re.externalDocs, this.constraints = ks(re), this.displayFormat = this.format, this.isPrimitive = _s(re, this.type), this.default = re.default, this.readOnly = !!re.readOnly, this.writeOnly = !!re.writeOnly, this.const = re.const || "", this.contentEncoding = re.contentEncoding, this.contentMediaType = re.contentMediaType, this.minItems = re.minItems, this.maxItems = re.maxItems, (re.nullable || re["x-nullable"]) && (G(this.type) && !this.type.some((ie) => ie === null || ie === "null") ? this.type = [...this.type, "null"] : G(this.type) || this.type === null && this.type === "null" || (this.type = [this.type, "null"])), this.displayType = G(this.type) ? this.type.map((ie) => ie === null ? "null" : ie).join(" or ") : this.type, !this.isCircular) if (re.if && re.then || re.if && re.else) this.initConditionalOperators(re, c);
            else if (p || sx(re) === void 0) {
              if (p && G(re.oneOf) && re.oneOf.find((ie) => ie.$ref === this.pointer) && delete re.oneOf, re.oneOf !== void 0) return this.initOneOf(re.oneOf, c), this.oneOfType = "One of", void (re.anyOf !== void 0 && console.warn(`oneOf and anyOf are not supported on the same level. Skipping anyOf at ${this.pointer}`));
              if (re.anyOf !== void 0) return this.initOneOf(re.anyOf, c), void (this.oneOfType = "Any of");
              if (this.hasType("object")) this.fields = ox(c, re, this.pointer, this.options, this.refsStack);
              else if (this.hasType("array") && (G(re.items) || G(re.prefixItems) ? this.fields = ox(c, re, this.pointer, this.options, this.refsStack) : re.items && (this.items = new ku(c, re.items, this.pointer + "/items", this.options, !1, this.refsStack)), this.displayType = re.prefixItems || G(re.items) ? "items" : Up(((h = this.items) == null ? void 0 : h.displayType) || this.displayType), this.displayFormat = ((w = this.items) == null ? void 0 : w.format) || "", this.typePrefix = ((_ = this.items) == null ? void 0 : _.typePrefix) || "" + z("arrayOf"), this.title = this.title || ((T = this.items) == null ? void 0 : T.title) || "", this.isPrimitive = ((R = this.items) == null ? void 0 : R.isPrimitive) !== void 0 ? (W = this.items) == null ? void 0 : W.isPrimitive : this.isPrimitive, this.example === void 0 && ((Z = this.items) == null ? void 0 : Z.example) !== void 0 && (this.example = [this.items.example]), (ne = this.items) != null && ne.isPrimitive && (this.enum = this.items.enum), G(this.type))) {
                const ie = this.type.filter((me) => me !== "array");
                ie.length && (this.displayType += ` or ${ie.join(" or ")}`);
              }
              this.enum.length && this.options.sortEnumValuesAlphabetically && this.enum.sort();
            } else this.initDiscriminator(re, c);
          }
          initOneOf(c, p) {
            if (this.oneOf = c.map((h, w) => {
              const { resolved: _, refsStack: T } = p.deref(h, this.refsStack, !0), R = p.mergeAllOf(_, this.pointer + "/oneOf/" + w, T), W = To(h.$ref) && !R.title ? rt.baseName(h.$ref) : `${R.title || ""}${R.const !== void 0 && JSON.stringify(R.const) || ""}`;
              return new ku(p, vy(Fa({}, R), { title: W, allOf: [vy(Fa({}, this.schema), { oneOf: void 0, anyOf: void 0 })], discriminator: _.allOf ? void 0 : R.discriminator }), h.$ref || this.pointer + "/oneOf/" + w, this.options, !1, T);
            }), this.options.simpleOneOfTypeLabel) {
              const h = function(w) {
                const _ = /* @__PURE__ */ new Set();
                return function T(R) {
                  for (const W of R.oneOf || []) W.oneOf ? T(W) : W.type && _.add(W.type);
                }(w), Array.from(_.values());
              }(this);
              this.displayType = h.join(" or ");
            } else this.displayType = this.oneOf.map((h) => {
              let w = h.typePrefix + (h.title ? `${h.title} (${h.displayType})` : h.displayType);
              return w.indexOf(" or ") > -1 && (w = `(${w})`), w;
            }).join(" or ");
          }
          initDiscriminator(c, p) {
            const h = sx(c);
            this.discriminatorProp = h.propertyName;
            const w = p.findDerived([...this.schema["x-parentRefs"] || [], this.pointer]);
            if (c.oneOf) for (const re of c.oneOf) {
              if (re.$ref === void 0) continue;
              const ie = rt.baseName(re.$ref);
              w[re.$ref] = ie;
            }
            const _ = h.mapping || {};
            let T = h["x-explicitMappingOnly"] || !1;
            Object.keys(_).length === 0 && (T = !1);
            const R = {};
            for (const re in _) {
              const ie = _[re];
              G(R[ie]) ? R[ie].push(re) : R[ie] = [re];
            }
            const W = Fa(T ? {} : Fa({}, w), R);
            let Z = [];
            for (const re of Object.keys(W)) {
              const ie = W[re];
              if (G(ie)) for (const me of ie) Z.push({ $ref: re, name: me });
              else Z.push({ $ref: re, name: ie });
            }
            const ne = Object.keys(_);
            ne.length !== 0 && (Z = Z.sort((re, ie) => {
              const me = ne.indexOf(re.name), Ie = ne.indexOf(ie.name);
              return me < 0 && Ie < 0 ? re.name.localeCompare(ie.name) : me < 0 ? 1 : Ie < 0 ? -1 : me - Ie;
            })), this.oneOf = Z.map(({ $ref: re, name: ie }) => {
              const me = new ku(p, { $ref: re }, re, this.options, !0, this.refsStack.slice(0, -1));
              return me.title = ie, me;
            });
          }
          initConditionalOperators(c, p) {
            const h = c, { if: w, else: _ = {}, then: T = {} } = h, R = ((Z, ne) => {
              var re = {};
              for (var ie in Z) tx.call(Z, ie) && ne.indexOf(ie) < 0 && (re[ie] = Z[ie]);
              if (Z != null && af) for (var ie of af(Z)) ne.indexOf(ie) < 0 && rx.call(Z, ie) && (re[ie] = Z[ie]);
              return re;
            })(h, ["if", "else", "then"]), W = [{ allOf: [R, T, w], title: w && w["x-displayName"] || (w == null ? void 0 : w.title) || "case 1" }, { allOf: [R, _], title: _ && _["x-displayName"] || (_ == null ? void 0 : _.title) || "case 2" }];
            this.oneOf = W.map((Z, ne) => new ku(p, Fa({}, Z), this.pointer + "/oneOf/" + ne, this.options, !1, this.refsStack)), this.oneOfType = "One of";
          }
        };
        let Au = ku;
        function ox(c, p, h, w, _) {
          const T = p.properties || p.prefixItems || p.items || {}, R = p.patternProperties || {}, W = p.additionalProperties || p.unevaluatedProperties, Z = p.prefixItems ? p.items : p.additionalItems, ne = p.default;
          let re = Object.keys(T || []).map((ie) => {
            let me = T[ie];
            me || (console.warn(`Field "${ie}" is invalid, skipping.
 Field must be an object but got ${typeof me} at "${h}"`), me = {});
            const Ie = p.required !== void 0 && p.required.indexOf(ie) > -1;
            return new ln(c, { name: p.properties ? ie : `[${ie}]`, required: Ie, schema: vy(Fa({}, me), { default: me.default === void 0 && ne ? ne[ie] : me.default }) }, h + "/properties/" + ie, w, _);
          });
          return w.sortPropsAlphabetically && (re = di(re, "name")), w.requiredPropsFirst && (re = Bi(re, w.sortPropsAlphabetically ? void 0 : p.required)), re.push(...Object.keys(R).map((ie) => {
            let me = R[ie];
            return me || (console.warn(`Field "${ie}" is invalid, skipping.
 Field must be an object but got ${typeof me} at "${h}"`), me = {}), new ln(c, { name: ie, required: !1, schema: me, kind: "patternProperties" }, `${h}/patternProperties/${ie}`, w, _);
          })), typeof W != "object" && W !== !0 || re.push(new ln(c, { name: (typeof W == "object" && W["x-additionalPropertiesName"] || "property name").concat("*"), required: !1, schema: W === !0 ? {} : W, kind: "additionalProperties" }, h + "/additionalProperties", w, _)), re.push(...function({ parser: ie, schema: me = !1, fieldsCount: Ie, $ref: Fe, options: vt, refsStack: Pt }) {
            return ee(me) ? me ? [new ln(ie, { name: `[${Ie}...]`, schema: {} }, `${Fe}/additionalItems`, vt, Pt)] : [] : G(me) ? [...me.map((it, un) => new ln(ie, { name: `[${Ie + un}]`, schema: it }, `${Fe}/additionalItems`, vt, Pt))] : $(me) ? [new ln(ie, { name: `[${Ie}...]`, schema: me }, `${Fe}/additionalItems`, vt, Pt)] : [];
          }({ parser: c, schema: Z, fieldsCount: re.length, $ref: h, options: w, refsStack: _ })), re;
        }
        function sx(c) {
          return c.discriminator || c["x-discriminator"];
        }
        ix([D.observable], Au.prototype, "activeOneOf", 2), ix([D.action], Au.prototype, "activateOneOf", 1);
        const by = {};
        class za {
          constructor(p, h, w, _) {
            this.mime = w;
            const { resolved: T } = p.deref(h);
            this.value = T.value, this.summary = T.summary, this.description = T.description, T.externalValue && (this.externalValueUrl = new URL(T.externalValue, p.specUrl).href), Aa(w) && this.value && typeof this.value == "object" && (this.value = Pa(this.value, _));
          }
          getExternalValue(p) {
            return this.externalValueUrl ? (this.externalValueUrl in by || (by[this.externalValueUrl] = fetch(this.externalValueUrl).then((h) => h.text().then((w) => {
              if (!h.ok) return Promise.reject(new Error(w));
              if (!Po(p)) return w;
              try {
                return JSON.parse(w);
              } catch {
                return w;
              }
            }))), by[this.externalValueUrl]) : Promise.resolve(void 0);
          }
        }
        var l2 = Object.defineProperty, u2 = Object.getOwnPropertyDescriptor, lf = (c, p, h, w) => {
          for (var _, T = w > 1 ? void 0 : w ? u2(p, h) : p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = (w ? _(p, h, T) : _(T)) || T);
          return w && T && l2(p, h, T), T;
        };
        const ax = { path: { style: "simple", explode: !1 }, query: { style: "form", explode: !0 }, header: { style: "simple", explode: !1 }, cookie: { style: "form", explode: !0 } };
        class ln {
          constructor(p, h, w, _, T) {
            var R, W, Z, ne, re;
            this.expanded = void 0, (0, D.makeObservable)(this);
            const { resolved: ie } = p.deref(h);
            this.kind = h.kind || "field", this.name = h.name || ie.name, this.in = ie.in, this.required = !!ie.required;
            let me = ie.schema, Ie = "";
            if (!me && ie.in && ie.content && (Ie = Object.keys(ie.content)[0], me = ie.content[Ie] && ie.content[Ie].schema), this.schema = new Au(p, me || {}, w, _, !1, T), this.description = ie.description === void 0 ? this.schema.description || "" : ie.description, this.example = ie.example || this.schema.example, ie.examples !== void 0 || this.schema.examples !== void 0) {
              const Fe = ie.examples || this.schema.examples;
              this.examples = G(Fe) ? Fe : x(Fe, (vt, Pt) => new za(p, vt, Pt, ie.encoding));
            }
            Ie ? this.serializationMime = Ie : ie.style ? this.style = ie.style : this.in && (this.style = (W = (R = ax[this.in]) == null ? void 0 : R.style) != null ? W : "form"), ie.explode === void 0 && this.in ? this.explode = (ne = (Z = ax[this.in]) == null ? void 0 : Z.explode) == null || ne : this.explode = !!ie.explode, this.deprecated = ie.deprecated === void 0 ? !!this.schema.deprecated : ie.deprecated, _.showExtensions && (this.extensions = Vi(ie, _.showExtensions)), this.const = ((re = this.schema) == null ? void 0 : re.const) || (ie == null ? void 0 : ie.const) || "";
          }
          toggle() {
            this.expanded = !this.expanded;
          }
          collapse() {
            this.expanded = !1;
          }
          expand() {
            this.expanded = !0;
          }
        }
        lf([D.observable], ln.prototype, "expanded", 2), lf([D.action], ln.prototype, "toggle", 1), lf([D.action], ln.prototype, "collapse", 1), lf([D.action], ln.prototype, "expand", 1);
        var lx = NX;
        class wy {
          constructor(p, h, w, _, T) {
            this.name = h, this.isRequestType = w, this.schema = _.schema && new Au(p, _.schema, "", T), this.onlyRequiredInSamples = T.onlyRequiredInSamples, this.generatedPayloadSamplesMaxDepth = T.generatedPayloadSamplesMaxDepth, _.examples !== void 0 ? this.examples = x(_.examples, (R) => new za(p, R, h, _.encoding)) : _.example !== void 0 ? this.examples = { default: new za(p, { value: p.deref(_.example).resolved }, h, _.encoding) } : Po(h) && this.generateExample(p, _);
          }
          generateExample(p, h) {
            const w = { skipReadOnly: this.isRequestType, skipWriteOnly: !this.isRequestType, skipNonRequired: this.isRequestType && this.onlyRequiredInSamples, maxSampleDepth: this.generatedPayloadSamplesMaxDepth };
            if (this.schema && this.schema.oneOf) {
              this.examples = {};
              for (const _ of this.schema.oneOf) {
                const T = lx.sample(_.rawSchema, w, p.spec);
                this.schema.discriminatorProp && typeof T == "object" && T && (T[this.schema.discriminatorProp] = _.title), this.examples[_.title] = new za(p, { value: T }, this.name, h.encoding);
              }
            } else this.schema && (this.examples = { default: new za(p, { value: lx.sample(h.schema, w, p.spec) }, this.name, h.encoding) });
          }
        }
        var c2 = Object.defineProperty, p2 = Object.getOwnPropertyDescriptor, Sy = (c, p, h, w) => {
          for (var _, T = w > 1 ? void 0 : w ? p2(p, h) : p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = (w ? _(p, h, T) : _(T)) || T);
          return w && T && c2(p, h, T), T;
        };
        class qa {
          constructor(p, h, w, _) {
            this.isRequestType = w, this.activeMimeIdx = 0, (0, D.makeObservable)(this), _.unstable_ignoreMimeParameters && (h = bu(h)), this.mediaTypes = Object.keys(h).map((T) => {
              const R = h[T];
              return new wy(p, T, w, R, _);
            });
          }
          activate(p) {
            this.activeMimeIdx = p;
          }
          get active() {
            return this.mediaTypes[this.activeMimeIdx];
          }
          get hasSample() {
            return this.mediaTypes.filter((p) => !!p.examples).length > 0;
          }
        }
        Sy([D.observable], qa.prototype, "activeMimeIdx", 2), Sy([D.action], qa.prototype, "activate", 1), Sy([D.computed], qa.prototype, "active", 1);
        class ux {
          constructor({ parser: p, infoOrRef: h, options: w, isEvent: _ }) {
            const T = !_, { resolved: R } = p.deref(h);
            this.description = R.description || "", this.required = R.required;
            const W = Ps(R);
            W !== void 0 && (this.content = new qa(p, W, T, w));
          }
        }
        var cx = Object.defineProperty, f2 = Object.defineProperties, d2 = Object.getOwnPropertyDescriptor, h2 = Object.getOwnPropertyDescriptors, px = Object.getOwnPropertySymbols, m2 = Object.prototype.hasOwnProperty, g2 = Object.prototype.propertyIsEnumerable, fx = (c, p, h) => p in c ? cx(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h, dx = (c, p, h, w) => {
          for (var _, T = w > 1 ? void 0 : w ? d2(p, h) : p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = (w ? _(p, h, T) : _(T)) || T);
          return w && T && cx(p, h, T), T;
        };
        class uf {
          constructor({ parser: p, code: h, defaultAsError: w, infoOrRef: _, options: T, isEvent: R }) {
            this.expanded = !1, this.headers = [], (0, D.makeObservable)(this), this.expanded = T.expandResponses === "all" || T.expandResponses[h];
            const { resolved: W } = p.deref(_);
            this.code = h, W.content !== void 0 && (this.content = new qa(p, W.content, R, T)), W["x-summary"] !== void 0 ? (this.summary = W["x-summary"], this.description = W.description || "") : (this.summary = W.description || "", this.description = ""), this.type = Qt(h, w);
            const Z = W.headers;
            Z !== void 0 && (this.headers = Object.keys(Z).map((ne) => {
              const re = Z[ne];
              return new ln(p, (ie = ((me, Ie) => {
                for (var Fe in Ie || (Ie = {})) m2.call(Ie, Fe) && fx(me, Fe, Ie[Fe]);
                if (px) for (var Fe of px(Ie)) g2.call(Ie, Fe) && fx(me, Fe, Ie[Fe]);
                return me;
              })({}, re), f2(ie, h2({ name: ne }))), "", T);
              var ie;
            })), T.showExtensions && (this.extensions = Vi(W, T.showExtensions));
          }
          toggle() {
            this.expanded = !this.expanded;
          }
        }
        dx([D.observable], uf.prototype, "expanded", 2), dx([D.action], uf.prototype, "toggle", 1);
        var y2 = Object.defineProperty, v2 = Object.getOwnPropertyDescriptor, Vn = (c, p, h, w) => {
          for (var _, T = w > 1 ? void 0 : w ? v2(p, h) : p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = (w ? _(p, h, T) : _(T)) || T);
          return w && T && y2(p, h, T), T;
        };
        function xy(c) {
          return c.lang === "payload" && c.requestBodyContent;
        }
        let hx = !1;
        class Mr {
          constructor(p, h, w, _, T = !1) {
            this.parser = p, this.operationSpec = h, this.options = _, this.type = "operation", this.items = [], this.ready = !0, this.active = !1, this.expanded = !1, (0, D.makeObservable)(this), this.pointer = h.pointer, this.description = h.description, this.parent = w, this.externalDocs = h.externalDocs, this.deprecated = !!h.deprecated, this.httpVerb = h.httpVerb, this.deprecated = !!h.deprecated, this.operationId = h.operationId, this.path = h.pathName, this.isCallback = T, this.isWebhook = h.isWebhook, this.isEvent = this.isCallback || this.isWebhook, this.name = gu(h), this.sidebarLabel = _.sideNavStyle === te.IdOnly ? this.operationId || this.path : _.sideNavStyle === te.PathOnly ? this.path : this.name, this.isCallback ? (this.security = (h.security || []).map((R) => new W1(R, p)), this.servers = Ra("", h.servers || h.pathServers || [])) : (this.operationHash = h.operationId && "operation/" + h.operationId, this.id = h.operationId !== void 0 ? (w ? w.id + "/" : "") + this.operationHash : w !== void 0 ? w.id + this.pointer : this.pointer, this.security = (h.security || p.spec.security || []).map((R) => new W1(R, p)), this.servers = Ra(p.specUrl, h.servers || h.pathServers || p.spec.servers || [])), _.showExtensions && (this.extensions = Vi(h, _.showExtensions));
          }
          activate() {
            this.active = !0;
          }
          deactivate() {
            this.active = !1;
          }
          toggle() {
            this.expanded = !this.expanded;
          }
          expand() {
            this.parent && this.parent.expand();
          }
          collapse() {
          }
          get requestBody() {
            return this.operationSpec.requestBody && new ux({ parser: this.parser, infoOrRef: this.operationSpec.requestBody, options: this.options, isEvent: this.isEvent });
          }
          get codeSamples() {
            const { payloadSampleIdx: p, hideRequestPayloadSample: h } = this.options;
            let w = this.operationSpec["x-codeSamples"] || this.operationSpec["x-code-samples"] || [];
            this.operationSpec["x-code-samples"] && !hx && (hx = !0, console.warn('"x-code-samples" is deprecated. Use "x-codeSamples" instead'));
            const _ = this.requestBody && this.requestBody.content;
            if (_ && _.hasSample && !h) {
              const T = Math.min(w.length, p);
              w = [...w.slice(0, T), { lang: "payload", label: "Payload", source: "", requestBodyContent: _ }, ...w.slice(T)];
            }
            return w;
          }
          get parameters() {
            const p = Ui(this.parser, this.operationSpec.pathParameters, this.operationSpec.parameters).map((h) => new ln(this.parser, h, this.pointer, this.options));
            return this.options.sortPropsAlphabetically ? di(p, "name") : this.options.requiredPropsFirst ? Bi(p) : p;
          }
          get responses() {
            let p = !1;
            return Object.keys(this.operationSpec.responses || []).filter((h) => h === "default" || (Qt(h) === "success" && (p = !0), mu(h))).map((h) => new uf({ parser: this.parser, code: h, defaultAsError: p, infoOrRef: this.operationSpec.responses[h], options: this.options, isEvent: this.isEvent }));
          }
          get callbacks() {
            return Object.keys(this.operationSpec.callbacks || []).map((p) => new tf(this.parser, p, this.operationSpec.callbacks[p], this.pointer, this.options));
          }
        }
        Vn([D.observable], Mr.prototype, "ready", 2), Vn([D.observable], Mr.prototype, "active", 2), Vn([D.observable], Mr.prototype, "expanded", 2), Vn([D.action], Mr.prototype, "activate", 1), Vn([D.action], Mr.prototype, "deactivate", 1), Vn([D.action], Mr.prototype, "toggle", 1), Vn([yi], Mr.prototype, "requestBody", 1), Vn([yi], Mr.prototype, "codeSamples", 1), Vn([yi], Mr.prototype, "parameters", 1), Vn([yi], Mr.prototype, "responses", 1), Vn([yi], Mr.prototype, "callbacks", 1);
        var b2 = Object.defineProperty, w2 = Object.defineProperties, S2 = Object.getOwnPropertyDescriptors, mx = Object.getOwnPropertySymbols, x2 = Object.prototype.hasOwnProperty, E2 = Object.prototype.propertyIsEnumerable, gx = (c, p, h) => p in c ? b2(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h, _2 = (c, p) => {
          for (var h in p || (p = {})) x2.call(p, h) && gx(c, h, p[h]);
          if (mx) for (var h of mx(p)) E2.call(p, h) && gx(c, h, p[h]);
          return c;
        };
        class O2 {
          constructor(p, h, w) {
            this.operations = [];
            const { resolved: _ } = p.deref(w || {});
            this.initWebhooks(p, _, h);
          }
          initWebhooks(p, h, w) {
            for (const T of Object.keys(h)) {
              const R = h[T], W = Object.keys(R).filter(Yt);
              for (const Z of W) {
                const ne = R[Z];
                if (R.$ref) {
                  const ie = p.deref(R || {});
                  this.initWebhooks(p, { [Z]: ie }, w);
                }
                if (!ne) continue;
                const re = new Mr(p, (_ = _2({}, ne), w2(_, S2({ httpVerb: Z }))), void 0, w, !1);
                this.operations.push(re);
              }
            }
            var _;
          }
        }
        class yx {
          constructor(p, h, w) {
            const { resolved: _ } = p.deref(w);
            this.id = h, this.sectionId = hi + h, this.type = _.type, this.displayName = _["x-displayName"] || h, this.description = _.description || "", _.type === "apiKey" && (this.apiKey = { name: _.name, in: _.in }), _.type === "http" && (this.http = { scheme: _.scheme, bearerFormat: _.bearerFormat }), _.type === "openIdConnect" && (this.openId = { connectUrl: _.openIdConnectUrl }), _.type === "oauth2" && _.flows && (this.flows = _.flows);
          }
        }
        class vx {
          constructor(p) {
            const h = p.spec.components && p.spec.components.securitySchemes || {};
            this.schemes = Object.keys(h).map((w) => new yx(p, w, h[w]));
          }
        }
        var k2 = Object.defineProperty, bx = Object.getOwnPropertySymbols, A2 = Object.prototype.hasOwnProperty, P2 = Object.prototype.propertyIsEnumerable, wx = (c, p, h) => p in c ? k2(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h, Sx = (c, p) => {
          for (var h in p || (p = {})) A2.call(p, h) && wx(c, h, p[h]);
          if (bx) for (var h of bx(p)) P2.call(p, h) && wx(c, h, p[h]);
          return c;
        };
        class xx {
          constructor(p, h, w) {
            var _, T, R;
            this.options = w, this.parser = new Z1(p, h, w), this.info = new B1(this.parser, this.options), this.externalDocs = this.parser.spec.externalDocs, this.contentItems = vi.buildStructure(this.parser, this.options), this.securitySchemes = new vx(this.parser);
            const W = Sx(Sx({}, (T = (_ = this.parser) == null ? void 0 : _.spec) == null ? void 0 : T["x-webhooks"]), (R = this.parser) == null ? void 0 : R.spec.webhooks);
            this.webhooks = new O2(this.parser, w, W);
          }
        }
        var T2 = Object.defineProperty, C2 = Object.getOwnPropertyDescriptor, Ba = (c, p, h, w) => {
          for (var _, T = w > 1 ? void 0 : w ? C2(p, h) : p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = (w ? _(p, h, T) : _(T)) || T);
          return w && T && T2(p, h, T), T;
        };
        class Wn {
          constructor(p, h, w) {
            this.items = [], this.active = !1, this.expanded = !1, (0, D.makeObservable)(this), this.id = h.id || p + "/" + F(h.name), this.type = p, this.name = h["x-displayName"] || h.name, this.level = h.level || 1, this.sidebarLabel = this.name, this.description = h.description || "";
            const _ = h.items;
            _ && _.length && (this.description = Da.getTextBeforeHading(this.description, _[0].name)), this.parent = w, this.externalDocs = h.externalDocs, this.type === "group" && (this.expanded = !0);
          }
          activate() {
            this.active = !0;
          }
          expand() {
            this.parent && this.parent.expand(), this.expanded = !0;
          }
          collapse() {
            this.type !== "group" && (this.expanded = !1);
          }
          deactivate() {
            this.active = !1;
          }
        }
        Ba([D.observable], Wn.prototype, "active", 2), Ba([D.observable], Wn.prototype, "expanded", 2), Ba([D.action], Wn.prototype, "activate", 1), Ba([D.action], Wn.prototype, "expand", 1), Ba([D.action], Wn.prototype, "collapse", 1), Ba([D.action], Wn.prototype, "deactivate", 1);
        var $2 = Object.defineProperty, R2 = Object.defineProperties, I2 = Object.getOwnPropertyDescriptors, Ex = Object.getOwnPropertySymbols, N2 = Object.prototype.hasOwnProperty, j2 = Object.prototype.propertyIsEnumerable, _x = (c, p, h) => p in c ? $2(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h, Ox = (c, p) => {
          for (var h in p || (p = {})) N2.call(p, h) && _x(c, h, p[h]);
          if (Ex) for (var h of Ex(p)) j2.call(p, h) && _x(c, h, p[h]);
          return c;
        }, kx = (c, p) => R2(c, I2(p));
        const cf = 0;
        class vi {
          static buildStructure(p, h) {
            const w = p.spec, _ = [], T = vi.getTagsWithOperations(p, w);
            return _.push(...vi.addMarkdownItems(w.info.description || "", void 0, 1, h)), w["x-tagGroups"] && w["x-tagGroups"].length > 0 ? _.push(...vi.getTagGroupsItems(p, void 0, w["x-tagGroups"], T, h)) : _.push(...vi.getTagsItems(p, T, void 0, void 0, h)), _;
          }
          static addMarkdownItems(p, h, w, _) {
            const T = new Da(_, h == null ? void 0 : h.id).extractHeadings(p || "");
            T.length && h && h.description && (h.description = Da.getTextBeforeHading(h.description, T[0].name));
            const R = (W, Z, ne = 1) => Z.map((re) => {
              const ie = new Wn("section", re, W);
              return ie.depth = ne, re.items && (ie.items = R(ie, re.items, ne + 1)), ie;
            });
            return R(h, T, w);
          }
          static getTagGroupsItems(p, h, w, _, T) {
            const R = [];
            for (const W of w) {
              const Z = new Wn("group", W, h);
              Z.depth = cf, Z.items = vi.getTagsItems(p, _, Z, W, T), R.push(Z);
            }
            return R;
          }
          static getTagsItems(p, h, w, _, T) {
            let R;
            R = _ === void 0 ? Object.keys(h) : _.tags;
            const W = R.map((ne) => h[ne] ? (h[ne].used = !0, h[ne]) : (console.warn(`Non-existing tag "${ne}" is added to the group "${_.name}"`), null)), Z = [];
            for (const ne of W) {
              if (!ne) continue;
              const re = new Wn("tag", ne, w);
              if (re.depth = cf + 1, ne.name === "") {
                const me = [...vi.addMarkdownItems(ne.description || "", re, re.depth + 1, T), ...this.getOperationsItems(p, void 0, ne, re.depth + 1, T)];
                Z.push(...me);
                continue;
              }
              const ie = this.getTagRelatedSchema({ parser: p, tag: ne, parent: re });
              re.items = [...ie, ...vi.addMarkdownItems(ne.description || "", re, re.depth + 1, T), ...this.getOperationsItems(p, re, ne, re.depth + 1, T)], Z.push(re);
            }
            return T.sortTagsAlphabetically && Z.sort(ja("name")), Z;
          }
          static getOperationsItems(p, h, w, _, T) {
            if (w.operations.length === 0) return [];
            const R = [];
            for (const W of w.operations) {
              const Z = new Mr(p, W, h, T);
              Z.depth = _, R.push(Z);
            }
            return T.sortOperationsAlphabetically && R.sort(ja("name")), R;
          }
          static getTagsWithOperations(p, h) {
            const w = {}, _ = h["x-webhooks"] || h.webhooks;
            for (const R of h.tags || []) w[R.name] = kx(Ox({}, R), { operations: [] });
            function T(R, W, Z) {
              for (const ne of Object.keys(W)) {
                const re = W[ne], ie = Object.keys(re).filter(Yt);
                for (const me of ie) {
                  const Ie = re[me];
                  if (re.$ref) {
                    const { resolved: vt } = R.deref(re);
                    T(R, { [ne]: vt }, Z);
                    continue;
                  }
                  let Fe = Ie == null ? void 0 : Ie.tags;
                  Fe && Fe.length || (Fe = [""]);
                  for (const vt of Fe) {
                    let Pt = w[vt];
                    Pt === void 0 && (Pt = { name: vt, operations: [] }, w[vt] = Pt), Pt["x-traitTag"] || Pt.operations.push(kx(Ox({}, Ie), { pathName: ne, pointer: rt.compile(["paths", ne, me]), httpVerb: me, pathParameters: re.parameters || [], pathServers: re.servers, isWebhook: !!Z }));
                  }
                }
              }
            }
            return _ && T(p, _, !0), h.paths && T(p, h.paths), w;
          }
          static getTagRelatedSchema({ parser: p, tag: h, parent: w }) {
            var _;
            return Object.entries(((_ = p.spec.components) == null ? void 0 : _.schemas) || {}).map(([T, R]) => {
              const W = R["x-tags"];
              if (!(W != null && W.includes(h.name))) return null;
              const Z = new Wn("schema", { name: T, "x-displayName": `${R.title || T}`, description: `<SchemaDefinition showWriteOnly={true} schemaRef="#/components/schemas/${T}" />` }, w);
              return Z.depth = w.depth + 1, Z;
            }).filter(Boolean);
          }
        }
        var L2 = Object.defineProperty, M2 = Object.getOwnPropertyDescriptor, Ua = (c, p, h, w) => {
          for (var _, T = w > 1 ? void 0 : w ? M2(p, h) : p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = (w ? _(p, h, T) : _(T)) || T);
          return w && T && L2(p, h, T), T;
        };
        const Is = "data-section-id";
        class Hi {
          constructor(p, h, w) {
            this.scroll = h, this.history = w, this.activeItemIdx = -1, this.sideBarOpened = !1, this.updateOnScroll = (_) => {
              const T = _ ? 1 : -1;
              let R = this.activeItemIdx;
              for (; (R !== -1 || _) && !(R >= this.flatItems.length - 1 && _); ) {
                if (_) {
                  const W = this.getElementAtOrFirstChild(R + 1);
                  if (this.scroll.isElementBellow(W)) break;
                } else {
                  const W = this.getElementAt(R);
                  if (this.scroll.isElementAbove(W)) break;
                }
                R += T;
              }
              this.activate(this.flatItems[R], !0, !0);
            }, this.updateOnHistory = (_ = this.history.currentId) => {
              if (!_) return;
              let T;
              T = this.flatItems.find((R) => R.id === _), T ? this.activateAndScroll(T, !1) : (_.startsWith(hi) && (T = this.flatItems.find((R) => hi.startsWith(R.id)), this.activateAndScroll(T, !1)), this.scroll.scrollIntoViewBySelector(`[${Is}="${ce(_)}"]`));
            }, this.getItemById = (_) => this.flatItems.find((T) => T.id === _), (0, D.makeObservable)(this), this.items = p.contentItems, this.flatItems = g(this.items || [], "items"), this.flatItems.forEach((_, T) => _.absoluteIdx = T), this.subscribe();
          }
          static updateOnHistory(p = $s.currentId, h) {
            p && h.scrollIntoViewBySelector(`[${Is}="${ce(p)}"]`);
          }
          subscribe() {
            this._unsubscribe = this.scroll.subscribe(this.updateOnScroll), this._hashUnsubscribe = this.history.subscribe(this.updateOnHistory);
          }
          toggleSidebar() {
            this.sideBarOpened = !this.sideBarOpened;
          }
          closeSidebar() {
            this.sideBarOpened = !1;
          }
          getElementAt(p) {
            const h = this.flatItems[p];
            return h && d(`[${Is}="${ce(h.id)}"]`) || null;
          }
          getElementAtOrFirstChild(p) {
            let h = this.flatItems[p];
            return h && h.type === "group" && (h = h.items[0]), h && d(`[${Is}="${ce(h.id)}"]`) || null;
          }
          get activeItem() {
            return this.flatItems[this.activeItemIdx] || void 0;
          }
          activate(p, h = !0, w = !1) {
            if ((this.activeItem && this.activeItem.id) !== (p && p.id) && (!p || p.type !== "group")) {
              if (this.deactivate(this.activeItem), !p) return this.activeItemIdx = -1, void this.history.replace("", w);
              p.depth <= cf || (this.activeItemIdx = p.absoluteIdx, h && this.history.replace(encodeURI(p.id), w), p.activate(), p.expand());
            }
          }
          deactivate(p) {
            if (p !== void 0) for (p.deactivate(); p !== void 0; ) p.collapse(), p = p.parent;
          }
          activateAndScroll(p, h, w) {
            const _ = p && this.getItemById(p.id) || p;
            this.activate(_, h, w), this.scrollToActive(), _ && _.items.length || this.closeSidebar();
          }
          scrollToActive() {
            this.scroll.scrollIntoView(this.getElementAt(this.activeItemIdx));
          }
          dispose() {
            this._unsubscribe(), this._hashUnsubscribe();
          }
        }
        Ua([D.observable], Hi.prototype, "activeItemIdx", 2), Ua([D.observable], Hi.prototype, "sideBarOpened", 2), Ua([D.action], Hi.prototype, "toggleSidebar", 1), Ua([D.action], Hi.prototype, "closeSidebar", 1), Ua([D.action], Hi.prototype, "activate", 1), Ua([D.action.bound], Hi.prototype, "activateAndScroll", 1);
        var D2 = Object.defineProperty, F2 = Object.getOwnPropertyDescriptor;
        const pf = "scroll";
        class Ey {
          constructor(p) {
            this.options = p, this._prevOffsetY = 0, this._scrollParent = f ? window : void 0, this._emiter = new Re.EventEmitter(), this.bind();
          }
          bind() {
            this._prevOffsetY = this.scrollY(), this._scrollParent && this._scrollParent.addEventListener("scroll", this.handleScroll);
          }
          dispose() {
            this._scrollParent && this._scrollParent.removeEventListener("scroll", this.handleScroll), this._emiter.removeAllListeners(pf);
          }
          scrollY() {
            return typeof HTMLElement < "u" && this._scrollParent instanceof HTMLElement ? this._scrollParent.scrollTop : this._scrollParent !== void 0 ? this._scrollParent.pageYOffset : 0;
          }
          isElementBellow(p) {
            if (p !== null) return p.getBoundingClientRect().top > this.options.scrollYOffset();
          }
          isElementAbove(p) {
            if (p === null) return;
            const h = p.getBoundingClientRect().top;
            return (h > 0 ? Math.floor(h) : Math.ceil(h)) <= this.options.scrollYOffset();
          }
          subscribe(p) {
            const h = this._emiter.addListener(pf, p);
            return () => h.removeListener(pf, p);
          }
          scrollIntoView(p) {
            p !== null && (p.scrollIntoView(), this._scrollParent && this._scrollParent.scrollBy && this._scrollParent.scrollBy(0, 1 - this.options.scrollYOffset()));
          }
          scrollIntoViewBySelector(p) {
            const h = d(p);
            this.scrollIntoView(h);
          }
          handleScroll() {
            const p = this.scrollY() - this._prevOffsetY > 0;
            this._prevOffsetY = this.scrollY(), this._emiter.emit(pf, p);
          }
        }
        ((c, p, h, w) => {
          for (var _, T = F2(p, h), R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = _(p, h, T) || T);
          T && D2(p, h, T);
        })([Pe.bind, Wp(100)], Ey.prototype, "handleScroll");
        class Ax {
          constructor() {
            this.searchWorker = function() {
              let p;
              if (f) try {
                p = i(595);
              } catch {
                p = i(388).ZP;
              }
              else p = i(388).ZP;
              return new p();
            }();
          }
          indexItems(p) {
            const h = (w) => {
              w.forEach((_) => {
                _.type !== "group" && this.add(_.name, (_.description || "").concat(" ", _.path || ""), _.id), h(_.items);
              });
            };
            h(p), this.searchWorker.done();
          }
          add(p, h, w) {
            this.searchWorker.add(p, h, w);
          }
          dispose() {
            this.searchWorker.terminate(), this.searchWorker.dispose();
          }
          search(p) {
            return this.searchWorker.search(p);
          }
          toJS() {
            return p = this, h = function* () {
              return this.searchWorker.toJS();
            }, new Promise((w, _) => {
              var T = (Z) => {
                try {
                  W(h.next(Z));
                } catch (ne) {
                  _(ne);
                }
              }, R = (Z) => {
                try {
                  W(h.throw(Z));
                } catch (ne) {
                  _(ne);
                }
              }, W = (Z) => Z.done ? w(Z.value) : Promise.resolve(Z.value).then(T, R);
              W((h = h.apply(p, null)).next());
            });
            var p, h;
          }
          load(p) {
            this.searchWorker.load(p);
          }
          fromExternalJS(p, h) {
            p && h && this.searchWorker.fromExternalJS(p, h);
          }
        }
        const No = M.div`
  width: calc(100% - ${(c) => c.theme.rightPanel.width});
  padding: 0 ${(c) => c.theme.spacing.sectionHorizontal}px;

  ${({ $compact: c, theme: p }) => O.lessThan("medium", !0)`
    width: 100%;
    padding: ${`${c ? 0 : p.spacing.sectionVertical}px ${p.spacing.sectionHorizontal}px`};
  `};
`, Pu = M.div.attrs((c) => ({ [Is]: c.id }))`
  padding: ${(c) => c.theme.spacing.sectionVertical}px 0;

  &:last-child {
    min-height: calc(100vh + 1px);
  }

  & > &:last-child {
    min-height: initial;
  }

  ${O.lessThan("medium", !0)`
    padding: 0;
  `}
  ${({ $underlined: c }) => c ? `
    position: relative;

    &:not(:last-of-type):after {
      position: absolute;
      bottom: 0;
      width: 100%;
      display: block;
      content: '';
      border-bottom: 1px solid rgba(0, 0, 0, 0.2);
    }
  ` : ""}
`, Px = M.div`
  width: ${(c) => c.theme.rightPanel.width};
  color: ${({ theme: c }) => c.rightPanel.textColor};
  background-color: ${(c) => c.theme.rightPanel.backgroundColor};
  padding: 0 ${(c) => c.theme.spacing.sectionHorizontal}px;

  ${O.lessThan("medium", !0)`
    width: 100%;
    padding: ${(c) => `${c.theme.spacing.sectionVertical}px ${c.theme.spacing.sectionHorizontal}px`};
  `};
`, Tx = M(Px)`
  background-color: ${(c) => c.theme.rightPanel.backgroundColor};
`, Ns = M.div`
  display: flex;
  width: 100%;
  padding: 0;

  ${O.lessThan("medium", !0)`
    flex-direction: column;
  `};
`, z2 = { 1: "1.85714em", 2: "1.57143em", 3: "1.27em" }, Tu = (c) => ye`
  font-family: ${({ theme: p }) => p.typography.headings.fontFamily};
  font-weight: ${({ theme: p }) => p.typography.headings.fontWeight};
  font-size: ${z2[c]};
  line-height: ${({ theme: p }) => p.typography.headings.lineHeight};
`, q2 = M.h1`
  ${Tu(1)};
  color: ${({ theme: c }) => c.colors.text.primary};

  ${se("H1")};
`, _y = M.h2`
  ${Tu(2)};
  color: ${({ theme: c }) => c.colors.text.primary};
  margin: 0 0 20px;

  ${se("H2")};
`, B2 = M.h2`
  ${Tu(3)};
  color: ${({ theme: c }) => c.colors.text.primary};

  ${se("H3")};
`, Oy = M.h3`
  color: ${({ theme: c }) => c.rightPanel.textColor};

  ${se("RightPanelHeader")};
`, Cu = M.h5`
  border-bottom: 1px solid rgba(38, 50, 56, 0.3);
  margin: 1em 0 1em 0;
  color: rgba(38, 50, 56, 0.5);
  font-weight: normal;
  text-transform: uppercase;
  font-size: 0.929em;
  line-height: 20px;

  ${se("UnderlinedHeader")};
`;
        var U2 = (c, p, h) => new Promise((w, _) => {
          var T = (Z) => {
            try {
              W(h.next(Z));
            } catch (ne) {
              _(ne);
            }
          }, R = (Z) => {
            try {
              W(h.throw(Z));
            } catch (ne) {
              _(ne);
            }
          }, W = (Z) => Z.done ? w(Z.value) : Promise.resolve(Z.value).then(T, R);
          W((h = h.apply(c, p)).next());
        });
        const ff = (0, o.createContext)(void 0), { Provider: Cx, Consumer: $x } = ff;
        function Rx(c) {
          const { spec: p, specUrl: h, options: w, onLoaded: _, children: T } = c, [R, W] = o.useState(null), [Z, ne] = o.useState(null);
          if (Z) throw Z;
          o.useEffect(() => {
            (function() {
              U2(this, null, function* () {
                if (p || h) {
                  W(null);
                  try {
                    const ie = yield $e(p || h);
                    W(ie);
                  } catch (ie) {
                    throw _ && _(ie), ne(ie), ie;
                  }
                }
              });
            })();
          }, [p, h]);
          const re = o.useMemo(() => {
            if (!R) return null;
            try {
              return new Ha(R, h, w);
            } catch (ie) {
              throw _ && _(ie), ie;
            }
          }, [R, h, w]);
          return o.useEffect(() => {
            re && _ && _();
          }, [re, _]), T({ loading: !re, store: re });
        }
        function Ix() {
          return (0, o.useContext)(ff);
        }
        const Nx = (c) => ye`
  ${c} {
    cursor: pointer;
    margin-left: -20px;
    padding: 0;
    line-height: 1;
    width: 20px;
    display: inline-block;
    outline: 0;
  }
  ${c}:before {
    content: '';
    width: 15px;
    height: 15px;
    background-size: contain;
    background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgeD0iMCIgeT0iMCIgd2lkdGg9IjUxMiIgaGVpZ2h0PSI1MTIiIHZpZXdCb3g9IjAgMCA1MTIgNTEyIiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMCA1MTIgNTEyIiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSIjMDEwMTAxIiBkPSJNNDU5LjcgMjMzLjRsLTkwLjUgOTAuNWMtNTAgNTAtMTMxIDUwLTE4MSAwIC03LjktNy44LTE0LTE2LjctMTkuNC0yNS44bDQyLjEtNDIuMWMyLTIgNC41LTMuMiA2LjgtNC41IDIuOSA5LjkgOCAxOS4zIDE1LjggMjcuMiAyNSAyNSA2NS42IDI0LjkgOTAuNSAwbDkwLjUtOTAuNWMyNS0yNSAyNS02NS42IDAtOTAuNSAtMjQuOS0yNS02NS41LTI1LTkwLjUgMGwtMzIuMiAzMi4yYy0yNi4xLTEwLjItNTQuMi0xMi45LTgxLjYtOC45bDY4LjYtNjguNmM1MC01MCAxMzEtNTAgMTgxIDBDNTA5LjYgMTAyLjMgNTA5LjYgMTgzLjQgNDU5LjcgMjMzLjR6TTIyMC4zIDM4Mi4ybC0zMi4yIDMyLjJjLTI1IDI0LjktNjUuNiAyNC45LTkwLjUgMCAtMjUtMjUtMjUtNjUuNiAwLTkwLjVsOTAuNS05MC41YzI1LTI1IDY1LjUtMjUgOTAuNSAwIDcuOCA3LjggMTIuOSAxNy4yIDE1LjggMjcuMSAyLjQtMS40IDQuOC0yLjUgNi44LTQuNWw0Mi4xLTQyYy01LjQtOS4yLTExLjYtMTgtMTkuNC0yNS44IC01MC01MC0xMzEtNTAtMTgxIDBsLTkwLjUgOTAuNWMtNTAgNTAtNTAgMTMxIDAgMTgxIDUwIDUwIDEzMSA1MCAxODEgMGw2OC42LTY4LjZDMjc0LjYgMzk1LjEgMjQ2LjQgMzkyLjMgMjIwLjMgMzgyLjJ6Ii8+PC9zdmc+Cg==');
    opacity: 0.5;
    visibility: hidden;
    display: inline-block;
    vertical-align: middle;
  }

  h1:hover > ${c}::before, h2:hover > ${c}::before, ${c}:hover::before {
    visibility: visible;
  }
`, V2 = M(function(c) {
          const p = o.useContext(ff), h = o.useCallback((w) => {
            p && function(_, T, R) {
              T.defaultPrevented || T.button !== 0 || ((W) => !!(W.metaKey || W.altKey || W.ctrlKey || W.shiftKey))(T) || (T.preventDefault(), _.replace(encodeURI(R)));
            }(p.menu.history, w, c.to);
          }, [p, c.to]);
          return p ? o.createElement("a", { className: c.className, href: p.menu.history.linkForId(c.to), onClick: h, "aria-label": c.to }, c.children) : null;
        })`
  ${Nx("&")};
`;
        function ky(c) {
          return o.createElement(V2, { to: c.to });
        }
        const W2 = { left: "90deg", right: "-90deg", up: "-180deg", down: "0" }, Qi = M((c) => o.createElement("svg", { className: c.className, style: c.style, version: "1.1", viewBox: "0 0 24 24", x: "0", xmlns: "http://www.w3.org/2000/svg", y: "0", "aria-hidden": "true" }, o.createElement("polygon", { points: "17.3 8.3 12 13.6 6.7 8.3 5.3 9.7 12 16.4 18.7 9.7 " })))`
  height: ${(c) => c.size || "18px"};
  width: ${(c) => c.size || "18px"};
  min-width: ${(c) => c.size || "18px"};
  vertical-align: middle;
  float: ${(c) => c.float || ""};
  transition: transform 0.2s ease-out;
  transform: rotateZ(${(c) => W2[c.direction || "down"]});

  polygon {
    fill: ${({ color: c, theme: p }) => c && p.colors.responses[c] && p.colors.responses[c].color || c};
  }
`, $u = M.span`
  display: inline-block;
  padding: 2px 8px;
  margin: 0;
  background-color: ${(c) => c.theme.colors[c.type].main};
  color: ${(c) => c.theme.colors[c.type].contrastText};
  font-size: ${(c) => c.theme.typography.code.fontSize};
  vertical-align: middle;
  line-height: 1.6;
  border-radius: 4px;
  font-weight: ${({ theme: c }) => c.typography.fontWeightBold};
  font-size: 12px;
  + span[type] {
    margin-left: 4px;
  }
`, df = ye`
  text-decoration: line-through;
  color: #707070;
`, H2 = M.caption`
  text-align: right;
  font-size: 0.9em;
  font-weight: normal;
  color: ${(c) => c.theme.colors.text.secondary};
`, jx = M.td`
  border-left: 1px solid ${(c) => c.theme.schema.linesColor};
  box-sizing: border-box;
  position: relative;
  padding: 10px 10px 10px 0;

  ${O.lessThan("small")`
    display: block;
    overflow: hidden;
  `}

  tr:first-of-type > &,
  tr.last > & {
    border-left-width: 0;
    background-position: top left;
    background-repeat: no-repeat;
    background-size: 1px 100%;
  }

  tr:first-of-type > & {
    background-image: linear-gradient(
      to bottom,
      transparent 0%,
      transparent 22px,
      ${(c) => c.theme.schema.linesColor} 22px,
      ${(c) => c.theme.schema.linesColor} 100%
    );
  }

  tr.last > & {
    background-image: linear-gradient(
      to bottom,
      ${(c) => c.theme.schema.linesColor} 0%,
      ${(c) => c.theme.schema.linesColor} 22px,
      transparent 22px,
      transparent 100%
    );
  }

  tr.last + tr > & {
    border-left-color: transparent;
  }

  tr.last:first-child > & {
    background: none;
    border-left-color: transparent;
  }
`, Q2 = M(jx)`
  padding: 0;
`, Lx = M(jx)`
  vertical-align: top;
  line-height: 20px;
  white-space: nowrap;
  font-size: 13px;
  font-family: ${(c) => c.theme.typography.code.fontFamily};

  &.deprecated {
    ${df};
  }

  ${({ kind: c }) => c === "patternProperties" && ye`
      > span.property-name {
        display: inline-table;
        white-space: break-spaces;
        margin-right: 20px;

        ::before,
        ::after {
          content: '/';
          filter: opacity(0.2);
        }
      }
    `}

  ${({ kind: c = "" }) => ["field", "additionalProperties", "patternProperties"].includes(c) ? "" : "font-style: italic"};

  ${se("PropertyNameCell")};
`, Y2 = M.td`
  border-bottom: 1px solid #9fb4be;
  padding: 10px 0;
  width: ${(c) => c.theme.schema.defaultDetailsWidth};
  box-sizing: border-box;

  tr.expanded & {
    border-bottom: none;
  }

  ${O.lessThan("small")`
    padding: 0 20px;
    border-bottom: none;
    border-left: 1px solid ${(c) => c.theme.schema.linesColor};

    tr.last > & {
      border-left: none;
    }
  `}

  ${se("PropertyDetailsCell")};
`, Mx = M.span`
  color: ${(c) => c.theme.schema.linesColor};
  font-family: ${(c) => c.theme.typography.code.fontFamily};
  margin-right: 10px;

  &::before {
    content: '';
    display: inline-block;
    vertical-align: middle;
    width: 10px;
    height: 1px;
    background: ${(c) => c.theme.schema.linesColor};
  }

  &::after {
    content: '';
    display: inline-block;
    vertical-align: middle;
    width: 1px;
    background: ${(c) => c.theme.schema.linesColor};
    height: 7px;
  }
`, Gt = M.div`
  padding: ${({ theme: c }) => c.schema.nestingSpacing};
`, Ay = M.table`
  border-collapse: separate;
  border-radius: 3px;
  font-size: ${(c) => c.theme.typography.fontSize};

  border-spacing: 0;
  width: 100%;

  > tr {
    vertical-align: middle;
  }

  ${O.lessThan("small")`
    display: block;
    > tr, > tbody > tr {
      display: block;
    }
  `}

  ${O.lessThan("small", !1, " and (-ms-high-contrast:none)")`
    td {
      float: left;
      width: 100%;
    }
  `}

  &
    ${Gt},
    &
    ${Gt}
    ${Gt}
    ${Gt},
    &
    ${Gt}
    ${Gt}
    ${Gt}
    ${Gt}
    ${Gt} {
    margin: ${({ theme: c }) => c.schema.nestingSpacing};
    margin-right: 0;
    background: ${({ theme: c }) => c.schema.nestedBackground};
  }

  &
    ${Gt}
    ${Gt},
    &
    ${Gt}
    ${Gt}
    ${Gt}
    ${Gt},
    &
    ${Gt}
    ${Gt}
    ${Gt}
    ${Gt}
    ${Gt}
    ${Gt} {
    background: #ffffff;
  }
`, G2 = M.div`
  margin: 0 0 3px 0;
  display: inline-block;
`, K2 = M.span`
  font-size: 0.9em;
  margin-right: 10px;
  color: ${(c) => c.theme.colors.primary.main};
  font-family: ${(c) => c.theme.typography.headings.fontFamily};
}
`, X2 = M.button`
  display: inline-block;
  margin-right: 10px;
  margin-bottom: 5px;
  font-size: 0.8em;
  cursor: pointer;
  border: 1px solid ${(c) => c.theme.colors.primary.main};
  padding: 2px 10px;
  line-height: 1.5em;
  outline: none;
  &:focus {
    box-shadow: 0 0 0 1px ${(c) => c.theme.colors.primary.main};
  }

  ${({ $deprecated: c }) => c && df || ""};

  ${(c) => c.$active ? `
      color: white;
      background-color: ${c.theme.colors.primary.main};
      &:focus {
        box-shadow: none;
        background-color: ${(0, a.darken)(0.15, c.theme.colors.primary.main)};
      }
      ` : `
        color: ${c.theme.colors.primary.main};
        background-color: white;
      `}
`, J2 = M.div`
  font-size: 0.9em;
  font-family: ${(c) => c.theme.typography.code.fontFamily};
  &::after {
    content: ' [';
  }
`, Z2 = M.div`
  font-size: 0.9em;
  font-family: ${(c) => c.theme.typography.code.fontFamily};
  &::after {
    content: ']';
  }
`;
        var js = sJ;
        const Py = M(js.Tabs)`
  > ul {
    list-style: none;
    padding: 0;
    margin: 0;
    margin: 0 -5px;

    > li {
      padding: 5px 10px;
      display: inline-block;

      background-color: ${({ theme: c }) => c.codeBlock.backgroundColor};
      border-bottom: 1px solid rgba(0, 0, 0, 0.5);
      cursor: pointer;
      text-align: center;
      outline: none;
      color: ${({ theme: c }) => (0, a.darken)(c.colors.tonalOffset, c.rightPanel.textColor)};
      margin: 0
        ${({ theme: c }) => `${c.spacing.unit}px ${c.spacing.unit}px ${c.spacing.unit}px`};
      border: 1px solid ${({ theme: c }) => (0, a.darken)(0.05, c.codeBlock.backgroundColor)};
      border-radius: 5px;
      min-width: 60px;
      font-size: 0.9em;
      font-weight: bold;

      &.react-tabs__tab--selected {
        color: ${(c) => c.theme.colors.text.primary};
        background: ${({ theme: c }) => c.rightPanel.textColor};
        &:focus {
          outline: auto;
        }
      }

      &:only-child {
        flex: none;
        min-width: 100px;
      }

      &.tab-success {
        color: ${(c) => c.theme.colors.responses.success.tabTextColor};
      }

      &.tab-redirect {
        color: ${(c) => c.theme.colors.responses.redirect.tabTextColor};
      }

      &.tab-info {
        color: ${(c) => c.theme.colors.responses.info.tabTextColor};
      }

      &.tab-error {
        color: ${(c) => c.theme.colors.responses.error.tabTextColor};
      }
    }
  }
  > .react-tabs__tab-panel {
    background: ${({ theme: c }) => c.codeBlock.backgroundColor};
    & > div,
    & > pre {
      padding: ${(c) => 4 * c.theme.spacing.unit}px;
      margin: 0;
    }

    & > div > pre {
      padding: 0;
    }
  }
`, Ty = (M(Py)`
  > ul {
    display: block;
    > li {
      padding: 2px 5px;
      min-width: auto;
      margin: 0 15px 0 0;
      font-size: 13px;
      font-weight: normal;
      border-bottom: 1px dashed;
      color: ${({ theme: c }) => (0, a.darken)(c.colors.tonalOffset, c.rightPanel.textColor)};
      border-radius: 0;
      background: none;

      &:last-child {
        margin-right: 0;
      }

      &.react-tabs__tab--selected {
        color: ${({ theme: c }) => c.rightPanel.textColor};
        background: none;
      }
    }
  }
  > .react-tabs__tab-panel {
    & > div,
    & > pre {
      padding: ${(c) => 2 * c.theme.spacing.unit}px 0;
    }
  }
`, M.div`
  /**
  * Based on prism-dark.css
  */

  code[class*='language-'],
  pre[class*='language-'] {
    /* color: white;
    background: none; */
    text-shadow: 0 -0.1em 0.2em black;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;

    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;

    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
  }

  @media print {
    code[class*='language-'],
    pre[class*='language-'] {
      text-shadow: none;
    }
  }

  /* Code blocks */
  pre[class*='language-'] {
    padding: 1em;
    margin: 0.5em 0;
    overflow: auto;
  }

  .token.comment,
  .token.prolog,
  .token.doctype,
  .token.cdata {
    color: hsl(30, 20%, 50%);
  }

  .token.punctuation {
    opacity: 0.7;
  }

  .namespace {
    opacity: 0.7;
  }

  .token.property,
  .token.tag,
  .token.number,
  .token.constant,
  .token.symbol {
    color: #4a8bb3;
  }

  .token.boolean {
    color: #e64441;
  }

  .token.selector,
  .token.attr-name,
  .token.string,
  .token.char,
  .token.builtin,
  .token.inserted {
    color: #a0fbaa;
    & + a,
    & + a:visited {
      color: #4ed2ba;
      text-decoration: underline;
    }
  }

  .token.property.string {
    color: white;
  }

  .token.operator,
  .token.entity,
  .token.url,
  .token.variable {
    color: hsl(40, 90%, 60%);
  }

  .token.atrule,
  .token.attr-value,
  .token.keyword {
    color: hsl(350, 40%, 70%);
  }

  .token.regex,
  .token.important {
    color: #e90;
  }

  .token.important,
  .token.bold {
    font-weight: bold;
  }
  .token.italic {
    font-style: italic;
  }

  .token.entity {
    cursor: help;
  }

  .token.deleted {
    color: red;
  }

  ${se("Prism")};
`), hf = M.div`
  opacity: 0.7;
  transition: opacity 0.3s ease;
  text-align: right;
  &:focus-within {
    opacity: 1;
  }
  > button {
    background-color: transparent;
    border: 0;
    color: inherit;
    padding: 2px 10px;
    font-family: ${({ theme: c }) => c.typography.fontFamily};
    font-size: ${({ theme: c }) => c.typography.fontSize};
    line-height: ${({ theme: c }) => c.typography.lineHeight};
    cursor: pointer;
    outline: 0;

    :hover,
    :focus {
      background: rgba(255, 255, 255, 0.1);
    }
  }
`, eD = M.div`
  &:hover ${hf} {
    opacity: 1;
  }
`, Dx = M(Ty).attrs({ as: "pre" })`
  font-family: ${(c) => c.theme.typography.code.fontFamily};
  font-size: ${(c) => c.theme.typography.code.fontSize};
  overflow-x: auto;
  margin: 0;

  white-space: ${({ theme: c }) => c.typography.code.wrap ? "pre-wrap" : "pre"};
`;
        var Fx = wJ, tD = i.n(Fx), rD = Object.defineProperty, zx = Object.getOwnPropertySymbols, nD = Object.prototype.hasOwnProperty, iD = Object.prototype.propertyIsEnumerable, qx = (c, p, h) => p in c ? rD(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h;
        const oD = tD() || Fx;
        let Yi = "";
        f && (Yi = i(232), Yi = typeof Yi.toString == "function" && Yi.toString() || "", Yi = Yi === "[object Object]" ? "" : Yi);
        const sD = de`${Yi}`, aD = M.div`
  position: relative;
`;
        class lD extends o.Component {
          constructor() {
            super(...arguments), this.handleRef = (p) => {
              this._container = p;
            };
          }
          componentDidMount() {
            const p = this._container.parentElement && this._container.parentElement.scrollTop || 0;
            this.inst = new oD(this._container, this.props.options || {}), this._container.scrollTo && this._container.scrollTo(0, p);
          }
          componentDidUpdate() {
            this.inst.update();
          }
          componentWillUnmount() {
            this.inst.destroy();
          }
          render() {
            const { children: p, className: h, updateFn: w } = this.props;
            return w && w(this.componentDidUpdate.bind(this)), o.createElement(o.Fragment, null, Yi && o.createElement(sD, null), o.createElement(aD, { className: `scrollbar-container ${h}`, ref: this.handleRef }, p));
          }
        }
        function Bx(c) {
          return o.createElement(He.Consumer, null, (p) => p.nativeScrollbars ? o.createElement("div", { style: { overflow: "auto", overscrollBehavior: "contain", msOverflowStyle: "-ms-autohiding-scrollbar" } }, c.children) : o.createElement(lD, ((h, w) => {
            for (var _ in w || (w = {})) nD.call(w, _) && qx(h, _, w[_]);
            if (zx) for (var _ of zx(w)) iD.call(w, _) && qx(h, _, w[_]);
            return h;
          })({}, c), c.children));
        }
        const uD = M(({ className: c, style: p }) => o.createElement("svg", { className: c, style: p, xmlns: "http://www.w3.org/2000/svg", width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, o.createElement("polyline", { points: "6 9 12 15 18 9" })))`
  position: absolute;
  pointer-events: none;
  z-index: 1;
  top: 50%;
  -webkit-transform: translateY(-50%);
  -ms-transform: translateY(-50%);
  transform: translateY(-50%);
  right: 8px;
  margin: auto;
  text-align: center;
  polyline {
    color: ${(c) => c.variant === "dark" && "white"};
  }
`, cD = o.memo((c) => {
          const { options: p, onChange: h, placeholder: w, value: _ = "", variant: T, className: R } = c;
          return o.createElement("div", { className: R }, o.createElement(uD, { variant: T }), o.createElement("select", { onChange: (W) => {
            const { selectedIndex: Z } = W.target;
            h(p[w ? Z - 1 : Z]);
          }, value: _, className: "dropdown-select" }, w && o.createElement("option", { disabled: !0, hidden: !0, value: w }, w), p.map(({ idx: W, value: Z, title: ne }, re) => o.createElement("option", { key: W || Z + re, value: Z }, ne || Z))), o.createElement("label", null, _));
        }), mf = U()(cD)`
  label {
    box-sizing: border-box;
    min-width: 100px;
    outline: none;
    display: inline-block;
    font-family: ${(c) => c.theme.typography.headings.fontFamily};
    color: ${({ theme: c }) => c.colors.text.primary};
    vertical-align: bottom;
    width: ${({ fullWidth: c }) => c ? "100%" : "auto"};
    text-transform: none;
    padding: 0 22px 0 4px;

    font-size: 0.929em;
    line-height: 1.5em;
    font-family: inherit;
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
  }
  .dropdown-select {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
    border: none;
    appearance: none;
    cursor: pointer;

    color: ${({ theme: c }) => c.colors.text.primary};
    line-height: inherit;
    font-family: inherit;
  }
  box-sizing: border-box;
  min-width: 100px;
  outline: none;
  display: inline-block;
  border-radius: 2px;
  border: 1px solid rgba(38, 50, 56, 0.5);
  vertical-align: bottom;
  padding: 2px 0px 2px 6px;
  position: relative;
  width: auto;
  background: white;
  color: #263238;
  font-family: ${(c) => c.theme.typography.headings.fontFamily};
  font-size: 0.929em;
  line-height: 1.5em;
  cursor: pointer;
  transition: border 0.25s ease, color 0.25s ease, box-shadow 0.25s ease;

  &:hover,
  &:focus-within {
    border: 1px solid ${(c) => c.theme.colors.primary.main};
    color: ${(c) => c.theme.colors.primary.main};
    box-shadow: 0px 0px 0px 1px ${(c) => c.theme.colors.primary.main};
  }
`, Ux = U()(mf)`
  margin-left: 10px;
  text-transform: none;
  font-size: 0.969em;

  font-size: 1em;
  border: none;
  padding: 0 1.2em 0 0;
  background: transparent;

  &:hover,
  &:focus-within {
    border: none;
    box-shadow: none;
    label {
      color: ${(c) => c.theme.colors.primary.main};
      text-shadow: 0px 0px 0px ${(c) => c.theme.colors.primary.main};
    }
  }
`, Vx = U().span`
  margin-left: 10px;
  text-transform: none;
  font-size: 0.929em;
  color: black;
`;
        var pD = Object.defineProperty, Wx = Object.getOwnPropertySymbols, fD = Object.prototype.hasOwnProperty, dD = Object.prototype.propertyIsEnumerable, Hx = (c, p, h) => p in c ? pD(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h, hD = (c, p) => {
          for (var h in p || (p = {})) fD.call(p, h) && Hx(c, h, p[h]);
          if (Wx) for (var h of Wx(p)) dD.call(p, h) && Hx(c, h, p[h]);
          return c;
        };
        function Va(c) {
          const { Label: p = Vx, Dropdown: h = Ux } = c;
          return c.options.length === 1 ? o.createElement(p, null, c.options[0].value) : o.createElement(h, hD({}, c));
        }
        var mD = SJ();
        const gf = ye`
  a {
    text-decoration: ${(c) => c.theme.typography.links.textDecoration};
    color: ${(c) => c.theme.typography.links.color};

    &:visited {
      color: ${(c) => c.theme.typography.links.visited};
    }

    &:hover {
      color: ${(c) => c.theme.typography.links.hover};
      text-decoration: ${(c) => c.theme.typography.links.hoverTextDecoration};
    }
  }
`, Wa = M(Ty)`
  font-family: ${(c) => c.theme.typography.fontFamily};
  font-weight: ${(c) => c.theme.typography.fontWeightRegular};
  line-height: ${(c) => c.theme.typography.lineHeight};

  p {
    &:last-child {
      margin-bottom: 0;
    }
  }

  ${({ $compact: c }) => c && `
    p:first-child {
      margin-top: 0;
    }
    p:last-child {
      margin-bottom: 0;
    }
  `}

  ${({ $inline: c }) => c && ` p {
    display: inline-block;
  }`}

  h1 {
    ${Tu(1)};
    color: ${(c) => c.theme.colors.primary.main};
    margin-top: 0;
  }

  h2 {
    ${Tu(2)};
    color: ${(c) => c.theme.colors.text.primary};
  }

  code {
    color: ${({ theme: c }) => c.typography.code.color};
    background-color: ${({ theme: c }) => c.typography.code.backgroundColor};

    font-family: ${(c) => c.theme.typography.code.fontFamily};
    border-radius: 2px;
    border: 1px solid rgba(38, 50, 56, 0.1);
    padding: 0 ${({ theme: c }) => c.spacing.unit}px;
    font-size: ${(c) => c.theme.typography.code.fontSize};
    font-weight: ${({ theme: c }) => c.typography.code.fontWeight};

    word-break: break-word;
  }

  pre {
    font-family: ${(c) => c.theme.typography.code.fontFamily};
    white-space: ${({ theme: c }) => c.typography.code.wrap ? "pre-wrap" : "pre"};
    background-color: ${({ theme: c }) => c.codeBlock.backgroundColor};
    color: white;
    padding: ${(c) => 4 * c.theme.spacing.unit}px;
    overflow-x: auto;
    line-height: normal;
    border-radius: 0;
    border: 1px solid rgba(38, 50, 56, 0.1);

    code {
      background-color: transparent;
      color: white;
      padding: 0;

      &:before,
      &:after {
        content: none;
      }
    }
  }

  blockquote {
    margin: 0;
    margin-bottom: 1em;
    padding: 0 15px;
    color: #777;
    border-left: 4px solid #ddd;
  }

  img {
    max-width: 100%;
    box-sizing: content-box;
  }

  ul,
  ol {
    padding-left: 2em;
    margin: 0;
    margin-bottom: 1em;

    ul,
    ol {
      margin-bottom: 0;
      margin-top: 0;
    }
  }

  table {
    display: block;
    width: 100%;
    overflow: auto;
    word-break: normal;
    word-break: keep-all;
    border-collapse: collapse;
    border-spacing: 0;
    margin-top: 1.5em;
    margin-bottom: 1.5em;
  }

  table tr {
    background-color: #fff;
    border-top: 1px solid #ccc;

    &:nth-child(2n) {
      background-color: ${({ theme: c }) => c.schema.nestedBackground};
    }
  }

  table th,
  table td {
    padding: 6px 13px;
    border: 1px solid #ddd;
  }

  table th {
    text-align: left;
    font-weight: bold;
  }

  ${Nx(".share-link")};

  ${gf}

  ${se("Markdown")};
`;
        var gD = Object.defineProperty, yD = Object.defineProperties, vD = Object.getOwnPropertyDescriptors, yf = Object.getOwnPropertySymbols, Qx = Object.prototype.hasOwnProperty, Yx = Object.prototype.propertyIsEnumerable, Gx = (c, p, h) => p in c ? gD(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h, Kx = (c, p) => {
          for (var h in p || (p = {})) Qx.call(p, h) && Gx(c, h, p[h]);
          if (yf) for (var h of yf(p)) Yx.call(p, h) && Gx(c, h, p[h]);
          return c;
        };
        const bD = U()((c) => o.createElement(Wa, Kx({}, c)))`
  display: inline;
`;
        function Xx(c) {
          var p = c, { inline: h, compact: w } = p, _ = ((R, W) => {
            var Z = {};
            for (var ne in R) Qx.call(R, ne) && W.indexOf(ne) < 0 && (Z[ne] = R[ne]);
            if (R != null && yf) for (var ne of yf(R)) W.indexOf(ne) < 0 && Yx.call(R, ne) && (Z[ne] = R[ne]);
            return Z;
          })(p, ["inline", "compact"]);
          const T = h ? bD : Wa;
          return o.createElement(Ot, null, (R) => {
            return o.createElement(T, (W = Kx({ className: "redoc-markdown " + (_.className || ""), dangerouslySetInnerHTML: { __html: (Z = R.untrustedSpec, ne = _.html, Z ? mD.sanitize(ne) : ne) }, "data-role": _["data-role"] }, _), yD(W, vD({ $inline: h, $compact: w }))));
            var W, Z, ne;
          });
        }
        class Dr extends o.Component {
          render() {
            const { source: p, inline: h, compact: w, className: _, "data-role": T } = this.props, R = new Da();
            return o.createElement(Xx, { html: R.renderMd(p), inline: h, compact: w, className: _, "data-role": T });
          }
        }
        const wD = M.div`
  position: relative;
`, SD = M.div`
  position: absolute;
  min-width: 80px;
  max-width: 500px;
  background: #fff;
  bottom: 100%;
  left: 50%;
  margin-bottom: 10px;
  transform: translateX(-50%);

  border-radius: 4px;
  padding: 0.3em 0.6em;
  text-align: center;
  box-shadow: 0px 0px 5px 0px rgba(204, 204, 204, 1);
`, xD = M.div`
  background: #fff;
  color: #000;
  display: inline;
  font-size: 0.85em;
  white-space: nowrap;
`, ED = M.div`
  position: absolute;
  width: 0;
  height: 0;
  bottom: -5px;
  left: 50%;
  margin-left: -5px;
  border-left: solid transparent 5px;
  border-right: solid transparent 5px;
  border-top: solid #fff 5px;
`, _D = M.div`
  position: absolute;
  width: 100%;
  height: 20px;
  bottom: -20px;
`;
        class OD extends o.Component {
          render() {
            const { open: p, title: h, children: w } = this.props;
            return o.createElement(wD, null, w, p && o.createElement(SD, null, o.createElement(xD, null, h), o.createElement(ED, null), o.createElement(_D, null)));
          }
        }
        const kD = typeof document < "u" && document.queryCommandSupported && document.queryCommandSupported("copy");
        class Gi {
          static isSupported() {
            return kD;
          }
          static selectElement(p) {
            let h, w;
            document.body.createTextRange ? (h = document.body.createTextRange(), h.moveToElementText(p), h.select()) : document.createRange && window.getSelection && (w = window.getSelection(), h = document.createRange(), h.selectNodeContents(p), w.removeAllRanges(), w.addRange(h));
          }
          static deselect() {
            if (document.selection) document.selection.empty();
            else if (window.getSelection) {
              const p = window.getSelection();
              p && p.removeAllRanges();
            }
          }
          static copySelected() {
            let p;
            try {
              p = document.execCommand("copy");
            } catch {
              p = !1;
            }
            return p;
          }
          static copyElement(p) {
            Gi.selectElement(p);
            const h = Gi.copySelected();
            return h && Gi.deselect(), h;
          }
          static copyCustom(p) {
            const h = document.createElement("textarea");
            h.style.position = "fixed", h.style.top = "0", h.style.left = "0", h.style.width = "2em", h.style.height = "2em", h.style.padding = "0", h.style.border = "none", h.style.outline = "none", h.style.boxShadow = "none", h.style.background = "transparent", h.value = p, document.body.appendChild(h), h.select();
            const w = Gi.copySelected();
            return document.body.removeChild(h), w;
          }
        }
        const Jx = (c) => {
          const [p, h] = o.useState(!1), w = () => {
            const T = typeof c.data == "string" ? c.data : JSON.stringify(c.data, null, 2);
            Gi.copyCustom(T), _();
          }, _ = () => {
            h(!0), setTimeout(() => {
              h(!1);
            }, 1500);
          };
          return c.children({ renderCopyButton: () => o.createElement("button", { onClick: w }, o.createElement(OD, { title: Gi.isSupported() ? "Copied" : "Not supported in your browser", open: p }, "Copy")) });
        };
        let Ki = 1;
        function AD(c, p) {
          Ki = 1;
          let h = "";
          return h += '<div class="redoc-json">', h += "<code>", h += $y(c, p), h += "</code>", h += "</div>", h;
        }
        function Cy(c) {
          return c !== void 0 ? c.toString().replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;") : "";
        }
        function Zx(c) {
          return JSON.stringify(c).slice(1, -1);
        }
        function Ls(c, p) {
          return '<span class="' + p + '">' + Cy(c) + "</span>";
        }
        function Ms(c) {
          return '<span class="token punctuation">' + c + "</span>";
        }
        function $y(c, p) {
          const h = typeof c;
          let w = "";
          return c == null ? w += Ls("null", "token keyword") : c && c.constructor === Array ? (Ki++, w += function(_, T) {
            const R = Ki > T ? "collapsed" : "";
            let W = `<button class="collapser" aria-label="${Ki > T + 1 ? "expand" : "collapse"}"></button>${Ms("[")}<span class="ellipsis"></span><ul class="array collapsible">`, Z = !1;
            const ne = _.length;
            for (let re = 0; re < ne; re++) Z = !0, W += '<li><div class="hoverable ' + R + '">', W += $y(_[re], T), re < ne - 1 && (W += ","), W += "</div></li>";
            return W += `</ul>${Ms("]")}`, Z || (W = Ms("[ ]")), W;
          }(c, p), Ki--) : c && c.constructor === Date ? w += Ls('"' + c.toISOString() + '"', "token string") : h === "object" ? (Ki++, w += function(_, T) {
            const R = Ki > T ? "collapsed" : "", W = Object.keys(_), Z = W.length;
            let ne = `<button class="collapser" aria-label="${Ki > T + 1 ? "expand" : "collapse"}"></button>${Ms("{")}<span class="ellipsis"></span><ul class="obj collapsible">`, re = !1;
            for (let ie = 0; ie < Z; ie++) {
              const me = W[ie];
              re = !0, ne += '<li><div class="hoverable ' + R + '">', ne += '<span class="property token string">"' + Cy(me) + '"</span>: ', ne += $y(_[me], T), ie < Z - 1 && (ne += Ms(",")), ne += "</div></li>";
            }
            return ne += `</ul>${Ms("}")}`, re || (ne = Ms("{ }")), ne;
          }(c, p), Ki--) : h === "number" ? w += Ls(c, "token number") : h === "string" ? /^(http|https):\/\/[^\s]+$/.test(c) ? w += Ls('"', "token string") + '<a href="' + encodeURI(c) + '">' + Cy(Zx(c)) + "</a>" + Ls('"', "token string") : w += Ls('"' + Zx(c) + '"', "token string") : h === "boolean" && (w += Ls(c, "token boolean")), w;
        }
        const PD = ye`
  .redoc-json code > .collapser {
    display: none;
    pointer-events: none;
  }

  font-family: ${(c) => c.theme.typography.code.fontFamily};
  font-size: ${(c) => c.theme.typography.code.fontSize};

  white-space: ${({ theme: c }) => c.typography.code.wrap ? "pre-wrap" : "pre"};
  contain: content;
  overflow-x: auto;

  .callback-function {
    color: gray;
  }

  .collapser:after {
    content: '-';
    cursor: pointer;
  }

  .collapsed > .collapser:after {
    content: '+';
    cursor: pointer;
  }

  .ellipsis:after {
    content: '  ';
  }

  .collapsible {
    margin-left: 2em;
  }

  .hoverable {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 2px;
    padding-right: 2px;
    border-radius: 2px;
  }

  .hovered {
    background-color: rgba(235, 238, 249, 1);
  }

  .collapser {
    background-color: transparent;
    border: 0;
    color: #fff;
    font-family: ${(c) => c.theme.typography.code.fontFamily};
    font-size: ${(c) => c.theme.typography.code.fontSize};
    padding-right: 6px;
    padding-left: 6px;
    padding-top: 0;
    padding-bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 15px;
    height: 15px;
    position: absolute;
    top: 4px;
    left: -1.5em;
    cursor: default;
    user-select: none;
    -webkit-user-select: none;
    padding: 2px;
    &:focus {
      outline-color: #fff;
      outline-style: dotted;
      outline-width: 1px;
    }
  }

  ul {
    list-style-type: none;
    padding: 0px;
    margin: 0px 0px 0px 26px;
  }

  li {
    position: relative;
    display: block;
  }

  .hoverable {
    display: inline-block;
  }

  .selected {
    outline-style: solid;
    outline-width: 1px;
    outline-style: dotted;
  }

  .collapsed > .collapsible {
    display: none;
  }

  .ellipsis {
    display: none;
  }

  .collapsed > .ellipsis {
    display: inherit;
  }
`, TD = M.div`
  &:hover > ${hf} {
    opacity: 1;
  }
`, eE = M((c) => {
          const [p, h] = o.useState(), w = ({ renderCopyButton: ne }) => {
            const re = c.data && Object.values(c.data).some((ie) => typeof ie == "object" && ie !== null);
            return o.createElement(TD, null, o.createElement(hf, null, ne(), re && o.createElement(o.Fragment, null, o.createElement("button", { onClick: _ }, " Expand all "), o.createElement("button", { onClick: T }, " Collapse all "))), o.createElement(He.Consumer, null, (ie) => o.createElement(Ty, { className: c.className, ref: (me) => h(me), dangerouslySetInnerHTML: { __html: AD(c.data, ie.jsonSampleExpandLevel) } })));
          }, _ = () => {
            const ne = p == null ? void 0 : p.getElementsByClassName("collapsible");
            for (const re of Array.prototype.slice.call(ne)) {
              const ie = re.parentNode;
              ie.classList.remove("collapsed"), ie.querySelector(".collapser").setAttribute("aria-label", "collapse");
            }
          }, T = () => {
            const ne = p == null ? void 0 : p.getElementsByClassName("collapsible"), re = Array.prototype.slice.call(ne, 1);
            for (const ie of re) {
              const me = ie.parentNode;
              me.classList.add("collapsed"), me.querySelector(".collapser").setAttribute("aria-label", "expand");
            }
          }, R = (ne) => {
            let re;
            ne.className === "collapser" && (re = ne.parentElement.getElementsByClassName("collapsible")[0], re.parentElement.classList.contains("collapsed") ? (re.parentElement.classList.remove("collapsed"), ne.setAttribute("aria-label", "collapse")) : (re.parentElement.classList.add("collapsed"), ne.setAttribute("aria-label", "expand")));
          }, W = o.useCallback((ne) => {
            R(ne.target);
          }, []), Z = o.useCallback((ne) => {
            ne.key === "Enter" && R(ne.target);
          }, []);
          return o.useEffect(() => (p == null || p.addEventListener("click", W), p == null || p.addEventListener("focus", Z), () => {
            p == null || p.removeEventListener("click", W), p == null || p.removeEventListener("focus", Z);
          }), [W, Z, p]), o.createElement(Jx, { data: c.data }, w);
        })`
  ${PD};
`, tE = (c) => {
          const { source: p, lang: h } = c;
          return o.createElement(Dx, { dangerouslySetInnerHTML: { __html: xu(p, h) } });
        }, Ry = (c) => {
          const { source: p, lang: h } = c;
          return o.createElement(Jx, { data: p }, ({ renderCopyButton: w }) => o.createElement(eD, null, o.createElement(hf, null, w()), o.createElement(tE, { lang: h, source: p })));
        };
        function rE({ value: c, mimeType: p }) {
          return Po(p) ? o.createElement(eE, { data: c }) : (typeof c == "object" && (c = JSON.stringify(c, null, 2)), o.createElement(Ry, { lang: qi(p), source: c }));
        }
        var CD = (c, p, h) => new Promise((w, _) => {
          var T = (Z) => {
            try {
              W(h.next(Z));
            } catch (ne) {
              _(ne);
            }
          }, R = (Z) => {
            try {
              W(h.throw(Z));
            } catch (ne) {
              _(ne);
            }
          }, W = (Z) => Z.done ? w(Z.value) : Promise.resolve(Z.value).then(T, R);
          W((h = h.apply(c, p)).next());
        });
        function Iy({ example: c, mimeType: p }) {
          return c.value === void 0 && c.externalValueUrl ? o.createElement(nE, { example: c, mimeType: p }) : o.createElement(rE, { value: c.value, mimeType: p });
        }
        function nE({ example: c, mimeType: p }) {
          const h = function(w, _) {
            const [, T] = (0, o.useState)(!0), R = (0, o.useRef)(void 0), W = (0, o.useRef)(void 0);
            return W.current !== w && (R.current = void 0), W.current = w, (0, o.useEffect)(() => {
              CD(this, null, function* () {
                T(!0);
                try {
                  R.current = yield w.getExternalValue(_);
                } catch (Z) {
                  R.current = Z;
                }
                T(!1);
              });
            }, [w, _]), R.current;
          }(c, p);
          return h === void 0 ? o.createElement("span", null, "Loading...") : h instanceof Error ? o.createElement(Dx, null, "Error loading external example: ", o.createElement("br", null), o.createElement("a", { className: "token string", href: c.externalValueUrl, target: "_blank", rel: "noopener noreferrer" }, c.externalValueUrl)) : o.createElement(rE, { value: h, mimeType: p });
        }
        const Ny = M.div`
  padding: 0.9em;
  background-color: ${({ theme: c }) => (0, a.transparentize)(0.6, c.rightPanel.backgroundColor)};
  margin: 0 0 10px 0;
  display: block;
  font-family: ${({ theme: c }) => c.typography.headings.fontFamily};
  font-size: 0.929em;
  line-height: 1.5em;
`, vf = M.span`
  font-family: ${({ theme: c }) => c.typography.headings.fontFamily};
  font-size: 12px;
  position: absolute;
  z-index: 1;
  top: -11px;
  left: 12px;
  font-weight: ${({ theme: c }) => c.typography.fontWeightBold};
  color: ${({ theme: c }) => (0, a.transparentize)(0.3, c.rightPanel.textColor)};
`, bf = M.div`
  position: relative;
`, wf = M(mf)`
  label {
    color: ${({ theme: c }) => c.rightPanel.textColor};
    text-overflow: ellipsis;
    white-space: nowrap;
    overflow: hidden;
    font-size: 1em;
    text-transform: none;
    border: none;
  }
  margin: 0 0 10px 0;
  display: block;
  background-color: ${({ theme: c }) => (0, a.transparentize)(0.6, c.rightPanel.backgroundColor)};
  border: none;
  padding: 0.9em 1.6em 0.9em 0.9em;
  box-shadow: none;
  &:hover,
  &:focus-within {
    border: none;
    box-shadow: none;
    background-color: ${({ theme: c }) => (0, a.transparentize)(0.3, c.rightPanel.backgroundColor)};
  }
`, iE = M.div`
  font-family: ${(c) => c.theme.typography.code.fontFamily};
  font-size: 12px;
  color: #ee807f;
`;
        class oE extends o.Component {
          constructor() {
            super(...arguments), this.state = { activeIdx: 0 }, this.switchMedia = ({ idx: p }) => {
              p !== void 0 && this.setState({ activeIdx: p });
            };
          }
          render() {
            const { activeIdx: p } = this.state, h = this.props.mediaType.examples || {}, w = this.props.mediaType.name, _ = o.createElement(iE, null, "No sample"), T = Object.keys(h);
            if (T.length === 0) return _;
            if (T.length > 1) {
              const R = T.map((ne, re) => ({ value: h[ne].summary || ne, idx: re })), W = h[T[p]], Z = W.description;
              return o.createElement(sE, null, o.createElement(bf, null, o.createElement(vf, null, "Example"), this.props.renderDropdown({ value: R[p].value, options: R, onChange: this.switchMedia, ariaLabel: "Example" })), o.createElement("div", null, Z && o.createElement(Dr, { source: Z }), o.createElement(Iy, { example: W, mimeType: w })));
            }
            {
              const R = h[T[0]];
              return o.createElement(sE, null, R.description && o.createElement(Dr, { source: R.description }), o.createElement(Iy, { example: R, mimeType: w }));
            }
          }
        }
        const sE = M.div`
  margin-top: 15px;
`;
        var wt = yZ;
        const $D = M(Lx)`
  &.deprecated {
    span.property-name {
      ${df}
    }
  }

  button {
    background-color: transparent;
    border: 0;
    outline: 0;
    font-size: 13px;
    font-family: ${(c) => c.theme.typography.code.fontFamily};
    cursor: pointer;
    padding: 0;
    color: ${(c) => c.theme.colors.text.primary};
    &:focus {
      font-weight: ${({ theme: c }) => c.typography.fontWeightBold};
    }
    ${({ kind: c }) => c === "patternProperties" && ye`
        display: inline-flex;
        margin-right: 20px;

        > span.property-name {
          white-space: break-spaces;
          text-align: left;

          ::before,
          ::after {
            content: '/';
            filter: opacity(0.2);
          }
        }

        > svg {
          align-self: center;
        }
      `}
  }
  ${Qi} {
    height: ${({ theme: c }) => c.schema.arrow.size};
    width: ${({ theme: c }) => c.schema.arrow.size};
    polygon {
      fill: ${({ theme: c }) => c.schema.arrow.color};
    }
  }
`, _n = M.span`
  vertical-align: middle;
  font-size: ${({ theme: c }) => c.typography.code.fontSize};
  line-height: 20px;
`, aE = M(_n)`
  color: ${(c) => (0, a.transparentize)(0.1, c.theme.schema.typeNameColor)};
`, Sf = M(_n)`
  color: ${(c) => c.theme.schema.typeNameColor};
`, lE = M(_n)`
  color: ${(c) => c.theme.schema.typeTitleColor};
  word-break: break-word;
`, xf = Sf, jy = M(_n).attrs({ as: "div" })`
  color: ${(c) => c.theme.schema.requireLabelColor};
  font-size: ${(c) => c.theme.schema.labelsTextSize};
  font-weight: normal;
  margin-left: 20px;
  line-height: 1;
`, uE = M(jy)`
  color: ${(c) => c.theme.colors.primary.light};
`, cE = M(_n)`
  color: ${({ theme: c }) => c.colors.warning.main};
  font-size: 13px;
`, RD = M(_n)`
  color: #0e7c86;
  &::before,
  &::after {
    font-weight: bold;
  }
`, Ru = M(_n)`
  border-radius: 2px;
  word-break: break-word;
  ${({ theme: c }) => `
    background-color: ${(0, a.transparentize)(0.95, c.colors.text.primary)};
    color: ${(0, a.transparentize)(0.1, c.colors.text.primary)};

    padding: 0 ${c.spacing.unit}px;
    border: 1px solid ${(0, a.transparentize)(0.9, c.colors.text.primary)};
    font-family: ${c.typography.code.fontFamily};
}`};
  & + & {
    margin-left: 0;
  }
  ${se("ExampleValue")};
`, ID = M(Ru)``, ND = M(_n)`
  border-radius: 2px;
  ${({ theme: c }) => `
    background-color: ${(0, a.transparentize)(0.95, c.colors.primary.light)};
    color: ${(0, a.transparentize)(0.1, c.colors.primary.main)};

    margin: 0 ${c.spacing.unit}px;
    padding: 0 ${c.spacing.unit}px;
    border: 1px solid ${(0, a.transparentize)(0.9, c.colors.primary.main)};
}`};
  & + & {
    margin-left: 0;
  }
  ${se("ConstraintItem")};
`, jD = M.button`
  background-color: transparent;
  border: 0;
  color: ${({ theme: c }) => c.colors.text.secondary};
  margin-left: ${({ theme: c }) => c.spacing.unit}px;
  border-radius: 2px;
  cursor: pointer;
  outline-color: ${({ theme: c }) => c.colors.text.secondary};
  font-size: 12px;
`, LD = M.div`
  ${gf};
  ${({ $compact: c }) => c ? "" : "margin: 1em 0"}
`;
        let Ds = class extends o.Component {
          render() {
            const { externalDocs: c } = this.props;
            return c && c.url ? o.createElement(LD, { $compact: this.props.compact }, o.createElement("a", { href: c.url }, c.description || c.url)) : null;
          }
        };
        Ds = ((c, p, h, w) => {
          for (var _, T = p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = _(T) || T);
          return T;
        })([wt.observer], Ds);
        class pE extends o.PureComponent {
          constructor() {
            super(...arguments), this.state = { collapsed: !0 };
          }
          toggle() {
            this.setState({ collapsed: !this.state.collapsed });
          }
          render() {
            const { values: p, isArrayType: h } = this.props, { collapsed: w } = this.state, { enumSkipQuotes: _, maxDisplayedEnumValues: T } = this.context;
            if (!p.length) return null;
            const R = this.state.collapsed && T ? p.slice(0, T) : p, W = !!T && p.length > T, Z = T ? w ? ` ${p.length - T} more` : "Hide" : "";
            return o.createElement("div", null, o.createElement(_n, null, h ? z("enumArray") : "", " ", p.length === 1 ? z("enumSingleValue") : z("enum"), ":"), " ", R.map((ne, re) => {
              const ie = _ ? String(ne) : JSON.stringify(ne);
              return o.createElement(o.Fragment, { key: re }, o.createElement(Ru, null, ie), " ");
            }), W ? o.createElement(MD, { onClick: () => {
              this.toggle();
            } }, Z) : null);
          }
        }
        pE.contextType = He;
        const MD = M.span`
  color: ${(c) => c.theme.colors.primary.main};
  vertical-align: middle;
  font-size: 13px;
  line-height: 20px;
  padding: 0 5px;
  cursor: pointer;
`, DD = M(Wa)`
  margin: 2px 0;
`;
        class Ef extends o.PureComponent {
          render() {
            const p = this.props.extensions;
            return o.createElement(He.Consumer, null, (h) => o.createElement(o.Fragment, null, h.showExtensions && Object.keys(p).map((w) => o.createElement(DD, { key: w }, o.createElement(_n, null, " ", w.substring(2), ": "), " ", o.createElement(ID, null, typeof p[w] == "string" ? p[w] : JSON.stringify(p[w]))))));
          }
        }
        function FD({ field: c }) {
          return c.examples ? o.createElement(o.Fragment, null, o.createElement(_n, null, " ", z("examples"), ": "), G(c.examples) ? c.examples.map((p, h) => {
            const w = zi(c, p), _ = c.in ? String(w) : JSON.stringify(w);
            return o.createElement(o.Fragment, { key: h }, o.createElement(Ru, null, _), " ");
          }) : o.createElement(zD, null, Object.values(c.examples).map((p, h) => o.createElement("li", { key: h + p.value }, o.createElement(Ru, null, zi(c, p.value)), " -", " ", p.summary || p.description)))) : null;
        }
        const zD = M.ul`
  margin-top: 1em;
  list-style-position: outside;
`;
        class Iu extends o.PureComponent {
          render() {
            return this.props.constraints.length === 0 ? null : o.createElement("span", null, " ", this.props.constraints.map((p) => o.createElement(ND, { key: p }, " ", p, " ")));
          }
        }
        const Ly = o.memo(function({ value: c, label: p, raw: h }) {
          if (c === void 0) return null;
          const w = h ? String(c) : JSON.stringify(c);
          return o.createElement("div", null, o.createElement(_n, null, " ", p, " "), " ", o.createElement(Ru, null, w));
        }), My = 45;
        function Dy(c) {
          const p = c.schema.pattern, { hideSchemaPattern: h } = o.useContext(He), [w, _] = o.useState(!1), T = o.useCallback(() => _(!w), [w]);
          return !p || h ? null : o.createElement(o.Fragment, null, o.createElement(RD, null, w || p.length < My ? p : `${p.substr(0, My)}...`), p.length > My && o.createElement(jD, { onClick: T }, w ? "Hide pattern" : "Show pattern"));
        }
        function fE({ schema: c }) {
          var p;
          const { hideSchemaPattern: h } = o.useContext(He);
          return c && (c != null && c.pattern && !h || c.items || c.displayFormat || (p = c.constraints) != null && p.length) ? c.type === "string" && c.pattern ? o.createElement(dE, null, "[", o.createElement(Dy, { schema: c }), "]") : o.createElement(dE, null, "[ items", c.displayFormat && o.createElement(xf, null, " <", c.displayFormat, " >"), o.createElement(Iu, { constraints: c.constraints }), o.createElement(Dy, { schema: c }), c.items && o.createElement(fE, { schema: c.items }), " ]") : null;
        }
        const dE = M(aE)`
  margin: 0 5px;
  vertical-align: text-top;
`;
        var qD = Object.defineProperty, hE = Object.getOwnPropertySymbols, BD = Object.prototype.hasOwnProperty, UD = Object.prototype.propertyIsEnumerable, mE = (c, p, h) => p in c ? qD(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h, gE = (c, p) => {
          for (var h in p || (p = {})) BD.call(p, h) && mE(c, h, p[h]);
          if (hE) for (var h of hE(p)) UD.call(p, h) && mE(c, h, p[h]);
          return c;
        };
        const VD = (0, wt.observer)((c) => {
          const { enumSkipQuotes: p, hideSchemaTitles: h } = o.useContext(He), { showExamples: w, field: _, renderDiscriminatorSwitch: T } = c, { schema: R, description: W, deprecated: Z, extensions: ne, in: re, const: ie } = _, me = R.type === "array", Ie = p || re === "header", Fe = o.useMemo(() => !w || _.example === void 0 && _.examples === void 0 ? null : _.examples !== void 0 ? o.createElement(FD, { field: _ }) : o.createElement(Ly, { label: z("example") + ":", value: zi(_, _.example), raw: !!_.in }), [_, w]), vt = $(R.default) && _.in ? zi(_, R.default).replace(`${_.name}=`, "") : R.default;
          return o.createElement("div", null, o.createElement("div", null, o.createElement(aE, null, R.typePrefix), o.createElement(Sf, null, R.displayType), R.displayFormat && o.createElement(xf, null, " ", "<", R.displayFormat, ">", " "), R.contentEncoding && o.createElement(xf, null, " ", "<", R.contentEncoding, ">", " "), R.contentMediaType && o.createElement(xf, null, " ", "<", R.contentMediaType, ">", " "), R.title && !h && o.createElement(lE, null, " (", R.title, ") "), o.createElement(Iu, { constraints: R.constraints }), o.createElement(Dy, { schema: R }), R.isCircular && o.createElement(cE, null, " ", z("recursive"), " "), me && R.items && o.createElement(fE, { schema: R.items })), Z && o.createElement("div", null, o.createElement($u, { type: "warning" }, " ", z("deprecated"), " ")), o.createElement(Ly, { raw: Ie, label: z("default") + ":", value: vt }), !T && o.createElement(pE, { isArrayType: me, values: R.enum }), " ", Fe, o.createElement(Ef, { extensions: gE(gE({}, ne), R.extensions) }), o.createElement("div", null, o.createElement(Dr, { compact: !0, source: W })), R.externalDocs && o.createElement(Ds, { externalDocs: R.externalDocs, compact: !0 }), T && T(c) || null, ie && o.createElement(Ly, { label: z("const") + ":", value: ie }) || null);
        }), yE = o.memo(VD);
        var WD = Object.defineProperty, vE = Object.getOwnPropertySymbols, HD = Object.prototype.hasOwnProperty, QD = Object.prototype.propertyIsEnumerable, bE = (c, p, h) => p in c ? WD(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h;
        let Nu = class extends o.Component {
          constructor() {
            super(...arguments), this.toggle = () => {
              this.props.field.expanded === void 0 && this.props.expandByDefault ? this.props.field.collapse() : this.props.field.toggle();
            }, this.handleKeyPress = (c) => {
              c.key === "Enter" && (c.preventDefault(), this.toggle());
            };
          }
          render() {
            const { className: c = "", field: p, isLast: h, expandByDefault: w } = this.props, { name: _, deprecated: T, required: R, kind: W } = p, Z = !p.schema.isPrimitive && !p.schema.isCircular, ne = p.expanded === void 0 ? w : p.expanded, re = o.createElement(o.Fragment, null, W === "additionalProperties" && o.createElement(uE, null, "additional property"), W === "patternProperties" && o.createElement(uE, null, "pattern property"), R && o.createElement(jy, null, "required")), ie = Z ? o.createElement($D, { className: T ? "deprecated" : "", kind: W, title: _ }, o.createElement(Mx, null), o.createElement("button", { onClick: this.toggle, onKeyPress: this.handleKeyPress, "aria-label": `expand ${_}` }, o.createElement("span", { className: "property-name" }, _), o.createElement(Qi, { direction: ne ? "down" : "right" })), re) : o.createElement(Lx, { className: T ? "deprecated" : void 0, kind: W, title: _ }, o.createElement(Mx, null), o.createElement("span", { className: "property-name" }, _), re);
            return o.createElement(o.Fragment, null, o.createElement("tr", { className: h ? "last " + c : c }, ie, o.createElement(Y2, null, o.createElement(yE, ((me, Ie) => {
              for (var Fe in Ie || (Ie = {})) HD.call(Ie, Fe) && bE(me, Fe, Ie[Fe]);
              if (vE) for (var Fe of vE(Ie)) QD.call(Ie, Fe) && bE(me, Fe, Ie[Fe]);
              return me;
            })({}, this.props)))), ne && Z && o.createElement("tr", { key: p.name + "inner" }, o.createElement(Q2, { colSpan: 2 }, o.createElement(Gt, null, o.createElement(Xi, { schema: p.schema, skipReadOnly: this.props.skipReadOnly, skipWriteOnly: this.props.skipWriteOnly, showTitle: this.props.showTitle, level: this.props.level })))));
          }
        };
        Nu = ((c, p, h, w) => {
          for (var _, T = p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = _(T) || T);
          return T;
        })([wt.observer], Nu);
        let _f = class extends o.Component {
          constructor() {
            super(...arguments), this.changeActiveChild = (c) => {
              c.idx !== void 0 && this.props.parent.activateOneOf(c.idx);
            };
          }
          sortOptions(c, p) {
            if (p.length === 0) return;
            const h = {};
            p.forEach((w, _) => {
              h[w] = _;
            }), c.sort((w, _) => h[w.value] > h[_.value] ? 1 : -1);
          }
          render() {
            const { parent: c, enumValues: p } = this.props;
            if (c.oneOf === void 0) return null;
            const h = c.oneOf.map((_, T) => ({ value: _.title, idx: T })), w = h[c.activeOneOf].value;
            return this.sortOptions(h, p), o.createElement(mf, { value: w, options: h, onChange: this.changeActiveChild, ariaLabel: "Example" });
          }
        };
        _f = ((c, p, h, w) => {
          for (var _, T = p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = _(T) || T);
          return T;
        })([wt.observer], _f);
        const Of = (0, wt.observer)(({ schema: { fields: c = [], title: p }, showTitle: h, discriminator: w, skipReadOnly: _, skipWriteOnly: T, level: R }) => {
          const { expandSingleSchemaField: W, showObjectSchemaExamples: Z, schemaExpansionLevel: ne } = o.useContext(He), re = o.useMemo(() => _ || T ? c.filter((me) => !(_ && me.schema.readOnly || T && me.schema.writeOnly)) : c, [_, T, c]), ie = W && re.length === 1 || ne >= R;
          return o.createElement(Ay, null, h && o.createElement(H2, null, p), o.createElement("tbody", null, E(re, (me, Ie) => o.createElement(Nu, { key: me.name, isLast: Ie, field: me, expandByDefault: ie, renderDiscriminatorSwitch: (w == null ? void 0 : w.fieldName) === me.name ? () => o.createElement(_f, { parent: w.parentSchema, enumValues: me.schema.enum }) : void 0, className: me.expanded ? "expanded" : void 0, showExamples: Z, skipReadOnly: _, skipWriteOnly: T, showTitle: h, level: R }))));
        });
        var YD = Object.defineProperty, GD = Object.defineProperties, KD = Object.getOwnPropertyDescriptors, wE = Object.getOwnPropertySymbols, XD = Object.prototype.hasOwnProperty, JD = Object.prototype.propertyIsEnumerable, SE = (c, p, h) => p in c ? YD(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h, xE = (c, p) => {
          for (var h in p || (p = {})) XD.call(p, h) && SE(c, h, p[h]);
          if (wE) for (var h of wE(p)) JD.call(p, h) && SE(c, h, p[h]);
          return c;
        }, EE = (c, p) => GD(c, KD(p));
        const ZD = M.div`
  padding-left: ${({ theme: c }) => 2 * c.spacing.unit}px;
`;
        class _E extends o.PureComponent {
          render() {
            const p = this.props.schema, h = p.items, w = p.minItems === void 0 && p.maxItems === void 0 ? "" : `(${ks(p)})`;
            return p.fields ? o.createElement(Of, EE(xE({}, this.props), { level: this.props.level })) : !p.displayType || h || w.length ? o.createElement("div", null, o.createElement(J2, null, " Array ", w), o.createElement(ZD, null, o.createElement(Xi, EE(xE({}, this.props), { schema: h }))), o.createElement(Z2, null)) : o.createElement("div", null, o.createElement(Sf, null, p.displayType));
          }
        }
        var eF = Object.defineProperty, tF = Object.defineProperties, rF = Object.getOwnPropertyDescriptors, OE = Object.getOwnPropertySymbols, nF = Object.prototype.hasOwnProperty, iF = Object.prototype.propertyIsEnumerable, kE = (c, p, h) => p in c ? eF(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h, AE = (c, p, h, w) => {
          for (var _, T = p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = _(T) || T);
          return T;
        };
        let kf = class extends o.Component {
          constructor() {
            super(...arguments), this.activateOneOf = () => {
              this.props.schema.activateOneOf(this.props.idx);
            };
          }
          render() {
            const { idx: c, schema: p, subSchema: h } = this.props;
            return o.createElement(X2, { $deprecated: h.deprecated, $active: c === p.activeOneOf, onClick: this.activateOneOf }, h.title || h.typePrefix + h.displayType);
          }
        };
        kf = AE([wt.observer], kf);
        let Af = class extends o.Component {
          render() {
            const { schema: { oneOf: c }, schema: p } = this.props;
            if (c === void 0) return null;
            const h = c[p.activeOneOf];
            return o.createElement("div", null, o.createElement(K2, null, " ", p.oneOfType, " "), o.createElement(G2, null, c.map((_, T) => o.createElement(kf, { key: _.pointer, schema: p, subSchema: _, idx: T }))), o.createElement("div", null, c[p.activeOneOf].deprecated && o.createElement($u, { type: "warning" }, "Deprecated")), o.createElement(Iu, { constraints: h.constraints }), o.createElement(Xi, (w = ((_, T) => {
              for (var R in T || (T = {})) nF.call(T, R) && kE(_, R, T[R]);
              if (OE) for (var R of OE(T)) iF.call(T, R) && kE(_, R, T[R]);
              return _;
            })({}, this.props), tF(w, rF({ schema: h })))));
            var w;
          }
        };
        Af = AE([wt.observer], Af);
        const PE = (0, wt.observer)(({ schema: c }) => o.createElement("div", null, o.createElement(Sf, null, c.displayType), c.title && o.createElement(lE, null, " ", c.title, " "), o.createElement(cE, null, " ", z("recursive"), " ")));
        var oF = Object.defineProperty, sF = Object.defineProperties, aF = Object.getOwnPropertyDescriptors, Pf = Object.getOwnPropertySymbols, TE = Object.prototype.hasOwnProperty, CE = Object.prototype.propertyIsEnumerable, $E = (c, p, h) => p in c ? oF(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h, Tf = (c, p) => {
          for (var h in p || (p = {})) TE.call(p, h) && $E(c, h, p[h]);
          if (Pf) for (var h of Pf(p)) CE.call(p, h) && $E(c, h, p[h]);
          return c;
        }, Fy = (c, p) => sF(c, aF(p));
        let Xi = class extends o.Component {
          render() {
            var c;
            const p = this.props, { schema: h } = p, w = ((ie, me) => {
              var Ie = {};
              for (var Fe in ie) TE.call(ie, Fe) && me.indexOf(Fe) < 0 && (Ie[Fe] = ie[Fe]);
              if (ie != null && Pf) for (var Fe of Pf(ie)) me.indexOf(Fe) < 0 && CE.call(ie, Fe) && (Ie[Fe] = ie[Fe]);
              return Ie;
            })(p, ["schema"]), _ = (w.level || 0) + 1;
            if (!h) return o.createElement("em", null, " Schema not provided ");
            const { type: T, oneOf: R, discriminatorProp: W, isCircular: Z } = h;
            if (Z) return o.createElement(PE, { schema: h });
            if (W !== void 0) {
              if (!R || !R.length) return console.warn(`Looks like you are using discriminator wrong: you don't have any definition inherited from the ${h.title}`), null;
              const ie = R[h.activeOneOf];
              return ie.isCircular ? o.createElement(PE, { schema: ie }) : o.createElement(Of, Fy(Tf({}, w), { level: _, schema: ie, discriminator: { fieldName: W, parentSchema: h } }));
            }
            if (R !== void 0) return o.createElement(Af, Tf({ schema: h }, w));
            const ne = G(T) ? T : [T];
            if (ne.includes("object")) {
              if ((c = h.fields) != null && c.length) return o.createElement(Of, Fy(Tf({}, this.props), { level: _ }));
            } else if (ne.includes("array")) return o.createElement(_E, Fy(Tf({}, this.props), { level: _ }));
            const re = { schema: h, name: "", required: !1, description: h.description, externalDocs: h.externalDocs, deprecated: !1, toggle: () => null, expanded: !1 };
            return o.createElement("div", null, o.createElement(yE, { field: re }));
          }
        };
        Xi = ((c, p, h, w) => {
          for (var _, T = p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = _(T) || T);
          return T;
        })([wt.observer], Xi);
        var lF = Object.defineProperty, uF = Object.defineProperties, cF = Object.getOwnPropertyDescriptors, RE = Object.getOwnPropertySymbols, pF = Object.prototype.hasOwnProperty, fF = Object.prototype.propertyIsEnumerable, IE = (c, p, h) => p in c ? lF(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h;
        class Cf extends o.PureComponent {
          constructor() {
            super(...arguments), this.renderDropdown = (p) => {
              return o.createElement(Va, (h = ((w, _) => {
                for (var T in _ || (_ = {})) pF.call(_, T) && IE(w, T, _[T]);
                if (RE) for (var T of RE(_)) fF.call(_, T) && IE(w, T, _[T]);
                return w;
              })({ Label: Vx, Dropdown: wf }, p), uF(h, cF({ variant: "dark" }))));
              var h;
            };
          }
          static getMediaType(p, h) {
            if (!p) return {};
            const w = { schema: { $ref: p } };
            return h && (w.examples = { example: { $ref: h } }), w;
          }
          get mediaModel() {
            const { parser: p, schemaRef: h, exampleRef: w, options: _ } = this.props;
            return this._mediaModel || (this._mediaModel = new wy(p, "json", !1, Cf.getMediaType(h, w), _)), this._mediaModel;
          }
          render() {
            const { showReadOnly: p = !0, showWriteOnly: h = !1, showExample: w = !0 } = this.props;
            return o.createElement(Pu, null, o.createElement(Ns, null, o.createElement(No, null, o.createElement(Xi, { skipWriteOnly: !h, skipReadOnly: !p, schema: this.mediaModel.schema })), w && o.createElement(Tx, null, o.createElement(dF, null, o.createElement(oE, { renderDropdown: this.renderDropdown, mediaType: this.mediaModel })))));
          }
        }
        const dF = M.div`
  background: ${({ theme: c }) => c.codeBlock.backgroundColor};
  & > div,
  & > pre {
    padding: ${(c) => 4 * c.theme.spacing.unit}px;
    margin: 0;
  }

  & > div > pre {
    padding: 0;
  }
`, hF = (U().div`
  background-color: #e4e7eb;
`, U().ul`
  display: inline;
  list-style: none;
  padding: 0;

  li {
    display: inherit;

    &:after {
      content: ',';
    }
    &:last-child:after {
      content: none;
    }
  }
`, U().code`
  font-size: ${(c) => c.theme.typography.code.fontSize};
  font-family: ${(c) => c.theme.typography.code.fontFamily};
  margin: 0 3px;
  padding: 0.2em;
  display: inline-block;
  line-height: 1;

  &:after {
    content: ',';
    font-weight: normal;
  }

  &:last-child:after {
    content: none;
  }
`), mF = U().span`
  &:after {
    content: ' and ';
    font-weight: normal;
  }

  &:last-child:after {
    content: none;
  }

  ${gf};
`, NE = U().span`
  ${(c) => !c.$expanded && "white-space: nowrap;"}
  &:after {
    content: ' or ';
    ${(c) => c.$expanded && "content: ' or \\a';"}
    white-space: pre;
  }

  &:last-child:after,
  &:only-child:after {
    content: none;
  }

  ${gf};
`, gF = U().div`
  flex: 1 1 auto;
  cursor: pointer;
`, yF = U().div`
  width: ${(c) => c.theme.schema.defaultDetailsWidth};
  text-overflow: ellipsis;
  border-radius: 4px;
  overflow: hidden;
  ${(c) => c.$expanded && `background: ${c.theme.colors.gray[100]};
     padding: 8px 9.6px;
     margin: 20px 0;
     width: 100%;
    `};
  ${O.lessThan("small")`
    margin-top: 10px;
  `}
`, vF = U()(Cu)`
  display: inline-block;
  margin: 0;
`, bF = U().div`
  width: 100%;
  display: flex;
  margin: 1em 0;
  flex-direction: ${(c) => c.$expanded ? "column" : "row"};
  ${O.lessThan("small")`
    flex-direction: column;
  `}
`, bi = U().div`
  margin: 0.5em 0;
`, jE = U().div`
  border-bottom: 1px solid ${({ theme: c }) => c.colors.border.dark};
  margin-bottom: 1.5em;
  padding-bottom: 0.7em;

  h5 {
    line-height: 1em;
    margin: 0 0 0.6em;
    font-size: ${({ theme: c }) => c.typography.fontSize};
  }

  .redoc-markdown p:first-child {
    display: inline;
  }
`;
        function wF({ children: c, height: p }) {
          const h = o.createRef(), [w, _] = o.useState(!1), [T, R] = o.useState(!1);
          return o.useEffect(() => {
            h.current && h.current.clientHeight + 20 < h.current.scrollHeight && R(!0);
          }, [h]), o.createElement(o.Fragment, null, o.createElement(SF, { ref: h, className: w ? "" : "container", style: { height: w ? "auto" : p } }, c), o.createElement(xF, { $dimmed: !w }, T && o.createElement(EF, { onClick: () => {
            _(!w);
          } }, w ? "See less" : "See more")));
        }
        const SF = U().div`
  overflow-y: hidden;
`, xF = U().div`
  text-align: center;
  line-height: 1.5em;
  ${({ $dimmed: c }) => c && `background-image: linear-gradient(to bottom, transparent,rgb(255 255 255));
     position: relative;
     top: -0.5em;
     padding-top: 0.5em;
     background-position-y: -1em;
    `}
`, EF = U().a`
  cursor: pointer;
`, _F = o.memo(function(c) {
          const { type: p, flow: h, RequiredScopes: w } = c, _ = Object.keys((h == null ? void 0 : h.scopes) || {});
          return o.createElement(o.Fragment, null, o.createElement(bi, null, o.createElement("b", null, "Flow type: "), o.createElement("code", null, p, " ")), (p === "implicit" || p === "authorizationCode") && o.createElement(bi, null, o.createElement("strong", null, " Authorization URL: "), o.createElement("code", null, o.createElement("a", { target: "_blank", rel: "noopener noreferrer", href: h.authorizationUrl }, h.authorizationUrl))), (p === "password" || p === "clientCredentials" || p === "authorizationCode") && o.createElement(bi, null, o.createElement("b", null, " Token URL: "), o.createElement("code", null, h.tokenUrl)), h.refreshUrl && o.createElement(bi, null, o.createElement("strong", null, " Refresh URL: "), o.createElement("code", null, h.refreshUrl)), !!_.length && o.createElement(o.Fragment, null, w || null, o.createElement(bi, null, o.createElement("b", null, " Scopes: ")), o.createElement(wF, { height: "4em" }, o.createElement("ul", null, _.map((T) => o.createElement("li", { key: T }, o.createElement("code", null, T), " -", " ", o.createElement(Dr, { className: "redoc-markdown", inline: !0, source: h.scopes[T] || "" })))))));
        });
        function LE(c) {
          const { RequiredScopes: p, scheme: h } = c;
          return o.createElement(Wa, null, h.apiKey ? o.createElement(o.Fragment, null, o.createElement(bi, null, o.createElement("b", null, ae(h.apiKey.in || ""), " parameter name: "), o.createElement("code", null, h.apiKey.name)), p) : h.http ? o.createElement(o.Fragment, null, o.createElement(bi, null, o.createElement("b", null, "HTTP Authorization Scheme: "), o.createElement("code", null, h.http.scheme)), o.createElement(bi, null, h.http.scheme === "bearer" && h.http.bearerFormat && o.createElement(o.Fragment, null, o.createElement("b", null, "Bearer format: "), o.createElement("code", null, h.http.bearerFormat))), p) : h.openId ? o.createElement(o.Fragment, null, o.createElement(bi, null, o.createElement("b", null, "Connect URL: "), o.createElement("code", null, o.createElement("a", { target: "_blank", rel: "noopener noreferrer", href: h.openId.connectUrl }, h.openId.connectUrl))), p) : h.flows ? Object.keys(h.flows).map((w) => o.createElement(_F, { key: w, type: w, RequiredScopes: p, flow: h.flows[w] })) : null);
        }
        const $f = { oauth2: "OAuth2", apiKey: "API Key", http: "HTTP", openIdConnect: "OpenID Connect" };
        class zy extends o.PureComponent {
          render() {
            return this.props.securitySchemes.schemes.map((p) => o.createElement(Pu, { id: p.sectionId, key: p.id }, o.createElement(Ns, null, o.createElement(No, null, o.createElement(_y, null, o.createElement(ky, { to: p.sectionId }), p.displayName), o.createElement(Dr, { source: p.description || "" }), o.createElement(jE, null, o.createElement(bi, null, o.createElement("b", null, "Security Scheme Type: "), o.createElement("span", null, $f[p.type] || p.type)), o.createElement(LE, { scheme: p }))))));
          }
        }
        var ME = (c, p, h) => new Promise((w, _) => {
          var T = (Z) => {
            try {
              W(h.next(Z));
            } catch (ne) {
              _(ne);
            }
          }, R = (Z) => {
            try {
              W(h.throw(Z));
            } catch (ne) {
              _(ne);
            }
          }, W = (Z) => Z.done ? w(Z.value) : Promise.resolve(Z.value).then(T, R);
          W((h = h.apply(c, p)).next());
        });
        function OF(c, p) {
          return ME(this, arguments, function* (h, w, _ = {}) {
            const T = yield $e(h || w);
            return new Ha(T, w, _);
          });
        }
        class Ha {
          constructor(p, h, w = {}, _ = !0) {
            this.marker = new Ge(), this.disposer = null, this.rawOptions = w, this.options = new X(w, kF), this.scroll = new Ey(this.options), Hi.updateOnHistory($s.currentId, this.scroll), this.spec = new xx(p, h, this.options), this.menu = new Hi(this.spec, this.scroll, $s), this.options.disableSearch || (this.search = new Ax(), _ && this.search.indexItems(this.menu.items), this.disposer = (0, D.observe)(this.menu, "activeItemIdx", (T) => {
              this.updateMarkOnMenu(T.newValue);
            }));
          }
          static fromJS(p) {
            const h = new Ha(p.spec.data, p.spec.url, p.options, !1);
            return h.menu.activeItemIdx = p.menu.activeItemIdx || 0, h.menu.activate(h.menu.flatItems[h.menu.activeItemIdx]), h.options.disableSearch || h.search.load(p.searchIndex), h;
          }
          onDidMount() {
            this.menu.updateOnHistory(), this.updateMarkOnMenu(this.menu.activeItemIdx);
          }
          dispose() {
            this.scroll.dispose(), this.menu.dispose(), this.search && this.search.dispose(), this.disposer != null && this.disposer();
          }
          toJS() {
            return ME(this, null, function* () {
              return { menu: { activeItemIdx: this.menu.activeItemIdx }, spec: { url: this.spec.parser.specUrl, data: this.spec.parser.spec }, searchIndex: this.search ? yield this.search.toJS() : void 0, options: this.rawOptions };
            });
          }
          updateMarkOnMenu(p) {
            const h = Math.max(0, p), w = Math.min(this.menu.flatItems.length, h + 5), _ = [];
            for (let T = h; T < w; T++) {
              const R = this.menu.getElementAt(T);
              R && _.push(R);
            }
            if (p === -1 && f) {
              const T = document.querySelector('[data-role="redoc-description"]'), R = document.querySelector('[data-role="redoc-summary"]');
              T && _.push(T), R && _.push(R);
            }
            this.marker.addOnly(_), this.marker.mark();
          }
        }
        const kF = { allowedMdComponents: { [Ia]: { component: zy, propsSelector: (c) => ({ securitySchemes: c.spec.securitySchemes }) }, [Su]: { component: zy, propsSelector: (c) => ({ securitySchemes: c.spec.securitySchemes }) }, [As]: { component: Cf, propsSelector: (c) => ({ parser: c.spec.parser, options: c.options }) } } }, AF = M(q2)`
  margin-top: 0;
  margin-bottom: 0.5em;

  ${se("ApiHeader")};
`, PF = M.a`
  border: 1px solid ${(c) => c.theme.colors.primary.main};
  color: ${(c) => c.theme.colors.primary.main};
  font-weight: normal;
  margin-left: 0.5em;
  padding: 4px 8px 4px;
  display: inline-block;
  text-decoration: none;
  cursor: pointer;

  ${se("DownloadButton")};
`, Rf = M.span`
  &::before {
    content: '|';
    display: inline-block;
    opacity: 0.5;
    width: ${15}px;
    text-align: center;
  }

  &:last-child::after {
    display: none;
  }
`, TF = M.div`
  overflow: hidden;
`, CF = M.div`
  display: flex;
  flex-wrap: wrap;
  // hide separator on new lines: idea from https://stackoverflow.com/a/31732902/1749888
  margin-left: -${15}px;
`;
        let If = class extends o.Component {
          constructor() {
            super(...arguments), this.handleDownloadClick = (c) => {
              c.target.href || (c.target.href = this.props.store.spec.info.downloadLink);
            };
          }
          render() {
            const { store: c } = this.props, { info: p, externalDocs: h } = c.spec, w = c.options.hideDownloadButton, _ = p.downloadFileName, T = p.downloadLink, R = p.license && o.createElement(Rf, null, "License:", " ", p.license.identifier ? p.license.identifier : o.createElement("a", { href: p.license.url }, p.license.name)) || null, W = p.contact && p.contact.url && o.createElement(Rf, null, "URL: ", o.createElement("a", { href: p.contact.url }, p.contact.url)) || null, Z = p.contact && p.contact.email && o.createElement(Rf, null, p.contact.name || "E-mail", ":", " ", o.createElement("a", { href: "mailto:" + p.contact.email }, p.contact.email)) || null, ne = p.termsOfService && o.createElement(Rf, null, o.createElement("a", { href: p.termsOfService }, "Terms of Service")) || null, re = p.version && o.createElement("span", null, "(", p.version, ")") || null;
            return o.createElement(Pu, null, o.createElement(Ns, null, o.createElement(No, { className: "api-info" }, o.createElement(AF, null, p.title, " ", re), !w && o.createElement("p", null, z("downloadSpecification"), ":", o.createElement(PF, { download: _ || !0, target: "_blank", href: T, onClick: this.handleDownloadClick }, z("download"))), o.createElement(Wa, null, (p.license || p.contact || p.termsOfService) && o.createElement(TF, null, o.createElement(CF, null, Z, " ", W, " ", R, " ", ne)) || null), o.createElement(Dr, { source: c.spec.info.summary, "data-role": "redoc-summary" }), o.createElement(Dr, { source: c.spec.info.description, "data-role": "redoc-description" }), h && o.createElement(Ds, { externalDocs: h }))));
          }
        };
        If = ((c, p, h, w) => {
          for (var _, T = p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = _(T) || T);
          return T;
        })([wt.observer], If);
        const $F = M.img`
  max-height: ${(c) => c.theme.logo.maxHeight};
  max-width: ${(c) => c.theme.logo.maxWidth};
  padding: ${(c) => c.theme.logo.gutter};
  width: 100%;
  display: block;
`, RF = M.div`
  text-align: center;
`, IF = M.a`
  display: inline-block;
`;
        let Nf = class extends o.Component {
          render() {
            const { info: c } = this.props, p = c["x-logo"];
            if (!p || !p.url) return null;
            const h = p.href || c.contact && c.contact.url, w = p.altText ? p.altText : "logo", _ = o.createElement($F, { src: p.url, alt: w });
            return o.createElement(RF, { style: { backgroundColor: p.backgroundColor } }, h ? (T = h, (R) => o.createElement(IF, { href: T }, R))(_) : _);
            var T;
          }
        };
        Nf = ((c, p, h, w) => {
          for (var _, T = p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = _(T) || T);
          return T;
        })([wt.observer], Nf);
        var NF = Object.defineProperty, DE = Object.getOwnPropertySymbols, jF = Object.prototype.hasOwnProperty, LF = Object.prototype.propertyIsEnumerable, FE = (c, p, h) => p in c ? NF(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h, qy = (c, p) => {
          for (var h in p || (p = {})) jF.call(p, h) && FE(c, h, p[h]);
          if (DE) for (var h of DE(p)) LF.call(p, h) && FE(c, h, p[h]);
          return c;
        };
        class MF extends o.Component {
          render() {
            return o.createElement(Ot, null, (p) => o.createElement($x, null, (h) => this.renderWithOptionsAndStore(p, h)));
          }
          renderWithOptionsAndStore(p, h) {
            const { source: w, htmlWrap: _ = (R) => R } = this.props;
            if (!h) throw new Error("When using components in markdown, store prop must be provided");
            const T = new Da(p, this.props.parentId).renderMdWithComponents(w);
            return T.length ? T.map((R, W) => {
              if (typeof R == "string") return o.cloneElement(_(o.createElement(Xx, { html: R, inline: !1, compact: !1 })), { key: W });
              const Z = R.component;
              return o.createElement(Z, qy({ key: W }, qy(qy({}, R.props), R.propsSelector(h))));
            }) : null;
          }
        }
        var DF = vZ();
        const ju = M.span.attrs((c) => ({ className: `operation-type ${c.type}` }))`
  width: 9ex;
  display: inline-block;
  height: ${(c) => c.theme.typography.code.fontSize};
  line-height: ${(c) => c.theme.typography.code.fontSize};
  background-color: #333;
  border-radius: 3px;
  background-repeat: no-repeat;
  background-position: 6px 4px;
  font-size: 7px;
  font-family: Verdana, sans-serif; // web-safe
  color: white;
  text-transform: uppercase;
  text-align: center;
  font-weight: bold;
  vertical-align: middle;
  margin-right: 6px;
  margin-top: 2px;

  &.get {
    background-color: ${({ theme: c }) => c.colors.http.get};
  }

  &.post {
    background-color: ${({ theme: c }) => c.colors.http.post};
  }

  &.put {
    background-color: ${({ theme: c }) => c.colors.http.put};
  }

  &.options {
    background-color: ${({ theme: c }) => c.colors.http.options};
  }

  &.patch {
    background-color: ${({ theme: c }) => c.colors.http.patch};
  }

  &.delete {
    background-color: ${({ theme: c }) => c.colors.http.delete};
  }

  &.basic {
    background-color: ${({ theme: c }) => c.colors.http.basic};
  }

  &.link {
    background-color: ${({ theme: c }) => c.colors.http.link};
  }

  &.head {
    background-color: ${({ theme: c }) => c.colors.http.head};
  }

  &.hook {
    background-color: ${({ theme: c }) => c.colors.primary.main};
  }

  &.schema {
    background-color: ${({ theme: c }) => c.colors.http.basic};
  }
`;
        function jf(c, { theme: p }, h) {
          return c > 1 ? p.sidebar.level1Items[h] : c === 1 ? p.sidebar.groupItems[h] : "";
        }
        const zE = M.ul`
  margin: 0;
  padding: 0;

  &:first-child {
    padding-bottom: 32px;
  }

  & & {
    font-size: 0.929em;
  }

  ${(c) => c.$expanded ? "" : "display: none;"};
`, qE = M.li`
  list-style: none inside none;
  overflow: hidden;
  text-overflow: ellipsis;
  padding: 0;
  ${(c) => c.depth === 0 ? "margin-top: 15px" : ""};
`, BE = { 0: ye`
    opacity: 0.7;
    text-transform: ${({ theme: c }) => c.sidebar.groupItems.textTransform};
    font-size: 0.8em;
    padding-bottom: 0;
    cursor: default;
  `, 1: ye`
    font-size: 0.929em;
    text-transform: ${({ theme: c }) => c.sidebar.level1Items.textTransform};
  ` }, Lf = M.label.attrs((c) => ({ className: DF("-depth" + c.$depth, { active: c.$active }) }))`
  cursor: pointer;
  color: ${(c) => c.$active ? jf(c.$depth, c, "activeTextColor") : c.theme.sidebar.textColor};
  margin: 0;
  padding: 12.5px ${(c) => 4 * c.theme.spacing.unit}px;
  ${({ $depth: c, $type: p, theme: h }) => p === "section" && c > 1 && "padding-left: " + 8 * h.spacing.unit + "px;" || ""}
  display: flex;
  justify-content: space-between;
  font-family: ${(c) => c.theme.typography.headings.fontFamily};
  ${(c) => BE[c.$depth]};
  background-color: ${(c) => c.$active ? jf(c.$depth, c, "activeBackgroundColor") : c.theme.sidebar.backgroundColor};

  ${(c) => c.$deprecated && df || ""};

  &:hover {
    color: ${(c) => jf(c.$depth, c, "activeTextColor")};
    background-color: ${(c) => jf(c.$depth, c, "activeBackgroundColor")};
  }

  ${Qi} {
    height: ${({ theme: c }) => c.sidebar.arrow.size};
    width: ${({ theme: c }) => c.sidebar.arrow.size};
    polygon {
      fill: ${({ theme: c }) => c.sidebar.arrow.color};
    }
  }
`, By = M.span`
  display: inline-block;
  vertical-align: middle;
  width: ${(c) => c.width ? c.width : "auto"};
  overflow: hidden;
  text-overflow: ellipsis;
`, UE = M.div`
  ${({ theme: c }) => ye`
    font-size: 0.8em;
    margin-top: ${2 * c.spacing.unit}px;
    text-align: center;
    position: fixed;
    width: ${c.sidebar.width};
    bottom: 0;
    background: ${c.sidebar.backgroundColor};

    a,
    a:visited,
    a:hover {
      color: ${c.sidebar.textColor} !important;
      padding: ${c.spacing.unit}px 0;
      border-top: 1px solid ${(0, a.darken)(0.1, c.sidebar.backgroundColor)};
      text-decoration: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }
  `};
  img {
    width: 15px;
    margin-right: 5px;
  }

  ${O.lessThan("small")`
    width: 100%;
  `};
`, FF = M.button`
  border: 0;
  width: 100%;
  text-align: left;
  & > * {
    vertical-align: middle;
  }

  ${Qi} {
    polygon {
      fill: ${({ theme: c }) => (0, a.darken)(c.colors.tonalOffset, c.colors.gray[100])};
    }
  }
`, zF = M.span`
  text-decoration: ${(c) => c.$deprecated ? "line-through" : "none"};
  margin-right: 8px;
`, qF = M(ju)`
  margin: 0 5px 0 0;
`, BF = M((c) => {
          const { name: p, opened: h, className: w, onClick: _, httpVerb: T, deprecated: R } = c;
          return o.createElement(FF, { className: w, onClick: _ || void 0 }, o.createElement(qF, { type: T }, mi(T)), o.createElement(Qi, { size: "1.5em", direction: h ? "down" : "right", float: "left" }), o.createElement(zF, { $deprecated: R }, p), R ? o.createElement($u, { type: "warning" }, " ", z("deprecated"), " ") : null);
        })`
  padding: 10px;
  border-radius: 2px;
  margin-bottom: 4px;
  line-height: 1.5em;
  background-color: ${({ theme: c }) => c.colors.gray[100]};
  cursor: pointer;
  outline-color: ${({ theme: c }) => (0, a.darken)(c.colors.tonalOffset, c.colors.gray[100])};
`, UF = M.div`
  padding: 10px 25px;
  background-color: ${({ theme: c }) => c.colors.gray[50]};
  margin-bottom: 5px;
  margin-top: 5px;
`;
        class VF extends o.PureComponent {
          constructor() {
            super(...arguments), this.selectElement = () => {
              Gi.selectElement(this.child);
            };
          }
          render() {
            const { children: p } = this.props;
            return o.createElement("div", { ref: (h) => this.child = h, onClick: this.selectElement, onFocus: this.selectElement, tabIndex: 0, role: "button" }, p);
          }
        }
        const WF = M.div`
  cursor: pointer;
  position: relative;
  margin-bottom: 5px;
`, VE = M.span`
  font-family: ${(c) => c.theme.typography.code.fontFamily};
  margin-left: 10px;
  flex: 1;
  overflow-x: hidden;
  text-overflow: ellipsis;
`, HF = M.button`
  outline: 0;
  color: inherit;
  width: 100%;
  text-align: left;
  cursor: pointer;
  padding: 10px 30px 10px ${(c) => c.$inverted ? "10px" : "20px"};
  border-radius: ${(c) => c.$inverted ? "0" : "4px 4px 0 0"};
  background-color: ${(c) => c.$inverted ? "transparent" : c.theme.codeBlock.backgroundColor};
  display: flex;
  white-space: nowrap;
  align-items: center;
  border: ${(c) => c.$inverted ? "0" : "1px solid transparent"};
  border-bottom: ${(c) => c.$inverted ? "1px solid #ccc" : "0"};
  transition: border-color 0.25s ease;

  ${(c) => c.$expanded && !c.$inverted && `border-color: ${c.theme.colors.border.dark};` || ""}

  .${VE} {
    color: ${(c) => c.$inverted ? c.theme.colors.text.primary : "#ffffff"};
  }
  &:focus {
    box-shadow: inset 0 2px 2px rgba(0, 0, 0, 0.45), 0 2px 0 rgba(128, 128, 128, 0.25);
  }
`, QF = M.span.attrs((c) => ({ className: `http-verb ${c.type}` }))`
  font-size: ${(c) => c.$compact ? "0.8em" : "0.929em"};
  line-height: ${(c) => c.$compact ? "18px" : "20px"};
  background-color: ${(c) => c.theme.colors.http[c.type] || "#999999"};
  color: #ffffff;
  padding: ${(c) => c.$compact ? "2px 8px" : "3px 10px"};
  text-transform: uppercase;
  font-family: ${(c) => c.theme.typography.headings.fontFamily};
  margin: 0;
`, YF = M.div`
  position: absolute;
  width: 100%;
  z-index: 100;
  background: ${(c) => c.theme.rightPanel.servers.overlay.backgroundColor};
  color: ${(c) => c.theme.rightPanel.servers.overlay.textColor};
  box-sizing: border-box;
  box-shadow: 0 0 6px rgba(0, 0, 0, 0.33);
  overflow: hidden;
  border-bottom-left-radius: 4px;
  border-bottom-right-radius: 4px;
  transition: all 0.25s ease;
  visibility: hidden;
  ${(c) => c.$expanded ? "visibility: visible;" : "transform: translateY(-50%) scaleY(0);"}
`, GF = M.div`
  padding: 10px;
`, KF = M.div`
  padding: 5px;
  border: 1px solid #ccc;
  background: ${(c) => c.theme.rightPanel.servers.url.backgroundColor};
  word-break: break-all;
  color: ${(c) => c.theme.colors.primary.main};
  > span {
    color: ${(c) => c.theme.colors.text.primary};
  }
`;
        class Uy extends o.Component {
          constructor(p) {
            super(p), this.toggle = () => {
              this.setState({ expanded: !this.state.expanded });
            }, this.state = { expanded: !1 };
          }
          render() {
            const { operation: p, inverted: h, hideHostname: w } = this.props, { expanded: _ } = this.state;
            return o.createElement(He.Consumer, null, (T) => o.createElement(WF, null, o.createElement(HF, { onClick: this.toggle, $expanded: _, $inverted: h }, o.createElement(QF, { type: p.httpVerb, $compact: this.props.compact }, p.httpVerb), o.createElement(VE, null, p.path), o.createElement(Qi, { float: "right", color: h ? "black" : "white", size: "20px", direction: _ ? "up" : "down", style: { marginRight: "-25px" } })), o.createElement(YF, { $expanded: _, "aria-hidden": !_ }, p.servers.map((R) => {
              const W = T.expandDefaultServerVariables ? wu(R.url, R.variables) : R.url, Z = Y(W);
              return o.createElement(GF, { key: W }, o.createElement(Dr, { source: R.description || "", compact: !0 }), o.createElement(VF, null, o.createElement(KF, null, o.createElement("span", null, w || T.hideHostname ? Z === "/" ? "" : Z : W), p.path)));
            }))));
          }
        }
        class XF extends o.PureComponent {
          render() {
            const { place: p, parameters: h } = this.props;
            return h && h.length ? o.createElement("div", { key: p }, o.createElement(Cu, null, p, " Parameters"), o.createElement(Ay, null, o.createElement("tbody", null, E(h, (w, _) => o.createElement(Nu, { key: w.name, isLast: _, field: w, showExamples: !0 }))))) : null;
          }
        }
        let Qa = class extends o.Component {
          constructor() {
            super(...arguments), this.switchMedia = ({ idx: c }) => {
              this.props.content && c !== void 0 && this.props.content.activate(c);
            };
          }
          render() {
            const { content: c } = this.props;
            if (!c || !c.mediaTypes || !c.mediaTypes.length) return null;
            const p = c.activeMimeIdx, h = c.mediaTypes.map((_, T) => ({ value: _.name, idx: T })), w = ({ children: _ }) => this.props.withLabel ? o.createElement(bf, null, o.createElement(vf, null, "Content type"), _) : _;
            return o.createElement(o.Fragment, null, o.createElement(w, null, this.props.renderDropdown({ value: h[p].value, options: h, onChange: this.switchMedia, ariaLabel: "Content type" })), this.props.children(c.active));
          }
        };
        Qa = ((c, p, h, w) => {
          for (var _, T = p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = _(T) || T);
          return T;
        })([wt.observer], Qa);
        var JF = Object.defineProperty, Mf = Object.getOwnPropertySymbols, WE = Object.prototype.hasOwnProperty, HE = Object.prototype.propertyIsEnumerable, QE = (c, p, h) => p in c ? JF(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h, YE = (c, p) => {
          for (var h in p || (p = {})) WE.call(p, h) && QE(c, h, p[h]);
          if (Mf) for (var h of Mf(p)) HE.call(p, h) && QE(c, h, p[h]);
          return c;
        }, ZF = (c, p) => {
          var h = {};
          for (var w in c) WE.call(c, w) && p.indexOf(w) < 0 && (h[w] = c[w]);
          if (c != null && Mf) for (var w of Mf(c)) p.indexOf(w) < 0 && HE.call(c, w) && (h[w] = c[w]);
          return h;
        };
        const ez = ["path", "query", "cookie", "header"];
        class Vy extends o.PureComponent {
          orderParams(p) {
            const h = {};
            return p.forEach((w) => {
              var _, T, R;
              R = w, (_ = h)[T = w.in] || (_[T] = []), _[T].push(R);
            }), h;
          }
          render() {
            const { body: p, parameters: h = [] } = this.props;
            if (p === void 0 && h === void 0) return null;
            const w = this.orderParams(h), _ = h.length > 0 ? ez : [], T = p && p.content, R = p && p.description, W = p && p.required;
            return o.createElement(o.Fragment, null, _.map((Z) => o.createElement(XF, { key: Z, place: Z, parameters: w[Z] })), T && o.createElement(GE, { content: T, description: R, bodyRequired: W }));
          }
        }
        function tz(c) {
          var p = c, { bodyRequired: h } = p, w = ZF(p, ["bodyRequired"]);
          const _ = typeof h == "boolean" && !!h, T = typeof h == "boolean" && !h;
          return o.createElement(Cu, { key: "header" }, "Request Body schema: ", o.createElement(Va, YE({}, w)), _ && o.createElement(rz, null, "required"), T && o.createElement(nz, null, "optional"));
        }
        function GE(c) {
          const { content: p, description: h, bodyRequired: w } = c, { isRequestType: _ } = p;
          return o.createElement(Qa, { content: p, renderDropdown: (T) => o.createElement(tz, YE({ bodyRequired: w }, T)) }, ({ schema: T }) => o.createElement(o.Fragment, null, h !== void 0 && o.createElement(Dr, { source: h }), (T == null ? void 0 : T.type) === "object" && o.createElement(Iu, { constraints: (T == null ? void 0 : T.constraints) || [] }), o.createElement(Xi, { skipReadOnly: _, skipWriteOnly: !_, key: "schema", schema: T })));
        }
        const KE = `
  text-transform: lowercase;
  margin-left: 0;
  line-height: 1.5em;
`, rz = M(jy)`
  ${KE}
`, nz = M("div")`
  ${KE}
  color: ${({ theme: c }) => c.colors.text.secondary};
  font-size: ${(c) => c.theme.schema.labelsTextSize};
`, XE = o.memo(function({ title: c, type: p, empty: h, code: w, opened: _, className: T, onClick: R }) {
          return o.createElement("button", { className: T, onClick: !h && R || void 0, "aria-expanded": _, disabled: h }, !h && o.createElement(Qi, { size: "1.5em", color: p, direction: _ ? "down" : "right", float: "left" }), o.createElement(az, null, w, " "), o.createElement(Dr, { compact: !0, inline: !0, source: c }));
        }), iz = M(XE)`
  display: block;
  border: 0;
  width: 100%;
  text-align: left;
  padding: 10px;
  border-radius: 2px;
  margin-bottom: 4px;
  line-height: 1.5em;
  cursor: pointer;

  color: ${(c) => c.theme.colors.responses[c.type].color};
  background-color: ${(c) => c.theme.colors.responses[c.type].backgroundColor};
  &:focus {
    outline: auto ${(c) => c.theme.colors.responses[c.type].color};
  }
  ${(c) => c.empty ? `
cursor: default;
&::before {
  content: "";
  font-weight: bold;
  width: 1.5em;
  text-align: center;
  display: inline-block;
  vertical-align: top;
}
&:focus {
  outline: 0;
}
` : ""};
`, oz = M.div`
  padding: 10px;
`, sz = M(Cu).attrs({ as: "caption" })`
  text-align: left;
  margin-top: 1em;
  caption-side: top;
`, az = M.strong`
  vertical-align: top;
`;
        class JE extends o.PureComponent {
          render() {
            const { headers: p } = this.props;
            return p === void 0 || p.length === 0 ? null : o.createElement(Ay, null, o.createElement(sz, null, " Response Headers "), o.createElement("tbody", null, E(p, (h, w) => o.createElement(Nu, { isLast: w, key: h.name, field: h, showExamples: !0 }))));
          }
        }
        var lz = Object.defineProperty, ZE = Object.getOwnPropertySymbols, uz = Object.prototype.hasOwnProperty, cz = Object.prototype.propertyIsEnumerable, e_ = (c, p, h) => p in c ? lz(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h;
        class t_ extends o.PureComponent {
          constructor() {
            super(...arguments), this.renderDropdown = (p) => o.createElement(Cu, { key: "header" }, "Response Schema: ", o.createElement(Va, ((h, w) => {
              for (var _ in w || (w = {})) uz.call(w, _) && e_(h, _, w[_]);
              if (ZE) for (var _ of ZE(w)) cz.call(w, _) && e_(h, _, w[_]);
              return h;
            })({}, p)));
          }
          render() {
            const { description: p, extensions: h, headers: w, content: _ } = this.props.response;
            return o.createElement(o.Fragment, null, p && o.createElement(Dr, { source: p }), o.createElement(Ef, { extensions: h }), o.createElement(JE, { headers: w }), o.createElement(Qa, { content: _, renderDropdown: this.renderDropdown }, ({ schema: T }) => o.createElement(o.Fragment, null, (T == null ? void 0 : T.type) === "object" && o.createElement(Iu, { constraints: (T == null ? void 0 : T.constraints) || [] }), o.createElement(Xi, { skipWriteOnly: !0, key: "schema", schema: T }))));
          }
        }
        const r_ = (0, wt.observer)(({ response: c }) => {
          const { extensions: p, headers: h, type: w, summary: _, description: T, code: R, expanded: W, content: Z } = c, ne = o.useMemo(() => Z === void 0 ? [] : Z.mediaTypes.filter((ie) => ie.schema !== void 0), [Z]), re = o.useMemo(() => !(p && Object.keys(p).length !== 0 || h.length !== 0 || ne.length !== 0 || T), [p, h, ne, T]);
          return o.createElement("div", null, o.createElement(iz, { onClick: () => c.toggle(), type: w, empty: re, title: _ || "", code: R, opened: W }), W && !re && o.createElement(oz, null, o.createElement(t_, { response: c })));
        }), pz = M.h3`
  font-size: 1.3em;
  padding: 0.2em 0;
  margin: 3em 0 1.1em;
  color: ${({ theme: c }) => c.colors.text.primary};
  font-weight: normal;
`;
        class Wy extends o.PureComponent {
          render() {
            const { responses: p, isCallback: h } = this.props;
            return p && p.length !== 0 ? o.createElement("div", null, o.createElement(pz, null, z(h ? "callbackResponses" : "responses")), p.map((w) => o.createElement(r_, { key: w.code, response: w }))) : null;
          }
        }
        function fz(c) {
          const { security: p, showSecuritySchemeType: h, expanded: w } = c, _ = p.schemes.length > 1;
          return p.schemes.length === 0 ? o.createElement(NE, { $expanded: w }, "None") : o.createElement(NE, { $expanded: w }, _ && "(", p.schemes.map((T) => o.createElement(mF, { key: T.id }, h && `${$f[T.type] || T.type}: `, o.createElement("i", null, T.displayName), w && T.scopes.length ? [" (", T.scopes.map((R) => o.createElement(hF, { key: R }, R)), ") "] : null)), _ && ") ");
        }
        const dz = ({ scopes: c }) => c.length ? o.createElement("div", null, o.createElement("b", null, "Required scopes: "), c.map((p, h) => o.createElement(o.Fragment, { key: h }, o.createElement("code", null, p), " "))) : null;
        function n_(c) {
          const p = Ix(), h = p == null ? void 0 : p.options.showSecuritySchemeType, [w, _] = (0, o.useState)(!1), { securities: T } = c;
          if (!(T != null && T.length) || p != null && p.options.hideSecuritySection) return null;
          const R = p == null ? void 0 : p.spec.securitySchemes.schemes.filter(({ id: W }) => T.find((Z) => Z.schemes.find((ne) => ne.id === W)));
          return o.createElement(o.Fragment, null, o.createElement(bF, { $expanded: w }, o.createElement(gF, { onClick: () => _(!w) }, o.createElement(vF, null, "Authorizations:"), o.createElement(Qi, { size: "1.3em", direction: w ? "down" : "right" })), o.createElement(yF, { $expanded: w }, T.map((W, Z) => o.createElement(fz, { key: Z, expanded: w, showSecuritySchemeType: h, security: W })))), w && !!(R != null && R.length) && R.map((W, Z) => o.createElement(jE, { key: Z }, o.createElement("h5", null, o.createElement(hz, null), " ", $f[W.type] || W.type, ": ", W.id), o.createElement(Dr, { source: W.description || "" }), o.createElement(LE, { key: W.id, scheme: W, RequiredScopes: o.createElement(dz, { scopes: mz(W.id, T) }) }))));
        }
        const hz = () => o.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "11", height: "11" }, o.createElement("path", { fill: "currentColor", d: "M18 10V6A6 6 0 0 0 6 6v4H3v14h18V10h-3zM8 6c0-2.206 1.794-4 4-4s4 1.794 4 4v4H8V6zm11 16H5V12h14v10z" }));
        function mz(c, p) {
          const h = [];
          let w = p.length;
          for (; w--; ) {
            const _ = p[w];
            let T = _.schemes.length;
            for (; T--; ) {
              const R = _.schemes[T];
              R.id === c && Array.isArray(R.scopes) && h.push(...R.scopes);
            }
          }
          return Array.from(new Set(h));
        }
        let Hy = class extends o.Component {
          render() {
            const { operation: c } = this.props, { description: p, externalDocs: h } = c, w = !(!p && !h);
            return o.createElement(UF, null, w && o.createElement(gz, null, p !== void 0 && o.createElement(Dr, { source: p }), h && o.createElement(Ds, { externalDocs: h })), o.createElement(Uy, { operation: this.props.operation, inverted: !0, compact: !0 }), o.createElement(Ef, { extensions: c.extensions }), o.createElement(n_, { securities: c.security }), o.createElement(Vy, { parameters: c.parameters, body: c.requestBody }), o.createElement(Wy, { responses: c.responses, isCallback: c.isCallback }));
          }
        };
        Hy = ((c, p, h, w) => {
          for (var _, T = p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = _(T) || T);
          return T;
        })([wt.observer], Hy);
        const gz = M.div`
  margin-bottom: ${({ theme: c }) => 3 * c.spacing.unit}px;
`;
        let Qy = class extends o.Component {
          constructor() {
            super(...arguments), this.toggle = () => {
              this.props.callbackOperation.toggle();
            };
          }
          render() {
            const { name: c, expanded: p, httpVerb: h, deprecated: w } = this.props.callbackOperation;
            return o.createElement(o.Fragment, null, o.createElement(BF, { onClick: this.toggle, name: c, opened: p, httpVerb: h, deprecated: w }), p && o.createElement(Hy, { operation: this.props.callbackOperation }));
          }
        };
        Qy = ((c, p, h, w) => {
          for (var _, T = p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = _(T) || T);
          return T;
        })([wt.observer], Qy);
        class yz extends o.PureComponent {
          render() {
            const { callbacks: p } = this.props;
            return p && p.length !== 0 ? o.createElement("div", null, o.createElement(vz, null, " Callbacks "), p.map((h) => h.operations.map((w, _) => o.createElement(Qy, { key: `${h.name}_${_}`, callbackOperation: w })))) : null;
          }
        }
        const vz = M.h3`
  font-size: 1.3em;
  padding: 0.2em 0;
  margin: 3em 0 1.1em;
  color: ${({ theme: c }) => c.colors.text.primary};
  font-weight: normal;
`;
        let Yy = class extends o.Component {
          constructor(c) {
            super(c), this.switchItem = ({ idx: p }) => {
              this.props.items && p !== void 0 && this.setState({ activeItemIdx: p });
            }, this.state = { activeItemIdx: 0 };
          }
          render() {
            const { items: c } = this.props;
            if (!c || !c.length) return null;
            const p = ({ children: h }) => this.props.label ? o.createElement(bf, null, o.createElement(vf, null, this.props.label), h) : h;
            return o.createElement(o.Fragment, null, o.createElement(p, null, this.props.renderDropdown({ value: this.props.options[this.state.activeItemIdx].value, options: this.props.options, onChange: this.switchItem, ariaLabel: this.props.label || "Callback" })), this.props.children(c[this.state.activeItemIdx]));
          }
        };
        Yy = ((c, p, h, w) => {
          for (var _, T = p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = _(T) || T);
          return T;
        })([wt.observer], Yy);
        var bz = Object.defineProperty, wz = Object.defineProperties, Sz = Object.getOwnPropertyDescriptors, i_ = Object.getOwnPropertySymbols, xz = Object.prototype.hasOwnProperty, Ez = Object.prototype.propertyIsEnumerable, o_ = (c, p, h) => p in c ? bz(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h;
        let Ya = class extends o.Component {
          constructor() {
            super(...arguments), this.renderDropdown = (c) => {
              return o.createElement(Va, (p = ((h, w) => {
                for (var _ in w || (w = {})) xz.call(w, _) && o_(h, _, w[_]);
                if (i_) for (var _ of i_(w)) Ez.call(w, _) && o_(h, _, w[_]);
                return h;
              })({ Label: Ny, Dropdown: wf }, c), wz(p, Sz({ variant: "dark" }))));
              var p;
            };
          }
          render() {
            const c = this.props.content;
            return c === void 0 ? null : o.createElement(Qa, { content: c, renderDropdown: this.renderDropdown, withLabel: !0 }, (p) => o.createElement(oE, { key: "samples", mediaType: p, renderDropdown: this.renderDropdown }));
          }
        };
        Ya = ((c, p, h, w) => {
          for (var _, T = p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = _(T) || T);
          return T;
        })([wt.observer], Ya);
        class _z extends o.Component {
          render() {
            const p = this.props.callback.codeSamples.find((h) => xy(h));
            return p ? o.createElement(Oz, null, o.createElement(Ya, { content: p.requestBodyContent })) : null;
          }
        }
        const Oz = M.div`
  margin-top: 15px;
`;
        var kz = Object.defineProperty, Az = Object.defineProperties, Pz = Object.getOwnPropertyDescriptors, s_ = Object.getOwnPropertySymbols, Tz = Object.prototype.hasOwnProperty, Cz = Object.prototype.propertyIsEnumerable, a_ = (c, p, h) => p in c ? kz(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h;
        let Df = class extends o.Component {
          constructor() {
            super(...arguments), this.renderDropdown = (c) => {
              return o.createElement(Va, (p = ((h, w) => {
                for (var _ in w || (w = {})) Tz.call(w, _) && a_(h, _, w[_]);
                if (s_) for (var _ of s_(w)) Cz.call(w, _) && a_(h, _, w[_]);
                return h;
              })({ Label: Ny, Dropdown: wf }, c), Az(p, Pz({ variant: "dark" }))));
              var p;
            };
          }
          render() {
            const { callbacks: c } = this.props;
            if (!c || c.length === 0) return null;
            const p = c.map((w) => w.operations.map((_) => _)).reduce((w, _) => w.concat(_), []);
            if (!p.some((w) => w.codeSamples.length > 0)) return null;
            const h = p.map((w, _) => ({ value: `${w.httpVerb.toUpperCase()}: ${w.name}`, idx: _ }));
            return o.createElement("div", null, o.createElement(Oy, null, " Callback payload samples "), o.createElement($z, null, o.createElement(Yy, { items: p, renderDropdown: this.renderDropdown, label: "Callback", options: h }, (w) => o.createElement(_z, { key: "callbackPayloadSample", callback: w, renderDropdown: this.renderDropdown }))));
          }
        };
        Df.contextType = He, Df = ((c, p, h, w) => {
          for (var _, T = p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = _(T) || T);
          return T;
        })([wt.observer], Df);
        const $z = M.div`
  background: ${({ theme: c }) => c.codeBlock.backgroundColor};
  padding: ${(c) => 4 * c.theme.spacing.unit}px;
`;
        let Ff = class extends o.Component {
          render() {
            const { operation: c } = this.props, p = c.codeSamples, h = p.length > 0, w = p.length === 1 && this.context.hideSingleRequestSampleTab;
            return h && o.createElement("div", null, o.createElement(Oy, null, " ", z("requestSamples"), " "), o.createElement(Py, { defaultIndex: 0 }, o.createElement(js.TabList, { hidden: w }, p.map((_) => o.createElement(js.Tab, { key: _.lang + "_" + (_.label || "") }, _.label !== void 0 ? _.label : _.lang))), p.map((_) => o.createElement(js.TabPanel, { key: _.lang + "_" + (_.label || "") }, xy(_) ? o.createElement("div", null, o.createElement(Ya, { content: _.requestBodyContent })) : o.createElement(Ry, { lang: _.lang, source: _.source }))))) || null;
          }
        };
        Ff.contextType = He, Ff = ((c, p, h, w) => {
          for (var _, T = p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = _(T) || T);
          return T;
        })([wt.observer], Ff);
        let zf = class extends o.Component {
          render() {
            const { operation: c } = this.props, p = c.responses.filter((h) => h.content && h.content.hasSample);
            return p.length > 0 && o.createElement("div", null, o.createElement(Oy, null, " ", z("responseSamples"), " "), o.createElement(Py, { defaultIndex: 0 }, o.createElement(js.TabList, null, p.map((h) => o.createElement(js.Tab, { className: "tab-" + h.type, key: h.code }, h.code))), p.map((h) => o.createElement(js.TabPanel, { key: h.code }, o.createElement("div", null, o.createElement(Ya, { content: h.content })))))) || null;
          }
        };
        zf = ((c, p, h, w) => {
          for (var _, T = p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = _(T) || T);
          return T;
        })([wt.observer], zf);
        var Rz = Object.defineProperty, Iz = Object.defineProperties, Nz = Object.getOwnPropertyDescriptors, l_ = Object.getOwnPropertySymbols, jz = Object.prototype.hasOwnProperty, Lz = Object.prototype.propertyIsEnumerable, u_ = (c, p, h) => p in c ? Rz(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h;
        const Mz = M.div`
  margin-bottom: ${({ theme: c }) => 6 * c.spacing.unit}px;
`, c_ = (0, wt.observer)(({ operation: c }) => {
          const { name: p, description: h, deprecated: w, externalDocs: _, isWebhook: T, httpVerb: R } = c, W = !(!h && !_), { showWebhookVerb: Z } = o.useContext(He);
          return o.createElement(He.Consumer, null, (ne) => {
            return o.createElement(Ns, (re = ((me, Ie) => {
              for (var Fe in Ie || (Ie = {})) jz.call(Ie, Fe) && u_(me, Fe, Ie[Fe]);
              if (l_) for (var Fe of l_(Ie)) Lz.call(Ie, Fe) && u_(me, Fe, Ie[Fe]);
              return me;
            })({}, { [Is]: c.operationHash }), ie = { id: c.operationHash }, Iz(re, Nz(ie))), o.createElement(No, null, o.createElement(_y, null, o.createElement(ky, { to: c.id }), p, " ", w && o.createElement($u, { type: "warning" }, " Deprecated "), T && o.createElement($u, { type: "primary" }, " ", "Webhook ", Z && R && "| " + R.toUpperCase())), ne.pathInMiddlePanel && !T && o.createElement(Uy, { operation: c, inverted: !0 }), W && o.createElement(Mz, null, h !== void 0 && o.createElement(Dr, { source: h }), _ && o.createElement(Ds, { externalDocs: _ })), o.createElement(Ef, { extensions: c.extensions }), o.createElement(n_, { securities: c.security }), o.createElement(Vy, { parameters: c.parameters, body: c.requestBody }), o.createElement(Wy, { responses: c.responses }), o.createElement(yz, { callbacks: c.callbacks })), o.createElement(Tx, null, !ne.pathInMiddlePanel && !T && o.createElement(Uy, { operation: c }), o.createElement(Ff, { operation: c }), o.createElement(zf, { operation: c }), o.createElement(Df, { callbacks: c.callbacks })));
            var re, ie;
          });
        });
        var Dz = Object.defineProperty, p_ = Object.getOwnPropertySymbols, Fz = Object.prototype.hasOwnProperty, zz = Object.prototype.propertyIsEnumerable, f_ = (c, p, h) => p in c ? Dz(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h, qf = (c, p, h, w) => {
          for (var _, T = p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = _(T) || T);
          return T;
        };
        let Lu = class extends o.Component {
          render() {
            const c = this.props.items;
            return c.length === 0 ? null : c.map((p) => o.createElement(Bf, { key: p.id, item: p }));
          }
        };
        Lu = qf([wt.observer], Lu);
        let Bf = class extends o.Component {
          render() {
            const c = this.props.item;
            let p;
            const { type: h } = c;
            switch (h) {
              case "group":
                p = null;
                break;
              case "tag":
              case "section":
              default:
                p = o.createElement(Uf, ((w, _) => {
                  for (var T in _ || (_ = {})) Fz.call(_, T) && f_(w, T, _[T]);
                  if (p_) for (var T of p_(_)) zz.call(_, T) && f_(w, T, _[T]);
                  return w;
                })({}, this.props));
                break;
              case "operation":
                p = o.createElement(Vf, { item: c });
            }
            return o.createElement(o.Fragment, null, p && o.createElement(Pu, { id: c.id, $underlined: c.type === "operation" }, p), c.items && o.createElement(Lu, { items: c.items }));
          }
        };
        Bf = qf([wt.observer], Bf);
        const qz = (c) => o.createElement(No, { $compact: !0 }, c);
        let Uf = class extends o.Component {
          render() {
            const { name: c, description: p, externalDocs: h, level: w } = this.props.item, _ = w === 2 ? B2 : _y;
            return o.createElement(o.Fragment, null, o.createElement(Ns, null, o.createElement(No, { $compact: !1 }, o.createElement(_, null, o.createElement(ky, { to: this.props.item.id }), c))), o.createElement(MF, { parentId: this.props.item.id, source: p || "", htmlWrap: qz }), h && o.createElement(Ns, null, o.createElement(No, null, o.createElement(Ds, { externalDocs: h }))));
          }
        };
        Uf = qf([wt.observer], Uf);
        let Vf = class extends o.Component {
          render() {
            return o.createElement(c_, { operation: this.props.item });
          }
        };
        Vf = qf([wt.observer], Vf);
        var Bz = Object.defineProperty, Uz = Object.defineProperties, Vz = Object.getOwnPropertyDescriptors, d_ = Object.getOwnPropertySymbols, Wz = Object.prototype.hasOwnProperty, Hz = Object.prototype.propertyIsEnumerable, h_ = (c, p, h) => p in c ? Bz(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h;
        let Mu = class extends o.Component {
          constructor() {
            super(...arguments), this.ref = o.createRef(), this.activate = (c) => {
              this.props.onActivate(this.props.item), c.stopPropagation();
            };
          }
          componentDidMount() {
            this.scrollIntoViewIfActive();
          }
          componentDidUpdate() {
            this.scrollIntoViewIfActive();
          }
          scrollIntoViewIfActive() {
            this.props.item.active && this.ref.current && v(this.ref.current);
          }
          render() {
            const { item: c, withoutChildren: p } = this.props;
            return o.createElement(qE, { tabIndex: 0, onClick: this.activate, depth: c.depth, "data-item-id": c.id, role: "menuitem" }, c.type === "operation" ? o.createElement(m_, (h = ((w, _) => {
              for (var T in _ || (_ = {})) Wz.call(_, T) && h_(w, T, _[T]);
              if (d_) for (var T of d_(_)) Hz.call(_, T) && h_(w, T, _[T]);
              return w;
            })({}, this.props), Uz(h, Vz({ item: c })))) : o.createElement(Lf, { $depth: c.depth, $active: c.active, $type: c.type, ref: this.ref }, c.type === "schema" && o.createElement(ju, { type: "schema" }, "schema"), o.createElement(By, { width: "calc(100% - 38px)", title: c.sidebarLabel }, c.sidebarLabel, this.props.children), c.depth > 0 && c.items.length > 0 && o.createElement(Qi, { float: "right", direction: c.expanded ? "down" : "right" }) || null), !p && c.items && c.items.length > 0 && o.createElement(Du, { expanded: c.expanded, items: c.items, onActivate: this.props.onActivate }));
            var h;
          }
        };
        Mu = ((c, p, h, w) => {
          for (var _, T = p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = _(T) || T);
          return T;
        })([wt.observer], Mu);
        const m_ = (0, wt.observer)((c) => {
          const { item: p } = c, h = o.createRef(), { showWebhookVerb: w } = o.useContext(He);
          return o.useEffect(() => {
            c.item.active && h.current && v(h.current);
          }, [c.item.active, h]), o.createElement(Lf, { $depth: p.depth, $active: p.active, $deprecated: p.deprecated, ref: h }, p.isWebhook ? o.createElement(ju, { type: "hook" }, w ? p.httpVerb : z("webhook")) : o.createElement(ju, { type: p.httpVerb }, mi(p.httpVerb)), o.createElement(By, { tabIndex: 0, width: "calc(100% - 38px)" }, p.sidebarLabel, c.children));
        });
        var Qz = Object.defineProperty, g_ = Object.getOwnPropertySymbols, Yz = Object.prototype.hasOwnProperty, Gz = Object.prototype.propertyIsEnumerable, y_ = (c, p, h) => p in c ? Qz(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h;
        let Du = class extends o.Component {
          render() {
            const { items: c, root: p, className: h } = this.props, w = this.props.expanded == null || this.props.expanded;
            return o.createElement(zE, ((_, T) => {
              for (var R in T || (T = {})) Yz.call(T, R) && y_(_, R, T[R]);
              if (g_) for (var R of g_(T)) Gz.call(T, R) && y_(_, R, T[R]);
              return _;
            })({ className: h, style: this.props.style, $expanded: w }, p ? { role: "menu" } : {}), c.map((_, T) => o.createElement(Mu, { key: T, item: _, onActivate: this.props.onActivate })));
          }
        };
        function Kz() {
          const [c, p] = (0, o.useState)(!1);
          return (0, o.useEffect)(() => {
            p(!0);
          }, []), c ? o.createElement("img", { alt: "redocly logo", onError: () => p(!1), src: "https://cdn.redoc.ly/redoc/logo-mini.svg" }) : null;
        }
        Du = ((c, p, h, w) => {
          for (var _, T = p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = _(T) || T);
          return T;
        })([wt.observer], Du);
        let Fu = class extends o.Component {
          constructor() {
            super(...arguments), this.activate = (c) => {
              if (c && c.active && this.context.menuToggle) return c.expanded ? c.collapse() : c.expand();
              this.props.menu.activateAndScroll(c, !0), setTimeout(() => {
                this._updateScroll && this._updateScroll();
              });
            }, this.saveScrollUpdate = (c) => {
              this._updateScroll = c;
            };
          }
          render() {
            const c = this.props.menu;
            return o.createElement(Bx, { updateFn: this.saveScrollUpdate, className: this.props.className, options: { wheelPropagation: !1 } }, o.createElement(Du, { items: c.items, onActivate: this.activate, root: !0 }), o.createElement(UE, null, o.createElement("a", { target: "_blank", rel: "noopener noreferrer", href: "https://redocly.com/redoc/" }, o.createElement(Kz, null), "API docs by Redocly")));
          }
        };
        Fu.contextType = He, Fu = ((c, p, h, w) => {
          for (var _, T = p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = _(T) || T);
          return T;
        })([wt.observer], Fu);
        const Xz = ({ open: c }) => {
          const p = c ? 8 : -4;
          return o.createElement(Jz, null, o.createElement(v_, { size: 15, style: { transform: `translate(2px, ${p}px) rotate(180deg)`, transition: "transform 0.2s ease" } }), o.createElement(v_, { size: 15, style: { transform: `translate(2px, ${0 - p}px)`, transition: "transform 0.2s ease" } }));
        }, v_ = ({ size: c = 10, className: p = "", style: h }) => o.createElement("svg", { className: p, style: h || {}, viewBox: "0 0 926.23699 573.74994", version: "1.1", x: "0px", y: "0px", width: c, height: c }, o.createElement("g", { transform: "translate(904.92214,-879.1482)" }, o.createElement("path", { d: `
          m -673.67664,1221.6502 -231.2455,-231.24803 55.6165,
          -55.627 c 30.5891,-30.59485 56.1806,-55.627 56.8701,-55.627 0.6894,
          0 79.8637,78.60862 175.9427,174.68583 l 174.6892,174.6858 174.6892,
          -174.6858 c 96.079,-96.07721 175.253196,-174.68583 175.942696,
          -174.68583 0.6895,0 26.281,25.03215 56.8701,
          55.627 l 55.6165,55.627 -231.245496,231.24803 c -127.185,127.1864
          -231.5279,231.248 -231.873,231.248 -0.3451,0 -104.688,
          -104.0616 -231.873,-231.248 z
        `, fill: "currentColor" }))), Jz = M.div`
  user-select: none;
  width: 20px;
  height: 20px;
  align-self: center;
  display: flex;
  flex-direction: column;
  color: ${(c) => c.theme.colors.primary.main};
`;
        let Gy;
        f && (Gy = i(322));
        const Wf = Gy && Gy(), Zz = M.div`
  width: ${(c) => c.theme.sidebar.width};
  background-color: ${(c) => c.theme.sidebar.backgroundColor};
  overflow: hidden;
  display: flex;
  flex-direction: column;

  backface-visibility: hidden;
  /* contain: strict; TODO: breaks layout since Chrome 80*/

  height: 100vh;
  position: sticky;
  position: -webkit-sticky;
  top: 0;

  ${O.lessThan("small")`
    position: fixed;
    z-index: 20;
    width: 100%;
    background: ${({ theme: c }) => c.sidebar.backgroundColor};
    display: ${(c) => c.$open ? "flex" : "none"};
  `};

  @media print {
    display: none;
  }
`, eq = M.div`
  outline: none;
  user-select: none;
  background-color: ${({ theme: c }) => c.fab.backgroundColor};
  color: ${(c) => c.theme.colors.primary.main};
  display: none;
  cursor: pointer;
  position: fixed;
  right: 20px;
  z-index: 100;
  border-radius: 50%;
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
  ${O.lessThan("small")`
    display: flex;
  `};

  bottom: 44px;

  width: 60px;
  height: 60px;
  padding: 0 20px;
  svg {
    color: ${({ theme: c }) => c.fab.color};
  }

  @media print {
    display: none;
  }
`;
        let zu = class extends o.Component {
          constructor() {
            super(...arguments), this.state = { offsetTop: "0px" }, this.toggleNavMenu = () => {
              this.props.menu.toggleSidebar();
            };
          }
          componentDidMount() {
            Wf && Wf.add(this.stickyElement), this.setState({ offsetTop: this.getScrollYOffset(this.context) });
          }
          componentWillUnmount() {
            Wf && Wf.remove(this.stickyElement);
          }
          getScrollYOffset(c) {
            let p;
            return p = this.props.scrollYOffset !== void 0 ? X.normalizeScrollYOffset(this.props.scrollYOffset)() : c.scrollYOffset(), p + "px";
          }
          render() {
            const c = this.props.menu.sideBarOpened, p = this.state.offsetTop;
            return o.createElement(o.Fragment, null, o.createElement(Zz, { $open: c, className: this.props.className, style: { top: p, height: `calc(100vh - ${p})` }, ref: (h) => {
              this.stickyElement = h;
            } }, this.props.children), !this.context.hideFab && o.createElement(eq, { onClick: this.toggleNavMenu }, o.createElement(Xz, { open: c })));
          }
        };
        zu.contextType = He, zu = ((c, p, h, w) => {
          for (var _, T = p, R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = _(T) || T);
          return T;
        })([wt.observer], zu);
        const b_ = M.div`
  ${({ theme: c }) => `
  font-family: ${c.typography.fontFamily};
  font-size: ${c.typography.fontSize};
  font-weight: ${c.typography.fontWeightRegular};
  line-height: ${c.typography.lineHeight};
  color: ${c.colors.text.primary};
  display: flex;
  position: relative;
  text-align: left;

  -webkit-font-smoothing: ${c.typography.smoothing};
  font-smoothing: ${c.typography.smoothing};
  ${c.typography.optimizeSpeed ? "text-rendering: optimizeSpeed !important" : ""};

  tap-highlight-color: rgba(0, 0, 0, 0);
  text-size-adjust: 100%;

  * {
    box-sizing: border-box;
    -webkit-tap-highlight-color: rgba(255, 255, 255, 0);
  }
`};
`, w_ = M.div`
  z-index: 1;
  position: relative;
  overflow: hidden;
  width: calc(100% - ${(c) => c.theme.sidebar.width});
  ${O.lessThan("small", !0)`
    width: 100%;
  `};

  contain: layout;
`, S_ = M.div`
  background: ${({ theme: c }) => c.rightPanel.backgroundColor};
  position: absolute;
  top: 0;
  bottom: 0;
  right: 0;
  width: ${({ theme: c }) => {
          if (c.rightPanel.width.endsWith("%")) {
            const p = parseInt(c.rightPanel.width, 10);
            return `calc((100% - ${c.sidebar.width}) * ${p / 100})`;
          }
          return c.rightPanel.width;
        }};
  ${O.lessThan("medium", !0)`
    display: none;
  `};
`, tq = M.div`
  padding: 5px 0;
`, rq = M.input.attrs(() => ({ className: "search-input" }))`
  width: calc(100% - ${(c) => 8 * c.theme.spacing.unit}px);
  box-sizing: border-box;
  margin: 0 ${(c) => 4 * c.theme.spacing.unit}px;
  padding: 5px ${(c) => 2 * c.theme.spacing.unit}px 5px
    ${(c) => 4 * c.theme.spacing.unit}px;
  border: 0;
  border-bottom: 1px solid
    ${({ theme: c }) => ((0, a.getLuminance)(c.sidebar.backgroundColor) > 0.5 ? a.darken : a.lighten)(0.1, c.sidebar.backgroundColor)};
  font-family: ${({ theme: c }) => c.typography.fontFamily};
  font-weight: bold;
  font-size: 13px;
  color: ${(c) => c.theme.sidebar.textColor};
  background-color: transparent;
  outline: none;
`, nq = M((c) => o.createElement("svg", { className: c.className, version: "1.1", viewBox: "0 0 1000 1000", x: "0px", xmlns: "http://www.w3.org/2000/svg", y: "0px" }, o.createElement("path", { d: "M968.2,849.4L667.3,549c83.9-136.5,66.7-317.4-51.7-435.6C477.1-25,252.5-25,113.9,113.4c-138.5,138.3-138.5,362.6,0,501C219.2,730.1,413.2,743,547.6,666.5l301.9,301.4c43.6,43.6,76.9,14.9,104.2-12.4C981,928.3,1011.8,893,968.2,849.4z M524.5,522c-88.9,88.7-233,88.7-321.8,0c-88.9-88.7-88.9-232.6,0-321.3c88.9-88.7,233-88.7,321.8,0C613.4,289.4,613.4,433.3,524.5,522z" }))).attrs({ className: "search-icon" })`
  position: absolute;
  left: ${(c) => 4 * c.theme.spacing.unit}px;
  height: 1.8em;
  width: 0.9em;

  path {
    fill: ${(c) => c.theme.sidebar.textColor};
  }
`, x_ = M.div`
  padding: ${(c) => c.theme.spacing.unit}px 0;
  background-color: ${({ theme: c }) => (0, a.darken)(0.05, c.sidebar.backgroundColor)}};
  color: ${(c) => c.theme.sidebar.textColor};
  min-height: 150px;
  max-height: 250px;
  border-top: ${({ theme: c }) => (0, a.darken)(0.1, c.sidebar.backgroundColor)}};
  border-bottom: ${({ theme: c }) => (0, a.darken)(0.1, c.sidebar.backgroundColor)}};
  margin-top: 10px;
  line-height: 1.4;
  font-size: 0.9em;
  
  li {
    background-color: inherit;
  }

  ${Lf} {
    padding-top: 6px;
    padding-bottom: 6px;

    &:hover,
    &.active {
      background-color: ${({ theme: c }) => (0, a.darken)(0.1, c.sidebar.backgroundColor)};
    }

    > svg {
      display: none;
    }
  }
`, iq = M.i`
  position: absolute;
  display: inline-block;
  width: ${(c) => 2 * c.theme.spacing.unit}px;
  text-align: center;
  right: ${(c) => 4 * c.theme.spacing.unit}px;
  line-height: 2em;
  vertical-align: middle;
  margin-right: 2px;
  cursor: pointer;
  font-style: normal;
  color: '#666';
`;
        var oq = Object.defineProperty, sq = Object.getOwnPropertyDescriptor;
        class Hf extends o.PureComponent {
          constructor(p) {
            super(p), this.activeItemRef = null, this.clear = () => {
              this.setState({ results: [], noResults: !1, term: "", activeItemIdx: -1 }), this.props.marker.unmark();
            }, this.handleKeyDown = (h) => {
              if (h.keyCode === 27 && this.clear(), h.keyCode === 40 && (this.setState({ activeItemIdx: Math.min(this.state.activeItemIdx + 1, this.state.results.length - 1) }), h.preventDefault()), h.keyCode === 38 && (this.setState({ activeItemIdx: Math.max(0, this.state.activeItemIdx - 1) }), h.preventDefault()), h.keyCode === 13) {
                const w = this.state.results[this.state.activeItemIdx];
                if (w) {
                  const _ = this.props.getItemById(w.meta);
                  _ && this.props.onActivate(_);
                }
              }
            }, this.search = (h) => {
              const { minCharacterLengthToInitSearch: w } = this.context, _ = h.target.value;
              _.length < w ? this.clearResults(_) : this.setState({ term: _ }, () => this.searchCallback(this.state.term));
            }, this.state = { results: [], noResults: !1, term: "", activeItemIdx: -1 };
          }
          clearResults(p) {
            this.setState({ results: [], noResults: !1, term: p }), this.props.marker.unmark();
          }
          setResults(p, h) {
            this.setState({ results: p, noResults: p.length === 0 }), this.props.marker.mark(h);
          }
          searchCallback(p) {
            this.props.search.search(p).then((h) => {
              this.setResults(h, p);
            });
          }
          render() {
            const { activeItemIdx: p } = this.state, h = this.state.results.filter((w) => this.props.getItemById(w.meta)).map((w) => ({ item: this.props.getItemById(w.meta), score: w.score })).sort((w, _) => _.score - w.score);
            return o.createElement(tq, { role: "search" }, this.state.term && o.createElement(iq, { onClick: this.clear }, ""), o.createElement(nq, null), o.createElement(rq, { value: this.state.term, onKeyDown: this.handleKeyDown, placeholder: "Search...", "aria-label": "Search", type: "text", onChange: this.search }), h.length > 0 && o.createElement(Bx, { options: { wheelPropagation: !1 } }, o.createElement(x_, { "data-role": "search:results" }, h.map((w, _) => o.createElement(Mu, { item: Object.create(w.item, { active: { value: _ === p } }), onActivate: this.props.onActivate, withoutChildren: !0, key: w.item.id, "data-role": "search:result" })))), this.state.term && this.state.noResults ? o.createElement(x_, { "data-role": "search:results" }, z("noResultsFound")) : null);
          }
        }
        Hf.contextType = He, ((c, p, h, w) => {
          for (var _, T = sq(p, h), R = c.length - 1; R >= 0; R--) (_ = c[R]) && (T = _(p, h, T) || T);
          T && oq(p, h, T);
        })([Pe.bind, (0, Pe.debounce)(400)], Hf.prototype, "searchCallback");
        class Ky extends o.Component {
          componentDidMount() {
            this.props.store.onDidMount();
          }
          componentWillUnmount() {
            this.props.store.dispose();
          }
          render() {
            const { store: { spec: p, menu: h, options: w, search: _, marker: T } } = this.props, R = this.props.store;
            return o.createElement(Se, { theme: w.theme }, o.createElement(Cx, { value: R }, o.createElement(Ue, { value: w }, o.createElement(b_, { className: "redoc-wrap" }, o.createElement(zu, { menu: h, className: "menu-content" }, o.createElement(Nf, { info: p.info }), !w.disableSearch && o.createElement(Hf, { search: _, marker: T, getItemById: h.getItemById, onActivate: h.activateAndScroll }) || null, o.createElement(Fu, { menu: h })), o.createElement(w_, { className: "api-content" }, o.createElement(If, { store: R }), o.createElement(Lu, { items: h.items })), o.createElement(S_, null)))));
          }
        }
        Ky.propTypes = { store: Je.instanceOf(Ha).isRequired };
        var aq = Object.defineProperty, E_ = Object.getOwnPropertySymbols, lq = Object.prototype.hasOwnProperty, uq = Object.prototype.propertyIsEnumerable, __ = (c, p, h) => p in c ? aq(c, p, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[p] = h, cq = (c, p) => {
          for (var h in p || (p = {})) lq.call(p, h) && __(c, h, p[h]);
          if (E_) for (var h of E_(p)) uq.call(p, h) && __(c, h, p[h]);
          return c;
        };
        const pq = function(c) {
          const { spec: p, specUrl: h, options: w = {}, onLoaded: _ } = c, T = N(w.hideLoading, !1), R = new X(w);
          if (R.nonce !== void 0) try {
            i.nc = R.nonce;
          } catch {
          }
          return o.createElement(ge, null, o.createElement(Rx, { spec: p ? cq({}, p) : void 0, specUrl: h, options: w, onLoaded: _ }, ({ loading: W, store: Z }) => W ? T ? null : o.createElement(Ve, { color: R.theme.colors.primary.main }) : o.createElement(Ky, { store: Z })));
        };
      }(), s;
    }();
  });
})(yI);
var bZ = yI.exports, TM = {}, fu = {}, ko = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.isEventSourceSupported = e.isReactNative = e.ReadyState = e.UNPARSABLE_JSON_OBJECT = e.DEFAULT_RECONNECT_INTERVAL_MS = e.DEFAULT_RECONNECT_LIMIT = e.SOCKET_IO_PING_CODE = e.SOCKET_IO_PATH = e.SOCKET_IO_PING_INTERVAL = e.DEFAULT_EVENT_SOURCE_OPTIONS = e.EMPTY_EVENT_HANDLERS = e.DEFAULT_OPTIONS = void 0;
  var t = 1, r = 1e3 * t;
  e.DEFAULT_OPTIONS = {}, e.EMPTY_EVENT_HANDLERS = {}, e.DEFAULT_EVENT_SOURCE_OPTIONS = {
    withCredentials: !1,
    events: e.EMPTY_EVENT_HANDLERS
  }, e.SOCKET_IO_PING_INTERVAL = 25 * r, e.SOCKET_IO_PATH = "/socket.io/?EIO=3&transport=websocket", e.SOCKET_IO_PING_CODE = "2", e.DEFAULT_RECONNECT_LIMIT = 20, e.DEFAULT_RECONNECT_INTERVAL_MS = 5e3, e.UNPARSABLE_JSON_OBJECT = {}, function(i) {
    i[i.UNINSTANTIATED = -1] = "UNINSTANTIATED", i[i.CONNECTING = 0] = "CONNECTING", i[i.OPEN = 1] = "OPEN", i[i.CLOSING = 2] = "CLOSING", i[i.CLOSED = 3] = "CLOSED";
  }(e.ReadyState || (e.ReadyState = {}));
  var n = function() {
    try {
      return "EventSource" in globalThis;
    } catch {
      return !1;
    }
  };
  e.isReactNative = typeof navigator < "u" && navigator.product === "ReactNative", e.isEventSourceSupported = !e.isReactNative && n();
})(ko);
var ny = {}, iy = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.resetWebSockets = e.sharedWebSockets = void 0, e.sharedWebSockets = {}, e.resetWebSockets = function(t) {
    if (t && e.sharedWebSockets.hasOwnProperty(t))
      delete e.sharedWebSockets[t];
    else
      for (var r in e.sharedWebSockets)
        e.sharedWebSockets.hasOwnProperty(r) && delete e.sharedWebSockets[r];
  };
})(iy);
var oy = {}, Li = {};
Object.defineProperty(Li, "__esModule", { value: !0 });
Li.setUpSocketIOPing = Li.appendQueryParams = Li.parseSocketIOUrl = void 0;
var eg = ko;
Li.parseSocketIOUrl = function(e) {
  if (e) {
    var t = /^https|wss/.test(e), r = e.replace(/^(https?|wss?)(:\/\/)?/, ""), n = r.replace(/\/$/, ""), i = t ? "wss" : "ws";
    return i + "://" + n + eg.SOCKET_IO_PATH;
  } else if (e === "") {
    var t = /^https/.test(window.location.protocol), i = t ? "wss" : "ws", s = window.location.port ? ":" + window.location.port : "";
    return i + "://" + window.location.hostname + s + eg.SOCKET_IO_PATH;
  }
  return e;
};
Li.appendQueryParams = function(e, t) {
  t === void 0 && (t = {});
  var r = /\?([\w]+=[\w]+)/, n = r.test(e), i = "" + Object.entries(t).reduce(function(s, o) {
    var a = o[0], l = o[1];
    return s + (a + "=" + l + "&");
  }, "").slice(0, -1);
  return "" + e + (n ? "&" : "?") + i;
};
Li.setUpSocketIOPing = function(e, t) {
  t === void 0 && (t = eg.SOCKET_IO_PING_INTERVAL);
  var r = function() {
    return e(eg.SOCKET_IO_PING_CODE);
  };
  return setInterval(r, t);
};
var gs = {}, sy = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.resetSubscribers = e.removeSubscriber = e.addSubscriber = e.hasSubscribers = e.getSubscribers = void 0;
  var t = {}, r = [];
  e.getSubscribers = function(n) {
    return e.hasSubscribers(n) ? Array.from(t[n]) : r;
  }, e.hasSubscribers = function(n) {
    var i;
    return ((i = t[n]) === null || i === void 0 ? void 0 : i.size) > 0;
  }, e.addSubscriber = function(n, i) {
    t[n] = t[n] || /* @__PURE__ */ new Set(), t[n].add(i);
  }, e.removeSubscriber = function(n, i) {
    t[n].delete(i);
  }, e.resetSubscribers = function(n) {
    if (n && t.hasOwnProperty(n))
      delete t[n];
    else
      for (var i in t)
        t.hasOwnProperty(i) && delete t[i];
  };
})(sy);
Object.defineProperty(gs, "__esModule", { value: !0 });
gs.resetGlobalState = gs.assertIsWebSocket = void 0;
var wZ = iy, SZ = sy;
function xZ(e) {
  if (!(e instanceof WebSocket))
    throw new Error("");
}
gs.assertIsWebSocket = xZ;
function EZ(e) {
  SZ.resetSubscribers(e), wZ.resetWebSockets(e);
}
gs.resetGlobalState = EZ;
var tg = ft && ft.__assign || function() {
  return tg = Object.assign || function(e) {
    for (var t, r = 1, n = arguments.length; r < n; r++) {
      t = arguments[r];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    }
    return e;
  }, tg.apply(this, arguments);
};
Object.defineProperty(oy, "__esModule", { value: !0 });
oy.attachListeners = void 0;
var _Z = Li, Ci = ko, OZ = gs, kZ = function(e, t, r) {
  e.onmessage = function(n) {
    t.current.onMessage && t.current.onMessage(n), !(typeof t.current.filter == "function" && t.current.filter(n) !== !0) && r(n);
  };
}, AZ = function(e, t, r, n) {
  e.onopen = function(i) {
    t.current.onOpen && t.current.onOpen(i), n.current = 0, r(Ci.ReadyState.OPEN);
  };
}, PZ = function(e, t, r, n, i) {
  if (Ci.isEventSourceSupported && e instanceof EventSource)
    return function() {
    };
  OZ.assertIsWebSocket(e);
  var s;
  return e.onclose = function(o) {
    var a, l;
    if (t.current.onClose && t.current.onClose(o), r(Ci.ReadyState.CLOSED), t.current.shouldReconnect && t.current.shouldReconnect(o)) {
      var u = (a = t.current.reconnectAttempts) !== null && a !== void 0 ? a : Ci.DEFAULT_RECONNECT_LIMIT;
      i.current < u ? s = window.setTimeout(function() {
        i.current++, n();
      }, (l = t.current.reconnectInterval) !== null && l !== void 0 ? l : Ci.DEFAULT_RECONNECT_INTERVAL_MS) : (t.current.onReconnectStop && t.current.onReconnectStop(u), console.warn("Max reconnect attempts of " + u + " exceeded"));
    }
  }, function() {
    return s && window.clearTimeout(s);
  };
}, TZ = function(e, t, r, n, i) {
  var s;
  return e.onerror = function(o) {
    var a, l;
    t.current.onError && t.current.onError(o), Ci.isEventSourceSupported && e instanceof EventSource && (t.current.onClose && t.current.onClose(tg(tg({}, o), { code: 1006, reason: "An error occurred with the EventSource: " + o, wasClean: !1 })), r(Ci.ReadyState.CLOSED), e.close()), t.current.retryOnError && (i.current < ((a = t.current.reconnectAttempts) !== null && a !== void 0 ? a : Ci.DEFAULT_RECONNECT_LIMIT) ? s = window.setTimeout(function() {
      i.current++, n();
    }, (l = t.current.reconnectInterval) !== null && l !== void 0 ? l : Ci.DEFAULT_RECONNECT_INTERVAL_MS) : (t.current.onReconnectStop && t.current.onReconnectStop(t.current.reconnectAttempts), console.warn("Max reconnect attempts of " + t.current.reconnectAttempts + " exceeded")));
  }, function() {
    return s && window.clearTimeout(s);
  };
};
oy.attachListeners = function(e, t, r, n, i, s) {
  var o = t.setLastMessage, a = t.setReadyState, l, u, f;
  return r.current.fromSocketIO && (l = _Z.setUpSocketIOPing(s)), kZ(e, r, o), AZ(e, r, a, i), u = PZ(e, r, a, n, i), f = TZ(e, r, a, n, i), function() {
    a(Ci.ReadyState.CLOSING), u(), f(), e.close(), l && clearInterval(l);
  };
};
var ay = {}, rg = ft && ft.__assign || function() {
  return rg = Object.assign || function(e) {
    for (var t, r = 1, n = arguments.length; r < n; r++) {
      t = arguments[r];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    }
    return e;
  }, rg.apply(this, arguments);
};
Object.defineProperty(ay, "__esModule", { value: !0 });
ay.attachSharedListeners = void 0;
var CZ = iy, aa = ko, vp = sy, $Z = Li, RZ = function(e, t) {
  e.onmessage = function(r) {
    vp.getSubscribers(t).forEach(function(n) {
      n.optionsRef.current.onMessage && n.optionsRef.current.onMessage(r), !(typeof n.optionsRef.current.filter == "function" && n.optionsRef.current.filter(r) !== !0) && n.setLastMessage(r);
    });
  };
}, IZ = function(e, t) {
  e.onopen = function(r) {
    vp.getSubscribers(t).forEach(function(n) {
      n.reconnectCount.current = 0, n.optionsRef.current.onOpen && n.optionsRef.current.onOpen(r), n.setReadyState(aa.ReadyState.OPEN);
    });
  };
}, NZ = function(e, t) {
  e instanceof WebSocket && (e.onclose = function(r) {
    vp.getSubscribers(t).forEach(function(n) {
      n.optionsRef.current.onClose && n.optionsRef.current.onClose(r), n.setReadyState(aa.ReadyState.CLOSED);
    }), delete CZ.sharedWebSockets[t], vp.getSubscribers(t).forEach(function(n) {
      var i, s;
      if (n.optionsRef.current.shouldReconnect && n.optionsRef.current.shouldReconnect(r)) {
        var o = (i = n.optionsRef.current.reconnectAttempts) !== null && i !== void 0 ? i : aa.DEFAULT_RECONNECT_LIMIT;
        n.reconnectCount.current < o ? setTimeout(function() {
          n.reconnectCount.current++, n.reconnect.current();
        }, (s = n.optionsRef.current.reconnectInterval) !== null && s !== void 0 ? s : aa.DEFAULT_RECONNECT_INTERVAL_MS) : (n.optionsRef.current.onReconnectStop && n.optionsRef.current.onReconnectStop(n.optionsRef.current.reconnectAttempts), console.warn("Max reconnect attempts of " + o + " exceeded"));
      }
    });
  });
}, jZ = function(e, t) {
  e.onerror = function(r) {
    vp.getSubscribers(t).forEach(function(n) {
      n.optionsRef.current.onError && n.optionsRef.current.onError(r), aa.isEventSourceSupported && e instanceof EventSource && (n.optionsRef.current.onClose && n.optionsRef.current.onClose(rg(rg({}, r), { code: 1006, reason: "An error occurred with the EventSource: " + r, wasClean: !1 })), n.setReadyState(aa.ReadyState.CLOSED));
    }), aa.isEventSourceSupported && e instanceof EventSource && e.close();
  };
};
ay.attachSharedListeners = function(e, t, r, n) {
  var i;
  return r.current.fromSocketIO && (i = $Z.setUpSocketIOPing(n)), RZ(e, t), NZ(e, t), IZ(e, t), jZ(e, t), function() {
    i && clearInterval(i);
  };
};
Object.defineProperty(ny, "__esModule", { value: !0 });
ny.createOrJoinSocket = void 0;
var Bo = iy, Ec = ko, LZ = oy, MZ = ay, Lw = sy, DZ = function(e, t, r, n, i) {
  return function() {
    if (Lw.removeSubscriber(e, t), !Lw.hasSubscribers(e)) {
      try {
        var s = Bo.sharedWebSockets[e];
        s instanceof WebSocket && (s.onclose = function(o) {
          r.current.onClose && r.current.onClose(o), n(Ec.ReadyState.CLOSED);
        }), s.close();
      } catch {
      }
      i && i(), delete Bo.sharedWebSockets[e];
    }
  };
};
ny.createOrJoinSocket = function(e, t, r, n, i, s, o, a) {
  if (!Ec.isEventSourceSupported && n.current.eventSourceOptions)
    throw Ec.isReactNative ? new Error("EventSource is not supported in ReactNative") : new Error("EventSource is not supported");
  if (n.current.share) {
    var l = null;
    Bo.sharedWebSockets[t] === void 0 ? (Bo.sharedWebSockets[t] = n.current.eventSourceOptions ? new EventSource(t, n.current.eventSourceOptions) : new WebSocket(t, n.current.protocols), e.current = Bo.sharedWebSockets[t], r(Ec.ReadyState.CONNECTING), l = MZ.attachSharedListeners(Bo.sharedWebSockets[t], t, n, a)) : (e.current = Bo.sharedWebSockets[t], r(Bo.sharedWebSockets[t].readyState));
    var u = {
      setLastMessage: i,
      setReadyState: r,
      optionsRef: n,
      reconnectCount: o,
      reconnect: s
    };
    return Lw.addSubscriber(t, u), DZ(t, u, n, r, l);
  } else {
    if (e.current = n.current.eventSourceOptions ? new EventSource(t, n.current.eventSourceOptions) : new WebSocket(t, n.current.protocols), r(Ec.ReadyState.CONNECTING), !e.current)
      throw new Error("WebSocket failed to be created");
    return LZ.attachListeners(e.current, {
      setLastMessage: i,
      setReadyState: r
    }, n, s.current, o, a);
  }
};
var ly = {}, FZ = ft && ft.__awaiter || function(e, t, r, n) {
  function i(s) {
    return s instanceof r ? s : new r(function(o) {
      o(s);
    });
  }
  return new (r || (r = Promise))(function(s, o) {
    function a(f) {
      try {
        u(n.next(f));
      } catch (d) {
        o(d);
      }
    }
    function l(f) {
      try {
        u(n.throw(f));
      } catch (d) {
        o(d);
      }
    }
    function u(f) {
      f.done ? s(f.value) : i(f.value).then(a, l);
    }
    u((n = n.apply(e, t || [])).next());
  });
}, zZ = ft && ft.__generator || function(e, t) {
  var r = { label: 0, sent: function() {
    if (s[0] & 1) throw s[1];
    return s[1];
  }, trys: [], ops: [] }, n, i, s, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(u) {
    return function(f) {
      return l([u, f]);
    };
  }
  function l(u) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; r; ) try {
      if (n = 1, i && (s = u[0] & 2 ? i.return : u[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, u[1])).done) return s;
      switch (i = 0, s && (u = [u[0] & 2, s.value]), u[0]) {
        case 0:
        case 1:
          s = u;
          break;
        case 4:
          return r.label++, { value: u[1], done: !1 };
        case 5:
          r.label++, i = u[1], u = [0];
          continue;
        case 7:
          u = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (u[0] === 6 || u[0] === 2)) {
            r = 0;
            continue;
          }
          if (u[0] === 3 && (!s || u[1] > s[0] && u[1] < s[3])) {
            r.label = u[1];
            break;
          }
          if (u[0] === 6 && r.label < s[1]) {
            r.label = s[1], s = u;
            break;
          }
          if (s && r.label < s[2]) {
            r.label = s[2], r.ops.push(u);
            break;
          }
          s[2] && r.ops.pop(), r.trys.pop();
          continue;
      }
      u = t.call(e, r);
    } catch (f) {
      u = [6, f], i = 0;
    } finally {
      n = s = 0;
    }
    if (u[0] & 5) throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
};
Object.defineProperty(ly, "__esModule", { value: !0 });
ly.getUrl = void 0;
var ZC = Li;
ly.getUrl = function(e, t) {
  return FZ(void 0, void 0, void 0, function() {
    var r, n, i;
    return zZ(this, function(s) {
      switch (s.label) {
        case 0:
          return typeof e != "function" ? [3, 2] : [4, e()];
        case 1:
          return r = s.sent(), [3, 3];
        case 2:
          r = e, s.label = 3;
        case 3:
          return n = t.current.fromSocketIO ? ZC.parseSocketIOUrl(r) : r, i = t.current.queryParams ? ZC.appendQueryParams(n, t.current.queryParams) : n, [2, i];
      }
    });
  });
};
var CM = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.websocketWrapper = void 0, e.websocketWrapper = function(t, r) {
    return new Proxy(t, {
      get: function(n, i) {
        var s = n[i];
        return i === "reconnect" ? r : typeof s == "function" ? (console.error("Calling methods directly on the websocket is not supported at this moment. You must use the methods returned by useWebSocket."), function() {
        }) : s;
      },
      set: function(n, i, s) {
        return /^on/.test(i) ? (console.warn("The websocket's event handlers should be defined through the options object passed into useWebSocket."), !1) : (n[i] = s, !0);
      }
    });
  }, e.default = e.websocketWrapper;
})(CM);
var _l = ft && ft.__assign || function() {
  return _l = Object.assign || function(e) {
    for (var t, r = 1, n = arguments.length; r < n; r++) {
      t = arguments[r];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    }
    return e;
  }, _l.apply(this, arguments);
}, qZ = ft && ft.__awaiter || function(e, t, r, n) {
  function i(s) {
    return s instanceof r ? s : new r(function(o) {
      o(s);
    });
  }
  return new (r || (r = Promise))(function(s, o) {
    function a(f) {
      try {
        u(n.next(f));
      } catch (d) {
        o(d);
      }
    }
    function l(f) {
      try {
        u(n.throw(f));
      } catch (d) {
        o(d);
      }
    }
    function u(f) {
      f.done ? s(f.value) : i(f.value).then(a, l);
    }
    u((n = n.apply(e, t || [])).next());
  });
}, BZ = ft && ft.__generator || function(e, t) {
  var r = { label: 0, sent: function() {
    if (s[0] & 1) throw s[1];
    return s[1];
  }, trys: [], ops: [] }, n, i, s, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(u) {
    return function(f) {
      return l([u, f]);
    };
  }
  function l(u) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; r; ) try {
      if (n = 1, i && (s = u[0] & 2 ? i.return : u[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, u[1])).done) return s;
      switch (i = 0, s && (u = [u[0] & 2, s.value]), u[0]) {
        case 0:
        case 1:
          s = u;
          break;
        case 4:
          return r.label++, { value: u[1], done: !1 };
        case 5:
          r.label++, i = u[1], u = [0];
          continue;
        case 7:
          u = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (u[0] === 6 || u[0] === 2)) {
            r = 0;
            continue;
          }
          if (u[0] === 3 && (!s || u[1] > s[0] && u[1] < s[3])) {
            r.label = u[1];
            break;
          }
          if (u[0] === 6 && r.label < s[1]) {
            r.label = s[1], s = u;
            break;
          }
          if (s && r.label < s[2]) {
            r.label = s[2], r.ops.push(u);
            break;
          }
          s[2] && r.ops.pop(), r.trys.pop();
          continue;
      }
      u = t.call(e, r);
    } catch (f) {
      u = [6, f], i = 0;
    } finally {
      n = s = 0;
    }
    if (u[0] & 5) throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}, UZ = ft && ft.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(fu, "__esModule", { value: !0 });
fu.useWebSocket = void 0;
var Fr = et, to = ko, VZ = ny, WZ = ly, HZ = UZ(CM), e$ = gs;
fu.useWebSocket = function(e, t, r) {
  t === void 0 && (t = to.DEFAULT_OPTIONS), r === void 0 && (r = !0);
  var n = Fr.useState(null), i = n[0], s = n[1], o = Fr.useState({}), a = o[0], l = o[1], u = Fr.useMemo(function() {
    if (i)
      try {
        return JSON.parse(i.data);
      } catch {
        return to.UNPARSABLE_JSON_OBJECT;
      }
    return null;
  }, [i]), f = Fr.useRef(null), d = Fr.useRef(null), m = Fr.useRef(function() {
  }), v = Fr.useRef(0), S = Fr.useRef([]), y = Fr.useRef(null), E = Fr.useRef(t);
  E.current = t;
  var x = f.current && a[f.current] !== void 0 ? a[f.current] : e !== null && r === !0 ? to.ReadyState.CONNECTING : to.ReadyState.UNINSTANTIATED, g = t.queryParams ? JSON.stringify(t.queryParams) : null, b = Fr.useCallback(function(k, $) {
    var I;
    if ($ === void 0 && ($ = !0), to.isEventSourceSupported && d.current instanceof EventSource) {
      console.warn("Unable to send a message from an eventSource");
      return;
    }
    ((I = d.current) === null || I === void 0 ? void 0 : I.readyState) === to.ReadyState.OPEN ? (e$.assertIsWebSocket(d.current), d.current.send(k)) : $ && S.current.push(k);
  }, []), A = Fr.useCallback(function(k, $) {
    $ === void 0 && ($ = !0), b(JSON.stringify(k), $);
  }, [b]), P = Fr.useCallback(function() {
    return E.current.share !== !0 || to.isEventSourceSupported && d.current instanceof EventSource ? d.current : (y.current === null && d.current && (e$.assertIsWebSocket(d.current), y.current = HZ.default(d.current, m)), y.current);
  }, []);
  return Fr.useEffect(function() {
    if (e !== null && r === !0) {
      var k, $ = !1, I = function() {
        return qZ(void 0, void 0, void 0, function() {
          var F, L, Q;
          return BZ(this, function(Y) {
            switch (Y.label) {
              case 0:
                return F = f, [4, WZ.getUrl(e, E)];
              case 1:
                return F.current = Y.sent(), L = function(ae) {
                  $ || s(ae);
                }, Q = function(ae) {
                  $ || l(function(le) {
                    var ue;
                    return _l(_l({}, le), f.current && (ue = {}, ue[f.current] = ae, ue));
                  });
                }, k = VZ.createOrJoinSocket(d, f.current, Q, E, L, m, v, b), [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      return m.current = function() {
        $ || (y.current && (y.current = null), k == null || k(), I());
      }, I(), function() {
        $ = !0, y.current && (y.current = null), k == null || k(), s(null);
      };
    } else (e === null || r === !1) && (v.current = 0, l(function(F) {
      var L;
      return _l(_l({}, F), f.current && (L = {}, L[f.current] = to.ReadyState.CLOSED, L));
    }));
  }, [e, r, g, b]), Fr.useEffect(function() {
    x === to.ReadyState.OPEN && S.current.splice(0).forEach(function(k) {
      b(k);
    });
  }, [x]), {
    sendMessage: b,
    sendJsonMessage: A,
    lastMessage: i,
    lastJsonMessage: u,
    readyState: x,
    getWebSocket: P
  };
};
var uy = {}, ng = ft && ft.__assign || function() {
  return ng = Object.assign || function(e) {
    for (var t, r = 1, n = arguments.length; r < n; r++) {
      t = arguments[r];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    }
    return e;
  }, ng.apply(this, arguments);
};
Object.defineProperty(uy, "__esModule", { value: !0 });
uy.useSocketIO = void 0;
var t$ = et, QZ = fu, YZ = ko, Jb = {
  type: "empty",
  payload: null
}, GZ = function(e) {
  if (!e || !e.data)
    return Jb;
  var t = e.data.match(/\[.*]/);
  if (!t)
    return Jb;
  var r = JSON.parse(t);
  return !Array.isArray(r) || !r[1] ? Jb : {
    type: r[0],
    payload: r[1]
  };
};
uy.useSocketIO = function(e, t, r) {
  t === void 0 && (t = YZ.DEFAULT_OPTIONS), r === void 0 && (r = !0);
  var n = t$.useMemo(function() {
    return ng(ng({}, t), { fromSocketIO: !0 });
  }, []), i = QZ.useWebSocket(e, n, r), s = i.sendMessage, o = i.sendJsonMessage, a = i.lastMessage, l = i.readyState, u = i.getWebSocket, f = t$.useMemo(function() {
    return GZ(a);
  }, [a]);
  return {
    sendMessage: s,
    sendJsonMessage: o,
    lastMessage: f,
    lastJsonMessage: f,
    readyState: l,
    getWebSocket: u
  };
};
var cy = {}, ig = ft && ft.__assign || function() {
  return ig = Object.assign || function(e) {
    for (var t, r = 1, n = arguments.length; r < n; r++) {
      t = arguments[r];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    }
    return e;
  }, ig.apply(this, arguments);
}, KZ = ft && ft.__rest || function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
      t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
Object.defineProperty(cy, "__esModule", { value: !0 });
cy.useEventSource = void 0;
var r$ = et, XZ = fu, n$ = ko;
cy.useEventSource = function(e, t, r) {
  t === void 0 && (t = n$.DEFAULT_EVENT_SOURCE_OPTIONS), r === void 0 && (r = !0);
  var n = t.withCredentials, i = t.events, s = KZ(t, ["withCredentials", "events"]), o = ig(ig({}, s), { eventSourceOptions: {
    withCredentials: n
  } }), a = r$.useRef(n$.EMPTY_EVENT_HANDLERS);
  i && (a.current = i);
  var l = XZ.useWebSocket(e, o, r), u = l.lastMessage, f = l.readyState, d = l.getWebSocket;
  return r$.useEffect(function() {
    u != null && u.type && Object.entries(a.current).forEach(function(m) {
      var v = m[0], S = m[1];
      v === u.type && S(u);
    });
  }, [u]), {
    lastEvent: u,
    readyState: f,
    getEventSource: d
  };
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 });
  var t = fu;
  Object.defineProperty(e, "default", { enumerable: !0, get: function() {
    return t.useWebSocket;
  } });
  var r = uy;
  Object.defineProperty(e, "useSocketIO", { enumerable: !0, get: function() {
    return r.useSocketIO;
  } });
  var n = ko;
  Object.defineProperty(e, "ReadyState", { enumerable: !0, get: function() {
    return n.ReadyState;
  } });
  var i = cy;
  Object.defineProperty(e, "useEventSource", { enumerable: !0, get: function() {
    return i.useEventSource;
  } });
  var s = gs;
  Object.defineProperty(e, "resetGlobalState", { enumerable: !0, get: function() {
    return s.resetGlobalState;
  } });
})(TM);
const JZ = /* @__PURE__ */ og(TM), ZZ = () => {
  const e = new URLSearchParams(window.location.search), t = e.get("project"), r = e.get("filename"), n = e.get("renderer"), i = window.location.port, { sendMessage: s, lastMessage: o, readyState: a } = JZ("ws://localhost:" + i + "/preview/ws?project=" + t + "&filename=" + r + "&renderer=" + n);
  return o ? /* @__PURE__ */ Zb.jsx(bZ.RedocStandalone, { options: { disableSearch: !0, hideDownloadButton: !0 }, spec: JSON.parse(o.data) }) : /* @__PURE__ */ Zb.jsx("p", { children: "Loading..." });
};
gI.render(/* @__PURE__ */ Zb.jsx(ZZ, {}), document.getElementById("root"));
